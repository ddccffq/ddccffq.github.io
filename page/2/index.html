<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ddccffq.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
<meta property="og:type" content="website">
<meta property="og:title" content="ddccffq的技术博客">
<meta property="og:url" content="https://ddccffq.github.io/page/2/index.html">
<meta property="og:site_name" content="ddccffq的技术博客">
<meta property="og:description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ddccffq">
<meta property="article:tag" content="机器学习,计算机网络,算法,统计学习">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ddccffq.github.io/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ddccffq的技术博客</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","mhchem":false,"cdn":"//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ddccffq的技术博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">机器学习与计算机网络</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ddccffq"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ddccffq</p>
  <div class="site-description" itemprop="description">专注于机器学习、计算机网络、统计学习方法的技术分享</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ddccffq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ddccffq" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1765752538@qq.com" title="E-Mail → mailto:1765752538@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/03/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/03/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/" class="post-title-link" itemprop="url">上下文无关文法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-03 10:25:03" itemprop="dateCreated datePublished" datetime="2025-06-03T10:25:03+08:00">2025-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-10 14:33:14" itemprop="dateModified" datetime="2025-06-10T14:33:14+08:00">2025-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">形式语言与自动机</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="上下文无关文法的定义"><a href="#上下文无关文法的定义" class="headerlink" title="上下文无关文法的定义"></a>上下文无关文法的定义</h1><p>定义文法 $G = (V, T, P, S)$，其中产生式，除了空产生式外，有如下特点：</p>
<script type="math/tex; mode=display">
\forall \alpha \to \beta \in P, \quad \beta \in (V \cup T)^{\ast}, \quad \text{All have } |\beta| \geq |\alpha|, \text{and } \alpha \in V</script><h1 id="派生树"><a href="#派生树" class="headerlink" title="派生树"></a>派生树</h1><p>设有 CFG $ G = (V, T, P, S)$，$G$ 的派生树是满足如<br>下条件的有序树。</p>
<ol>
<li>树的每个顶点有一个标记 $X$，且 $X \in V \cup T \cup {\epsilon}$；</li>
<li>树根的标记为 $S$；</li>
<li>如果非叶子顶点 $v$ 标记为 $A$，$v$ 的儿子从左到右依次为$v_1, v_2, \dots, v_n$，并且它们分别标记为$X_1, X_2, \dots, X_n$，则 $A \to X_1 X_2 \cdots X_n \in P$；</li>
<li>如果 $X$ 是一个<strong>非叶子顶点</strong>的标记，则 $X \in V$；</li>
<li>如果顶点 $v$ 标记为 $\epsilon$，则 $v$ 是该树的叶子，并且 $v$ 是其父顶点的<strong>惟一儿子</strong>。</li>
</ol>
<p>派生树都是 CFG 的派生树。</p>
<h2 id="顶点的结果"><a href="#顶点的结果" class="headerlink" title="顶点的结果"></a>顶点的结果</h2><p>派生树 $T$ 的所有叶子结点从左到右的符号串为 $X_1 X_2 \cdots X_n$是 $T$ 的结果。</p>
<h1 id="CFG-的化简"><a href="#CFG-的化简" class="headerlink" title="CFG 的化简"></a>CFG 的化简</h1><h2 id="删除无用符号"><a href="#删除无用符号" class="headerlink" title="删除无用符号"></a>删除无用符号</h2><p><strong>无用符号</strong></p>
<h1 id="CNF：乔姆斯基范式文法"><a href="#CNF：乔姆斯基范式文法" class="headerlink" title="CNF：乔姆斯基范式文法"></a>CNF：乔姆斯基范式文法</h1><p>CFG $G = (V, T, P, S)$ 中的产生式形式为：$A \to BC, \, A\to a$，其中 $A,B,C \in V,\, a \in T$，需要注意的是此 CFG 已完成化简。</p>
<p>利用 CNF 范式派生长度为 $n$ 的串，刚好需要 $2n-1$ 步。</p>
<h1 id="上下文无关文法的性质"><a href="#上下文无关文法的性质" class="headerlink" title="上下文无关文法的性质"></a>上下文无关文法的性质</h1><h2 id="CFL-的泵引理"><a href="#CFL-的泵引理" class="headerlink" title="CFL 的泵引理"></a>CFL 的泵引理</h2><p>对于任意的 CFL $L$，存在仅仅依赖于 $L$ 的正整数 $N$，对于任意的 $z \in L$，当 $|z| \geq N$ 时，存在 $u, v, w, x, y$，使得 $z = uvwxy$，同时满足：</p>
<ol>
<li>$|vwx| \leq N$；</li>
<li>$|vx| \geq 1$；</li>
<li>对于任意的非负整数 $i$，$u v^i w x^i y \in L$。</li>
</ol>
<h3 id="利用-CFL-泵引理证明一个语言不是-CFL"><a href="#利用-CFL-泵引理证明一个语言不是-CFL" class="headerlink" title="利用 CFL 泵引理证明一个语言不是 CFL"></a>利用 CFL 泵引理证明一个语言不是 CFL</h3><ol>
<li>首先假设该语言是 CFL，则其满足泵引理，任选 $N$；</li>
<li>找到语言中的句子 $z \in L$ 且 $|z| \geq N$；</li>
<li>分析 $v$、$x$ 的各种取值，当满足 $z = uvwxy$，且 $|vwx| \leq N$，$|vx| \geq 1$ 时，均能找到 $i \geq 0$，使得 $i$，$u v^i w x^i y \notin L$。</li>
</ol>
<h2 id="Ogden-引理"><a href="#Ogden-引理" class="headerlink" title="Ogden 引理"></a>Ogden 引理</h2><p>对于任意的 CFL $L$，存在仅仅依赖于 $L$ 的正整数 $N$，对于任意的 $z \in L$，当 $z$ 中至少含有 $N$ 个特异点时，存在 $u, v, w, x, y$，使得 $z = uvwxy$，同时满足：</p>
<ol>
<li>$|vwx|$ 中的特异点的数目 $\leq N$；</li>
<li>$|vx|$ 中的特异点的数目 $\geq 1$；</li>
<li>对于任意的非负整数 $i$，$u v^i w x^i y \in L$。</li>
</ol>
<h2 id="CFL-在并、乘积、闭包运算下是封闭的，但在交运算下不封闭"><a href="#CFL-在并、乘积、闭包运算下是封闭的，但在交运算下不封闭" class="headerlink" title="CFL 在并、乘积、闭包运算下是封闭的，但在交运算下不封闭"></a>CFL 在并、乘积、闭包运算下是封闭的，但在交运算下不封闭</h2><h1 id="CYK-Algorithm"><a href="#CYK-Algorithm" class="headerlink" title="CYK Algorithm"></a>CYK Algorithm</h1><p>输入：CNF $G = (V, T, P, S)$，$x$；<br>输出：$x \in L$ 或者 $x \notin L$；</p>
<p>$V<em>{i,k}$：可以派生出子串 $x</em>{i,k}$ 的变量集合，$x_{i,k}$ 表示从 $i$ 开始，长度为 $k$ 的子串。</p>
<ol>
<li><code>for i = 1 in |x|</code> $V<em>{i,1} = {A \mid A \to x</em>{i,1} \in P}$</li>
<li><code>for k = 2 in |x| &#123;for i = 1 to |x| - k + 1&#125;</code> $V_{i,k} = \Phi $<ol>
<li><code>for j = 1 to k - 1</code> $V<em>{i,k} = V</em>{i,k} \cup {A \mid A \to BC \text{ and } B \in V<em>{i,j} \text{ and } C \in V</em>{i + j,k - j}}$</li>
</ol>
</li>
</ol>
<h1 id="hw13"><a href="#hw13" class="headerlink" title="hw13"></a>hw13</h1><p><strong>题目1：</strong> 使用CFL的泵引理证明 $L = { ww \mid w \in {a, b}^{\ast} }$ 不是上下文无关语言.</p>
<p><strong>解答1：</strong></p>
<p>我们使用 CFL 的泵引理来证明 $L = { ww \mid w \in {a, b}^\ast }$ 不是上下文无关语言。</p>
<p>假设 $L$ 是一个上下文无关语言，则它满足 CFL 的泵引理。</p>
<p>设 $N$ 为泵引理中的 $N$，取句子 $ z = a^{N} b^{N} a^{N} b^{N} \in L $</p>
<p>接下来分析 $vwx$ 的各种取值：</p>
<ol>
<li>因为 $|vwx| \leq N$，不妨先假设 $vwx \subseteq a^{N}$ 或者 $b^{N}$，显然对于 $\forall i &gt; 0$，都会破坏 $L$ 的结构，即要求 $ww \in L$。<br><br></li>
<li>然后再分析 $vwx$ 跨越了 $a$ 部分或者 $b$ 部分，由于 $|vwx| \leq N$，可以证明 $vwx$ 最多横跨一个 $a$ 和一个 $b$，也即是类似 $a \cdots ab \cdots b$ 和 $b \cdots ba \cdots a$ 的结构；<br><br><ol>
<li>假设 $vwx$ 横跨第一个 $a$ 和 $b$。设 $ v = a^{m}, \, x = b^{n}$，则 $\forall i &gt; 0$，$u a^{im} w b^{in} y \notin L$，这很好证明：此时 $u a^{im} w b^{in} y$ 可以写成 $a^{N + im} b^{N + in} a^{N} b^{N}$ 的形式，为了保证 $ww$ 的结构，只能如此分割 $a^{N + im} b^{N + in}$ 和 $a^{N} b^{N}$，因为 $|vx| \geq 1$，所以不存在 $i$ 使得分割后得两个句子相等；<br><br></li>
<li>同理可以证明 $vwx$ 横跨第二个 $a$ 和 $b$ 时同样不满足泵引理；<br><br></li>
<li>对于 $vwx$ 横跨第一个 $b$ 和 第二个 $a$ 的情况，此时 $u a^{im} w b^{in} y$ 可以写成 $a^{N} b^{N + im} a^{N + in} b^{N}$ 的形式，同样为了保证 $ww$ 的结构，只能如此分割 $a^{N} b^{N + im}$ 和 $a^{N + in} b^{N}$，显然分割后的句子不相等，也就是不满足泵引理。<br><br></li>
</ol>
</li>
</ol>
<p>综上，$L$ 不是 CFL。</p>
<p><strong>题目2：</strong><br>给定文法 $G$ 如下：</p>
<p>[<br>\begin{align<em>}<br>&amp;S \to AB \,|\, AA \,|\, BC \<br>&amp;A \to CD \,|\, a \<br>&amp;B \to BD \,|\, SB \,|\, b \<br>&amp;C \to c \<br>&amp;D \to DB \,|\, b<br>\end{align</em>}<br>]</p>
<p>根据算法 CYK 算法，请识别字符串”aabbc”是否属于 $L(G)$?</p>
<p><strong>解答2：</strong><br>$x = \text{“aabbc”}$，长度 $|x| = 5$。</p>
<p>构造一个二维表 $V<em>{i,k}$，其中 $V</em>{i,k}$ 表示从位置 $i$ 开始，长度为 $k$ 的子串可以由哪些非终结符生成。</p>
<ol>
<li><p><strong>第一步：处理长度为 1 的子串</strong><br>根据文法的终结符规则，填充 $V_{i,1}$：</p>
<ul>
<li>$x<em>1 = a \implies V</em>{1,1} = {A}$</li>
<li>$x<em>2 = a \implies V</em>{2,1} = {A}$</li>
<li>$x<em>3 = b \implies V</em>{3,1} = {B, D}$</li>
<li>$x<em>4 = b \implies V</em>{4,1} = {B, D}$</li>
<li>$x<em>5 = c \implies V</em>{5,1} = {C}$</li>
</ul>
</li>
<li><p><strong>第二步：处理长度为 2 的子串</strong><br>根据文法的组合规则，填充 $V_{i,2}$：</p>
<ul>
<li>$x<em>{1,2} = “aa” \implies V</em>{1,2} = {S}$ （因为 $A \to AA$）</li>
<li>$x<em>{2,2} = “ab” \implies V</em>{2,2} = {B}$ （因为 $S \to AB$）</li>
<li>$x<em>{3,2} = “bb” \implies V</em>{3,2} = {B, D}$ （因为 $B \to BD$ 和 $D \to DB$）</li>
<li>$x<em>{4,2} = “bc” \implies V</em>{4,2} = {S}$ （因为 $S \to BC$）</li>
</ul>
</li>
<li><p><strong>第三步：处理长度为 3 的子串</strong><br>根据文法的组合规则，填充 $V_{i,3}$：</p>
<ul>
<li>$x<em>{1,3} = “aab” \implies V</em>{1,3} = {B}$ （因为 $S \to AB$）</li>
<li>$x<em>{2,3} = “abb” \implies V</em>{2,3} = {S}$ （因为 $S \to AB$ 和 $B \to SB$）</li>
<li>$x<em>{3,3} = “bbc” \implies V</em>{3,3} = {S}$ （因为 $S \to BC$）</li>
</ul>
</li>
<li><p><strong>第四步：处理长度为 4 的子串</strong><br>根据文法的组合规则，填充 $V_{i,4}$：</p>
<ul>
<li>$x<em>{1,4} = “aabb” \implies V</em>{1,4} = {S}$ （因为 $S \to AB$ 和 $B \to SB$）</li>
<li>$x<em>{2,4} = “abbc” \implies V</em>{2,4} = {S}$ （因为 $S \to BC$）</li>
</ul>
</li>
<li><p><strong>第五步：处理长度为 5 的子串</strong><br>根据文法的组合规则，填充 $V_{1,5}$：</p>
<ul>
<li>$x<em>{1,5} = “aabbc” \implies V</em>{1,5} = {S}$ （因为 $S \to AB$ 和 $B \to SB$）</li>
</ul>
</li>
</ol>
<p>最终，$V_{1,5}$ 包含 $S$，因此字符串 “aabbc” 属于文法 $G$ 的语言 $L(G)$。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/02/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/02/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">最大熵模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-02 10:02:23" itemprop="dateCreated datePublished" datetime="2025-06-02T10:02:23+08:00">2025-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 11:38:47" itemprop="dateModified" datetime="2025-06-06T11:38:47+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><h3 id="Logistic-Distribution"><a href="#Logistic-Distribution" class="headerlink" title="Logistic Distribution"></a>Logistic Distribution</h3><p>设$X$是连续随机变量，$X$服从 <strong>logistic distribution</strong> 是指$X$具有下列分布函数和密度函数：</p>
<script type="math/tex; mode=display">
\begin{align}
F(x) &= P(X \leq x) = \frac{1}{1 + e^{-(x-\mu)/\gamma}} \tag{1}
\\
f(x) &= F'(x) = \frac{e^{-(x-\mu)/\gamma}}{\gamma\left(1 + e^{-(x-\mu)/\gamma}\right)^2} \tag{2}
\end{align}</script><h3 id="Binomial-Logistic-Regression-Model"><a href="#Binomial-Logistic-Regression-Model" class="headerlink" title="Binomial Logistic Regression Model"></a>Binomial Logistic Regression Model</h3><p>这是一种二分类模型，这里规定模型输出 $Y \in {0, 1}$， 也就是 $y_i \in {0, 1}$</p>
<script type="math/tex; mode=display">
\begin{align}
P(Y = 0 | \mathbf{x}) &= \frac{1}{1 + \exp (\mathbf{w} \cdot \mathbf{x} + b)} \tag{3}
\\
P(Y = 1 | \mathbf{x}) &= \frac{\exp (\mathbf{w} \cdot \mathbf{x} + b)}{1 + \exp (\mathbf{w} \cdot \mathbf{x} + b)} \tag{4}
\end{align}</script><p>其中，$\mathbf{x} \in \mathbb{R}^n$ 是输入，$\mathbf{w} \in \mathbb{R}^n$ 和 $ b \in \mathbb{R}$ 分别是权值向量和偏置，$\mathbf{w} \cdot \mathbf{x}$ 是向量内积运算。</p>
<h3 id="Evaluation-of-Model-Parameters"><a href="#Evaluation-of-Model-Parameters" class="headerlink" title="Evaluation of Model Parameters"></a>Evaluation of Model Parameters</h3><p>采用极大似然估计法估计模型参数，从而得到 <strong><em>logistics regression model</em></strong>。</p>
<p>我们设</p>
<script type="math/tex; mode=display">
P(Y = 1 | x) = \pi(x) \tag{5}</script><p>则得到似然函数为</p>
<script type="math/tex; mode=display">
\prod_{i=1}^{N}[\pi(x_i)]^{y_i}[1 - \pi(x_i)]^{1 - y_i} \tag{6}</script><p>经过计算，对数似然函数为</p>
<script type="math/tex; mode=display">
L(w) = \sum_{i=1}^{N} [y_i(\vec{w} \cdot \vec{x_i}) - \ln (1 + \exp (\vec{w} \cdot \vec{x_i}))] \tag{7}</script><p>对 $L(w)$ 求极大值，得到 $w$ 的估计值 $\hat{w}$</p>
<hr>
<h2 id="Maximum-Entropy-Model"><a href="#Maximum-Entropy-Model" class="headerlink" title="Maximum Entropy Model"></a>Maximum Entropy Model</h2><h3 id="The-Principle-of-Maximum-Entropy"><a href="#The-Principle-of-Maximum-Entropy" class="headerlink" title="The Principle of Maximum Entropy"></a>The Principle of Maximum Entropy</h3><p>最大熵原理的核心在于，使得整个概率模型的熵最大。</p>
<h3 id="MaxEntropy-Model"><a href="#MaxEntropy-Model" class="headerlink" title="MaxEntropy Model"></a>MaxEntropy Model</h3><p>模型输入 $X \in \mathcal{X} \subseteq \mathbb{R}^n$，输出 $Y \in \mathcal{Y}$，条件概率分布 $P(Y | X)$ 表示对于给定输入 $X$ 以该条件概率输出 $Y$。</p>
<p>给定训练数据集，可以确定联合分布 $P(X, Y)$ 的经验分布和边缘分布。</p>
<script type="math/tex; mode=display">
\begin{align}
\tilde{P}(X = x, Y = y) &= \frac{\nu(X = x, Y = y)}{N} \tag{8}
\\
\tilde{P}(X = x) &= \frac{\nu(X = x)}{N} \tag{9}
\end{align}</script><p>其中 $\nu(X = x, Y = y)$ 是样本 $(x, y)$ 出现的频数。</p>
<p>接下来介绍特征函数 <strong><em>feature function</em></strong> $f(x,y)$，$f()$ 描述输入 $x$ 与输出 $y$ 之间的某一个事实。</p>
<script type="math/tex; mode=display">
f(x, y) =
\begin{cases}
1, &\text{satisfying}
\\
0, &\text{otherwise} \tag{10}
\end{cases}</script><p>特征函数关于经验分布的期望值</p>
<script type="math/tex; mode=display">
E_{\tilde{P}}(f) = \sum_{x,y} \tilde{P}(x,y) f(x,y) \tag{11}</script><p>特征函数关于模型与经验分布的期望值</p>
<script type="math/tex; mode=display">
E_P(f) = \sum_{x,y} \tilde{P}(x) P(y|x) f(x,y) \tag{12}</script><p>如果模型能够获得训练数据中的信息，则可以认为上述两个期望值相等，即</p>
<script type="math/tex; mode=display">
E_{\tilde{P}}(f) = E_P(f) \tag{13}</script><p>综上，我们引出最大熵模型。</p>
<p>假设满足所有约束条件的模型集合为</p>
<script type="math/tex; mode=display">
\mathcal{C} \equiv \{P \in \mathcal{P} \mid E_{\tilde{P}}(f_i) = E_P(f_i), \quad i=1,2,\dots,n\} \tag{14}</script><p>定义在条件概率分布 $P(Y|X)$ 上的条件熵为</p>
<script type="math/tex; mode=display">
H(P) = -\sum_{x,y} \tilde{P}(x) P(y|x) \ln P(y|x) \tag{15}</script><p>则模型集合 $\mathcal{C}$ 中条件熵 $H(P)$ 最大的模型称为最大熵模型。</p>
<h3 id="Training-a-Maximum-Entropy-Model"><a href="#Training-a-Maximum-Entropy-Model" class="headerlink" title="Training a Maximum Entropy Model"></a>Training a Maximum Entropy Model</h3><p>类似 <strong>SVM</strong> 的学习过程。给定训练数据集 $T = {(x_1,y_1),(x_2,y_2),\dots,(x_N,y_N)}$ 以及特征函数 $f_i(x,y), \quad i = 1, 2, \dots, n$，最大熵模型的学习等价于约束最优化问题：</p>
<script type="math/tex; mode=display">
\begin{align*}
\max_{P \in \mathcal{C}} \quad & H(P) = -\sum_{x, y} \tilde{P}(x) P(y \mid x) \ln P(y \mid x)
\\
\text{subject to} \quad & E_{\tilde{P}}[f_i] = E_P[f_i], \quad i = 1, 2, \dots, n
\\
& \sum_{y} P(y \mid x) = 1
\end{align*}</script><p>将其换为等价的最小化问题</p>
<script type="math/tex; mode=display">
\begin{align*}
\min_{P \in \mathcal{C}} \quad -&H(P) = \sum_{x, y} \tilde{P}(x) P(y \mid x) \ln P(y \mid x) \tag{16}
\\
\text{subject to} \quad & E_{\tilde{P}}[f_i] - E_P[f_i]= 0, \quad i = 1, 2, \dots, n \tag{17}
\\
& \sum_{y} P(y \mid x) = 1 \tag{18}
\end{align*}</script><p>将约束最优化问题转换为无约束最优化的对偶问题。引入拉格朗日乘子 $w_0, w_1, \dots, w_n$，定义拉格朗日函数 $L(P, w)$：</p>
<script type="math/tex; mode=display">
\begin{align*}
L(P, w) &\equiv -H(P) + w_0 \left(1 - \sum_{y} P(y | x)\right) + \sum_{i = 1}^{n} w_i (E_{\tilde{P}}(f_i) - E_{P}(f_i)) \tag{19}
\\
&= \sum_{x,y} \tilde{P}(x) P(y | x) \ln P(y | x) + w_0\left(1 - \sum_{y} P(y | x)\right) +
\\
&\sum_{i = 1}^{n} w_i\left(\sum_{x, y} \tilde{P}(x, y) f_i(x, y) - \sum_{x, y} \tilde{P}(x) P(y | x) f_i(x, y) \right)
\end{align*}</script><p>最优化的原始问题是</p>
<script type="math/tex; mode=display">
\min_{P \in \mathcal{C}} \max_{w} L(P, w) \tag{20}</script><p>对偶问题是</p>
<script type="math/tex; mode=display">
\max_{w} \min_{P \in \mathcal{C}} L(P, w) \tag{21}</script><p>先解决极小化问题， 记</p>
<script type="math/tex; mode=display">
\Psi(w) = \min_{P \in \mathcal{C}} L(P, w) = L(P_w, w) \tag{22}</script><p>求 $L(P, w)$ 对 $P(y | x)$ 的偏导数</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{\partial L(P, w)}{\partial P(y | x)} &= \sum_{x, y} \tilde{P}(x)(\ln P(y | x) + 1) - \sum_{y}w_0 - \sum_{x, y} \left(\tilde{P}(x) \sum_{i = 1}^{n} w_i f_i(x, y) \right)
\\
&= \sum_{x, y} \tilde{P}(x) \left(\ln P(y | x) + 1 - w_0 - \sum_{i = 1}^{n} w_i f_i(x, y) \right)
\end{align*}</script><p>令偏导数等于 $0$， 在 $\tilde{P} &gt; 0$ 的情况下，解得</p>
<script type="math/tex; mode=display">
P_w(y | x) = \frac{1}{Z_w(x)} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right) \tag{23}</script><p>其中</p>
<script type="math/tex; mode=display">
Z_w(x) = \sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right) \tag{24}</script><p>称 $Z_w(x)$ 为归一化因子。</p>
<p>最后求解对偶问题外部的极大化问题</p>
<script type="math/tex; mode=display">
\max_{w} \Psi(w) \tag{25}</script><h3 id="Improved-Iterative-Scaling"><a href="#Improved-Iterative-Scaling" class="headerlink" title="Improved Iterative Scaling"></a>Improved Iterative Scaling</h3><p>已知最大熵模型</p>
<script type="math/tex; mode=display">
P_w(y | x) = \frac{1}{Z_w(x)} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)</script><p>其中</p>
<script type="math/tex; mode=display">
Z_w(x) = \sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)</script><p>对数似然函数为</p>
<script type="math/tex; mode=display">
L(w) = \sum_{x, y} \tilde{P}(x, y) \sum_{i = 1}^{n} w_i f_i(x, y) - \sum_{x} \tilde{P}(x) \ln Z_w(x)</script><p>改进迭代算法的思路是，假设最大熵模型当前的参数向量是 $w = (w_1, w_2, \dots, w_n)^{T}$，我们希望找到一个新的参数向量 $w + \delta = (w_1 + \delta_1, \dots, w_n + \delta_n)^{T}$，使得模型的对数似然函数增值。</p>
<p><strong>算法步骤</strong></p>
<p><strong>输入</strong>：特征函数 $f_1, f_2, \dots, f_n$；经验分布 $\tilde{P}(X, Y)$；模型 $P_w(y | x)$</p>
<p><strong>输出</strong>：最优参数值 $w<em>i^{\ast}$；最优模型 $P</em>{w^{\ast}}$</p>
<p><strong>步骤1</strong>：对所有 $i \in {1, 2, \dots, n}$，取初值 $w_i = 0$。</p>
<p><strong>步骤2</strong>：对每一 $i \in {1, 2, \dots, n}$，执行以下操作：</p>
<p>首先，令 $\delta_i$ 为下列方程的解：</p>
<script type="math/tex; mode=display">
\sum_{x, y} \tilde{P}(x) P(y | x) f_i(x, y) \exp \left(\delta_i f^{\Sigma}(x, y) \right) = E_{\tilde{P}}(f_i)</script><p>其中，$f^{\Sigma}(x, y)$ 定义为：</p>
<script type="math/tex; mode=display">
f^{\Sigma}(x, y) = \sum_{i = 1}^{n} f_i(x, y)</script><p>然后，更新 $w_i$ 的值：</p>
<script type="math/tex; mode=display">
w_i \leftarrow w_i + \delta_i</script><p><strong>步骤3</strong>：如果不是所有 $w_i$ 都收敛，则重复步骤2。</p>
<h3 id="Quasi-Newton-Method-BFGS"><a href="#Quasi-Newton-Method-BFGS" class="headerlink" title="Quasi-Newton Method : BFGS"></a>Quasi-Newton Method : BFGS</h3><p>对最大熵模型而言，</p>
<script type="math/tex; mode=display">
P_w(y | x) = \frac{\exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)}{\sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)}</script><p>目标函数：</p>
<script type="math/tex; mode=display">
\min_{w \in \mathbb{R}^n} f(w) = \sum_{x} \tilde{P}(x) \ln \sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right) - \sum_{x, y} \tilde{P}(x, y) \sum_{i = 1}^{n} w_i f_i(x, y)</script><p>相应 $i$ 的梯度有，</p>
<script type="math/tex; mode=display">
\frac{\partial f(w)}{\partial w_i} = \sum_{x, y} \tilde{P}(x) P_w(y | x) f_i(x, y) - E_{\tilde{p}}(f_i)</script><p>定义 $g()$</p>
<script type="math/tex; mode=display">
g(w) = \left(\frac{\partial f(x)}{\partial w_1}, \frac{\partial f(x)}{\partial w_2}, \dots,\frac{\partial f(x)}{\partial w_n} \right)^T</script><p><strong>算法步骤</strong></p>
<p><strong>输入</strong>：特征函数 $f<em>1, f_2, \dots, f_n$；经验分布 $\tilde{P}(X, Y)$；目标函数 $f(w)$；梯度 $g(w) = \nabla f(w)$；精度要求 $\epsilon$；<br><strong>输出</strong>：最优参数值 $w_i^{\ast}$；最优模型 $P</em>{w^{\ast}}$</p>
<ol>
<li>选定初始点 $w^{(0)}$，取 $B_0$ 为正定对称矩阵，置 $k = 0$。</li>
<li>计算 $g_k = g(w^{(k)})$。<br>若 $\lVert g_k \rVert &lt; \epsilon$，则停止计算，得 $w^{*} = w^{(k)}$；否则转第 3 步。</li>
<li>由 $B_k p_k = -g_k$ 求出 $p_k$。</li>
<li>一维搜索，求 $\lambda_k$ 使得<script type="math/tex; mode=display">
 f(w^{(k)} + \lambda_k p_k) = \min_{\lambda \geq 0} f(w^{(k)} + \lambda p_k)</script></li>
<li>置 $w^{(k + 1)} = w^{(k)} + \lambda_k p_k$。</li>
<li>计算 $g<em>{k + 1} = g(w^{(k + 1)})$。<br>若 $\lVert g</em>{k + 1} \rVert &lt; \epsilon$，则停止计算，得 $w^{*} = w^{(k + 1)}$；否则，按下式求出 $B_{k + 1}$：<script type="math/tex; mode=display">
 B_{k + 1} = B_k + \frac{y_k y_k^T}{y_k^T \delta_k} - \frac{B_k \delta_k \delta_k^T B_k}{\delta_k^T B_k \delta_k}</script> 其中，<script type="math/tex; mode=display">
 y_k = g_{k + 1} - g_k, \quad \delta_k = w^{(k + 1)} - w^{(k)}</script></li>
<li>置 $k = k + 1$，转第 3 步。</li>
</ol>
<p><strong>补充说明</strong></p>
<p>在 BFGS 算法中，$B_k$ 是对目标函数 <strong><em>Hessian</em></strong> 矩阵的近似。初始时 $B_0$ 通常取为单位矩阵或其他对称正定矩阵。每次迭代后，$B_k$ 按如下公式更新：</p>
<script type="math/tex; mode=display">
B_{k + 1} = B_k + \frac{y_k y_k^T}{y_k^T \delta_k} - \frac{B_k \delta_k \delta_k^T B_k}{\delta_k^T B_k \delta_k}</script><p>其中，</p>
<ul>
<li>$\delta_k = w^{(k + 1)} - w^{(k)}$ 表示参数的变化，</li>
<li>$y<em>k = g</em>{k + 1} - g_k$ 表示梯度的变化。</li>
</ul>
<p>$B_k$ 的更新保证了其对称正定性，并逐步逼近真实的 Hessian 矩阵，从而提升搜索方向的准确性和收敛速度。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/01/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/01/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/" class="post-title-link" itemprop="url">条件随机场</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-01 13:55:26" itemprop="dateCreated datePublished" datetime="2025-06-01T13:55:26+08:00">2025-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-10 13:27:30" itemprop="dateModified" datetime="2025-09-10T13:27:30+08:00">2025-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本章仅讨论条件随机场在 <strong>标注问题（tagging problem）</strong> 的应用，因此主要讲述 <strong>线性链（linear chain）</strong> 条件随机场。</p>
<h2 id="概率无向图模型"><a href="#概率无向图模型" class="headerlink" title="概率无向图模型"></a>概率无向图模型</h2><h3 id="成对马尔可夫性"><a href="#成对马尔可夫性" class="headerlink" title="成对马尔可夫性"></a>成对马尔可夫性</h3><p>节点 $u$、$v$ 和所有其他节点 $O$，对应的随机变量分别为 $Y_u$、$Y_v$、$Y_O$（$Y$ 表示随机变量）。它们具有以下概率关系：</p>
<script type="math/tex; mode=display">
P(Y_u, Y_v | Y_O) = P(Y_u | Y_O) P(Y_v | Y_O)</script><h3 id="局部马尔可夫性"><a href="#局部马尔可夫性" class="headerlink" title="局部马尔可夫性"></a>局部马尔可夫性</h3><p>节点 $v$，$W$ 是与 $v$ 相邻的所有节点，$O$ 是其余节点。它们具有以下概率关系：</p>
<script type="math/tex; mode=display">
P(Y_v, Y_O | Y_W) = P(Y_v | Y_W) P(Y_O | Y_W)</script><h3 id="全局马尔可夫性"><a href="#全局马尔可夫性" class="headerlink" title="全局马尔可夫性"></a>全局马尔可夫性</h3><p>节点集合 $A$、$B$、$C$，其中 $A$ 和 $B$ 被 $C$ 分离。它们具有以下概率关系：</p>
<script type="math/tex; mode=display">
P(Y_A, Y_B | Y_C) = P(Y_A | Y_C) P(Y_B | Y_C)</script><h3 id="Definition-概率无向图模型"><a href="#Definition-概率无向图模型" class="headerlink" title="Definition: 概率无向图模型"></a>Definition: 概率无向图模型</h3><p>如果联合概率分布 $P(Y)$ 满足上述三个马尔可夫性质，就称此联合概率分布为概率无向图模型。</p>
<h3 id="Definition-团与最大团"><a href="#Definition-团与最大团" class="headerlink" title="Definition: 团与最大团"></a>Definition: 团与最大团</h3><p><strong>团（Clique）：</strong> 图中的一个子集，其中任意两个节点都相邻连接。</p>
<p><strong>最大团（Maximum Clique）：</strong> 不能再添加其他节点的团，即包含所有可能相邻节点的最大子集。</p>
<h3 id="概率无向图模型的因子分解"><a href="#概率无向图模型的因子分解" class="headerlink" title="概率无向图模型的因子分解"></a>概率无向图模型的因子分解</h3><script type="math/tex; mode=display">
\begin{align}
P(Y) &= \frac{1}{Z} \prod_{C} \psi_{C}(Y_C), \quad C \text{ is a maximum clique}
\\
Z &= \sum_{Y} \prod_{C} \psi_{C}(Y_C), \quad Z \text{ is normalization factor}
\\
\psi_{C}(Y_C) &= \exp\{-E(Y_C) \}
\end{align}</script><p>其中，$\psi$ 函数称为<strong>势函数</strong>，常用<strong>指数函数</strong>定义势函数。</p>
<script type="math/tex; mode=display">
\psi_{C}(Y_{C}) = e ^{- H_{C}(Y_{C})}</script><p>$H<em>{C}(Y</em>{C})$ 是一个定义在变量 $Y_{C}$ 上的实值函数，常见形式为</p>
<script type="math/tex; mode=display">
H_{C}(Y_{C}) = \sum_{u,v \in C, u \neq v} \alpha_{uv} x_u x_v + \sum_{v \in C} \beta_v x_v</script><p>其中，$\alpha<em>{uv}$ 和 $\beta</em>{v}$ 是参数。</p>
<hr>
<h2 id="CRF"><a href="#CRF" class="headerlink" title="CRF"></a>CRF</h2><h3 id="Definition-线性链条件随机场"><a href="#Definition-线性链条件随机场" class="headerlink" title="Definition: 线性链条件随机场"></a>Definition: 线性链条件随机场</h3><p>我们假设 $X$ 和 $Y$ 是随机变量。如果随机变量 $Y$ 是一个马尔可夫随机场，即满足：</p>
<script type="math/tex; mode=display">
P(Y_v | X, Y_w, w \neq v) = P(Y_v | X, Y_w, w \sim v)</script><p>其中 $w \sim v$ 表示节点 $v$ 与节点 $w$ 相邻。</p>
<blockquote>
<p>通常情况下，我们认为 $X$ 与 $Y$ 具有相同的结构。</p>
</blockquote>
<img src="/2025/06/01/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/Linear-Chain.png" class="" title="具有相同结构的线性链">
<div align = "center"><em>图1：线性链示例</em></div>

<p>我们有如下概率关系。</p>
<script type="math/tex; mode=display">
P(Y_i | X, Y_1, \dots, Y_{i-1}, Y_{i+1}, \dots, Y_n) = P(Y_i | X, Y_{i - 1}, Y_{i + 1})</script><h3 id="条件随机场的参数化形式"><a href="#条件随机场的参数化形式" class="headerlink" title="条件随机场的参数化形式"></a>条件随机场的参数化形式</h3><script type="math/tex; mode=display">
P(\mathbf{y} | \mathbf{x}) = \frac{1}{Z(\mathbf{x})} \exp \left(\sum_{i,k}\lambda_k t_k(y_{i -1}, y_i, \mathbf{x}, i) + \sum_{i,l}\mu_l s_l(y_i, \mathbf{x}, i))\right)</script><p>其中，</p>
<script type="math/tex; mode=display">
Z(\mathbf{x}) = \sum_{\mathbf{y}} \exp \left(\sum_{i,k}\lambda_k t_k(y_{i -1}, y_i, \mathbf{x}, i) + \sum_{i,l}\mu_l s_l(y_i, \mathbf{x}, i)\right)</script><p>其中，$t_k$ 和 $s_l$ 是特征函数，$\lambda_k$ 和 $\mu_l$ 是对应的权重参数。</p>
<p><strong>Simplification</strong></p>
<script type="math/tex; mode=display">
f_k(y_{i-1}, y_i, \mathbf{x}, i) =
\begin{cases}
t_k(y_{i-1}, y_i, \mathbf{x}, i), \quad &k = 1,2, \dots,K_1 \\\\
s_l(y_i, \mathbf{x}, i), \quad &k = K_1 + l; \text{ } l = 1,2,\dots, K_2
\end{cases}</script><script type="math/tex; mode=display">
f_k(\mathbf{y}, \mathbf{x}) = \sum_{i=1}^{n} f_k(y_{i-1}, y_i, \mathbf{x}, i), \quad k = 1,2,\dots,K</script><script type="math/tex; mode=display">
w_k =
\begin{cases}
\lambda_k, &k = 1,2,\dots,K_1 \\\\
\mu_l, &k = K_1 + l; \text{ } l = 1, 2, \dots, K_2
\end{cases}</script><p>即，</p>
<script type="math/tex; mode=display">
\begin{align*}
P(\mathbf{y} \mid \mathbf{x}) &= \frac{1}{Z(\mathbf{x})} \exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right) \\\\
Z(\mathbf{x}) &= \sum_{\mathbf{y}} \exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right)
\end{align*}</script><p>注意，这里的 $\sum_{\mathbf{y}}$ 是在对所有可能的标签序列求和，而不仅仅是一个确定的标签序列。</p>
<p>最后，</p>
<script type="math/tex; mode=display">
\begin{align}
P_{\mathbf{w}}(\mathbf{y} \mid \mathbf{x}) = \frac{\exp(\vec{w} \cdot \vec{F}(\mathbf{y}, \mathbf{x}))}{Z_{\mathbf{w}}(\mathbf{x})}
\end{align}</script><script type="math/tex; mode=display">
Z_{\mathbf{w}}(\mathbf{x}) = \sum_{\mathbf{y}} \exp(\vec{w} \cdot \vec{F}(\mathbf{y}, \mathbf{x}))</script><h3 id="矩阵形式"><a href="#矩阵形式" class="headerlink" title="矩阵形式"></a>矩阵形式</h3><p>对于每个标签序列，我们引入特殊的起始点和结束点标签，$y<em>0 = \text{start}$ 和 $y</em>{n+1} = \text{stop}$。对于观测序列 $\mathbf{x}$ 中的每个位置 $i = 1,2,\dots,n+1$，我们可以定义一个矩阵 $M_i \in \mathbb{R}^{m \times m}$：</p>
<script type="math/tex; mode=display">
\begin{align*}
M_i(\mathbf{x}) &= [M_i(y_{i-1}, y_i | \mathbf{x})]
\\\\
M_i(y_{i-1}, y_i |\mathbf{x}) &= \exp \left(W_i(y_{i-1}, y_i | \mathbf{x})\right)
\\\\
W_i(y_{i-1}, y_i |\mathbf{x}) &= \sum_{k=1}^{K}w_kf_k(y_{i-1},y_i,\mathbf{x},i)
\end{align*}</script><p>因此：</p>
<script type="math/tex; mode=display">
P_w(\mathbf{y} |\mathbf{x}) = \frac{1}{Z_w(\mathbf{x})} \prod_{i=1}^{n+1} M_i(y_{i-1}, y_i |\mathbf{x})</script><p>特别地：</p>
<script type="math/tex; mode=display">
Z_w(\mathbf{x}) = [M_1(\mathbf{x})M_2(\mathbf{x}) \cdots M_{n+1}(\mathbf{x})]_{\text{start},\text{stop}}</script><p>也就是矩阵 $(\text{start}, \text{stop})$ 位置上的元素。</p>
<p>矩阵形式不难理解，CRF 中的 $M<em>i(\mathbf{x})$ 矩阵就是在每个位置 $i$ 上，枚举所有可能的标签对 $(y</em>{i-1}, y_i)$，并计算它们的转移得分。例如 $m = 2$，$Y = {A, B}$，则 $M_1$ 为：</p>
<script type="math/tex; mode=display">
M_1(\mathbf{x}) =
\begin{bmatrix}
M_1(A, A \mid \mathbf{x}) & M_1(A, B \mid \mathbf{x}) \\\\
M_1(B, A \mid \mathbf{x}) & M_1(B, B \mid \mathbf{x})
\end{bmatrix}</script><hr>
<h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>接下来给出计算 $P(Y<em>i = y_i |\mathbf{x})$、$P(Y</em>{i - 1} = y_{i - 1}, Y_i = y_i |\mathbf{x})$ 以及相应数学期望的解决方法。</p>
<h3 id="前向-后向算法"><a href="#前向-后向算法" class="headerlink" title="前向-后向算法"></a>前向-后向算法</h3><p>对于每个索引 $i = 0, 1, \dots, n + 1$，我们定义前向列向量 $\alpha_i(x)$：</p>
<script type="math/tex; mode=display">
\alpha_0(y|\mathbf{x}) =
\begin{cases}
1, &y = \text{start}
\\\\
0, &\text{其他情况}
\end{cases}</script><p>递推公式为：</p>
<script type="math/tex; mode=display">
\alpha_i^T(y_i|\mathbf{x}) = \alpha_{i-1}^T (y_{i-1}|\mathbf{x}) [M_i(y_{i-1},y_i|\mathbf{x})],\quad i = 1,2,\dots,n+1 \tag{forward}</script><p>同样地，我们定义后向行向量：</p>
<script type="math/tex; mode=display">
\begin{align}
\beta_{n+1}(y_{n+1}|\mathbf{x}) &=
\begin{cases}
1, &y_{n+1} = \text{stop}
\\\\
0, &\text{其他情况}
\end{cases}
\\\\
\beta_i(y_i|\mathbf{x})& = [M_{i+1}(y_i,y_{i+1}|\mathbf{x})] \beta_{i+1}(y_{i+1}|\mathbf{x}) \tag{backward}
\end{align}</script><h3 id="概率计算"><a href="#概率计算" class="headerlink" title="概率计算"></a>概率计算</h3><script type="math/tex; mode=display">
P(Y_i = y_i | \mathbf{x}) = \frac{\alpha_i^T(y_i | \mathbf{x}) \beta_i(y_i | \mathbf{x})}{Z(\mathbf{x})}</script><script type="math/tex; mode=display">
P(Y_{i-1} = y_{i-1}, Y_i = y_i |\mathbf{x}) = \frac{\alpha_{i-1}^T(y_{i-1} |\mathbf{x}) M_i(y_{i-1},y_i |\mathbf{x}) \beta_i(y_i |\mathbf{x})}{Z(\mathbf{x})}</script><p>其中：</p>
<script type="math/tex; mode=display">
Z(\mathbf{x}) = \alpha_n^T(\mathbf{x})\mathbf{1} = \mathbf{1}^T \beta_1(\mathbf{x})</script><p><strong>可以仿照隐马尔科夫模型计算相似问题时引入 $\alpha$ 和 $\beta$ 矩阵</strong>，</p>
<h4 id="前向向量矩阵-alpha"><a href="#前向向量矩阵-alpha" class="headerlink" title="前向向量矩阵 $\alpha$"></a>前向向量矩阵 $\alpha$</h4><script type="math/tex; mode=display">
\alpha = \begin{bmatrix}
\alpha_0(A) & \alpha_0(B) & \cdots & \alpha_0(N) \\\\[10pt]
\alpha_1(A) & \alpha_1(B) & \cdots & \alpha_1(N) \\\\[10pt]
\vdots & \vdots & \ddots & \vdots \\\\[10pt]
\alpha_{n+1}(A) & \alpha_{n+1}(B) & \cdots & \alpha_{n+1}(N)
\end{bmatrix}^{T} \tag{CRF-1}</script><p>每一行表示在位置 $i$ 的前向向量 $\alpha_i$，每一列对应一个标签 $y_i \in \mathcal{Y}$。</p>
<h4 id="后向向量矩阵-beta"><a href="#后向向量矩阵-beta" class="headerlink" title="后向向量矩阵 $\beta$"></a>后向向量矩阵 $\beta$</h4><script type="math/tex; mode=display">
\beta = \begin{bmatrix}
\beta_0(A) & \beta_0(B) & \cdots & \beta_0(N) \\\\[10pt]
\beta_1(A) & \beta_1(B) & \cdots & \beta_1(N) \\\\[10pt]
\vdots & \vdots & \ddots & \vdots \\\\[10pt]
\beta_{n+1}(A) & \beta_{n+1}(B) & \cdots & \beta_{n+1}(N)
\end{bmatrix} \tag{CRF-2}</script><p>每一行表示在位置 $i$ 的后向向量 $\beta_i$，每一列对应一个标签 $y_i \in \mathcal{Y}$。</p>
<h3 id="期望值计算"><a href="#期望值计算" class="headerlink" title="期望值计算"></a>期望值计算</h3><p>比较复杂，详情参考《统计学习方法》</p>
<hr>
<h2 id="优化学习算法"><a href="#优化学习算法" class="headerlink" title="优化学习算法"></a>优化学习算法</h2><p>优化学习算法涉及改进迭代尺度法、梯度下降法以及拟牛顿法。这些方法曾在最大熵的学习算法中提及，可以比对学习。</p>
<h3 id="改进的迭代尺度法"><a href="#改进的迭代尺度法" class="headerlink" title="改进的迭代尺度法"></a>改进的迭代尺度法</h3><p>已知训练数据集，由此可知经验概率分布 $\tilde{P}(X, Y)$。可以通过极大化训练数据的对数似然函数来求模型参数。</p>
<p>训练数据的对数似然函数为：</p>
<script type="math/tex; mode=display">
L(w) = L_{\tilde{P}}(P_{w}) = \sum_{\mathbf{x} ,\mathbf{y}} \tilde{P}(\mathbf{x} ,\mathbf{y}) \log P_{w}(\mathbf{y} |\mathbf{x})</script><p>若</p>
<script type="math/tex; mode=display">
\begin{align*}
P(\mathbf{y} \mid \mathbf{x}) &= \frac{1}{Z(\mathbf{x})} \exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right) \\\\
Z(\mathbf{x}) &= \sum_{\mathbf{y}} \exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right)
\end{align*}</script><p>则</p>
<script type="math/tex; mode=display">
L(w) = \sum_{j = 1}^{N} \sum_{k = 1}^{K} w_{k} f_{k}(y_j, x_j) - \sum_{j = 1}^{N} \log Z_w(x_j)</script><h3 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h3><p>这里介绍的拟牛顿法是 $\mathbf{BFGS}$ 算法。</p>
<p><strong>输入</strong>：特征函数 $f<em>1, f_2, \cdots, f_n$；经验分布 $\tilde{P}(X, Y)$；精度要求 $\epsilon$；<br><strong>输出</strong>：最优参数值 $\hat{w}$；最优模型 $P</em>{\hat{w}}(\mathbf{y} |\mathbf{x})$。</p>
<ol>
<li>选定初始点 $w^{(0)}$，取 $B_0$ 为正定对称矩阵，置 $k = 0$。</li>
<li>计算 $g_k = g(w^{(k)})$。  若 $\lVert g_k \rVert &lt; \epsilon$，则停止计算，得 $w^{*} = w^{(k)}$；否则转第 3 步。</li>
<li>由 $B_k p_k = -g_k$ 求出 $p_k$。</li>
<li>一维搜索，求 $\lambda_k$ 使得<script type="math/tex; mode=display">
 f(w^{(k)} + \lambda_k p_k) = \min_{\lambda \geq 0} f(w^{(k)} + \lambda p_k)</script></li>
<li>置 $w^{(k + 1)} = w^{(k)} + \lambda_k p_k$。</li>
<li>计算 $g<em>{k + 1} = g(w^{(k + 1)})$。  若 $\lVert g</em>{k + 1} \rVert &lt; \epsilon$，则停止计算，得 $w^{*} = w^{(k + 1)}$；否则，按下式求出 $B_{k + 1}$：<script type="math/tex; mode=display">
 B_{k + 1} = B_k + \frac{y_k y_k^T}{y_k^T \delta_k} - \frac{B_k \delta_k \delta_k^T B_k}{\delta_k^T B_k \delta_k}</script> 其中，<script type="math/tex; mode=display">
 y_k = g_{k + 1} - g_k, \quad \delta_k = w^{(k + 1)} - w^{(k)}</script></li>
<li>置 $k = k + 1$，转第 3 步。</li>
</ol>
<h2 id="条件随机场的预测算法"><a href="#条件随机场的预测算法" class="headerlink" title="条件随机场的预测算法"></a>条件随机场的预测算法</h2><p>采用隐马尔科夫模型相似的预测算法</p>
<h3 id="维特比算法"><a href="#维特比算法" class="headerlink" title="维特比算法"></a>维特比算法</h3><p><strong>输入</strong>：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/05/30/The-Network-Layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/30/The-Network-Layer/" class="post-title-link" itemprop="url">The Network Layer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-30 21:43:21" itemprop="dateCreated datePublished" datetime="2025-05-30T21:43:21+08:00">2025-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-17 12:48:23" itemprop="dateModified" datetime="2025-06-17T12:48:23+08:00">2025-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/" itemprop="url" rel="index"><span itemprop="name">Computer Network</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/Network-Layer/" itemprop="url" rel="index"><span itemprop="name">Network Layer</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>网络层有如下功能：</p>
<ul>
<li>将从 transport layer 传来的 <strong>segment</strong> 打包成 <strong>datagram</strong>，再将 <strong>datagram</strong> 中的 <strong>segment</strong> 分离开传给 transport layer。</li>
<li>网络层协议应用在 <strong>host</strong> 和 <strong>router</strong> 中。</li>
</ul>
<p><strong>Router</strong> 和 <strong>Switch</strong> 都属于 <strong>packet switch</strong>。</p>
<p>尽管路由器和链路层交换机都被称为<strong>packet switches</strong>（分组交换机），但它们有以下根本区别：</p>
<ol>
<li><p><strong>工作层次不同</strong>：</p>
<ul>
<li>路由器（Router）：工作在<strong>网络层</strong>（第3层）</li>
<li>链路层交换机：工作在<strong>链路层</strong>（第2层）</li>
</ul>
</li>
<li><p><strong>转发决策依据</strong>：</p>
<ul>
<li>路由器：基于<strong>IP地址</strong>（网络层地址）做出转发决策</li>
<li>链路层交换机：基于<strong>MAC地址</strong>（物理地址）做出转发决策</li>
</ul>
</li>
<li><p><strong>功能范围</strong>：</p>
<ul>
<li>路由器：能够连接<strong>不同网络</strong>，执行<strong>路由决策</strong>和<strong>网络互联</strong></li>
<li>链路层交换机：主要在<strong>同一网络内</strong>转发帧</li>
</ul>
</li>
<li><p><strong>网络视角</strong>：</p>
<ul>
<li>路由器：能看到网络的<strong>拓扑结构</strong>，具有全局视野</li>
<li>链路层交换机：仅限于<strong>局部链路</strong>的连接情况</li>
</ul>
</li>
</ol>
<p>路由器拥有的IP地址数量<strong>通常等于其活跃网络接口的数量</strong>。这是因为：</p>
<ul>
<li>路由器的<strong>每个接口</strong>都需要一个IP地址来参与其所连接网络的通信</li>
<li>不同接口连接到不同的网络，因此需要不同的IP地址</li>
</ul>
<h2 id="Forwarding-and-Routing"><a href="#Forwarding-and-Routing" class="headerlink" title="Forwarding and Routing"></a>Forwarding and Routing</h2><p>这两个功能十分好理解：</p>
<ul>
<li><strong>Forwarding：</strong> 一个 router 中，决定如何移动 datagram 到正确的输出。</li>
<li><strong>Routing：</strong> 决定 datagram 在整个网络中的传输路线。</li>
</ul>
<h2 id="Network-Service-Model"><a href="#Network-Service-Model" class="headerlink" title="Network Service Model"></a>Network Service Model</h2><p>需要保证，对 <strong>individual datagram</strong>：正确传输和传输时间；对 <strong>a flow of datagrams</strong>： 顺序接受，完整传输和传输最小带宽。</p>
<h1 id="Virtual-Circuit-and-Datagram-Networks"><a href="#Virtual-Circuit-and-Datagram-Networks" class="headerlink" title="Virtual Circuit and Datagram Networks"></a>Virtual Circuit and Datagram Networks</h1><p>网络层有两种服务：<strong>connectionless service</strong> 和 <strong>connection service</strong>；这两种服务分别应用在 <strong>datagram network</strong> 和 <strong>virtual circuit network</strong>。</p>
<h2 id="Datagram-Network"><a href="#Datagram-Network" class="headerlink" title="Datagram Network"></a>Datagram Network</h2><p>数据包网络使用的是<strong>动态路由</strong>，每一个数据包可以根据当前的网络状况独立地选择路径。</p>
<h3 id="Forwarding-Table"><a href="#Forwarding-Table" class="headerlink" title="Forwarding Table"></a>Forwarding Table</h3><p><strong>Forwarding table</strong> 应用在 <strong>router</strong> 中，决定如何移动 datagram 到正确的输出。</p>
<p>具体形式如下表格所示，可以看到就是一个简单的地址到接口的映射</p>
<div style="display: block; margin: 0 auto; width: fit-content;">

| **Destination Address Range**        | **Link Interface**     |
|:------------------------------------:|:----------------------:|
| $\sim$                               | $0$                    |
| $\sim$                               | $1$                    |
| otherwise                            | $2$                    |

</div>

<p><strong>需要注意的是</strong>：表格中的 <strong>Destination Address Range</strong> 可以不是完整的 IP address，而是其的一个前缀；比如 <strong>00111000</strong>，对应的地址范围是 <strong>00111000 00000000 00000000 00000000</strong> 到 <strong>00111000 11111111 11111111 11111111 11111111</strong>。这时 forwarding table 变成：</p>
<div style="display: block; margin: 0 auto; width: fit-content;">

| **Header**        | **Link Interface**     |
|:------------------------------------:|:----------------------:|
| $\sim$                               | $0$                    |
| $\sim$                               | $1$                    |
| otherwise                            | $2$                    |

</div>

<h1 id="What’s-inside-a-Router"><a href="#What’s-inside-a-Router" class="headerlink" title="What’s inside a Router"></a>What’s inside a Router</h1><p>有两个重要的路由功能：</p>
<ul>
<li>运行路由算法。</li>
<li>推送 datagram。</li>
</ul>
<h2 id="Input-Port"><a href="#Input-Port" class="headerlink" title="Input Port"></a>Input Port</h2><div align="center">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A[Line Termination &lt;br&gt; bit-level reception] --&gt; B[Data Link Processing]</span><br><span class="line">    B --&gt; C[Look up and Forwarding &lt;br&gt; Queueing]</span><br><span class="line">    C --&gt; D[Switch Fabric]</span><br></pre></td></tr></table></figure>

</div>

<p>这里涉及到的 <strong>look up and forwarding</strong> 的方式是 <strong>decentralized switching</strong>，也就是 <strong>forwarding table</strong> 已经存入到了 input port 的 <strong>memory</strong> 中。</p>
<h2 id="Switching-Fabric"><a href="#Switching-Fabric" class="headerlink" title="Switching Fabric"></a>Switching Fabric</h2><p>有三种 <strong>switching fabrics</strong>。</p>
<h3 id="Switching-via-Memory"><a href="#Switching-via-Memory" class="headerlink" title="Switching via Memory"></a>Switching via Memory</h3><p>这时可以把路由器看作是一个 <strong>computer</strong>。使用电脑的 <strong>CPU</strong> 来 switching。</p>
<p>这个流程是，先把 datagram 拷贝到电脑 <strong>memory</strong> 中，在从 memory 传到相应的 output port。</p>
<p>可以分析的是：<strong>memory bandwidth</strong> 是限制 <strong>switching rate</strong> 的主要因素。同时需要注意的是，每个 datagram 会经过两次 <strong>system bus</strong>。</p>
<h3 id="Switching-via-Bus"><a href="#Switching-via-Bus" class="headerlink" title="Switching via Bus"></a>Switching via Bus</h3><p>其中只用到一个 bus。bus bandwidth 限制了 <strong>switching speed</strong>。</p>
<h3 id="Switching-via-Interconnection-Network"><a href="#Switching-via-Interconnection-Network" class="headerlink" title="Switching via Interconnection Network"></a>Switching via Interconnection Network</h3><p>网状结构。先 <strong>fragmenting datagram</strong> into fixed length cells，再 switch cells through the fabric。</p>
<h2 id="Output-Port"><a href="#Output-Port" class="headerlink" title="Output Port"></a>Output Port</h2><div align="center">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A[Switch Fabric] --&gt; B[Queueing: Buffer Management]</span><br><span class="line">    B --&gt; C[Data Link Processing]</span><br><span class="line">    C --&gt; D[Line Termination]</span><br></pre></td></tr></table></figure>

</div>

<h3 id="Output-Port-Queueing"><a href="#Output-Port-Queueing" class="headerlink" title="Output Port Queueing"></a>Output Port Queueing</h3><p>Buffering when arrival rate via switch <strong>exceeds</strong> output line speed. Queueing (<strong>delay</strong>) and loss due to output port buffer overflows.</p>
<p>所以，需要多大的 buffer？假设 <strong>typical $\text{RTT}$</strong>（一般是 $250$ ms），link capacity $C$，有 $N$ 个 datagram flow。则：</p>
<script type="math/tex; mode=display">
\text{buffering} = \frac{\text{RTT} \cdot C}{\sqrt{N}}</script><h3 id="Input-Port-Queueing"><a href="#Input-Port-Queueing" class="headerlink" title="Input Port Queueing"></a>Input Port Queueing</h3><p>同样，输入端也会堵塞。应用了名叫 <strong>Head-of-the-Line (HOL) blocking</strong> 的机制，这个机制很好理解：就是排在前面的 datagram 传输了，其后面的 datagram 才能传输。</p>
<h1 id="Internet-Protocol"><a href="#Internet-Protocol" class="headerlink" title="Internet Protocol"></a>Internet Protocol</h1><p>这个协议干了三件事：<strong>addressing conventions</strong>（地址约定），<strong>datagram format</strong>，<strong>packet handling conventions</strong>（分组处理约定）。</p>
<h2 id="IP-Datagram-Format"><a href="#IP-Datagram-Format" class="headerlink" title="IP Datagram Format"></a>IP Datagram Format</h2><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><p><img src="The-Network-Layer/IPv4 datagram format.png" alt="IPv4 datagram format">{style=”display: block; margin: 0 auto; width: 60%”}</p>
<p><strong>总结表格：</strong></p>
<div style="display: block; margin: 0 auto; width: fit-content;">

| 字段名                    | 长度      | 作用/说明                         |
|--------------------------|-----------|-----------------------------------|
| Version                  | 4 位     | IP 协议版本号                     |
| Header Length            | 4 位     | 首部长度（单位：$4$ 字节，最少 $5$ ）|
| Type of Service          | 8 位     | 服务类型/QoS                      |
| Datagram Length          | 16 位    | 数据报总长度（单位：$1$ 字节）      |
| Identifier               | 16 位    | 分片标识符                        |
| **Flags**                | 3 位     | 分片控制标志                      |
| **Fragmentation Offset** | 13 位    | 分片偏移量（单位：$8$ 字节）       |
| Time-to-Live (TTL)       | 8 位     | 生存时间/最大跳数                 |
| Upper-layer Protocol     | 8 位     | 上层协议类型                      |
| Header Checksum          | 16 位    | 首部校验和                        |
| Source IP Address        | 32 位    | 源 IP 地址                        |
| Destination IP Address   | 32 位    | 目的 IP 地址                      |
| Options                  | 可变     | 可选字段                          |
| Data                     | 可变     | 负载数据                          |

</div>

<p><strong>补充</strong>：</p>
<ul>
<li><strong>Flags</strong> 有 $3$ 位，第一位恒为 $0$，第二位表示 <strong>Don’t fragment</strong>（不可分片），第三位表示 <strong>More fragments</strong>（后续有分片）。为 $1$ 的时候相应功能开启。</li>
</ul>
<h3 id="IP-Fragmentation-and-Reassembly"><a href="#IP-Fragmentation-and-Reassembly" class="headerlink" title="IP Fragmentation and Reassembly"></a>IP Fragmentation and Reassembly</h3><p>从 IPv4 的 datagram format 中可以发现，必要时会对 datagram 切片。</p>
<p><strong>MTU</strong>：max transfer size。这是对 <strong>link</strong> 而言，也就是说不同的 <strong>link</strong> 有不同的 <strong>MTU</strong>。</p>
<p><strong>Fragmentation and Reassembly</strong> 的过程很简单，就是需要时切分 datagram，最后在最终目的主机的网络层进行：只有当所有分片都到达后，网络层才会将完整的数据报交给上层（如传输层）。</p>
<p>假设原 IP datagram 总长度为 $L$，待转发链路的 MTU 为 $M$，若 $L &gt; M$ 且 DF 为 $0$，则需要分片。</p>
<ul>
<li>先复制 <strong>Identifier</strong>。</li>
<li>一个切片可封装的数据为：<script type="math/tex">d = \left \lfloor \frac{M - 20}{8} \right \rfloor \times 8</script></li>
<li>需要的总片数为：<script type="math/tex">n = \left \lceil \frac{L - 20}{d} \right \rceil</script></li>
</ul>
<h2 id="IPv4-Addressing"><a href="#IPv4-Addressing" class="headerlink" title="IPv4 Addressing"></a>IPv4 Addressing</h2><h3 id="Subnet"><a href="#Subnet" class="headerlink" title="Subnet"></a>Subnet</h3><p><strong>IP address</strong>: subnet part (high order bits) $+$ host part (low order bits).</p>
<p>在一个 subnet 中的所有设备都可以直接<strong>物理意义上</strong>地连接。</p>
<p><strong>Subnet mask</strong>：用类似 <code>/24</code> 的形式表示。也就是说，前 $24$ 相同的 IP address 在同一个 subnet 中。</p>
<h4 id="Classes-Inter-Domain-Routing-CIDR"><a href="#Classes-Inter-Domain-Routing-CIDR" class="headerlink" title="Classes Inter Domain Routing: CIDR"></a>Classes Inter Domain Routing: CIDR</h4><p>规定了 address format 为 <code>a.b.c.d/x</code>。</p>
<h4 id="Dynamic-Host-Configuration-Protocol-DHCP"><a href="#Dynamic-Host-Configuration-Protocol-DHCP" class="headerlink" title="Dynamic Host Configuration Protocol: DHCP"></a>Dynamic Host Configuration Protocol: DHCP</h4><p><strong>Goal</strong>: allow host to dynamically get his IP address from a server when it joins network.</p>
<ul>
<li>Can renew its lease on address in use.</li>
<li>Allows reuse of address.</li>
<li>Support for mobile users who want to join network.</li>
</ul>
<p><strong>DHCP</strong>（Dynamic Host Configuration Protocol，动态主机配置协议）是一个<strong>网络管理协议</strong>，用于在IP网络中<strong>自动分配IP地址和其他网络配置参数</strong>给网络设备。DHCP运行在<strong>应用层</strong>，使用<strong>UDP协议</strong>，客户端使用<strong>端口68</strong>，服务器使用<strong>端口67</strong>。</p>
<p><img src="The-Network-Layer/DHCP client-server interaction.png" alt="DHCP client-server interaction">{style=”display: block; margin: 0 auto; width: 50%”}</p>
<div style="display: block; margin: 0 auto; width: fit-content">

| 步骤 | 消息类型 | 发送者 | 接收者 | 主要内容 |
|------|----------|--------|--------|----------|
| 1 | DISCOVER | 客户端 | 广播 | "我需要一个IP地址" |
| 2 | OFFER | 服务器 | 客户端 | "你可以使用这个IP" |
| 3 | REQUEST | 客户端 | 广播 | "我想使用这个IP" |
| 4 | ACK | 服务器 | 客户端 | "IP已分配，租期为X" |

</div>

<p><strong>yiaddr</strong>（your IP address）是DHCP协议中表示<strong>服务器提供给客户端的IP地址</strong>的字段。</p>
<p><strong>补充</strong>：DHCP 还可以 return <strong>address of first-hop router for client</strong>，<strong>name and IP address of DNS server</strong>，<strong>network mask</strong>。</p>
<h3 id="Network-Address-Translation-NAT"><a href="#Network-Address-Translation-NAT" class="headerlink" title="Network Address Translation: NAT"></a>Network Address Translation: NAT</h3><p><img src="The-Network-Layer/Network address translation.png" alt="Network address translation">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p>右边：局域网内通信，使用内部地址：<code>10.0.0/24</code>；左边：局域网外通信，共用唯一地址。注意，没有共用同一个端口号，因为端口号是用来区分的。比如：</p>
  <div style="display: block; margin: 0 auto; width: fit-content">

  | WAN 侧 (对外显示) | LAN 侧 (实际主机) |
  |:---------------:|:----------------:|
  | 203.0.113.5:50001 | 192.168.1.10:3345 |
  | 203.0.113.5:50002 | 192.168.1.10:3346 |
  | 203.0.113.5:50003 | 192.168.1.11:3345 |

  </div>

<p>这样布置有一个比较好的优势：可以更换 ISP 的同时不改变局域网内的地址。</p>
<p>注意到中间的 <strong>NAT router</strong>。它的功能如下：</p>
<ul>
<li>对 <strong>outgoing datagrams</strong>，把原始 IP address 和 port 更换为自己的 IP address 和 port。</li>
<li>再把上述转换记下来记为 <strong>NAT translation table</strong>。</li>
<li>对 <strong>incoming datagrams</strong>，更换。</li>
</ul>
<p>现在回顾 NAT，不难察觉几个问题：</p>
<ul>
<li>如果 LAN 中的 host 想要通过 P2P 进行 communication，此时该怎么办？</li>
<li>如果一个服务器是 NAT 的 LAN 地址，怎么办？</li>
</ul>
<h2 id="Internet-Control-Message-Protocol-ICMP"><a href="#Internet-Control-Message-Protocol-ICMP" class="headerlink" title="Internet Control Message Protocol: ICMP"></a>Internet Control Message Protocol: ICMP</h2><p>这个协议 used by hosts and routers to communicate network-level information。具体包括：</p>
<ul>
<li>Error reporting.</li>
<li>Echo request and reply.</li>
</ul>
<p><strong>ICMP message</strong> 的结构包括：<strong>type</strong>、<strong>code</strong>、<strong>checksum</strong> 以及数据部分。</p>
<p>具体用来干什么？</p>
<ul>
<li>通过发送 UDP segment，在 IP datagram header 内设置适当的 TTL，来计算 $\text{RTT}$。</li>
<li>还可以用来停止 source 持续发送 UDP segment。</li>
</ul>
<div style="display: block; margin: 0 auto; width: fit-content">

| 字段名 | 长度 | 作用/说明 |
|-------|------|----------|
| **Type** | 8位 | 消息类型（如0=回显回复，3=目的不可达，8=回显请求） |
| **Code** | 8位 | 消息子类型（进一步说明类型） |
| **Checksum** | 16位 | 校验和（覆盖整个ICMP消息） |
| **Rest of Header** | 32位 | 取决于Type和Code的其他信息 |
| **Data** | 可变 | 负载数据（例如原始数据包的片段） |

</div>

<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>为了解决 IPv4 地址不足。具体 format 不讲，但要注意 header 大小为 $40$ bytes，只有 address 大小变为 $128$ bits。</p>
<h3 id="Transition-from-IPv4-to-IPv6"><a href="#Transition-from-IPv4-to-IPv6" class="headerlink" title="Transition from IPv4 to IPv6"></a>Transition from IPv4 to IPv6</h3><p><img src="The-Network-Layer/Tunneling.png" alt="Tunneling">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>Tunneling</strong>: IPv6 carried as payload in IPv4 datagram among Ipv4 routers.</p>
<h1 id="Routing-Algorithms"><a href="#Routing-Algorithms" class="headerlink" title="Routing Algorithms"></a>Routing Algorithms</h1><h2 id="Software-Defined-Networking-SDN"><a href="#Software-Defined-Networking-SDN" class="headerlink" title="Software-Defined Networking: SDN"></a>Software-Defined Networking: SDN</h2><p>实际上，network layer 可以分为 <strong>data plane</strong> 和 <strong>control plane</strong>，在 <strong>control plane</strong> 有一个 logically centralized routing controller，由它 compute paths。</p>
<h2 id="Link-State-Algorithm"><a href="#Link-State-Algorithm" class="headerlink" title="Link State Algorithm"></a>Link State Algorithm</h2><h3 id="Dijkstra’s-Link-State-Algorithm"><a href="#Dijkstra’s-Link-State-Algorithm" class="headerlink" title="Dijkstra’s Link-State Algorithm"></a>Dijkstra’s Link-State Algorithm</h3><p>伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">N = &#123;u&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> a : nodes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isAdjacent</span>(u, a)) &#123;</span><br><span class="line">      D[a] = <span class="built_in">Cost</span>(u, a);</span><br><span class="line">      P[a] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      D[a] = INF;</span><br><span class="line">      P[a] = a;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (! all nodes in N) &#123;</span><br><span class="line">    D[a] = <span class="built_in">min</span>(D)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> b : nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isAdjacent</span>(b ,a)) &#123;</span><br><span class="line">          D[b] = <span class="built_in">min</span>(D[b], <span class="built_in">Cost</span>(b, a) + D[a])</span><br><span class="line">          <span class="keyword">if</span> (D[b] == <span class="built_in">Cost</span>(b, a) + D[a]) P[b] = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际做题的时候可以参考书上的风格：</p>
<p>记 $N’$ 为<strong>已找到最短路径</strong>的点集合，函数 $D(x)$ 为到点 $x$ 的最短路径，函数 $P(x)$ 为点 $x$ 的父母结点。可以规范化求解过程如下，其中 $0$ 轮初始化。</p>
<div style="display: block; margin: 0 auto; width: fit-content;">

| **Step**        | **$N'$**     |**$D()\,P()$**|**$D()\,P()$**| **$\cdots$** |**$D()\,P()$**|
|:---------------:|:------------:|:------------:|:------------:|:------------:|:------------:|
| $0$             | $u$          |  dis  node   |  dis  node   |  dis  node   |  dis  node   |
| $1$             | $uv$         |  dis  node   |  dis  node   |  dis  node   |  dis  node   |
| $2$             | $uvw$        |  dis  node   |  dis  node   |  dis  node   |  dis  node   |
| $\cdots$        | $\cdots$     |  dis  node   |  dis  node   |  dis  node   |  dis  node   |
| $N$             |$uvw \cdots l$|  dis  node   |  dis  node   |  dis  node   |  dis  node   |

</div>

<p>这样可以求出从起点到图中其它点的所有最短路径。可以用来制作 forwarding table。</p>
<p>可以用<strong>优先队列</strong>优化时间复杂度。</p>
<p>这里需要提到一个概念 <strong>Oscillation possible</strong>，指的是网络路由状态可能出现反复波动、难以稳定的现象，是网络设计和协议实现中需要重点关注和避免的问题。这可能会导致在 Link State Algorithm 中计算到无穷的结果。</p>
<h2 id="Distance-Vector-Algorithm"><a href="#Distance-Vector-Algorithm" class="headerlink" title="Distance Vector Algorithm"></a>Distance Vector Algorithm</h2><p><strong>Distributed Bellman-Ford equation</strong>: <script type="math/tex">D(x \to y) = \min_{v} \{\text{Cost}_{x \to v} + D(v \to y), \, D(x \to y)\}</script></p>
<p>其中，$v$ 是 $x$ 的邻居。</p>
<p>这是一个 <strong>iterative</strong> 算法，需要多次计算，直到收敛。计算过程可以参考课本，如下表所述，结点 $z$ 的 table。</p>
<div style="display: block; margin: 0 auto; width: fit-content">

|   $z$  | cost to|        |        |        |        |
|:------:|:------:|:------:|:------:|:------:|:------:|
|        | $x$      | $y$      | $z$      | $u$      | $v$      |
| from $x$ | $2$      | $3$      | $\infty$ | $\infty$ | $3$      |
| from $y$ | $3$      | $\infty$ | $\infty$ | $2$      | $\infty$ |
| from $z$ | $2$      | $5$      | $0$      | $7$      | $5$      |
| from $u$ | $\infty$ | $2$      | $\infty$ | $\infty$ | $2$      |
| from $v$ | $3$      | $\infty$ | $6$      | $1$      | $\infty$ |

</div>

<h1 id="Hierarchical-Routing"><a href="#Hierarchical-Routing" class="headerlink" title="Hierarchical Routing"></a>Hierarchical Routing</h1><p><strong>Internet approach to scalable routing</strong>: aggregate routers into regions known as <strong>autonomous system (AS)</strong></p>
<p><img src="The-Network-Layer/AS structure.jpg" alt="AS structure">{style=”display: block; margin: 0 auto; width: 100%”}</p>
<h2 id="Intra-AS-Routing-Protocol"><a href="#Intra-AS-Routing-Protocol" class="headerlink" title="Intra-AS Routing Protocol"></a>Intra-AS Routing Protocol</h2><ol>
<li>RIP: Routing Information Protocol (wasted).</li>
<li>OSPF: Open Shortest Path First (Link-State).</li>
<li>EIGRP: Enhanced Interior Gateway Routing Protocol.</li>
</ol>
<h3 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF: Open Shortest Path First"></a>OSPF: Open Shortest Path First</h3><p>classic link-state:</p>
<ol>
<li>Each router floods <strong>OSPF</strong> link-state advertisements (over IP) to all routers.</li>
<li>Multiple link costs metrics possible: bandwidth, delay.</li>
<li>Each router has full topology, Dijkstra algorithm.</li>
</ol>
<p>Security: all OSPF messages authenticated</p>
<p><img src="The-Network-Layer/Hierarchical OSPF.png" alt="Hierarchical OSPF">{style=”display: block; margin: 0 auto; width: 80%”}</p>
<h2 id="Inter-AS-Protocol"><a href="#Inter-AS-Protocol" class="headerlink" title="Inter-AS Protocol"></a>Inter-AS Protocol</h2><h3 id="BGP-Border-Gateway-Protocol"><a href="#BGP-Border-Gateway-Protocol" class="headerlink" title="BGP: Border Gateway Protocol"></a>BGP: Border Gateway Protocol</h3><p>BGP provides each AS a means to:</p>
<ul>
<li>obtain destination network reachability information form neighboring ASes eBGP.</li>
<li>determine routers to other networks based on reachability information and policy.</li>
<li>propagate reachability information to all AS-internal routers: iBGP.</li>
<li>advertise (to neighboring networks) destination reachability information.</li>
</ul>
<p><img src="The-Network-Layer/eBGP and iBGP sessions.png" alt="eBGP and iBGP sessions">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<ul>
<li>BGP对等体（BGP peers）通过<strong>半永久TCP连接</strong>（BGP会话）交换路由信息。</li>
<li>BGP会话不一定对应物理链路。</li>
<li>当AS2向AS1通告前缀时：<ul>
<li>AS2 <strong>承诺</strong>会为该前缀转发数据报。</li>
<li>AS2可以在通告中聚合前缀。</li>
</ul>
</li>
<li>通过eBGP会话，AS3将前缀可达性信息发送给AS1。</li>
<li>AS1内部的路由器（如1c）通过iBGP将新前缀信息分发给AS1内所有路由器。</li>
<li>AS1的1b路由器可以通过eBGP会话将新前缀信息再通告给AS2。</li>
<li>路由器学到新前缀后，会在转发表中为该前缀创建条目。</li>
<li>BGP通告的前缀包含<strong>BGP属性</strong>，前缀+属性即为<strong>路由</strong>。</li>
<li>两个重要属性：<ul>
<li><strong>AS-PATH</strong>：记录前缀通告经过的AS序列（如AS 67, AS 17）。</li>
<li><strong>NEXT-HOP</strong>：指明到下一个AS的具体内部路由器（可能有多条链路）。</li>
</ul>
</li>
<li>当网关路由器收到路由通告时，会根据<strong>import policy</strong>（导入策略）决定是否接受该路由。</li>
</ul>
<p>假设有以下网络拓扑结构：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        +------+</span><br><span class="line">        | AS65 |</span><br><span class="line">        +------+</span><br><span class="line">       /        \</span><br><span class="line">      /          \</span><br><span class="line">+------+        +------+</span><br><span class="line">| AS23 |--------| AS17 |</span><br><span class="line">+------+        +------+</span><br><span class="line">   |                |</span><br><span class="line">+------+        +------+</span><br><span class="line">| AS45 |        | AS78 |</span><br><span class="line">+------+        +------+</span><br><span class="line">                 /</span><br><span class="line">             +------+</span><br><span class="line">             | AS99 |---前缀：192.168.99.0/24</span><br><span class="line">             +------+</span><br></pre></td></tr></table></figure>

</div>

<p>AS-PATH传播过程</p>
<p>假设AS99宣告前缀192.168.99.0/24，我们跟踪这个前缀在网络中的传播：</p>
<ol>
<li><p><strong>AS99向AS78通告前缀</strong>：</p>
<ul>
<li>AS99向AS78发送BGP更新：<code>192.168.99.0/24, AS-PATH=&#123;99&#125;</code></li>
<li>AS78收到前缀后，将其存入路由表</li>
</ul>
</li>
<li><p><strong>AS78向AS17通告前缀</strong>：</p>
<ul>
<li>AS78在转发前，将自己的AS号添加到AS-PATH</li>
<li>AS78发送BGP更新：<code>192.168.99.0/24, AS-PATH=&#123;78, 99&#125;</code></li>
</ul>
</li>
<li><p><strong>AS17向多个AS传播</strong>：</p>
<ul>
<li>AS17向AS23发送：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li>
<li>AS17向AS65发送：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li>
</ul>
</li>
<li><p><strong>AS23收到两种路径</strong>：</p>
<ul>
<li>从AS17：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li>
<li>从AS45（假设AS45也与AS99间接相连）：<code>192.168.99.0/24, AS-PATH=&#123;45, ..., 99&#125;</code></li>
<li>AS23基于AS-PATH长度和其他策略选择最佳路径</li>
</ul>
</li>
<li><p><strong>AS65收到更新后</strong>：</p>
<ul>
<li>获得路由：<code>192.168.99.0/24, AS-PATH=&#123;65, 17, 78, 99&#125;</code></li>
<li>若之后收到AS23的路由通告，也会比较两条路径</li>
</ul>
</li>
</ol>
<h1 id="Subnet、Prefix和BGP-Route的对比分析"><a href="#Subnet、Prefix和BGP-Route的对比分析" class="headerlink" title="Subnet、Prefix和BGP Route的对比分析"></a>Subnet、Prefix和BGP Route的对比分析</h1><h2 id="Subnet（子网）"><a href="#Subnet（子网）" class="headerlink" title="Subnet（子网）"></a>Subnet（子网）</h2><p><strong>子网</strong>是指<strong>物理网络的逻辑划分</strong>，具有以下特征：</p>
<ul>
<li>由<strong>共享相同网络前缀</strong>的IP地址集合组成</li>
<li>通过<strong>网络地址</strong>和<strong>子网掩码</strong>定义（如192.168.1.0/24）</li>
<li>子网内设备可<strong>直接通信</strong>，无需路由器转发</li>
<li>代表<strong>单一广播域</strong>内的网络段</li>
<li>通常属于<strong>单一管理实体</strong></li>
</ul>
<h2 id="Prefix（前缀）"><a href="#Prefix（前缀）" class="headerlink" title="Prefix（前缀）"></a>Prefix（前缀）</h2><p><strong>前缀</strong>是<strong>IP地址空间中的地址块</strong>，具有以下特征：</p>
<ul>
<li>用<strong>CIDR表示法</strong>表示（如10.0.0.0/8）</li>
<li>表示IP地址中固定的<strong>网络部分位数</strong></li>
<li>是<strong>路由表聚合</strong>的基础单位</li>
<li>可以表示<strong>不同大小</strong>的地址块</li>
<li>是<strong>地址分配和路由通告</strong>的基本单位</li>
</ul>
<h2 id="BGP-Route（BGP路由）"><a href="#BGP-Route（BGP路由）" class="headerlink" title="BGP Route（BGP路由）"></a>BGP Route（BGP路由）</h2><p><strong>BGP路由</strong>是<strong>互联网核心路由系统</strong>中的路由条目：</p>
<ul>
<li>包含<strong>目的地前缀</strong>和<strong>完整路径属性</strong></li>
<li>核心属性包括<strong>AS_PATH</strong>（自治系统路径）、<strong>NEXT_HOP</strong>等</li>
<li>反映了<strong>网络政策</strong>和<strong>商业关系</strong></li>
<li>用于<strong>自治系统间</strong>的路由决策</li>
<li>通过BGP协议在全球互联网中<strong>传播和交换</strong></li>
</ul>
<p>NEXT-HOP属性在BGP中用于<strong>指明到达目标网络的下一跳路由器IP地址</strong>，具体使用方式如下：</p>
<ol>
<li><p><strong>路由转发决策</strong></p>
<ul>
<li>当路由器接收到目标数据包时，通过查询BGP表中的NEXT-HOP属性确定<strong>实际转发目标</strong></li>
<li>路由器必须能够通过IGP协议(如OSPF)到达NEXT-HOP地址</li>
</ul>
</li>
<li><p><strong>BGP会话中的传递规则</strong></p>
<ul>
<li><strong>eBGP传递</strong>：设置为发送更新的BGP对等体的IP地址</li>
<li><strong>iBGP传递</strong>：保持NEXT-HOP值不变（除非明确配置修改）</li>
<li><strong>多出口AS</strong>：帮助选择最佳出口点</li>
</ul>
</li>
<li><p><strong>策略实现</strong></p>
<ul>
<li>通过修改NEXT-HOP实现<strong>流量工程</strong></li>
<li>支持热备份和负载均衡策略</li>
<li>可设置为特定接口地址或第三方路由器地址</li>
</ul>
</li>
</ol>
<p>AS-PATH属性记录了<strong>路由通告经过的AS序列</strong>，在BGP中具有多重重要功能：</p>
<ol>
<li><p><strong>路由选择依据</strong></p>
<ul>
<li>作为BGP决策过程中的<strong>关键指标</strong>之一</li>
<li><strong>AS-PATH越短</strong>的路径通常被优先选择</li>
<li>影响决策优先级：Local Preference &gt; AS-PATH长度 &gt; Origin &gt; MED等</li>
</ul>
</li>
<li><p><strong>环路检测机制</strong></p>
<ul>
<li>当路由器在AS-PATH中发现<strong>自己的AS号</strong>时，自动拒绝该路由</li>
<li>避免路由环路产生，确保BGP路由收敛性</li>
<li>例如：AS17收到路径”AS23, AS45, AS17, AS78”会直接丢弃</li>
</ul>
</li>
<li><p><strong>路径操纵技术</strong></p>
<ul>
<li>通过<strong>AS-PATH预置</strong>(prepending)增加路径长度</li>
<li>例如：”AS78, AS78, AS78, AS99”使路径看起来更长</li>
<li>降低特定路径被选择的可能性，实现出站流量控制</li>
</ul>
</li>
<li><p><strong>路由过滤依据</strong></p>
<ul>
<li>基于AS-PATH中的特定AS创建<strong>过滤策略</strong></li>
<li>可拒绝包含竞争对手或不信任AS的路由</li>
<li>实现复杂的路由策略控制和商业关系维护</li>
</ul>
</li>
</ol>
<h2 id="三者关系对比"><a href="#三者关系对比" class="headerlink" title="三者关系对比"></a>三者关系对比</h2><div style="display: block; margin: 0 auto; width: fit-content">

| 特性 | Subnet | Prefix | BGP Route |
|------|--------|--------|-----------|
| **范围** | 局部网段 | 地址块 | 全球路由 |
| **用途** | 网络分段 | 地址分配与聚合 | 域间路由决策 |
| **包含信息** | 网络地址+掩码 | 地址块+长度 | 前缀+路径属性 |
| **管理层次** | 单一管理域内 | 可跨域使用 | 多AS协作 |
| **通告机制** | 不直接通告 | 内部路由协议 | BGP协议 |
| **聚合能力** | 固定大小 | 可变大小 | 可聚合或特定 |

</div>

<h2 id="层次关系"><a href="#层次关系" class="headerlink" title="层次关系"></a>层次关系</h2><p>这三个概念形成了一个层次结构：</p>
<ul>
<li><strong>Subnet</strong>：最基础，表示<strong>实际网络分段</strong></li>
<li><strong>Prefix</strong>：中间层，表示<strong>可路由的地址块</strong></li>
<li><strong>BGP Route</strong>：最高层，表示<strong>如何到达特定前缀的完整路径信息</strong></li>
</ul>
<p>一个BGP路由可以指向一个前缀，而一个前缀可以包含多个子网。</p>
<h1 id="End-of-chapter-exercises"><a href="#End-of-chapter-exercises" class="headerlink" title="End-of-chapter exercises"></a>End-of-chapter exercises</h1><h2 id="P-6"><a href="#P-6" class="headerlink" title="P.6"></a>P.6</h2><p><strong>Questions:</strong></p>
<p>In the text we have used the term connection-oriented service to describe a transport-layer service and connection service for a network-layer service. Why the subtle shades in terminology?</p>
<p><strong>Answer:</strong></p>
<p>The subtle difference in terminology reflects the distinct roles and responsibilities of the transport and network layers:</p>
<ul>
<li><p><strong>Connection-oriented service (Transport Layer):</strong><br>At the transport layer, a connection-oriented service (such as TCP) establishes, maintains, and terminates a logical end-to-end connection. This connection is defined <strong>between two processes</strong> on the end hosts (e.g., two TCP sockets). This service ensures reliable, ordered, and error-checked delivery of data across the entire network path, directly between the communicating applications.</p>
</li>
<li><p><strong>Connection service (Network Layer):</strong><br>At the network layer, a connection service (such as a virtual circuit) refers to the establishment of a logical path through the network, typically between routers or switches. This connection is defined <strong>between two hosts</strong> (and their intervening routers in the case of virtual-circuit networks). This path helps guide packets from source to destination but does not necessarily guarantee reliability or ordering. The focus here is on the route and forwarding of packets within the network infrastructure.</p>
</li>
</ul>
<p><strong>In summary:</strong><br>The term “connection-oriented service” at the transport layer emphasizes end-to-end reliability and communication, while “connection service” at the network layer highlights the setup of a path through the network, without necessarily providing full end-to-end guarantees. The nuanced terminology helps clarify the different scopes and guarantees provided by each layer.</p>
<h2 id="P-9"><a href="#P-9" class="headerlink" title="P.9"></a>P.9</h2><p><strong>Consider a datagram network using 32-bit host addresses. Suppose a router has four links, numbered 0 through 3, and packets are to be forwarded to the link interfaces as follows:</strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">

| Destination Address Range                                                                                                                                      | Link Interface |
|:--------------------------------------------------------------------------------------------------------------------------------------------------------------:|:--------------:|
| <div align = "center">11100000 00000000 00000000 00000000<br><strong>through</strong><br>11100000 00111111 11111111 11111111</div>                               |       0        |
| <div align = "center">11100000 01000000 00000000 00000000<br><strong>through</strong><br>11100000 01000000 11111111 11111111</div>                               |       1        |
| <div align = "center">11100000 01000001 00000000 00000000<br><strong>through</strong><br>11100001 01111111 11111111 11111111</div>                               |       2        |
| <div align = "center">otherwise</div>                                                                                                                            |       3        |

</div>

<p><strong>Questions and Answers:</strong></p>
<p><strong>a. Provide a forwarding table that has four entries, uses longest prefix matching, and forwards packets to the correct link interfaces.</strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">

| Header | Link Interface(output) |
|------------------------------|:--------------:|
| 11100000 00 | 0 |
| 11100000 01000000 | 1 |
| 1110000   | 2 |
| otherwise | 3 |

</div>

<p><strong>Explanation:</strong>  </p>
<ul>
<li>Each entry uses the longest prefix that matches the given address range.</li>
<li>The router checks the destination address against each prefix, starting from the longest, and forwards the packet to the corresponding interface.</li>
</ul>
<p><strong>b. Describe how your forwarding table determines the appropriate link interface for datagrams with destination addresses</strong>:  </p>
<div align = "center">11001000 10010001 01010001 01010101</div>  
<div align = "center">11100001 01000000 11000011 00111100</div>  
<div align = "center">11100001 10000000 00010001 01110111</div>

<ol>
<li><p><strong>11001000 10010001 01010001 01010101</strong>  </p>
<ul>
<li>This address does <strong>not</strong> match any of the specified prefixes (does not start with 111…), so it is forwarded to <strong>interface 3</strong>.</li>
</ul>
</li>
<li><p><strong>11100001 01000000 11000011 00111100</strong>  </p>
<ul>
<li>This address matches the third entry:  <ul>
<li>Prefix: <code>1110000</code></li>
<li>So, it is forwarded to <strong>interface 2</strong>.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>11100001 10000000 00010001 01110111</strong>  </p>
<ul>
<li>This address matches the third entry:  <ul>
<li>Prefix: <code>1110000</code></li>
<li>So, it is forwarded to <strong>interface 2</strong>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="P-10"><a href="#P-10" class="headerlink" title="P.10"></a>P.10</h2><p><strong>Consider a datagram network using 8-bit host addresses. Suppose a router uses longest-prefix matching and has the following forwarding table:</strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">

| Prefix Match | Interface |
|:------------:|:---------:|
| 00           | 0         |
| 010          | 1         |
| 011          | 2         |
| 10           | 2         |
| 11           | 3         |

</div>

<p><strong>Question and Answer:</strong></p>
<p>For each of the four interfaces, give the associated range of destination host addresses and the number of addresses in the range.</p>
<div style="display: block; margin: 0 auto; width: fit-content">

| Interface | Destination Address Range                            | Number of Addresses       |
|:--------:|:--------------------------------------------:|--------------:|
| 0        | 00000000 - 00111111                           | 64       |
| 1        | 01000000 - 01011111                           | 32       |
| 2        | 01100000 - 01111111<br>10000000 - 10111111       | 96  |
| 3        | 11000000 - 11111111                           | 64       |

</div>

<h2 id="P-17"><a href="#P-17" class="headerlink" title="P.17"></a>P.17</h2><p><strong>Question and Answer:</strong></p>
<p>Consider sending a 2400-byte datagram into a link that has an MTU of 700 bytes. Suppose the original datagram is stamped with the identification number 422. How many fragments are generated? What are the values in the various fields in the IP datagram(s) generated related to fragmentation?</p>
<p>According to IPv4 datagram format, each fragment includes a 20-bytes header.</p>
<p>先计算数据大小 $d = \lfloor \frac{700 - 20}{8} \rfloor \times 8 = 680$ bytes。</p>
<p>所以需要分成 $n = \lceil \frac{2400 - 20}{d} \rceil = 4$</p>
<p>主要变化在 <code>Offset</code> 和 <code>Flag</code>，所以：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

| Fragment | Datagram length | Offset | Flag |
|:--------:|:---------------:|:------:|:----:|
| 1        | 700             |    0   |   001  |
| 2        | 700             |   85   |   001  |
| 3        | 700             |   170  |   001  |
| 4        | 360             |   255  |   000  |

</div>

<h2 id="P-18"><a href="#P-18" class="headerlink" title="P.18"></a>P.18</h2><p><strong>Question and Answer:</strong></p>
<p>Suppose datagrams are limited to 1,500 bytes (including header) between source Host A and destination Host B. Assuming a 20-byte IP header, how many datagrams would be required to send an MP3 consisting of 5 million bytes? Explain how you computed your answer.</p>
<p>MTU 为 $1500$ bytes，一个 datagram 的 data 大小为 $d = \lfloor \frac{1500 -20}{8} \rfloor \times 8 = 1480$ bytes。</p>
<p>最终，datagram 的数目为 $n = \lceil \frac{5 \times 10^6}{d} \rceil = 3379$ 个。</p>
<h2 id="P-19"><a href="#P-19" class="headerlink" title="P.19"></a>P.19</h2><p><strong>Consider the network setup in Figure 4.22. Suppose that the ISP instead assigns the router the address 24.34.112.235 and that the network address of the home network is 192.168.1/24</strong>.</p>
<p><img src="The-Network-Layer/Network address translation.png" alt="Network address translation">{style=”display: block; margin: 0 auto; width: 80%”}</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. Assign addresses to all interfaces in the home network.</strong></p>
<p>也即是说，中间的 router WAN 的 IP address 是 <code>24.34.112.235</code>，LAN 的是 <code>192.168.1/24</code>，不妨和原图一样，设为 <code>192.168.1.4</code>。则右边的三个 host 的 LAN IP address 分别为：</p>
<ul>
<li>Host 1 address is 192.168.1.1</li>
<li>Host 2 address is 192.168.1.2</li>
<li>Host 3 address is 192.168.1.3</li>
</ul>
<p><strong>b. Suppose each host has two ongoing TCP connections, all to port 80 at host 128.119.40.86. Provide the six corresponding entries in the NAT translation table.</strong></p>
<p>总共有 $6$ 个 TCP connection，随便分几个端口号：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

| WAN side | LAN side |
|:--------:|:---------------:|
| 24.34.112.235, 50001 | 192.168.1.1, 3345 |
| 24.34.112.235, 50002 | 192.168.1.1, 3346 |
| 24.34.112.235, 50003 | 192.168.1.2, 3345 |
| 24.34.112.235, 50004 | 192.168.1.2, 3346 |
| 24.34.112.235, 50005 | 192.168.1.3, 3345 |
| 24.34.112.235, 50006 | 192.168.1.3, 3346 |

</div>

<h2 id="P-24"><a href="#P-24" class="headerlink" title="P.24"></a>P.24</h2><p><img src="The-Network-Layer/P24.jpg" alt="Graph P.24">{style=”display: block; margin: 0 auto; width: 80%”}</p>
<p><strong>Question:</strong></p>
<p>Consider the following network. With the indicated link costs, use Dijkstra’s shortest-path algorithm to compute the shortest path from x to all network nodes. Show how the algorithm works by computing a table similar to Table 4.3.</p>
<p><strong>Answer:</strong></p>
<p>$N’ = {x}$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">step</th>
<th style="text-align:center">$D(x)$ $P(x)$</th>
<th style="text-align:center">$D(y)$ $P(y)$</th>
<th style="text-align:center">$D(z)$ $P(z)$</th>
<th style="text-align:center">$D(v)$ $P(v)$</th>
<th style="text-align:center">$D(u)$ $P(u)$</th>
<th style="text-align:center">$D(w)$ $P(w)$</th>
<th style="text-align:center">$D(t)$ $P(t)$</th>
<th style="text-align:center">$N’$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center">$6$     $x$</td>
<td style="text-align:center">$8$     $x$</td>
<td style="text-align:center"><strong>$3$</strong>  $x$</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">$6$      $x$</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">$x$</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center"><strong>$6$</strong> $x$</td>
<td style="text-align:center">$8$     $x$</td>
<td style="text-align:center">$3$      $x$</td>
<td style="text-align:center">$6$     $v$</td>
<td style="text-align:center">$6$      $x$</td>
<td style="text-align:center">$7$     $v$</td>
<td style="text-align:center">$xv$</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center">$6$     $x$</td>
<td style="text-align:center">$8$     $x$</td>
<td style="text-align:center">$3$      $x$</td>
<td style="text-align:center"><strong>$6$</strong> $v$</td>
<td style="text-align:center">$6$      $x$</td>
<td style="text-align:center">$7$     $v$</td>
<td style="text-align:center">$xvy$</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center">$6$     $x$</td>
<td style="text-align:center">$8$     $x$</td>
<td style="text-align:center">$3$      $x$</td>
<td style="text-align:center">$6$     $v$</td>
<td style="text-align:center"><strong>$6$</strong>  $x$</td>
<td style="text-align:center">$7$     $v$</td>
<td style="text-align:center">$xvyu$</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center">$6$     $x$</td>
<td style="text-align:center">$8$     $x$</td>
<td style="text-align:center">$3$      $x$</td>
<td style="text-align:center">$6$     $v$</td>
<td style="text-align:center">$6$      $x$</td>
<td style="text-align:center"><strong>$7$</strong>  $v$</td>
<td style="text-align:center">$xvyuw$</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center">$6$     $x$</td>
<td style="text-align:center"><strong>$8$</strong> $x$</td>
<td style="text-align:center">$3$      $x$</td>
<td style="text-align:center">$6$     $v$</td>
<td style="text-align:center">$6$      $x$</td>
<td style="text-align:center">$7$     $v$</td>
<td style="text-align:center">$xvyuwt$</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center">$6$     $x$</td>
<td style="text-align:center">$8$     $x$</td>
<td style="text-align:center">$3$      $x$</td>
<td style="text-align:center">$6$     $v$</td>
<td style="text-align:center">$6$      $x$</td>
<td style="text-align:center">$7$     $v$</td>
<td style="text-align:center">$xvyuwtz$</td>
</tr>
</tbody>
</table>
</div>
<p>So the shortest path from $x$ to all nodes is follow.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Destination</th>
<th style="text-align:center">Shortest Distance</th>
<th style="text-align:center">Path</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$x$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$x$</td>
</tr>
<tr>
<td style="text-align:center">$v$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$x \to v$</td>
</tr>
<tr>
<td style="text-align:center">$y$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$x \to y$</td>
</tr>
<tr>
<td style="text-align:center">$w$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$x \to w$</td>
</tr>
<tr>
<td style="text-align:center">$u$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$x \to v \to u$</td>
</tr>
<tr>
<td style="text-align:center">$t$</td>
<td style="text-align:center">$7$</td>
<td style="text-align:center">$x \to v \to t$</td>
</tr>
<tr>
<td style="text-align:center">$z$</td>
<td style="text-align:center">$8$</td>
<td style="text-align:center">$x \to z$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="P-26"><a href="#P-26" class="headerlink" title="P.26"></a>P.26</h2><p><img src="The-Network-Layer/P26.png" alt="Graph P.26">{style=”display: block; margin: 0 auto; width: 80%”}</p>
<p><strong>Question:</strong></p>
<p>Consider the network shown below, and assume that each node initially knows the costs to each of its neighbors. Consider the distance-vector algorithm and show the distance table entries at node z.</p>
<p><strong>Answer:</strong></p>
<p><strong>Node z table:</strong></p>
<p><strong><em>First round</em></strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">

|        | cost to|       ||||
|:------:|:------:|:------:|:------:|:------:|:------:|
|        | x      | y      | z      | u      | v      |
| from x | $\infty$ | $\infty$ | $\infty$ | $\infty$ | $\infty$ |
| from y | $\infty$ | $\infty$ | $\infty$ | $\infty$ | $\infty$ |
| from z | 2        | $\infty$   | 0      | $\infty$ | 6      |
| from u | $\infty$ | $\infty$ | $\infty$ | $\infty$ | $\infty$ |
| from v | $\infty$ | $\infty$ | $\infty$ | $\infty$ | $\infty$ |

</div>

<p><strong><em>Second round</em></strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">

|        | cost to|        |        |        |        |
|:------:|:------:|:------:|:------:|:------:|:------:|
|        | $x$      | $y$      | $z$      | $u$      | $v$      |
| from $x$ | $2$      | $3$      | $\infty$ | $\infty$ | $3$      |
| from $y$ | $3$      | $\infty$ | $\infty$ | $2$      | $\infty$ |
| from $z$ | $2$      | $5$      | $0$      | $7$      | $5$      |
| from $u$ | $\infty$ | $2$      | $\infty$ | $\infty$ | $2$      |
| from $v$ | $3$      | $\infty$ | $6$      | $1$      | $\infty$ |

</div>

<p>Because the question only asks to show the distance table entries at node z, we do not need to compute the full routing tables for all nodes. The Second round result about node z is also the finial result. 到这一步 from z to other 的 cost 表就收敛了，题目也只问了 node z。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/05/30/%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/30/%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">提升方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-30 16:19:35" itemprop="dateCreated datePublished" datetime="2025-05-30T16:19:35+08:00">2025-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 12:50:16" itemprop="dateModified" datetime="2025-06-06T12:50:16+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="AdaBoost-算法"><a href="#AdaBoost-算法" class="headerlink" title="AdaBoost 算法"></a>AdaBoost 算法</h2><p><strong><em>Data Information</em></strong>： <strong>二分类</strong>训练数据集 $T$</p>
<script type="math/tex; mode=display">
\begin{align}
T& = \{(x_1, y_1), (x_2, y_2), \ldots, (x_N, y_N)\}
\\
x_i \in \mathcal{X}& = \mathbb{R}^n, \quad y_i \in \mathcal{Y} = \{+1, -1\}, \quad i = 1, 2, \ldots, N
\end{align}</script><p><strong><em>Algorithm Process</em></strong></p>
<ol>
<li><p>初始化训练数据的权值分布：</p>
<script type="math/tex; mode=display">
D_1 = (w_{11}, w_{12}, \dots, w_{1N}), \quad w_{1i} = \frac{1}{N}, \quad i = 1, 2, \dots, N</script></li>
<li><p>用权值分布 $D_i$<br> (a) 计算不正确率：</p>
<script type="math/tex; mode=display">
 e_m = \sum_{i=1}^{N} P(G_m(x_i) \neq y_i) = \sum_{i=1}^{N} w_{mi} I(G_m(x_i) \neq y_i)</script><p> (b) 计算 $\alpha_m$:</p>
<script type="math/tex; mode=display">
 \alpha_m = \frac{1}{2} \ln \frac{1 - e_m}{e_m}</script><p> (c) 更新权值分布:</p>
<script type="math/tex; mode=display">
 D_{m+1} = (w_{m+1,1}, \dots, w_{m+1, N})</script><script type="math/tex; mode=display">
 w_{m+1,i} = \frac{w_{mi}}{Z_m} \exp(-\alpha_m y_i G_m(x_i))</script><p> $Z_m$ 是归一化因子。</p>
<script type="math/tex; mode=display">
 Z_m = \sum_{i=1}^{N} w_{mi} \exp(-\alpha_m y_i G_m(x_i))</script></li>
<li>构造基本分类器的线性组合<script type="math/tex; mode=display">
 f(x) = \sum_{m=1}^{M} \alpha_m G_m(x)</script></li>
<li>得到最终分类器<script type="math/tex; mode=display">
 G(x) = \operatorname{sign}\left( \sum_{m=1}^{M} \alpha_m G_m(x) \right)</script></li>
</ol>
<h2 id="回归问题的提升树算法"><a href="#回归问题的提升树算法" class="headerlink" title="回归问题的提升树算法"></a>回归问题的提升树算法</h2><p><strong><em>Algorithm Process</em></strong><br>输入：训练数据集 $T = {(x_1, y_1),(x_2, y_2), \cdots, (x_N, y_N)}$；<br>输出：提升树 $f_M(x)$。<br>（1）初始化 $f_0(x) = 0$。<br>（2）对 $m = 1, 2, \cdots, M$。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/05/30/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/30/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" class="post-title-link" itemprop="url">支持向量机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-30 10:12:59" itemprop="dateCreated datePublished" datetime="2025-05-30T10:12:59+08:00">2025-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-05 17:24:23" itemprop="dateModified" datetime="2025-06-05T17:24:23+08:00">2025-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h2><p><strong>训练数据</strong></p>
<script type="math/tex; mode=display">
T = \{(x_1, y_1), (x_2, y_2), \ldots, (x_N, y_N)\}</script><script type="math/tex; mode=display">
x_i \in \mathcal{X} = \mathbb{R}^n, \quad y_i \in \mathcal{Y} = \{+1, -1\}, \quad i = 1, 2, \ldots, N</script><p><strong>分离超平面</strong></p>
<script type="math/tex; mode=display">
w^* \cdot x + b^* = 0</script><p><strong>分类决策函数</strong></p>
<script type="math/tex; mode=display">
f(x) = \operatorname{sign}(w^* \cdot x + b^*)</script><p><strong>函数间隔</strong></p>
<script type="math/tex; mode=display">
\begin{align*}
\hat{\gamma}_i &= y_i (w \cdot x_i + b)
\\\\
\hat{\gamma} &= \min_{i = 1, 2, \ldots, N} \hat{\gamma}_i
\end{align*}</script><p>规范化函数间隔得到<strong>几何间隔</strong></p>
<script type="math/tex; mode=display">
\begin{align*}
\gamma_i &= y_i \times \left(\frac{w \cdot x_i + b}{\lVert w \rVert}\right)
\\\\
\gamma &= \min_{i=1, \ldots, N} \gamma_i
\end{align*}</script><p>$\lVert w \rVert$ is $L_2$ 范数，也就是：</p>
<script type="math/tex; mode=display">
\lVert w \rVert _{2} = \sqrt{w_1^2 + w_2^2 + \cdots + w_n^2}</script><p>可以得到几何间隔和函数间隔之间的关系：</p>
<script type="math/tex; mode=display">
\gamma_i = \frac{\hat{\gamma}_i}{\lVert w \rVert}</script><h3 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h3><p>原始问题如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\max_{w, b} \quad \gamma
\\\\
&s.t. \quad y_i\left(\frac{w}{\lVert w \rVert} \cdot x_i + \frac{b}{\lVert w \rVert}\right) \geq \gamma, \quad i = 1, 2, \ldots ,N
\end{align*}</script><p>我们可以将原始问题转换为一个<strong>凸二次规划问题</strong>。</p>
<script type="math/tex; mode=display">
\begin{align*}
&\min_{w, b} \quad \frac{1}{2} \lVert w \rVert ^2
\\\\
&s.t. \quad y_i(w \cdot x_i + b) - 1 \geq 0, \quad i = 1, 2, \ldots, N
\end{align*}</script><p><strong>支持向量</strong>满足如下关系：</p>
<script type="math/tex; mode=display">
y_i(w \cdot x_i + b) - 1 = 0</script><p><strong>间隔</strong>的定义如下：</p>
<script type="math/tex; mode=display">
d = \frac{2}{\lVert w \rVert}</script><h4 id="学习的对偶算法"><a href="#学习的对偶算法" class="headerlink" title="学习的对偶算法"></a>学习的对偶算法</h4><p>如何解上述的<strong>凸二次规划</strong>问题？应用拉格朗日对偶性得到原始问题的对偶问题：</p>
<script type="math/tex; mode=display">
L(w, b, \alpha) = \frac{1}{2} \lVert w \rVert ^2 - \sum_{i = 1}^{N} \alpha_i y_i (w \cdot x_i + b) + \sum_{i = 1}^{N} \alpha_i</script><p>在求极大极小问题，先求极小问题 $\min_{w, b} L(w, b, \alpha)$</p>
<p>分别对 $w$，$b$ 求偏导，并令偏导为 $0$ 得：</p>
<script type="math/tex; mode=display">
\begin{align*}
\nabla_{w} L(w, b, \alpha) &= w - \sum_{i = 1}^{N} \alpha_i y_i x_i = 0
\\\\
\nabla_b L(w, b, \alpha) &= -\sum_{i = 1}^{N} \alpha_i y_i = 0
\end{align*}</script><p>也就是</p>
<script type="math/tex; mode=display">
\begin{align*}
&w = \sum_{i = 1}^{N} \alpha_i y_i x_i
\\\\
&\sum_{i = 1}^{N} \alpha_i y_i = 0
\end{align*}</script><p>回代，得到</p>
<script type="math/tex; mode=display">
\min_{w, b} L(w, b, \alpha) = -\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) + \sum_{i = 1}^{N} \alpha_i</script><p>再求极大问题</p>
<script type="math/tex; mode=display">
\max_{\alpha} \quad -\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) + \sum_{i = 1}^{N} \alpha_i</script><p>去掉负号，也就是</p>
<script type="math/tex; mode=display">
\begin{align*}
\min_{\alpha} \quad &\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i
\\\\
\operatorname{s.t.} \quad &\sum_{i = 1}^{N} \alpha_i y_i = 0
\\
&\alpha_i \geq 0, \quad i = 1, 2, \cdots, N
\end{align*}</script><h3 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h3><ul>
<li><strong>输入</strong>：$T$</li>
<li><p><strong>输出</strong>：分离超平面和分类决策函数</p>
<ul>
<li>构造并求解约束最优化问题。</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
\min_{\alpha} \quad &\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i
\\\\
\operatorname{s.t.} \quad &\sum_{i = 1}^{N} \alpha_i y_i = 0
\\
&\alpha_i \geq 0, \quad i = 1, 2, \cdots, N
\\\\
&\alpha^* = (\alpha_1^{\ast}, \alpha_2^{\ast}, \ldots, \alpha_N^{\ast})
\end{align*}</script><ul>
<li>计算</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
w^{\ast} &= \sum_{i=1}^{N} \alpha_i^{\ast} y_i x_i
\\\\
\forall y_j > 0, \quad b^\ast &= y_j - \sum_{i=1}^{N}\alpha_i^\ast y_i(x_i \cdot x_j)
\end{align*}</script></li>
</ul>
<hr>
<h2 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h2><p>引进一个松弛变量 $\xi_i \geq 0$，</p>
<script type="math/tex; mode=display">
y_i (w \cdot x_i + b) \geq 1 - \xi_i</script><p>相应的原始最优化问题变为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\min_{w, b, \xi} \quad &\frac{1}{2} \lVert w \rVert^2 + C \sum_{i = 1}^{N} \xi_i
\\\\
s.t. \quad &y_i(w \cdot x_i + b) \geq 1 - \xi_i
\\\\
&i = 1, 2, \ldots, N, \quad \xi_i \geq 0
\end{align*}</script><p>这里 $C \geq 0$ 称为惩罚变量，值越大，对误分类的惩罚越大。</p>
<p>求解原始问题的拉格朗日对偶问题得到</p>
<script type="math/tex; mode=display">
\begin{align*}
\min_{\alpha} \quad &\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i
\\\\
\operatorname{s.t.} \quad &\sum_{i = 1}^{N} \alpha_i y_i = 0
\\
&C \geq \alpha_i \geq 0, \quad i = 1, 2, \cdots, N
\end{align*}</script><h3 id="学习算法-1"><a href="#学习算法-1" class="headerlink" title="学习算法"></a>学习算法</h3><ul>
<li><strong>输入</strong>：$T$</li>
<li><p><strong>输出</strong>：分离超平面和分类决策函数</p>
<ul>
<li>选择惩罚参数，构造并求解：<script type="math/tex; mode=display">
\begin{align*}
\min_{\alpha} \quad &\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i
\\\\
\operatorname{s.t.} \quad &\sum_{i = 1}^{N} \alpha_i y_i = 0
\\
&C \geq \alpha_i \geq 0, \quad i = 1, 2, \cdots, N
\end{align*}</script></li>
</ul>
<p>得到最优解 $\alpha^* = (\alpha_1^{\ast}, \alpha_2^{\ast}, \ldots, \alpha_N^{\ast})$。</p>
<ul>
<li>计算</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
w^{\ast} &= \sum_{i=1}^{N} \alpha_i^{\ast} y_i x_i
\\\\
\forall C > \alpha_j^{\ast} > 0, \quad b^\ast &= y_j - \sum_{i=1}^{N}\alpha_i^\ast y_i(x_i \cdot x_j)
\end{align*}</script></li>
</ul>
<hr>
<h2 id="荷叶损失函数"><a href="#荷叶损失函数" class="headerlink" title="荷叶损失函数"></a>荷叶损失函数</h2><p>这是对线性支持向量机学习的一种解释，就是最小化以下目标函数：</p>
<script type="math/tex; mode=display">
\min_{w, b} \quad \sum_{i = 1}^{N} [1 - y_i(w \cdot x_i + b)]_+ + \lambda \lVert w \rVert^2</script><hr>
<h2 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h2><p><strong>正定核函数</strong></p>
<p>$K :\mathcal{X} \times \mathcal{X} \to \mathbb{R}$ 是对称函数，$K(x, z)$ 是正定核函数 $\Leftrightarrow$ 对于任意 $x_i \in \mathcal{X}, \quad i = 1, 2, 3, \dots, m$，$K(x, z)$ 对应的格拉姆矩阵是半正定的。</p>
<p><strong>$Gram$ 矩阵</strong></p>
<script type="math/tex; mode=display">
K = [K(x_i, x_j)]_{m \times m}</script><p>如何判别这个矩阵是半正定的，可以采用<strong>特征值判别法</strong>，如果一个矩阵的所有特征值都 $\geq 0$，则这个矩阵是半正定的。</p>
<h3 id="学习算法-2"><a href="#学习算法-2" class="headerlink" title="学习算法"></a>学习算法</h3><ul>
<li><strong>输入</strong>：$T$</li>
<li><p><strong>输出</strong>：分离超平面和分类决策函数</p>
<ul>
<li>选择惩罚参数，构造并求解：<script type="math/tex; mode=display">
\begin{align*}
\min_{\alpha} \quad &\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j K\left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i
\\\\
\operatorname{s.t.} \quad &\sum_{i = 1}^{N} \alpha_i y_i = 0
\\
&C \geq \alpha_i \geq 0, \quad i = 1, 2, \cdots, N
\end{align*}</script></li>
</ul>
<p>得到最优解 $\alpha^* = (\alpha_1^{\ast}, \alpha_2^{\ast}, \ldots, \alpha_N^{\ast})$。</p>
<ul>
<li>计算</li>
</ul>
<script type="math/tex; mode=display">
\begin{align*}
w^{\ast} &= \sum_{i=1}^{N} \alpha_i^{\ast} y_i x_i
\\\\
\forall C > \alpha_j^{\ast} > 0, \quad b^\ast &= y_j - \sum_{i=1}^{N}\alpha_i^\ast y_i K(x_i \cdot x_j)
\end{align*}</script></li>
</ul>
<h2 id="序列最小最优化算法"><a href="#序列最小最优化算法" class="headerlink" title="序列最小最优化算法"></a>序列最小最优化算法</h2><p><strong>两个变量二次规划的求解方式</strong></p>
<script type="math/tex; mode=display">
\begin{align}
&\min_{\alpha} \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}\alpha_i \alpha_j y_i y_j K(x_i \cdot x_j) - \sum_{i=1}^{N} \alpha_i \\\\
&s.t. \quad \sum_{i = 1}^{N} \alpha_i y_i = 0, \quad C \geq \alpha_i \geq 0, \quad i = 1, 2, \ldots, N
\end{align}</script><p>我们选择 $\alpha_1，\alpha_2$，规定其他 $\alpha_i (i = 3, 4, \dots, N)$。</p>
<h3 id="学习算法-3"><a href="#学习算法-3" class="headerlink" title="学习算法"></a>学习算法</h3><p>下面只给出<strong>应试过程</strong></p>
<p>我们的<strong>目标</strong>是，求解下述最小化问题：</p>
<script type="math/tex; mode=display">
\begin{align}
&\min_{\alpha_1, \alpha_2} W(\alpha_1, \alpha_2) = \frac{1}{2} K_{11}\alpha_1^2 +  \frac{1}{2} K_{22}\alpha_2^2 +y_1y_2K_{12}\alpha_1\alpha_2 - (\alpha_1 + \alpha_2) + y_1\alpha_1\sum_{i=3}^{N}y_i\alpha_iK_{i1} + y_2\alpha_2\sum_{i=3}^{N}y_i\alpha_iK_{i2} \tag{1}
\\\\
&s.t. \quad \alpha_1y_1 + \alpha_2y_2 = \sum_{i=3}^{N}y_i\alpha_i = \zeta, \quad 0 \leq \alpha_i \leq C, \quad i = 1, 2 \tag{2}
\end{align}</script><p>$K_{ij} = K(x_i, x_j),i,j = 1,2, \dots, N$，$\zeta$ 是一个常数。同时需要注意的是，公式 $(1)$ 缺少了常数项</p>
<script type="math/tex; mode=display">
\text{const} = \sum_{i=3}^N \alpha_i - \frac{1}{2} \sum_{i=3}^N \sum_{j=3}^N \alpha_i \alpha_j y_i y_j K(x_i, x_j)</script><p>但这个常数项<strong>不会</strong>影响优化 $\alpha_1$ 和 $\alpha_2$ 的结果，故可以省略。</p>
<p>我们考虑 $\alpha_2$ 的最优化问题。</p>
<p>如果 $ y_1 \neq y_2 $</p>
<script type="math/tex; mode=display">
L = \max(0, \alpha_2^{old} - alpha_1^{old}), \quad H = \min(C, C + \alpha_2^{old} - alpha_1^{old}) \tag{3}</script><p>否则</p>
<script type="math/tex; mode=display">
L = \max(0, \alpha_2^{old} + alpha_1^{old} - C), \quad H = \min(C, \alpha_2^{old} + alpha_1^{old}) \tag{4}</script><p>为了叙述简单，记</p>
<script type="math/tex; mode=display">
g(x) = \sum_{i=1}^{N}\alpha_i y_i K(x_i, x) + b</script><p>令</p>
<script type="math/tex; mode=display">
E_i = g(x_i) - y_i = \sum_{j=1}^{N}\alpha_j y_j K(x_j, x_i) + b - y_i, \quad i = 1, 2</script><p>接下来我们更新 $\alpha_2$</p>
<script type="math/tex; mode=display">
\alpha_2^{new,unc} = \alpha_2^{old} + \frac{y_2(E_1 - E_2)}{\eta}, \quad \eta = K_{11} + K_{22} - 2K_{12}</script><script type="math/tex; mode=display">
\alpha_2^{new} =
\begin{cases}
H, &\alpha_2^{new,unc} > H
\\\\
\alpha_2^{new,unc}, &L \leq \alpha_2^{new,unc} \leq H
\\\\
L, &\alpha_2^{new,unc} < L
\end{cases}</script><p>N然后再更新 $\alpha_1$</p>
<script type="math/tex; mode=display">
\alpha_1^{new} = \alpha_1^{old} + y_1 y_2(\alpha_2^{old} - \alpha_2^{new})</script><p><strong>如何选择 $\alpha_1$ 和 $\alpha_2$</strong></p>
<ol>
<li>在所有节点中选择具有最大 $E_i$ 值的节点作为 $\alpha_1$。</li>
<li>选择使得 $|E_1 - E_2|$ 最大的节点作为 $\alpha_2$。</li>
</ol>
<p><strong>求解阈值 b 和 E 的计算方法</strong></p>
<script type="math/tex; mode=display">
b_1^{new} = -E_1 - y_1 K_{11} (\alpha_1^{new} - \alpha_1^{old}) - y_2 K_{21} (\alpha_2^{new} - \alpha_2^{old}) + b^{old}</script><script type="math/tex; mode=display">
b_2^{new} = -E_2 - y_1 K_{12} (\alpha_1^{new} - \alpha_1^{old}) - y_2 K_{22} (\alpha_2^{new} - \alpha_2^{old}) + b^{old}</script><script type="math/tex; mode=display">
b^{new} = \frac{b_1^{new} + b_2^{new}}{2}</script><p><strong>此外</strong></p>
<p>更新 $E$：</p>
<script type="math/tex; mode=display">
E_i^{new} = \sum_{\mathcal{S}}y_j \alpha_j K(x_i, x_j) + b^{new} - y_i</script><p>其中 $\mathcal{S}$ 包含所有支持向量 $x_i$。样本 $x_i$ 是支持向量 $\Leftrightarrow$ $0 &lt; \alpha_i^* &lt; C$。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/05/28/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/28/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/" class="post-title-link" itemprop="url">下推自动机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-28 22:06:00" itemprop="dateCreated datePublished" datetime="2025-05-28T22:06:00+08:00">2025-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-03 20:28:03" itemprop="dateModified" datetime="2025-06-03T20:28:03+08:00">2025-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">形式语言与自动机</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="PDA形式化描述"><a href="#PDA形式化描述" class="headerlink" title="PDA形式化描述"></a>PDA形式化描述</h2><script type="math/tex; mode=display">
\text{PDA} \quad M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F) \tag{1}</script><ul>
<li>$Q$：状态集合</li>
<li>$\Sigma$：字母表</li>
<li>$\Gamma$：栈符号表</li>
<li>$\delta$：状态转移函数</li>
<li>$q_0$：开始状态</li>
<li>$Z_0$：栈底符号</li>
<li>$F$：终态集合</li>
</ul>
<p>其中状态转移函数为</p>
<script type="math/tex; mode=display">
\delta : Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow 2^{Q \times \Gamma^*} \tag{2}</script><h2 id="即时描述"><a href="#即时描述" class="headerlink" title="即时描述"></a>即时描述</h2><script type="math/tex; mode=display">
(q, w, \gamma) \in Q \times \Sigma^* \times \Gamma^* \tag{3}</script><ul>
<li>当前状态是 $q$</li>
<li>未处理的输入字符串是 $w$</li>
<li>栈中符号串是 $\gamma$</li>
</ul>
<h2 id="接受语言"><a href="#接受语言" class="headerlink" title="接受语言"></a>接受语言</h2><p>有两种方式描述：</p>
<script type="math/tex; mode=display">
L(M) = \{w \mid (q_0, w, Z_0)  \vdash ^* (p, \epsilon, \beta) \text{ and } p \in F \} \tag{4}</script><script type="math/tex; mode=display">
L(M) = \{w \mid (q_0, w, Z_0) \vdash ^* (p, \epsilon, \epsilon) \} \tag{5}</script><h1 id="构造PDA"><a href="#构造PDA" class="headerlink" title="构造PDA"></a>构造PDA</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[&quot;Get Grammar&quot;] --&gt; B[&quot;CFG&quot;]</span><br><span class="line">    B[&quot;CFG&quot;] --&gt; C[&quot;GNF&quot;]</span><br><span class="line">    C[&quot;GNF&quot;] --&quot;finial states&quot;--&gt; D[&quot;PDA&quot;]</span><br><span class="line">    C[&quot;GNF&quot;] --&quot;empty stack&quot;--&gt; D[&quot;PDA&quot;]</span><br></pre></td></tr></table></figure>
<h1 id="PDA转换"><a href="#PDA转换" class="headerlink" title="PDA转换"></a>PDA转换</h1><h2 id="终态换为空栈"><a href="#终态换为空栈" class="headerlink" title="终态换为空栈"></a>终态换为空栈</h2><p>已知终态接受的 PDA $M_1$，公式化构造空战接受的 PDA $M_2$，具体过程如下：</p>
<script type="math/tex; mode=display">
\text{PDA } M_1 = (Q, \Sigma, \Gamma, \delta_1, q_0, F) \tag{6}</script><script type="math/tex; mode=display">
\text{PDA } M_2 = (Q \cup \{q_{02}, q_e \}, \Sigma, \Gamma \cup \{Z_{02} \}, \delta_2, q_{02}, Z_{02}, F) \tag{7}</script><p>We construct PDA $M_2$ to simulates PDA $M_1’s$ function. And first step, we need to get in PDA $M_1$.</p>
<script type="math/tex; mode=display">
\delta_2(q_{02}, \epsilon, Z_{02}) = \{(q_{01}, Z_{01}Z_{02})\} \tag{8}</script><p>PDA $M_2$ simulates each none $\epsilon$ step of PDA $M_1$.</p>
<script type="math/tex; mode=display">
\forall (q, a, Z) \in Q \times \Sigma \times \Gamma, \delta_2(q, a, Z) = \delta_1(q, a, Z) \tag{9}</script><p>PDA $M_2$ completely simulates PDA $M_1$ transition function in none finial states.</p>
<script type="math/tex; mode=display">
\forall (q, Z) \in (Q - F) \times \Gamma, \delta_2(q, \epsilon, Z) = \delta_1(q, \epsilon, Z) \tag{10}</script><p>In $M_1’s$ finial states, not only should $M_2$ simulates $M_1’s$ $\epsilon$ moves, but also simulates accepting moves.</p>
<script type="math/tex; mode=display">
\forall (q, Z) \in F \times \Gamma, \delta_2(q, \epsilon, Z) = \delta_1(q, \epsilon, Z) \cup \\{(q_e, \epsilon)\\} \tag{11}</script><p>$M_1’s$ stacks having been empty and in finial states, $M_2$ begins to cleat stack.</p>
<script type="math/tex; mode=display">
\forall q \in F, \delta_2(q, \epsilon, Z_{02}) = \{(q_e, \epsilon) \} \tag{12}</script><script type="math/tex; mode=display">
\forall q \in \Gamma \cup \{Z_{02} \}, \delta_2(q_e, \epsilon, Z) = \{(q_e, \epsilon) \}</script><h3 id="Empty-Stack-to-Finial-State"><a href="#Empty-Stack-to-Finial-State" class="headerlink" title="Empty Stack to Finial State"></a>Empty Stack to Finial State</h3><p>已知空栈接受的 PDA $M_1$，要构造一个与之等价终态接受的 PDA $M_2$，核心思路在于<strong>只要 $M_2$ 发现 $M_1$ 在运行过程中将栈弹空，就可以进入终止状态</strong>。</p>
<p><strong>公式化构造</strong></p>
<p>设 PDA $M_1$ 为</p>
<script type="math/tex; mode=display">
\text{PDA } M_1 =\left(Q, \Sigma, \Gamma, \delta_1, q_{01}, Z_{01}, \Phi\right)</script><p>公式化构造 PDA $M_2$</p>
<script type="math/tex; mode=display">
\text{PDA } M_2 = \left(Q \cup \{q_0, q_f\}, \Sigma, \Gamma \cup \{Z_{02} \}, \delta_2, q_{02}, Z_{02}, \{q_f\} \right)</script><p>其中状态转移函数 $\delta_2$ 为</p>
<script type="math/tex; mode=display">
\begin{align*}
&\delta_2(q_{02}, \epsilon, Z_{02}) = \{(q_{01}, Z_{01} Z_{02})\}
\\
&\forall(q, a, Z) \in Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma, \quad \delta_2(q, a ,Z) = \delta_1(q, a, Z)
\\
&\delta_2(q, \epsilon, Z_{02}) = \{(q_f, \epsilon)\}
\end{align*}</script><h3 id="CFG-to-Empty-Stack"><a href="#CFG-to-Empty-Stack" class="headerlink" title="CFG to Empty Stack"></a>CFG to Empty Stack</h3><p>先考虑 $L$ 为不含 $\epsilon$ 的 CFL。$G$ 是该语言对应的 GNF 文法，考虑用 PDA 模拟 GNF 的最左派生。</p>
<p><strong>公式化构造</strong></p>
<p>设 GNF $G = (V, T, P, S)$。</p>
<p>取 PDA $M = ({q}, T, V, \delta, q, S, \Phi)$</p>
<p>$\forall A \in V, \quad a \in T, \quad \gamma \in V^{\ast}$ 我们有 $\delta(q, a, A) = {(q, \gamma) \mid A \to a\gamma \in P}$</p>
<p><strong>补充 ${\epsilon}$</strong></p>
<p>在 $M$ 的基础上，构造 $M_1$，具体是</p>
<script type="math/tex; mode=display">
M_1 = (\{q, q_0\}, T, V \cup \{Z\}, \delta_1, q_0, Z, \Phi)</script><p>对于状态转移函数 $\delta_1$，定义如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
\delta_1(q_0, \epsilon, Z) &= \{(q_0, \epsilon), (q, S)\}
\\
\delta_1(q, a, A) &= \delta(q, a, A)
\end{align*}</script><h3 id="Empty-Stack-to-CFG"><a href="#Empty-Stack-to-CFG" class="headerlink" title="Empty Stack to CFG"></a>Empty Stack to CFG</h3><p><strong>公式化构造</strong></p>
<p>设 PDA $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, \Phi)$，取 CFG $G = (V, \Sigma, P, S)$，其中：</p>
<script type="math/tex; mode=display">
\begin{align*}
V &= \{S\} \cup Q \times \Gamma \times Q，\text{特别地我们用$[q_i, A, q_j]$来表示变量}
\\
P &= \{S \to [q_0, Z_0, q] \mid q \in Q\}
\\
& \cup \{[q, A, q_{n + 1}] \to a[q_1, A_1, q_2][q_2, A_2, q_3] \dots [q_n, A_n, q_{n + 1} \mid (q_1, A_1A_2 \dots A_n) \in \delta(q, a, A) \text{且} a \in \Sigma \cup \{\epsilon\}, n \geq 1\}
\\
& \cup \{[q, A, q_1] \to a \mid (q_1, \epsilon) \in \delta(q, a, A)\}
\end{align*}</script><h2 id="课后习题解答"><a href="#课后习题解答" class="headerlink" title="课后习题解答"></a>课后习题解答</h2><h3 id="8-2-构造空栈接受的-PDA"><a href="#8-2-构造空栈接受的-PDA" class="headerlink" title="8.(2) 构造空栈接受的 PDA"></a>8.(2) 构造空栈接受的 PDA</h3><img src="/2025/05/28/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/8(2).png" class="" title="8(2)">
<div align = "center">图8.(2)</div>

<h3 id="补充题"><a href="#补充题" class="headerlink" title="补充题"></a>补充题</h3><p><strong>Question:</strong><br>PDA $\to$ CFG 绘制此PDA状态转移图，按照定理7-4所述的文法构造方法进行转换。并对所得到的文法进行化简。</p>
<script type="math/tex; mode=display">
\begin{align*}
\delta(q_0, a, Z) &= \{(q_0, AZ)\} \tag{1}
\\
\delta(q_0, a, A) &= \{(q_0, A)\} \tag{2}
\\
\delta(q_0, b, A) &= \{(q_1, \epsilon)\} \tag{3}
\\
\delta(q_1, \epsilon, Z) &= \{(q_2, \epsilon)\} \tag{4}
\end{align*}</script><p><strong>Answer:</strong></p>
<p>根据 $(4)$ 式，可以判断这是一个空栈接受的 PDA。</p>
<p>设 PDA $M = (Q, \Sigma, \Gamma, \delta, q_0, Z, \Phi)$</p>
<p>公式化构造 CFG。</p>
<p><strong>首先</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/05/28/hexo%E7%95%8C%E9%9D%A2%E5%92%8CGitHub%20page%E7%95%8C%E9%9D%A2%E5%85%AC%E5%BC%8F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/28/hexo%E7%95%8C%E9%9D%A2%E5%92%8CGitHub%20page%E7%95%8C%E9%9D%A2%E5%85%AC%E5%BC%8F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">hexo界面和GitHub page界面公式问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-28 20:00:00" itemprop="dateCreated datePublished" datetime="2025-05-28T20:00:00+08:00">2025-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-04 15:18:08" itemprop="dateModified" datetime="2025-06-04T15:18:08+08:00">2025-06-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="hexo界面和GitHub-page界面公式问题"><a href="#hexo界面和GitHub-page界面公式问题" class="headerlink" title="hexo界面和GitHub page界面公式问题"></a>hexo界面和GitHub page界面公式问题</h1><p>位置: <code>theme/fluid/layout/_partials/head.ejs</code><br>整个替换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">var separator = theme.title_join_string || theme.tab_title_separator</span><br><span class="line">var title = page.title ? [page.title, config.title].join(separator) : config.title</span><br><span class="line">var keywords = page.keywords || config.keywords</span><br><span class="line">if (keywords instanceof Array) &#123;</span><br><span class="line">  keywords = keywords.join(&#x27;,&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">var description = page.description || page.excerpt || (is_post() &amp;&amp; page.content) || config.description</span><br><span class="line">if (description) &#123;</span><br><span class="line">  description = strip_html(description).substring(0, 200).trim().replace(/\n/g, &#x27; &#x27;)</span><br><span class="line">&#125;</span><br><span class="line">var ogImage = page.og_img || page.index_img</span><br><span class="line">var ogConfig = Object.assign(&#123; image: ogImage &amp;&amp; url_for(ogImage) &#125;, theme.open_graph)</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;76x76&quot; href=&quot;&lt;%= url_for(theme.apple_touch_icon) %&gt;&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= url_for(theme.favicon) %&gt;&quot;&gt;</span><br><span class="line">  &lt;% if (theme.canonical.enable) &#123; %&gt;</span><br><span class="line">    &lt;link rel=&quot;canonical&quot; href=&quot;&lt;%= url_join(config.url, page.canonical_path.replace(&#x27;index.html&#x27;, &#x27;&#x27;)) %&gt;&quot;/&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;% if (theme.force_https) &#123; %&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;meta name=&quot;theme-color&quot; content=&quot;&lt;%= theme.color.navbar_bg_color %&gt;&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;author&quot; content=&quot;&lt;%= page.author || config.author %&gt;&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= keywords %&gt;&quot;&gt;</span><br><span class="line">  &lt;% if (theme.open_graph.enable) &#123; %&gt;</span><br><span class="line">    &lt;%- open_graph(ogConfig) %&gt;</span><br><span class="line">  &lt;% &#125; else &#123; %&gt;</span><br><span class="line">    &lt;meta name=&quot;description&quot; content=&quot;&lt;%= description %&gt;&quot;&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;% if ((theme.post.meta.views.enable &amp;&amp; theme.post.meta.views.source === &#x27;busuanzi&#x27;)</span><br><span class="line">    || (theme.footer.statistics.enable &amp;&amp; theme.footer.statistics.source === &#x27;busuanzi&#x27;)) &#123; %&gt;</span><br><span class="line">    &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer-when-downgrade&quot;&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;% if (theme.custom_head) &#123; %&gt;</span><br><span class="line">    &lt;%- theme.custom_head %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">  &lt;%- partial(&#x27;_partials/css.ejs&#x27;) %&gt;</span><br><span class="line">  &lt;%- export_config() %&gt;</span><br><span class="line">  &lt;%- js_ex(theme.static_prefix.internal_js, &#x27;utils.js&#x27;) %&gt;</span><br><span class="line">  &lt;%- js_ex(theme.static_prefix.internal_js, &#x27;color-schema.js&#x27;) %&gt;</span><br><span class="line">  &lt;%- partial(&#x27;_partials/plugins/analytics.ejs&#x27;) %&gt;</span><br><span class="line"></span><br><span class="line">  &lt;%- inject_point(&#x27;head&#x27;) %&gt;</span><br><span class="line">  &lt;% if (theme.math &amp;&amp; theme.math.engine === &#x27;mathjax&#x27;) &#123; %&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      window.MathJax = &#123;</span><br><span class="line">        tex: &#123;</span><br><span class="line">          inlineMath: [[&#x27;$&#x27;,&#x27;$&#x27;], [&#x27;\\(&#x27;,&#x27;\\)&#x27;]],</span><br><span class="line">          displayMath: [[&#x27;$$&#x27;,&#x27;$$&#x27;], [&#x27;\\[&#x27;,&#x27;\\]&#x27;]],</span><br><span class="line">          processEscapes: true,</span><br><span class="line">          tags: &#x27;ams&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          skipHtmlTags: [&#x27;script&#x27;,&#x27;noscript&#x27;,&#x27;style&#x27;,&#x27;textarea&#x27;,&#x27;pre&#x27;,&#x27;code&#x27;]</span><br><span class="line">        &#125;,</span><br><span class="line">        loader: &#123;</span><br><span class="line">          load: [&#x27;[tex]/ams&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      MathJax.startup &amp;&amp; MathJax.startup.promise.then(() =&gt; MathJax.typeset());</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;&lt;%= theme.math.mathjax.cdn %&gt;&quot; async&gt;&lt;/script&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此外, <button onclick="window.location.href='https://cps.ninja/2019/03/16/hexo-with-latex/'">to</button></p>
<p>不知道什么原因，使用kramed会导致Github page上无法显示 块级公式</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/05/28/%E5%86%B3%E7%AD%96%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/28/%E5%86%B3%E7%AD%96%E6%A0%91/" class="post-title-link" itemprop="url">决策树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-28 10:12:59" itemprop="dateCreated datePublished" datetime="2025-05-28T10:12:59+08:00">2025-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 11:02:26" itemprop="dateModified" datetime="2025-06-06T11:02:26+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="text-Decision-Tree"><a href="#text-Decision-Tree" class="headerlink" title="$\text{Decision Tree}$"></a>$\text{Decision Tree}$</h2><p>本文章中，总数据集是 $D$，属性集是 $a$，其中 $a = {a^1, a^2, \ldots, a^V }$，表示属性 $a$ 有 $V$ 种取值；$D^v = {D(\text{attribute}(a) = a^v)}$ 则表示总数据集 $D$ 中满足属性 $a = a^v$ 的数目。</p>
<p>决策树是一种分类算法，本文将介绍三种决策树算法，包括三种决策树算法涉及到的多个概念，比如信息熵、信息增益、信息增益比等等。</p>
<h2 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h2><script type="math/tex; mode=display">
p_k = \frac{\sum(sort = k)}{|D|} \quad (k = 1,2,\ldots,|\mathscr{Y}|)</script><p>用符号 <strong>$\operatorname{Ent}$</strong> 表示信息熵</p>
<script type="math/tex; mode=display">
\text{Ent}(D) = -\sum_{k=1}^{|\mathscr{Y}|}p_k\log_2p_k</script><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>用符号 <strong>$\text{Gain}$</strong> 表示信息增益</p>
<script type="math/tex; mode=display">
\text{Gain}(D, a) = \text{Ent}(D) - \sum_{v = 1}^{V} \frac{|D^v|}{|D|}\text{Ent}(D^v)</script><h2 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h2><p>用符号 <strong>$\text{Gain_ratio}$</strong> 表示信息增益比</p>
<script type="math/tex; mode=display">
\text{Gain_ratio}(D,a) = \frac{\text{Gain}(D,a)}{\text{IV}(a)}</script><p>其中，</p>
<script type="math/tex; mode=display">
\text{IV}(a) = -\sum_{v = 1}^{V}\frac{|D^v|}{|D|} \log_2 \frac{|D^v|}{|D|}</script><h2 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h2><p>用符号 <strong>$\text{Gini_index}$</strong> 表示基尼指数</p>
<script type="math/tex; mode=display">
\begin{align*}
\text{Gini}(D^v) &= \sum_{k = 1}^{|\mathscr{Y}|}\sum_{k' \neq k}p_k p_{k'}
\\\\
\text{Gini}(D^v) &= 1 - \sum_{k = 1}^{|\mathscr{Y}|}p_k^{2}
\\\\
\text{Gini_index}(D,a) &= \sum_{v = 1}^{V} \frac{|D^v|}{|D|} \text{Gini}(D^v)
\end{align*}</script><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>假设决策树 $T$ 有 $|T|$ 个叶节点，每个叶节点 $t$ 有 $N<em>t$ 个样本，其中类别 $k = 1, 2, \ldots, K$ 的样本数为 $N</em>{tk}$。</p>
<p><strong>损失函数</strong></p>
<script type="math/tex; mode=display">
C_\alpha(T) = \sum_{t=1}^{|T|}N_t \operatorname{Ent}(D_t) + \alpha |T|</script><p>其中 $\operatorname{Ent}(D_t)$ 是叶节点 $t$ 上样本集合 $D_t$ 的信息熵，</p>
<script type="math/tex; mode=display">
\operatorname{Ent}(D_t) = -\sum_{k=1}^{|\mathscr{Y}|} p_{tk} \log_2 p_{tk}</script><p>其中 $p<em>{tk} = \frac{N</em>{tk}}{N<em>t}$，$N</em>{tk}$ 为叶节点 $t$ 上第 $k$ 类样本数，$N_t$ 为叶节点 $t$ 的样本总数。</p>
<p>所以可以将损失函数写成：</p>
<script type="math/tex; mode=display">
\begin{align*}
C(T) &= -\sum_{t=1}^{|T|} N_t \sum_{k=1}^{|\mathscr{Y}|} p_{tk} \log_2 p_{tk}
\\\\
C_\alpha(T) &= C(T) + \alpha |T|
\end{align*}</script><p>我们的<strong>目的</strong>就是最小化损失函数</p>
<script type="math/tex; mode=display">
\min_{T} \quad C_\alpha(T) = \sum_{t=1}^{|T|}N_t \operatorname{Ent}(D_t) + \alpha |T|</script><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>我们可以定义一个DP[]数组，并使用动态规划的思想来找到最优剪枝</p>
<ul>
<li>输入数据 $X = {(\vec{x}_1, y_1), (\vec{x}_2, y_2), \ldots, (\vec{x}_N, y_N) }$</li>
<li>输出 $T_\alpha$</li>
</ul>
<ol>
<li>对于树T中的每个节点t，计算 $H_t(T)$</li>
<li>从树的叶节点开始递归地向上回溯，比较 $C<em>\alpha(T_A)$ 和 $C</em>\alpha(T_B)$</li>
<li>返回步骤2</li>
</ol>
<h2 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h2><h3 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h3><p>回归树对应于输入空间的分割和分割单元内的输出值。</p>
<p>输入空间 $M = R_1, R_2, \ldots, R_M$，每个空间 $R_m$ 有一个输出值 $c_m$，我们可以定义回归树模型如下：</p>
<p><strong>回归树模型</strong></p>
<script type="math/tex; mode=display">
f(x) = \sum_{m=1}^{M} c_m I (x \in R_m)</script><p><strong>均方误差</strong></p>
<script type="math/tex; mode=display">
\sum_{x_i \in R_m} (y_i - f(x_i))^2</script><script type="math/tex; mode=display">
\hat{c}_m = \text{ave}(y_i \mid x_i \in R_m)</script><h4 id="分割算法"><a href="#分割算法" class="headerlink" title="分割算法"></a>分割算法</h4><ul>
<li>输入：训练数据 $D$</li>
<li>输出：回归树 $f(x)$</li>
</ul>
<ol>
<li>选择 $x_j$，其输出为 $s$。空间 $R_1(j, s) = {x \mid x^{(j)} \leq s}$，空间 $R_2(j, s) = {x \mid x^{(j)} &gt; s}$</li>
<li><script type="math/tex; mode=display">\min_{j,s}\left[\min_{c_1} \sum_{x_i \in R_1(j,s)} (y_i - c_1)^2 + \min_{c_2} \sum_{x_i \in R_2(j,s)} (y_i - c_2)^2 \right]</script></li>
<li><script type="math/tex; mode=display">\frac{1}{N_m} \sum_{x_i \in R_m(j,s)} y_i, \quad x_i \in R_m, \quad m = 1, 2</script></li>
<li>重复步骤2和3，直至满足停止条件。</li>
</ol>
<h3 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h3><p>根据<strong>基尼指数</strong>进行分类即可</p>
<script type="math/tex; mode=display">
\begin{align*}
\text{Gini}(D^v) &= \sum_{k = 1}^{|\mathscr{Y}|}\sum_{k' \neq k}p_k p_{k'}
\\\\
\text{Gini}(D^v) &= 1 - \sum_{k = 1}^{|\mathscr{Y}|}p_k^{2}
\\\\
\text{Gini_index}(D,a) &= \sum_{v = 1}^{V} \frac{|D^v|}{|D|} \text{Gini}(D^v)
\end{align*}</script><h3 id="text-CART-剪枝"><a href="#text-CART-剪枝" class="headerlink" title="$\text{CART}$ 剪枝"></a>$\text{CART}$ 剪枝</h3><p>$\text{CART}$ 剪枝算法由两步组成：手下从省城算法产生的决策树 $T_0$ 底端开始不断简直，直到 $T_0$ 的根节点，形成一个子树序列 ${T_0, T_1, \cdots T_n}$；然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</p>
<h4 id="text-CART-剪枝算法"><a href="#text-CART-剪枝算法" class="headerlink" title="$\text{CART}$ 剪枝算法"></a>$\text{CART}$ 剪枝算法</h4><p><strong>输入</strong>：$\text{CART}$ 算法生成的决策树 $T<em>0$；<br><strong>输出</strong>：最优决策树 $T</em>{\alpha}$。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/05/27/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/27/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">隐马尔科夫模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-27 21:02:00" itemprop="dateCreated datePublished" datetime="2025-05-27T21:02:00+08:00">2025-05-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-04 13:26:46" itemprop="dateModified" datetime="2025-06-04T13:26:46+08:00">2025-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="隐马尔科夫模型的定义"><a href="#隐马尔科夫模型的定义" class="headerlink" title="隐马尔科夫模型的定义"></a>隐马尔科夫模型的定义</h2><p>隐马尔科夫模型有如下两个假设：任意状态只依赖于前一时刻状态和任意时刻的观测只依赖于该时刻的马尔科夫链的状态。<br>设 $Q$ 是所有可能的状态的集合，$V$是所有可能的观测的集合：</p>
<script type="math/tex; mode=display">
Q =\{q_1, q_2, \dots, q_N\}, \quad V = \{v_1, v_2, \dots, v_M\}</script><p>其中，$N$ 是可能的状态数，$M$ 是可能的观测数。<br>$I$ 是长度为 $T$ 的状态序列，$O$ 是对应的观测序列：</p>
<script type="math/tex; mode=display">
I = (i_1, i_2, \dots, i_T), \quad O =(o_1, o_2, \dots, o_T)</script><p>$A$ 是状态转移概率矩阵：</p>
<script type="math/tex; mode=display">
A = [a_{ij}]_{N \times N} \tag{1}</script><p>其中，</p>
<script type="math/tex; mode=display">
a_{ij} = P(i_{t + 1} = q_j | i_t = q_i), \quad i = 1, 2, \dots, N; \quad j = 1, 2, \dots, N \tag{2}</script><p>$B$ 是观测概率矩阵：</p>
<script type="math/tex; mode=display">
B = [b_j(k)]_{N \times N} \tag{3}</script><p>其中，</p>
<script type="math/tex; mode=display">
b_j(k) = P(o_t = v_k | i_t = q_j), \quad k = 1, 2, \dots, M; \quad j = 1, 2, \dots, N \tag{4}</script><p>$\pi$ 是初始状态概率向量：</p>
<script type="math/tex; mode=display">
\pi = (\pi_i) \tag{5}</script><p>其中，</p>
<script type="math/tex; mode=display">
\pi_i = P(i_1 = q_i), \quad i = 1, 2, \dots, N \tag{6}</script><p>综上，可以将隐马尔科夫模型用三元符号表示，即</p>
<script type="math/tex; mode=display">
\lambda = (A, B, \pi) \tag{7}</script><h2 id="隐马尔科夫模型的3个基本问题"><a href="#隐马尔科夫模型的3个基本问题" class="headerlink" title="隐马尔科夫模型的3个基本问题"></a>隐马尔科夫模型的3个基本问题</h2><h3 id="概率计算问题"><a href="#概率计算问题" class="headerlink" title="概率计算问题"></a>概率计算问题</h3><p>给定模型 $\lambda = (A, B, \pi)$ 和观测序列 $O = (o_1, o_2, \dots, o_T)$，计算在模型 $\lambda$ 下观测序列 $O$ 出现的概率 $P(O | \lambda)$。</p>
<h4 id="前向算法"><a href="#前向算法" class="headerlink" title="前向算法"></a>前向算法</h4><p>输入：隐马尔科夫模型 $\lambda$，观测序列 $O$；<br>输出：观测序列概率 $P(O | \lambda)$。</p>
<p>（1）初值</p>
<script type="math/tex; mode=display">
\alpha_1(i) = \pi_i b_i(o_1), \quad i = 1, 2, \dots, N \tag{8}</script><p>（2）递推，对 $t = 1, 2, \dots, T - 1$，</p>
<script type="math/tex; mode=display">
\alpha_{t + 1}(i) = \left[\sum_{j = 1}^{N} \alpha_t(j) a_{ji}\right]b_i(o_{t + 1}), \quad i = 1, 2, \dots, N \tag{9}</script><p>（3）终止</p>
<script type="math/tex; mode=display">
P(O | \lambda) = \sum_{i = 1}^{N} \alpha_T(i) \tag{10}</script><p>这个算法中的 $\alpha$ 可以用一个矩阵表示，其中下标表示行号，括号内表示列号</p>
<script type="math/tex; mode=display">
\alpha = \begin{bmatrix}
\alpha_1(1) & \alpha_1(2) & \alpha_1(3) & \cdots & \alpha_1(N) \\\\[10pt]
\alpha_2(1) & \alpha_2(2) & \alpha_2(3) & \cdots & \alpha_2(N) \\\\[10pt]
\vdots & \vdots & \vdots & \ddots & \vdots \\\\[10pt]
\alpha_T(1) & \alpha_T(2) & \alpha_T(3) & \cdots & \alpha_T(N)
\end{bmatrix} \tag{11}</script><p>每次迭代就是在一次计算行内容。</p>
<h4 id="后向算法"><a href="#后向算法" class="headerlink" title="后向算法"></a>后向算法</h4><p>输入：隐马尔科夫模型 $\lambda$，观测序列 $O$；<br>输出：观测序列概率 $P(O | \lambda)$。</p>
<p>（1）</p>
<script type="math/tex; mode=display">
\beta_T(i) = 1, \quad i = 1, 2, \dots, N \tag{12}</script><p>（2）对 $t = T - 1, T - 2, \dots, 1$</p>
<script type="math/tex; mode=display">
\beta_t(i) = \sum_{j = 1}^{N} a_{ij} b_j(o_{t + 1})\beta_{t + 1}(j) \tag{13}</script><p>（3）</p>
<script type="math/tex; mode=display">
P(O | \lambda) = \sum_{i = 1}^{N} \pi_i b_i(o_1) \beta_1(i) \tag{14}</script><p>$\beta$ 矩阵</p>
<script type="math/tex; mode=display">
\beta = \begin{bmatrix}
\beta_1(1) & \beta_1(2) & \beta_1(3) & \cdots & \beta_1(N) \\\\[10pt]
\beta_2(1) & \beta_2(2) & \beta_2(3) & \cdots & \beta_2(N) \\\\[10pt]
\vdots & \vdots & \vdots & \ddots & \vdots \\\\[10pt]
\beta_T(1) & \beta_T(2) & \beta_T(3) & \cdots & \beta_T(N)
\end{bmatrix} \tag{15}</script><h3 id="一些概率与期望值的计算"><a href="#一些概率与期望值的计算" class="headerlink" title="一些概率与期望值的计算"></a>一些概率与期望值的计算</h3><h4 id="单个状态的计算公式"><a href="#单个状态的计算公式" class="headerlink" title="单个状态的计算公式"></a>单个状态的计算公式</h4><p>给定模型 $\lambda$ 和观测 $O$，在时刻 $t$ 处于状态 $q_i$ 的概率。记</p>
<script type="math/tex; mode=display">
\gamma_t(i) = P(i_t = q_i |O, \lambda) \tag{16}</script><p>可以通过前向后向概率计算：</p>
<script type="math/tex; mode=display">
\gamma_t(i) = \frac{\alpha_t(i) \beta_t(i)}{P(O |\lambda)} = \frac{\alpha_t(i) \beta_t(i)}{\sum_{j = 1}^{N} \alpha_t(j) \alpha_t(j)} \tag{17}</script><h4 id="两个状态的计算公式"><a href="#两个状态的计算公式" class="headerlink" title="两个状态的计算公式"></a>两个状态的计算公式</h4><p>给定模型 $\lambda$ 和观测 $O$，在时刻 $t$ 处于状态 $q_i$，在时刻 $t + 1$ 处于 $q_j$ 的概率。记</p>
<script type="math/tex; mode=display">
\xi_t(i, j) = \frac{\alpha_t(i)a_{ij}b_j(o_{t + 1})\beta_{t + 1}(j)}{\sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_t(i) a_{ij} b_j(o_{t + 1}) \beta_{t + 1}(j)} \tag{18}</script><h4 id="在观测-O-下状态-i-出现的期望值"><a href="#在观测-O-下状态-i-出现的期望值" class="headerlink" title="在观测 $O$ 下状态 $i$ 出现的期望值"></a>在观测 $O$ 下状态 $i$ 出现的期望值</h4><script type="math/tex; mode=display">
\sum_{t = 1}^{T} \gamma_t(i) \tag{19}</script><h4 id="在观测-O-下由状态-i-转移的期望值"><a href="#在观测-O-下由状态-i-转移的期望值" class="headerlink" title="在观测 $O$ 下由状态 $i$ 转移的期望值"></a>在观测 $O$ 下由状态 $i$ 转移的期望值</h4><script type="math/tex; mode=display">
\sum_{t = 1}^{T - 1} \gamma_t(i) \tag{20}</script><h4 id="在观测-O-下由状态-i-转移到状态-j-的期望值"><a href="#在观测-O-下由状态-i-转移到状态-j-的期望值" class="headerlink" title="在观测 $O$ 下由状态 $i$ 转移到状态 $j$ 的期望值"></a>在观测 $O$ 下由状态 $i$ 转移到状态 $j$ 的期望值</h4><script type="math/tex; mode=display">
\sum_{t = 1}^{T - 1} \xi_t(i, j) \tag{21}</script><h2 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h2><p>前文的内容是都和概率计算有关，那如何根据训练集训练一个隐马尔科夫模型模型呢？</p>
<h3 id="监督学习方法"><a href="#监督学习方法" class="headerlink" title="监督学习方法"></a>监督学习方法</h3><p>如果已给训练数据集包含 $S$ 个长度相同的观测序列和对应的状态序列，我们可以用极大似然估计法来估计参数。分别的有：</p>
<script type="math/tex; mode=display">
\begin{align*}
\hat{a_{ij}} &= \frac{A_{ij}}{\sum_{j = 1}^{N} A_{ij}}, \quad i = 1, 2, \dots, N; \quad j = 1, 2, \dots, N \tag{22}
\\[10pt]
\hat{b_{j}}(k) &= \frac{B_{jk}}{\sum_{k = 1}^{M} B_{jk}}, \quad j = 1, 2, \dots, N; \quad k = 1, 2, \dots, M \tag{23}
\\[10pt]
\hat{\pi_{i}} &= \frac{\sum \text{初始状态为$q_i$} }{S} \tag{24}
\end{align*}</script><p>其中 $A<em>{ij}$ 表示在训练数据中，从状态 $q_i$ 转移到状态 $q_j$ 的<strong>次数总和</strong>。$B</em>{jk}$ 表示在状态 $q_j$ 下，观测到符号 $v_k$ 的<strong>次数总和</strong>。</p>
<h3 id="Baum-Welch-算法"><a href="#Baum-Welch-算法" class="headerlink" title="Baum-Welch 算法"></a>Baum-Welch 算法</h3><p>假定训练数据只包含 $S$ 个长度为 $T$ 的观测序列 ${O_1, O_2, \dots, O_S}$，我们将观测序列数据看作观测数据 $O$，状态序列数据看做不可观测的隐数据 $I$，那么存在如下概率模型</p>
<script type="math/tex; mode=display">
P(O | \lambda) = \sum_{I} P(O |I, \lambda) P(I |\lambda) \tag{25}</script><p>实际上，这个模型的参数学习可由 EM 算法实现。</p>
<p>（1）确定完全数据的对数似然函数。完全数据是$(O, I) = (o_1, o_2, \dots, o_T, i_1, i_2, \dots, i_T)$。</p>
<script type="math/tex; mode=display">
\log P(O, T |\lambda) \tag{26}</script><p>（2）E步</p>
<script type="math/tex; mode=display">
Q(\lambda, \bar{\lambda}) = \sum_{I} \log P(O, I |\lambda) P(O, I |\bar{\lambda}) \tag{27}</script><p>其中 $\bar{\lambda}$ 是当前模型参数的估计值，$\lambda$ 是要极大化的模型参数。</p>
<script type="math/tex; mode=display">
P(O, I |\lambda) = \pi_{i_1}b_{i_1}(o_1)a_{i_1i_2}b_{i_2}(o_2) \cdots a_{i_{T-1}i_{T}}b_{i_{T}}(o_T) \tag{28}</script><p>于是，函数 $Q$ 可以写成：</p>
<script type="math/tex; mode=display">
\begin{align*}
Q(\lambda, \bar{\lambda}) = &\sum_{I} \log \pi_{i_1} P(O, I |\bar{\lambda}) + \sum_{I} \left(\sum_{t = 1}^{T - 1} \log a_{i_t i_{t + 1}} \right) P(O, I |\bar{\lambda}) +
\\[10pt]
&\sum_{I} \left(\sum_{t = 1}^{T} \log b_{i_t}(o_t) \right) P(O, I |\bar{\lambda})
\end{align*}</script><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>（1）初始化。对 $n = 0$，随机初始化 $\lambda^{(0)}$。<br>（2）递推。对 $n = 1, 2, \dots$，</p>
<script type="math/tex; mode=display">
\begin{align*}
\alpha_{ij}^{(n + 1)} &= \frac{\sum_{t = 1}^{T - 1} \xi_t(i, j)}{\sum_{t = 1}^{T - 1} \gamma_t(i)}
\\[10pt]
b_{j}(k)^{(n + 1)} &= \frac{\sum_{t = 1, o_t = v_k}^{T} \gamma_t(j)}{\sum_{t= 1}^{T} \gamma_t(j)}
\\[10pt]
\pi_{i}^{(n + 1)} &= \gamma_1(i)
\end{align*}</script><h2 id="预测算法"><a href="#预测算法" class="headerlink" title="预测算法"></a>预测算法</h2><h3 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h3><p>由公式：</p>
<script type="math/tex; mode=display">
\gamma_t(i) = \frac{\alpha_t(i) \beta_t(i)}{P(O |\lambda)} = \frac{\alpha_t(i) \beta_t(i)}{\sum_{j = 1}^{N} \alpha_t(j) \alpha_t(j)}</script><p>知，在每一时刻 $t$ 最有可能的状态 $i_t^{\ast}$ 是</p>
<script type="math/tex; mode=display">
i_t^{\ast} = \operatorname{arg} \max_{1 \leq i \leq N} [\gamma_t(i)], \quad t = 1, 2, \dots, T \tag{29}</script><h3 id="维特比算法"><a href="#维特比算法" class="headerlink" title="维特比算法"></a>维特比算法</h3><p>维特比算法是用动态规划解隐马尔科夫模型的预测问题。</p>
<h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>输入：模型 $\lambda = (A, B, \pi)$ 和观测序列 $O = (o_1, o_2, \dots, o_T)$；<br>输出：最优路径 $I^{\ast} = (i_1^{\ast}, i_2^{\ast}, \dots, i_T^{\ast})$。</p>
<p>（1）初始化</p>
<script type="math/tex; mode=display">
\begin{align*}
\delta_1(i) = \pi_i b_i(o_1), \quad i = 1, 2, \dots, N
\\[10pt]
\Psi_1(i) = 0, \quad i = 1, 2, \dots, N
\end{align*}</script><p>（2）递推。对 $t = 2, 3, \cdots, T$</p>
<script type="math/tex; mode=display">
\begin{align*}
\delta_t(i) &= \max_{1 \leq j \leq N} [\delta_{t - 1}(j) a_{ji}] b_i(o_t), \quad i = 1, 2, \cdots, N
\\[10pt]
\Psi_t(i) &= \operatorname{arg} \max_{1 \leq j \leq N}[\delta_{t - 1} a_{ji}], \quad i = 1, 2, \cdots, N
\end{align*}</script><p>（3）终止</p>
<script type="math/tex; mode=display">
\begin{align*}
P^{\ast} &= \max_{1 \leq i \leq N} \delta_{T}(i)
\\[10pt]
i_{T}^{\ast} &= \operatorname{arg} \max_{1 \leq i \leq N} [\delta_{T}(i)]
\end{align*}</script><p>（4）最优路径回溯。对 $t = T - 1, T - 2, \cdots, 1$</p>
<script type="math/tex; mode=display">
i_t^{\ast} = \Psi_{t + 1}(i_{t + 1}^{\ast})</script><p>求得最优路径 $I^{\ast} = (i_1^{\ast}, i_2^{\ast}, \dots, i_T^{\ast})$。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ddccffq</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/ddccffq" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
