

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ddccffq">
  <meta name="keywords" content="���,�㷨,����ѧϰ,���������,��������,��������,ѧϰ�ʼ�">
  
    <meta name="description" content="r(R) satisfied by function dependency and function dependency holds on R.">
<meta property="og:type" content="article">
<meta property="og:title" content="Chapter 7: Relational Database Design: Schema Normalization">
<meta property="og:url" content="https://ddccffq.github.io/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Relational_Database_Design_Schema_Normalization/index.html">
<meta property="og:site_name" content="ddccffq&#39;s Blog">
<meta property="og:description" content="r(R) satisfied by function dependency and function dependency holds on R.">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-20T08:00:00.000Z">
<meta property="article:modified_time" content="2025-12-27T03:00:04.889Z">
<meta property="article:author" content="ddccffq">
<meta property="article:tag" content="���,�㷨,����ѧϰ,���������,��������,��������,ѧϰ�ʼ�">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Chapter 7: Relational Database Design: Schema Normalization - ddccffq&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ddccffq.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Chapter 7: Relational Database Design: Schema Normalization"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-12-20 16:00" pubdate>
          2025年12月20日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          2.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          23 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Chapter 7: Relational Database Design: Schema Normalization</h1>
            
            
              <div class="markdown-body">
                
                <p>r(R) satisfied by function dependency and function dependency holds on R.</p>
<span id="more"></span>
<h2 id="features-of-good-relational-design">*Features of Good Relational Design</h2>
<div style="display: block; margin: 0 auto; width: fit-content">
<pre><code class=" mermaid">flowchart TD
    A[Application problems in real words] --&gt;|Requirements analysis| B[Specification of user requirements]
    B --&gt;|Conceptual DB design| C[DB conceptual schema, i.e. E-R diagram]
    C --&gt;|&lt;span style=&quot;color:red;&quot;&gt;Logical DB design&lt;/span&gt;| D[DB logical schema, i.e. relational data schema]
    D --&gt;|Physical DB design| E[DB physical schema, e.g. physical storage structure]

</code></pre>
</div>
<div style="text-align: center; font-style: italic;">
Figure 1: DB design phases
</div>
<p>Example: <strong>combined schemas with pitfalls</strong>. Suppose to <strong>combine</strong> two tables, <strong>many to one</strong> mapping</p>
<ul>
<li><em>instructor</em>(ID, name, salary, dept_name)</li>
<li><em>department</em>(dept_name, building, budget)</li>
</ul>
<p>into</p>
<ul>
<li><em>ins_dept</em>(ID, name, salary, dept_name, building, budget)</li>
</ul>
<p>Pitfalls when</p>
<ul>
<li>adding a new instructor. Data for some attributes may be <strong>repeated</strong> for the instructors (building), making space being wasted</li>
<li>if the department Comp.Sci is canceled, all instructors in it should then be removed. This means every tuples containing the Comp.Sci department should be deleted</li>
<li>information redundancy complicates updating (introducing possibility of inconsistency of the budget values)
<ul>
<li>e.g. change budget of Comp.Sci department from <span class="math inline">\(100000\)</span> to <span class="math inline">\(120000\)</span> and every tuples belonging to Comp.Sci has to be updated</li>
</ul></li>
<li>to represent directly information about a <strong>new opened</strong> department in which there no exists instructors, a tuple containing null values, such as (null, null, null, Soft.Eng, Taylor, 100000). But null values in DB will complicate data handling in DBS</li>
</ul>
<p>The above example introduces two problems: when should we <strong>combine</strong> relations and when should we <strong>decompose</strong> relations.</p>
<p>Assume if there is a schema (<u>dept_name</u>, building, budget), then dept_name would be a candidate key. We denote dept_name <span class="math inline">\(\to\)</span> building, budget as a <strong>functional dependency</strong> (FD).</p>
<p>Not all decompositions are good, for example, suppose we decompose <em>employee</em>(ID, name, street, city, salary) into <em>employee1</em>(ID, name) and <em>employee2</em>(name, street, city, salary). This is a <strong>lossy decomposition</strong>. If there exists two persons with the same name, obviously when we use <code>NATURAL JOIN</code> will generate additional tuples.</p>
<h3 id="lossless-decomposition">*Lossless Decomposition</h3>
<p><strong>Def</strong>. Let <span class="math inline">\(R\)</span> be a relation schema, and <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> form a decomposition of <span class="math inline">\(R\)</span>. That is <span class="math inline">\(R = R_1 \cup R_2\)</span>. The decomposition is a <strong>lossless decomposition</strong>, if there is <strong>no loss</strong> of information by replacing the schema <span class="math inline">\(R\)</span> with two relation schemas <span class="math inline">\(R_1 \cup R_2\)</span>.</p>
<p><strong>Def</strong>. The decomposition is a <strong>lossy decomposition</strong> if <span class="math inline">\(r \subset \Pi_{R_1} (r) \Join \Pi_{R_2} (r)\)</span></p>
<p>When certain decomposition are <strong>lossless</strong>? For <span class="math inline">\(R = (R_1, R_2)\)</span>, require that for all possible relations <span class="math inline">\(r\)</span> on schema <span class="math inline">\(R\)</span>. <span class="math inline">\(r = \Pi_{R_{1}} (r) \Join \Pi_{R_2}(r)\)</span></p>
<p><strong>Def</strong>. A decomposition of <span class="math inline">\(R\)</span> into <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> is <strong>lossless</strong> if <strong>at least one of</strong> the following dependencies is in <span class="math inline">\(F^{+}\)</span>: <span class="math inline">\(R_1 \cap R_2 \to R_1\)</span> and <span class="math inline">\(R_1 \cap R_2 \to R_2\)</span>.</p>
<p>If only <span class="math inline">\(R_1 \cap R_2 \to R_1\)</span> holds, then <span class="math inline">\(R_1 \cap R_2\)</span> is the <strong>primary key</strong> of <span class="math inline">\(R_1\)</span>, and the <strong>foreign key</strong> of <span class="math inline">\(R_2\)</span></p>
<p><strong>Example</strong>, consider the schema: <em>in_dep</em>(ID, name, salary, dept_name, building, budget). Decompose it into the <em>instructor</em> and <em>department</em> schemas: <em>instructor</em>(ID, name, dept_name, salary) and <em>department</em>(dept_name, building, budget).</p>
<p>Consider the intersection of these two schemas, which is dept_name. Because of dept_name <span class="math inline">\(\to\)</span> building, budget, the <strong>lossless decomposition</strong> is satisfied</p>
<h3 id="functional-dependencies">*Functional Dependencies</h3>
<p><strong>Def</strong>. An instance of a relation that satisfies all such real world constraints is called a <strong>legal instance of relation</strong>.</p>
<p><strong>Def</strong>. <strong>Functional dependency (FD)</strong></p>
<p>Constraints on the legal relations that the value for a <strong>certain set</strong> of attributes determines uniquely the values for <strong>another set</strong> of attributes.</p>
<blockquote>
<p>A functional dependency is a <strong>generalization</strong> of the notion of a key.</p>
</blockquote>
<p><strong>Def</strong>. For a <strong>schema</strong> <span class="math inline">\(R\)</span> and <span class="math inline">\(\alpha \subseteq R\)</span>, <span class="math inline">\(\beta \subseteq R\)</span>, a <strong>relation instance</strong> <span class="math inline">\(r(R)\)</span> satisfies a <strong>FD</strong> <span class="math inline">\(\alpha \to \beta\)</span>, if for pairs of tuples <span class="math inline">\(t_i\)</span>, <span class="math inline">\(t_j\)</span> <span class="math inline">\(\in r(R)\)</span> such that <span class="math inline">\(t_{i}[\alpha] = t_{j}[\alpha] \to t_{i}[\beta] = t_{j}[\beta]\)</span>.</p>
<p><strong>Def</strong>. <span class="math inline">\(r(R)\)</span> is <strong>legal</strong> under <strong>FD</strong> <span class="math inline">\(\alpha \to \beta\)</span>, if <span class="math inline">\(\alpha \to \beta\)</span> is satisfied by <span class="math inline">\(r(R)\)</span></p>
<blockquote>
<p>The values for <strong>a certain set</strong> of attributes <strong>determines uniquely</strong> the values for <strong>another set</strong> of attributes.</p>
</blockquote>
<p>For <strong>example</strong>, given relation <span class="math inline">\(r(R)\)</span> shown below, which FD is satisfied by <span class="math inline">\(r\)</span>? (according to <span class="math inline">\(t_{i}[\alpha] = t_{j}[\alpha] \to t_{i}[\beta] = t_{j}[\beta]\)</span>, the answer is C)</p>
<ul>
<li>A. <span class="math inline">\(A \to B\)</span></li>
<li>B. <span class="math inline">\(AC \to B\)</span></li>
<li>C. <span class="math inline">\(BC \to A\)</span></li>
<li>D. <span class="math inline">\(B \to C\)</span></li>
</ul>
<div style="display: block; margin: 0 auto; width: fit-content">
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(t\)</span></th>
<th style="text-align: center;"><span class="math inline">\(A\)</span></th>
<th style="text-align: center;"><span class="math inline">\(B\)</span></th>
<th style="text-align: center;"><span class="math inline">\(C\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(t_1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(4\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(t_2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(6\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(t_3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(4\)</span></td>
<td style="text-align: center;"><span class="math inline">\(6\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(t_4\)</span></td>
<td style="text-align: center;"><span class="math inline">\(7\)</span></td>
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(8\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(t_5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(9\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
</tr>
</tbody>
</table>
</div>
<p><strong>Def</strong>. Let <span class="math inline">\(R\)</span> be a relation schema <span class="math inline">\(\alpha \subseteq R\)</span> and <span class="math inline">\(\beta \subseteq R\)</span>. The <strong>FD holds on</strong> <span class="math inline">\(R\)</span>, if <strong>every</strong> legal instance <span class="math inline">\(r(R)\)</span> satisfies <span class="math inline">\(\alpha \to \beta\)</span></p>
<blockquote>
<p>If <span class="math inline">\(\alpha \to \beta\)</span> holds on <span class="math inline">\(R\)</span>, then <strong>every legal</strong> <span class="math inline">\(r_i(R)\)</span> satisfies this <span class="math inline">\(R\)</span>, but for schema <span class="math inline">\(R\)</span> and <span class="math inline">\(\alpha \to \beta\)</span>, if only some <span class="math inline">\(r_i(R)\)</span> satisfies <span class="math inline">\(R\)</span>, <span class="math inline">\(\alpha \to \beta\)</span> may <strong>not</strong> holds on <span class="math inline">\(R\)</span></p>
</blockquote>
<p><strong>Example</strong> of modeling FD. Consider $R = $(<u>employee_ID</u>, turnover_per_day, <u>department_name</u>, manager). It is assumed that</p>
<ul>
<li>every day, each employee has <strong>only one</strong> turnover per-day</li>
<li>each employee works at <strong>only one</strong> department</li>
<li>each department is managed by <strong>only one</strong> manager</li>
</ul>
<p>All the functional dependencies on <span class="math inline">\(R\)</span> are</p>
<ul>
<li>employee_ID, date <span class="math inline">\(\to\)</span> turnover_per_day</li>
<li>employee_ID <span class="math inline">\(\to\)</span> department__name</li>
<li>department_name <span class="math inline">\(\to\)</span> manager</li>
</ul>
<h3 id="keys-and-functional-dependencies">*Keys and Functional Dependencies</h3>
<p><strong>Def</strong>. <span class="math inline">\(K\)</span> is a <strong>super key</strong> for relation schema <span class="math inline">\(R\)</span> <strong>if and only if</strong> <span class="math inline">\(K \to R\)</span>.</p>
<p><strong>Def</strong>. <span class="math inline">\(K\)</span> is a <strong>candidate key</strong> for <span class="math inline">\(R\)</span> <strong>if and only if</strong> <span class="math inline">\(K \to R\)</span> and for no <span class="math inline">\(\alpha \subset K\)</span>, <span class="math inline">\(\alpha \to R\)</span>.</p>
<p>For example, consider the schema: <em>in_dep</em>(<u>ID</u>, name, salary, <u>dept_name</u>, building, budget). We expect FD to hold: dept_name <span class="math inline">\(\to\)</span> building, or ID <span class="math inline">\(\to\)</span> building, but not to hold dept_name <span class="math inline">\(\to\)</span> salary.</p>
<h3 id="fd-as-integrity-constraints-in-db">FD as Integrity Constraints in DB</h3>
<p>While ER diagram describe <strong>objects</strong> and <strong>associations</strong> among them, FD illustrates <strong>relationships</strong> among <strong>attributes</strong> of objects.</p>
<blockquote>
<p>How to guarantee FD in DBS? Integrity mechanisms in DBMS, i.e. keys, checks, and triggers</p>
</blockquote>
<h3 id="use-of-functional-dependencies">Use of Functional Dependencies</h3>
<ol type="1">
<li>Test relations to see if they are <strong>legal</strong>. If a relation <span class="math inline">\(r\)</span> is legal under an FD set <span class="math inline">\(F\)</span>, we say that <span class="math inline">\(r\)</span> satisfies <span class="math inline">\(F\)</span></li>
<li>Specify constraints on the set of legal relations. <span class="math inline">\(F\)</span> <strong>holds on</strong> <span class="math inline">\(R\)</span> if all legal relations on <span class="math inline">\(R\)</span> satisfy the FD set <span class="math inline">\(F\)</span>.</li>
</ol>
<blockquote>
<p><em>Note</em>: A specific instance of a relation schema may satisfy a FD in <span class="math inline">\(F\)</span> even if the FD does not hold on all legal instances.</p>
</blockquote>
<h3 id="trivial-functional-dependencies">Trivial Functional Dependencies</h3>
<p><strong>Def</strong>. A functional dependency (FD) <span class="math inline">\(\alpha \to \beta\)</span> is <strong>trivial</strong> if <span class="math inline">\(\beta \subseteq \alpha\)</span>.</p>
<p>This means that the attributes on the right-hand side of the FD are already included in the attributes on the left-hand side. As a result, <span class="math inline">\(\alpha \to \beta\)</span> is satisfied by all possible instances of the relation schema, regardless of the data.</p>
<p><strong>Def</strong>. <strong>Primary attribute</strong> is the attribute appears in at least one candidate key.</p>
<h3 id="transitive-dependency">Transitive Dependency</h3>
<p><strong>Def</strong>. A functional dependency <span class="math inline">\(\alpha \to \gamma\)</span> is <strong>transitive</strong>, if</p>
<ul>
<li><span class="math inline">\(\alpha \to \beta\)</span> holds on, but <span class="math inline">\(\beta \to \alpha\)</span> does not hold</li>
<li><span class="math inline">\(\beta \to \gamma\)</span> holds on, and <span class="math inline">\(\gamma \cap \alpha = \phi\)</span></li>
<li><span class="math inline">\(\gamma\)</span> is called transitive dependent on <span class="math inline">\(\alpha\)</span></li>
</ul>
<h3 id="partial-dependency">*Partial Dependency</h3>
<p><strong>Def</strong>. A FD <span class="math inline">\(\alpha \to \beta\)</span> is <strong>partial</strong>, <span class="math inline">\(\beta\)</span> is <strong>partially</strong> dependent on <span class="math inline">\(\alpha\)</span> if there is a <strong>subset</strong> <span class="math inline">\(\gamma\)</span> if <span class="math inline">\(\alpha\)</span>, i.e. <span class="math inline">\(\gamma \subset \alpha\)</span>, such that <span class="math inline">\(\gamma \to \beta\)</span></p>
<p>For example, consider <em>Student</em>(sno, sname, address, depart). Partial dependency (sno, sname) <span class="math inline">\(\to\)</span> address.</p>
<h3 id="closure-of-fd-set">*Closure of FD Set</h3>
<p><strong>Def</strong>. Use the notation <span class="math inline">\(F^{+}\)</span> to denote the <strong>closure</strong> of the FD set <span class="math inline">\(F\)</span>. The set of all FDs that can be inferred given the FD set <span class="math inline">\(F\)</span>. <span class="math inline">\(F^{+}\)</span> contains all of FDs in <span class="math inline">\(F\)</span>.</p>
<p>For example, <span class="math inline">\(F^{+} = \{A \to B, B \to C\}^{+} = \{A \to B, B \to C, A \to C, AB \to B, AC \to BC, \cdots\}\)</span></p>
<h2 id="normal-forms">Normal Forms</h2>
<p>关系模式规范化处理的基本要求为：</p>
<ul>
<li><strong>静态关系</strong>具有第一范式形式</li>
<li><strong>动态关系</strong>最好具有 3NF 和 BCNF 形式</li>
</ul>
<div style="display: block; margin: 0 auto; width: fit-content">
<pre><code class=" mermaid">flowchart TD
   A[1NF] --&gt; |消除非主属性对键的部分函数依赖| B[2NF]
   B --&gt; |消除非主属性对键的传递函数依赖| C[3NF]
   C --&gt; |消除主属性对键的部分和传递函数依赖| D[BCNF]
</code></pre>
</div>
<div style="text-align: center; font-style: italic;">
Figure 2: The relations between each norm
</div>
<h3 id="goals-of-normalization">Goals of Normalization</h3>
<p>Let <span class="math inline">\(R\)</span> be a relation schema with a FD set <span class="math inline">\(F\)</span> (decide whether a relation schema <span class="math inline">\(R\)</span> is in good form). When a relation schema <span class="math inline">\(R\)</span> is not in good form, decompose it into <span class="math inline">\(\{R_1, R_2, \cdots, R_n\}\)</span> such that</p>
<ul>
<li>each relation schema is in good form, e.g. in 2NF, 3NF, BCNF</li>
<li>the decomposition is a <strong>lossless decomposition</strong></li>
<li>the decomposition should be <strong>dependency preserving</strong></li>
</ul>
<h3 id="atomic-domains-and-first-normal-form">Atomic Domains and First Normal Form</h3>
<p><strong>Def</strong>. A relational schema <span class="math inline">\(R\)</span> is in <strong>first normal form</strong> if the domains of all attributes of <span class="math inline">\(R\)</span> are <strong>atomic</strong>.</p>
<blockquote>
<p>Domain is <strong>atomic</strong> if its elements are <strong>indivisible</strong> units.</p>
<p>Examples of <strong>non-atomic</strong> domains: names and composite attributes</p>
</blockquote>
<p><strong>Def</strong>. <strong>Atomicity</strong> is actually a property of how the elements of the domain are used. For example, strings would normally be considered <strong>indivisible</strong>.</p>
<blockquote>
<p>Students are given roll numbers which are strings of CS0012 or EE1127. If the first two characters are extracted to find the department, the domain of roll numbers is not atomic.</p>
</blockquote>
<h3 id="second-normal-form">*Second Normal Form</h3>
<p><strong>Def</strong>. A relation schema <span class="math inline">\(R\)</span> is in <strong>2NF</strong> with respect to a FD set <span class="math inline">\(F\)</span>, if <span class="math inline">\(R\)</span> is in 1NF, and each attribute <span class="math inline">\(A\)</span> meets one of the <strong>criteria</strong></p>
<ul>
<li>It appears in a <strong>candidate key</strong> (a prime attribute)</li>
<li>It is (not partially) dependent on a <strong>candidate key</strong></li>
</ul>
<p>Here is an example about 2NF. Consider <em>SLC</em>(<u>S#</u>, SDpt, SLocation, <u>C#</u>, Grade). The FDs are</p>
<ul>
<li>(S#, C#) <span class="math inline">\(\to\)</span> Grade</li>
<li>(S#, C#) <span class="math inline">\(\to\)</span> SDpt</li>
<li>(S#, C#) <span class="math inline">\(\to\)</span> SLocation</li>
<li>SDpt <span class="math inline">\(\to\)</span> SLocation</li>
<li>S# <span class="math inline">\(\to\)</span> SDpt</li>
<li>S# <span class="math inline">\(\to\)</span> SLocation</li>
</ul>
<p>This schema is not in 2NF, because</p>
<ul>
<li>For non-primary attribute SDpt, there exists S# <span class="math inline">\(\to\)</span> SDpt, so SDpt is partially dependent on <strong>key</strong></li>
<li>For non-primary attribute SLocation, there exists S# <span class="math inline">\(\to\)</span> SLocation, so SLocation is partially dependent on <strong>key</strong></li>
</ul>
<h3 id="bcnf">*BCNF</h3>
<p><strong>Def</strong>. A relation schema <span class="math inline">\(R\)</span> is in <strong>BCNF</strong> with respect to a FD set <span class="math inline">\(F\)</span> if for all functional dependencies in <span class="math inline">\(F^{+}\)</span> of the form <span class="math inline">\(\alpha \to \beta\)</span> where <span class="math inline">\(\alpha \subseteq R\)</span> and <span class="math inline">\(\beta \subseteq R\)</span>, <strong>at least one</strong> holds:</p>
<ul>
<li><span class="math inline">\(\alpha \to \beta\)</span> is <strong>trivial</strong></li>
<li><span class="math inline">\(\alpha\)</span> is a <strong>super key</strong></li>
</ul>
<p>Example schema that is not in BCNF. Consider <em>in_dept</em>(<u>ID</u>, name, salary, <u>dept_name</u>, budget). Because dept_name <span class="math inline">\(\to\)</span> building, budget holds on <em>in_dep</em> but dept_name is not a super key. Decompose <em>in_dep</em> into <em>instructor</em> and <em>department</em> as follow are both BCNF.</p>
<ul>
<li><em>instructor</em>(<u>ID</u>, name, salary, dept_name)</li>
<li><em>department</em>(<u>dept_name</u>, building, budgets)</li>
</ul>
<h3 id="decompose-a-schema-into-bcnf">Decompose a Schema into BCNF</h3>
<p>Let <span class="math inline">\(R\)</span> be a schema <span class="math inline">\(R\)</span> that is <strong>not</strong> in <strong>BCNF</strong>. Let <span class="math inline">\(\alpha \to \beta\)</span> that causes <strong>violation</strong> of BCNF.</p>
<p>We decompose <span class="math inline">\(R\)</span> into:</p>
<ul>
<li><span class="math inline">\((\alpha \cup \beta)\)</span></li>
<li><span class="math inline">\((R - (\beta - \alpha))\)</span></li>
</ul>
<h3 id="bcnf-and-df-preservation">*BCNF and DF Preservation</h3>
<p>Constraints on FDs, are <strong>costly</strong> to check in practice, unless they pertain to <strong>only one</strong> relation.</p>
<p>If test only those DFs on <strong>each</strong> individual relation of a decomposition to ensure <strong>all</strong> FDs hold, then that decomposition is <strong>dependency preserving</strong>.</p>
<blockquote>
<p><em>Note</em>: because it is <strong>not always</strong> possible to achieve both BCNF and dependency preservation, we consider a <strong>weaker normal form</strong>, known as the 3NF.</p>
</blockquote>
<p>Consider a schema <em>dept_advisor</em>(s_ID, i_ID, dept_name) with <span class="math inline">\(F\)</span>: i_ID <span class="math inline">\(\to\)</span> dept_name and s_ID, dept_name <span class="math inline">\(\to\)</span> i_ID. Two candidate keys are {s_ID, dept_name} and {s_ID, i_ID}. <em>dept_advisor</em> is not in BCNF because i_ID is not a super key. If we need to decompose <em>dept_advisor</em> into two BCNF, any decomposition will <strong>not</strong> include all the attributes in s_ID, dept_name <span class="math inline">\(\to\)</span> i_ID. Thus, the decomposition not be dependency preserving.</p>
<blockquote>
<p>The FD can only be checked by <strong>the join of</strong> the decomposed relations.</p>
</blockquote>
<p>For example, consider <span class="math inline">\(R = (A, B, C)\)</span> and <span class="math inline">\(F = \{\A \to B, B \to C\}\)</span>.</p>
<ul>
<li>Decomposition1: <span class="math inline">\(R_1 = (A, B)\)</span>, <span class="math inline">\(R_2 = (B, C)\)</span>
<ul>
<li>Lossless join decomposition <span class="math inline">\(R_1 \cap R_2 \to R_2 \in F^{+}\)</span></li>
<li><strong>Dependency preserving</strong></li>
</ul></li>
<li>Decomposition2: <span class="math inline">\(R_1 = (A, B)\)</span>, <span class="math inline">\(R_2 = (A, C)\)</span>
<ul>
<li>Lossless join decomposition <span class="math inline">\(R_1 \cap R_2 \to R_1 \in F^{+}\)</span></li>
<li><strong>Not dependency preserving</strong></li>
</ul></li>
</ul>
<h3 id="third-normal-form">*Third Normal Form</h3>
<p><strong>Def</strong>. A relation schema <span class="math inline">\(R\)</span> is in <strong>third normal form (3NF)</strong> if for all: <span class="math inline">\(\alpha \to \beta\)</span> in <span class="math inline">\(F^{+}\)</span> <strong>at least one</strong> of the following holds:</p>
<ul>
<li><span class="math inline">\(\alpha \to \beta\)</span> is <strong>trivial</strong></li>
<li><span class="math inline">\(\alpha\)</span> is a <strong>super key</strong> for <span class="math inline">\(R\)</span></li>
<li>Each attribute in <span class="math inline">\(\beta - \alpha\)</span> is contained in a candidate key</li>
</ul>
<blockquote>
<p>If a schema is in BCNF, it is also in 3NF.</p>
</blockquote>
<p><strong>Def</strong>. A schema <span class="math inline">\(R\)</span> is in <strong>3NF</strong> with respect to a FD set, if there are no non-prime attributes <span class="math inline">\(A\)</span> for which <span class="math inline">\(A\)</span> is transitive dependent on a key</p>
<p>Consider a schema: <em>dept_advisor</em>(s_ID, i_ID, dept_name) with FDs: i_ID <span class="math inline">\(\to\)</span> dept_name and s_ID, dept_name <span class="math inline">\(\to\)</span> i_ID. Two candidate keys are {s_ID, dept_name} and {s_ID, i_ID}. <em>dept_advisor</em> is not in BCNF, however, <span class="math inline">\(R\)</span> is in 3NF.</p>
<ul>
<li>s_ID, dept_name is a super key</li>
<li>i_ID <span class="math inline">\(\to\)</span> dept_name and i_ID is not a super key, but
<ul>
<li>{dept_name} - {i_ID} = {dept_name} and dept_name is contained in a candidate key</li>
</ul></li>
</ul>
<h3 id="comparison-of-bcnf-and-3nf">Comparison of BCNF and 3NF</h3>
<ul>
<li>Advantages to 3NF over BCNF. It is always possible to obtain a 3NF design without <strong>sacrificing losslessness or dependency preservation</strong>.</li>
<li>Disadvantage to 3NF
<ul>
<li>We may have to use <strong>null</strong> values to represent some of the possible meaningful relationships among data items</li>
<li>There is the problem of <strong>repetition</strong> of information</li>
</ul></li>
</ul>
<h2 id="functional-dependency-fd-theory">Functional Dependency (FD) Theory</h2>
<ul>
<li>The theory shows which FDs are <strong>implied logically</strong> by <strong>a given set</strong> of FDs. (Armstrong’s Axioms)</li>
<li>Algorithms generating <strong>lossless decompositions</strong> into <strong>BCNF</strong> and <strong>3ND</strong>.</li>
<li>Algorithms testing if <strong>decomposition</strong> is <strong>dependency-preserving</strong>.</li>
</ul>
<blockquote>
<p>给定关系模式 <span class="math inline">\(R(A, B, C)\)</span> 和关系 <span class="math inline">\(r(R)\)</span>，利用 SQL 语句判断关系 <span class="math inline">\(r(R)\)</span> 是否满足函数依赖 <span class="math inline">\(B \to C\)</span></p>
<p>要求：如果 <span class="math inline">\(r(R)\)</span> 不满足该函数依赖，找出导致不满足的 <span class="math inline">\(r(R)\)</span> 中的<strong>元组</strong>；设计一个<strong>断言</strong>，以保证在 <span class="math inline">\(R(A, B, C)\)</span> 上成立 <span class="math inline">\(B \to C\)</span></p>
<p>方法：1. 使用元组变量，2. 使用 <code>GROUP BY</code>。如果查询结果为 <code>null</code>，<code>not exist</code>，则函数依赖成立。</p>
<p>参考 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> ASSERTION B_to_C <span class="hljs-keyword">CHECK</span><br>(<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> B <span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> B <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span> (<span class="hljs-keyword">DISTINCT</span> C) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure>
</blockquote>
<p>What’s <strong>logical implication</strong> between FDs? Given an FD set <span class="math inline">\(F\)</span>, there are <strong>other FDs</strong> <span class="math inline">\(f\)</span> that <strong>logically implied</strong> by <span class="math inline">\(F\)</span></p>
<ul>
<li>Example: if <span class="math inline">\(A \to B\)</span> and <span class="math inline">\(B \to C\)</span>, then infer that <span class="math inline">\(A \to C\)</span>.</li>
</ul>
<blockquote>
<p><strong>Def</strong>. Given a schema <span class="math inline">\(R\)</span>, a FD <span class="math inline">\(f\)</span> is <strong>logically implied</strong> by a FD set <span class="math inline">\(F\)</span>, if <strong>every</strong> instance <span class="math inline">\(r(R)\)</span> that satisfies <span class="math inline">\(F\)</span> also satisfies <span class="math inline">\(f\)</span></p>
<ul>
<li>Example: <span class="math inline">\(\{A \to B, B \to C\}^{+} = \{A \to B, B \to C, A \to C, \cdots\}\)</span></li>
</ul>
<p><strong>Def</strong>. The set of <strong>all FDs</strong> logically implied by <span class="math inline">\(F\)</span> is the <strong>closure</strong> of <span class="math inline">\(F\)</span>.</p>
<ul>
<li>Denote the closure of <span class="math inline">\(F\)</span> by <span class="math inline">\(F^{+}\)</span>.</li>
<li><span class="math inline">\(F^{+} = \{f \mid f \text{ is logically implied by } F\}\)</span></li>
</ul>
</blockquote>
<h3 id="closure-of-fds">*Closure of FDs</h3>
<p>Compute <span class="math inline">\(F^{+}\)</span>, the closure of <span class="math inline">\(F\)</span>, by repeatedly applying <strong>Armstrong’s Axioms</strong>:</p>
<ul>
<li><strong>Reflexive rule</strong>: if <span class="math inline">\(\beta \subseteq \alpha\)</span>, then <span class="math inline">\(\alpha \to \beta\)</span>.</li>
<li><strong>Augmentation rule</strong>: if <span class="math inline">\(\alpha \to \beta\)</span>, then <span class="math inline">\(\gamma \alpha \to \gamma \beta\)</span>.</li>
<li><strong>Transitivity rule</strong>: if <span class="math inline">\(\alpha \to \beta\)</span>, and <span class="math inline">\(\beta \to \gamma\)</span>, then <span class="math inline">\(\alpha \to \gamma\)</span>.</li>
</ul>
<blockquote>
<p>These rules are</p>
<ul>
<li>Sound: generate only functional dependencies that actually hold.</li>
<li>Complete: generate all functional dependencies that hold.</li>
</ul>
<p>Additional rules:</p>
<ul>
<li><strong>Union rule</strong>: if <span class="math inline">\(\alpha \to \beta\)</span> holds and <span class="math inline">\(\alpha \to \gamma\)</span> holds, then <span class="math inline">\(\alpha \to \beta \gamma\)</span> holds.</li>
<li><strong>Decomposition rule</strong>: if <span class="math inline">\(\alpha \to \beta \gamma\)</span> holds, then <span class="math inline">\(\alpha \to \beta\)</span> holds and <span class="math inline">\(\alpha \to \gamma\)</span> holds.</li>
<li><strong>Pseudo-Transitivity rule</strong>: if <span class="math inline">\(\alpha \to \beta\)</span> holds and <span class="math inline">\(\gamma \beta \to \delta\)</span> holds, then <span class="math inline">\(\alpha \gamma \to \delta\)</span> holds.</li>
</ul>
<p>“holds” 理解为”满足“</p>
</blockquote>
<p>Here is an example of computing <span class="math inline">\(F^{+}\)</span> with using rules mentioned above: <span class="math inline">\(R = (A, B, C, G, H, I)\)</span>, <span class="math inline">\(F = \{A \to B, A \to C, B \to H, CG \to H, CG \to I\}\)</span>.</p>
<p>Some members of <span class="math inline">\(F^{+}\)</span>. <span class="math inline">\(\{A \to H\} \subseteq F^{+}\)</span> (transitivity rule), <span class="math inline">\(\{AG \to I\} \subseteq F^{+}\)</span> (augmentation rule and transitivity rule), <span class="math inline">\(\{CG \to HI\}\)</span> (augmentation rule).</p>
<h3 id="closure-of-attribute-sets">*Closure of Attribute Sets</h3>
<blockquote>
<p><strong>Def</strong>. An attribute <span class="math inline">\(B\)</span> is <strong>functionally determined</strong> by <span class="math inline">\(\alpha\)</span> under <span class="math inline">\(F\)</span> if <span class="math inline">\(\alpha \to B\)</span> under <span class="math inline">\(F\)</span></p>
<ul>
<li><span class="math inline">\(\alpha | F \to B\)</span></li>
</ul>
<p><strong>Def</strong>. Given a set of attributes <span class="math inline">\(\alpha\)</span>, define the <strong>closure</strong> of <span class="math inline">\(\alpha\)</span> under <span class="math inline">\(F\)</span> (denoted by <span class="math inline">\(\alpha^{+}\)</span>) as the set of attributes that are functionally determined by <span class="math inline">\(\alpha\)</span> under <span class="math inline">\(F\)</span>.</p>
<ul>
<li><span class="math inline">\(\alpha^{+} = \{\beta \mid \beta \text{ is functionally determined by } \alpha \text{ under } F\} = \{\beta \mid \alpha | F \to \beta\}\)</span></li>
</ul>
</blockquote>
<p><strong>Algorithm</strong>: compute <span class="math inline">\(\alpha^{+}\)</span>, the closure of <span class="math inline">\(\alpha\)</span>, under <span class="math inline">\(F\)</span>.</p>
<ul>
<li><strong>Input</strong>: <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(F\)</span></li>
<li><strong>Output</strong>: <span class="math inline">\(\alpha^{+}\)</span></li>
<li><strong>Result</strong> <span class="math inline">\(:= \alpha\)</span></li>
</ul>
<p>The process is as follow:</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">while (changes to result) do<br>  for each beta_to_gamma in F do<br>    begin<br>      if beta subseteq result then result := result cup gamma<br>    end<br></code></pre></td></tr></table></figure>
<blockquote>
<p><span class="math inline">\(:=\)</span> 在数学定义里表示“被定义为”</p>
</blockquote>
<p>Here is an example of computing attribute set closure. We suppose <span class="math inline">\(R = (A, B, C, G, H, I)\)</span>, <span class="math inline">\(F = \{A \to B, A \to C, CG \to H, CG \to I, B \to H\}\)</span>. Compute <span class="math inline">\((AG)^{+}\)</span>.</p>
<ol type="1">
<li><span class="math inline">\(res = AG\)</span></li>
<li><span class="math inline">\(res = ABCG\)</span> &gt; <span class="math inline">\((A \to C)\)</span> and <span class="math inline">\((A \to B)\)</span></li>
<li><span class="math inline">\(res = ABCGH\)</span> &gt; <span class="math inline">\((CG \subseteq ABCG)\)</span> and <span class="math inline">\((CG \to H)\)</span></li>
<li><span class="math inline">\(res = ABCGHI\)</span> &gt; <span class="math inline">\((CG \subseteq ABCGH)\)</span> and <span class="math inline">\((CG \to I)\)</span></li>
</ol>
<p>So <span class="math inline">\((AG)^{+} = R\)</span>, <span class="math inline">\(AG\)</span> <strong>is a superkey of</strong> <span class="math inline">\(R\)</span></p>
<blockquote>
<p>Is <span class="math inline">\(AG\)</span> a candidate key?</p>
<ol type="1">
<li>Is <span class="math inline">\(AG\)</span> a super key?
<ul>
<li>Does <span class="math inline">\(AG \to R\)</span>? <span class="math inline">\(==\)</span> Is <span class="math inline">\(R \subseteq (AG)^{+}\)</span>?, yes</li>
</ul></li>
<li>Is any subset of <span class="math inline">\(AG\)</span> a superkey?
<ul>
<li>Does <span class="math inline">\(A \to R\)</span>? <span class="math inline">\(==\)</span> Is <span class="math inline">\(R \subseteq (A)^{+}\)</span>?, no</li>
<li>Does <span class="math inline">\(G \to R\)</span>? <span class="math inline">\(==\)</span> Is <span class="math inline">\(R \subseteq (G)^{+}\)</span>?, no</li>
</ul></li>
</ol>
</blockquote>
<p>We can use attribute closure algorithm to</p>
<ol type="1">
<li><strong>Test for super key</strong>
<ul>
<li>To test if <span class="math inline">\(\alpha\)</span> is a superkey, we compute <span class="math inline">\(\alpha^{+}\)</span> and check if <span class="math inline">\(\alpha^{+} = R\)</span></li>
</ul></li>
<li><strong>Test functional dependencies</strong>
<ul>
<li>To check if FD <span class="math inline">\(\alpha \to \beta\)</span> holds (or, in other words, is in <span class="math inline">\(F^{+}\)</span>), just check if <span class="math inline">\(\beta \subseteq \alpha^{+}\)</span></li>
</ul></li>
</ol>
<blockquote>
<p><strong>Def</strong>. For two FDs <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span>, if <span class="math inline">\(F^{+} = G^{+}\)</span> then <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span> are <strong>equivalent</strong>.</p>
</blockquote>
<h3 id="canonical-cover">*Canonical Cover</h3>
<blockquote>
<p><strong>Def</strong>. <strong>Extraneous</strong></p>
<ol type="1">
<li>Sets of FDs may have redundant FDs that can be inferred from others.
<ul>
<li><span class="math inline">\(A \to C\)</span> is redundant in <span class="math inline">\(\{A \to B, B \to C, A \to C\}\)</span>.</li>
</ul></li>
<li>Some attributes in the left or right sides of a FD may be extraneous
<ul>
<li><span class="math inline">\(\{A \to B, B \to C, A \to CD\}\)</span> can be simplified to <span class="math inline">\(\{A \to B, B \to C, A \to D\}\)</span>.</li>
</ul></li>
<li>An attribute of FD in <span class="math inline">\(F\)</span> is <strong>extraneous</strong> if we can remove it without changing <span class="math inline">\(F^{+}\)</span>.</li>
</ol>
</blockquote>
<p>Extraneous attributes:</p>
<ol type="1">
<li><p>Removing an attribute from the <strong>left</strong> side of a FD could <strong>make it a stronger constraint</strong>. If we have <span class="math inline">\(AB \to C\)</span>, we may remove <span class="math inline">\(A\)</span> or <span class="math inline">\(B\)</span>. The choice depends on what FD set <span class="math inline">\(F\)</span> happens to be. Suppose that <span class="math inline">\(F = \{AB \to C, A \to D, D \to C\}\)</span>, then we can show that <span class="math inline">\(F\)</span> logically implies <span class="math inline">\(A \to C\)</span>, making extraneous <span class="math inline">\(B\)</span> in <span class="math inline">\(AB \to C\)</span>.</p></li>
<li><p>Removing an attribute from the <strong>right</strong> side of a FD could <strong>make it a weaker constraint</strong>. If we have <span class="math inline">\(AB \to CD\)</span> and remove <span class="math inline">\(C\)</span>, we get possibly weaker result <span class="math inline">\(AB \to D\)</span>. Because using just <span class="math inline">\(AB \to D\)</span>, we can no longer infer <span class="math inline">\(AB \to C\)</span>. But, depending on what FD set <span class="math inline">\(F\)</span> happens to be, we may remove <span class="math inline">\(C\)</span> from <span class="math inline">\(AB \to CD\)</span> safely. Suppose that <span class="math inline">\(F = \{AB \to CD, A \to C\}\)</span>. Even after replacing <span class="math inline">\(AB \to CD\)</span> by <span class="math inline">\(AB \to D\)</span>, we can still infer <span class="math inline">\(AB \to C\)</span> and thus <span class="math inline">\(AB \to CD\)</span>.</p></li>
<li><p>Consider a set <span class="math inline">\(F\)</span> of FD and <span class="math inline">\(\alpha \to \beta\)</span> in F.</p>
<ul>
<li>Attribute <span class="math inline">\(A\)</span> is <strong>extraneous</strong> in <span class="math inline">\(\alpha\)</span>, if <span class="math inline">\(A \in \alpha\)</span>, and <span class="math inline">\(F\)</span> implies <span class="math inline">\((F - \{\alpha \to \beta\}) \cup {(\alpha - A) \to \beta} = F&#39;\)</span> (F’ F^{+}).</li>
<li>Attribute <span class="math inline">\(A\)</span> is <strong>extraneous</strong> in <span class="math inline">\(\beta\)</span>, if <span class="math inline">\(A \in \beta\)</span>, and the set of FDs <span class="math inline">\(F&#39; = (F - \{\alpha \to \beta\}) \cup \{\alpha \to (\beta - A)\}\)</span> implies <span class="math inline">\(F\)</span> (F (F’)^{+}).</li>
</ul></li>
</ol>
<p>How to test if an attribute is extraneous? Here are two ways to make it.</p>
<p>Let <span class="math inline">\(R\)</span> be a relation schema and let <span class="math inline">\(F\)</span> be a set of FDs that hold on <span class="math inline">\(R\)</span>. Consider an attribute <span class="math inline">\(B\)</span> in the FD. For <span class="math inline">\(\alpha \to \beta\)</span></p>
<ol type="1">
<li>Testing if attribute <span class="math inline">\(B \in \beta\)</span> is extraneous in <span class="math inline">\(\beta\)</span> under <span class="math inline">\(F\)</span>?
<ul>
<li>Consider the set <span class="math inline">\(F&#39; = (F - \{\alpha \to \beta\}) \cup \{\alpha \to (\beta - B)\}\)</span>.</li>
<li>Compute <span class="math inline">\(\alpha^{+}\)</span> under <span class="math inline">\(F&#39;\)</span> and check if <span class="math inline">\(B \in \alpha^{+}\)</span> under <span class="math inline">\(F&#39;\)</span>? If it does, <span class="math inline">\(B\)</span> is extraneous in <span class="math inline">\(\beta\)</span>.</li>
</ul></li>
<li>Testing if attribute <span class="math inline">\(A \in \alpha\)</span> is extraneous in <span class="math inline">\(\alpha\)</span> under <span class="math inline">\(F\)</span>?
<ul>
<li>Let <span class="math inline">\(\gamma = \alpha - \{A\}\)</span>. Compute <span class="math inline">\(\gamma^{+}\)</span> using the FDs in <span class="math inline">\(F\)</span>.</li>
<li>If <span class="math inline">\(\gamma^{+}\)</span> includes all attributes in <span class="math inline">\(\beta\)</span>, then <span class="math inline">\(A\)</span> is extraneous in <span class="math inline">\(\alpha\)</span>.</li>
</ul></li>
</ol>
<p>Examples</p>
<ul>
<li>Given <span class="math inline">\(F = \{A \to C, AB \to C\}\)</span>, <span class="math inline">\(B\)</span> is extraneous in <span class="math inline">\(AB \to C\)</span>, because <span class="math inline">\(\{A \to C, AB \to C\}\)</span> logically implies <span class="math inline">\(\{A \to C\}\)</span></li>
<li>Given <span class="math inline">\(F = \{A \to C, AB \to CD\}\)</span>, <span class="math inline">\(C\)</span> is extraneous in <span class="math inline">\(AB \to CD\)</span> since <span class="math inline">\(AB \to C\)</span> can be inferred even after deleting <span class="math inline">\(C\)</span></li>
<li>Given <span class="math inline">\(F = \{AB \to CD, A \to E, E \to C\}\)</span>, <span class="math inline">\(C\)</span> is extraneous in <span class="math inline">\(AB \to CD\)</span> since the closure includes <span class="math inline">\(C\)</span></li>
</ul>
<blockquote>
<p><strong>Def</strong>. A <strong>canonical cover</strong> of <span class="math inline">\(F\)</span>, denoted as <span class="math inline">\(F_{c}\)</span>, is a <strong>minimal</strong> set of FDs equivalent to <span class="math inline">\(F\)</span> without <strong>redundant</strong> FDs or attribute.</p>
<p>A <strong>canonical cover</strong> for <span class="math inline">\(F\)</span> is a set of FDs <span class="math inline">\(F_c\)</span> such that</p>
<ul>
<li><span class="math inline">\(F\)</span> logically implies all dependencies in <span class="math inline">\(F_c\)</span></li>
<li><span class="math inline">\(F_c\)</span> logically implies all dependencies in <span class="math inline">\(F\)</span></li>
<li>No FD in <span class="math inline">\(F_c\)</span> contains an extraneous attribute and each left side of FD in <span class="math inline">\(F_c\)</span> is <strong>unique</strong>.
<ul>
<li>There are no two FDs in <span class="math inline">\(F_c\)</span>, <span class="math inline">\(\alpha_1 \to \beta_1\)</span> and <span class="math inline">\(\alpha_2 \to \beta_2\)</span> such that <span class="math inline">\(\alpha_1 = \alpha_2\)</span>.</li>
</ul></li>
</ul>
</blockquote>
<p>How to compute a canonical cover for <span class="math inline">\(F\)</span>? We repeat using the <strong>union rule</strong> to replace any FDs in <span class="math inline">\(F\)</span> of the form <span class="math inline">\(\alpha_1 \to \beta_1\)</span> and <span class="math inline">\(\alpha_1 \to \beta_2\)</span> with <span class="math inline">\(\alpha_1 \to \beta_1 \beta_2\)</span>, finding a FD <span class="math inline">\(\alpha \to \beta\)</span> in <span class="math inline">\(F_c\)</span> with an <strong>extraneous attribute</strong> either in <span class="math inline">\(\alpha\)</span> or in <span class="math inline">\(\beta\)</span>, until <span class="math inline">\(F_c\)</span> not change.</p>
<blockquote>
<p><em>Note</em></p>
<ol type="1">
<li><p>Test for extraneous attributes done using <span class="math inline">\(F_c\)</span> not <span class="math inline">\(F\)</span>. IF an extraneous attribute is found, delete it from <span class="math inline">\(\alpha \to \beta\)</span></p></li>
<li><p>Union rule may become applicable after some extraneous attributes have been deleted, so it has to be reapplied.</p></li>
<li><p>There may be <strong>several</strong> <span class="math inline">\(F_c\)</span> for a set <span class="math inline">\(F\)</span> of FDs.</p></li>
</ol>
</blockquote>
<p>Here is an example of computing a canonical cover. Suppose <span class="math inline">\(R = (A, B, C)\)</span>, <span class="math inline">\(F = \{A \to BC, B \to C, A \to B, AB \to C\}\)</span>.</p>
<ol type="1">
<li><p>Use <strong>union rules</strong> to combine <span class="math inline">\(A \to BC\)</span> and <span class="math inline">\(A \to B\)</span> into <span class="math inline">\(A \to BC\)</span>.</p></li>
<li><p><span class="math inline">\(A\)</span> is <strong>extraneous</strong> in <span class="math inline">\(AB \to C\)</span>.</p></li>
<li><p><span class="math inline">\(C\)</span> is <strong>extraneous</strong> in <span class="math inline">\(A \to BC\)</span>.</p></li>
<li><p>The canonical cover is <span class="math inline">\(\{A \to B, B \to C\}\)</span>.</p></li>
</ol>
<h3 id="lossless-join-decomposition">Lossless-join Decomposition</h3>
<p><strong>Def</strong>. For <span class="math inline">\(R = (R_1, R_2)\)</span>, we require that for all possible relations <span class="math inline">\(r\)</span> on schema <span class="math inline">\(R\)</span>, <span class="math inline">\(r = \Pi_{R_1}(r) \Join \Pi_{R_2}(r)\)</span>.</p>
<p><strong>Def</strong>. Decomposition of <span class="math inline">\(R\)</span> into <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> is <strong>lossless join</strong> if at least one of the following dependencies is in <span class="math inline">\(F^{+}\)</span>.</p>
<ul>
<li><span class="math inline">\(R_1 \cap R_2 \to R_1\)</span> or <span class="math inline">\(R_1 \cap R_2 \to R_2\)</span></li>
</ul>
<p><em>Note</em>: The above FDs are a <strong>sufficient condition</strong> for lossless join decomposition; The dependencies are a <strong>necessary condition</strong> only if all constraints are FDs.</p>
<p><strong>Def</strong>. <strong>Lossy decomposition</strong>, <span class="math inline">\(r \neq \Pi_{R_1}(r) \Join \Pi_{R_2}(r) \cdots \Join \Pi_{R_n}(r)\)</span>, also known as <strong>lossy-join decomposition</strong>.</p>
<h3 id="functional-dependency-preservation">*Functional Dependency Preservation</h3>
<blockquote>
<p><strong>Def</strong>. For a schema <span class="math inline">\(R\)</span>, <span class="math inline">\(F\)</span> holds on <span class="math inline">\(R\)</span>, and decomposition <span class="math inline">\(\{R_1, R_2, \cdots, R_n\}\)</span> of <span class="math inline">\(R\)</span>, the <strong>restriction</strong> of <span class="math inline">\(F\)</span> to <span class="math inline">\(R_i\)</span>, denoted as <span class="math inline">\(F_i\)</span> is defined as</p>
<p><span class="math display">\[
F_i = \{\alpha \to \beta \mid \alpha \to \beta \in F^{+} \And \alpha \beta \subseteq R_i\}
\]</span></p>
<p>The set of FDs in <span class="math inline">\(F^{+}\)</span> that include only attributes in <span class="math inline">\(R_i\)</span>.</p>
<p><strong>Def</strong>. Let <span class="math inline">\(F_i\)</span> be <strong>restriction</strong> of <span class="math inline">\(F\)</span> to <span class="math inline">\(R_i\)</span>. A decomposition is <strong>dependency preserving</strong>, if <span class="math inline">\((F_1 \cup F_2 \cup \cdots \cup F_n)^{+} = F^{+}\)</span></p>
<p><em>Note</em>: Testing for dependency preservation take s exponential time.</p>
</blockquote>
<p><strong>Algorithm</strong>. How to test for dependency preservation? Check if a FD <span class="math inline">\(\alpha \to \beta\)</span> is preserved in decomposition <span class="math inline">\(R\)</span> of <span class="math inline">\(R_1\)</span>, <span class="math inline">\(R_2\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(R_n\)</span>. We set <span class="math inline">\(res = \alpha\)</span> and repeat updating <span class="math inline">\(t = (res \cap R_i)^{+} \cap R_i\)</span>, <span class="math inline">\(res = res \cup t\)</span> for each <span class="math inline">\(R_i\)</span> in the decomposition until <span class="math inline">\(res\)</span> does not change. If <span class="math inline">\(res\)</span> contains all attributes in <span class="math inline">\(\beta\)</span>, the FD <span class="math inline">\(\alpha \to \beta\)</span> preserved.</p>
<p>Test on <strong>all FDs</strong> in <span class="math inline">\(F\)</span> to check if a decomposition is dependency preserving</p>
<ul>
<li>The decomposition is preserved, if and only if all <span class="math inline">\(\alpha \to \beta\)</span> in <span class="math inline">\(F\)</span> are preserved.</li>
<li>This procedure takes polynomial time.</li>
</ul>
<p>Here is an example. Consider <em>Student</em>(sno, dept, head), <span class="math inline">\(F = \{\text{sno} \to \text{dept}, \text{dept} \to \text{head}\}\)</span>.</p>
<ul>
<li>Decomposition1:
<ul>
<li><span class="math inline">\(R_1(\text{sno, dept})\)</span>, <span class="math inline">\(F_1 = \{\text{sno} \to \text{dept}\}\)</span></li>
<li><span class="math inline">\(R_2(\text{sno, head})\)</span>, <span class="math inline">\(F_2 = \{\text{sno} \to \text{head}\}\)</span></li>
<li><strong>lossless decomposition</strong> because <span class="math inline">\(R_1 \cap R_2 \to R_1\)</span></li>
<li><strong>non-dependency preservation</strong>
<ul>
<li>Using definition, because <span class="math inline">\(\{\{\text{sno} \to \text{dept}\} \cup \{\text{sno} \to \text{head}\}\}^{+} \neq F^{+}\)</span></li>
<li>Using algorithm and checking if <span class="math inline">\(\text{dept} \to \text{head}\)</span> is preserved
<ul>
<li>result = <span class="math inline">\(\{text{dept}\}\)</span></li>
<li><span class="math inline">\((\text{dept} \cap R_1)^{+} \cap R_1 = \{\text{dept}\}\)</span></li>
<li><span class="math inline">\((\text{dept} \cap R_2)^{+} \cap R_2 = \phi\)</span></li>
<li>so th FD is not preserved</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="algorithms-for-decomposition-using-fd">Algorithms for Decomposition Using FD</h2>
<h3 id="testing-for-bcnf">*Testing for BCNF</h3>
<p><strong>Algorithm 1</strong>. To check if a non-trivial FD <span class="math inline">\(\alpha \to \beta\)</span> causes a violation of BCNF</p>
<ol type="1">
<li>Compute <span class="math inline">\(\alpha^{+}\)</span> (the attribute closure of <span class="math inline">\(\alpha\)</span>).</li>
<li>Verify that it includes all attributes of <span class="math inline">\(R\)</span>, that is, it is a super key of <span class="math inline">\(R\)</span>.</li>
</ol>
<blockquote>
<p><em>Simplified test</em>: To check if a relation schema <span class="math inline">\(R\)</span> is in BCNF, suffices to check only the FDs in <span class="math inline">\(F\)</span> for violation, rather than checking all FDs in <span class="math inline">\(F^{+}\)</span>. If none of the FDs in <span class="math inline">\(F\)</span> causes a violation of BCNF, none of the FDs in <span class="math inline">\(F^{+}\)</span> will cause a violation of BCNF either.</p>
<p>However, <em>simplified test</em> using only <span class="math inline">\(F\)</span> is incorrect when testing a relation in a <strong>decomposition</strong> of <span class="math inline">\(R\)</span>.</p>
<p>Consider <span class="math inline">\(R = (A, B, C, D, E)\)</span>, with <span class="math inline">\(F = \{A \to B, BC \to D\}\)</span>. We decompose <span class="math inline">\(R\)</span> into <span class="math inline">\(R_1 = (A, B)\)</span> and <span class="math inline">\(R_2 = (A, C, D, E)\)</span>. Neither of the dependencies in <span class="math inline">\(F\)</span> contain only attributes from <span class="math inline">\((A, C, D, E)\)</span>, so we might be mislead into thinking <span class="math inline">\(R_2\)</span> satisfies BCNF. In fact, dependency <span class="math inline">\(AC \to D\)</span> in <span class="math inline">\(F^{+}\)</span> shows <span class="math inline">\(R_2\)</span> is not in BCNF.</p>
</blockquote>
<p><strong>Algorithm 2</strong>. Check if a relation <span class="math inline">\(R_i\)</span> in a <strong>decomposition</strong> of <span class="math inline">\(R\)</span> is in BCNF.</p>
<p>Either test <span class="math inline">\(R_i\)</span> for BCNF with respect to the restriction of <span class="math inline">\(F^{+}\)</span> to <span class="math inline">\(R_i\)</span> or use the original set of FDs <span class="math inline">\(F\)</span> that hold on <span class="math inline">\(R\)</span>, but with test:</p>
<ul>
<li>For every set of attributes <span class="math inline">\(\alpha \subseteq R_{i}\)</span>, check that <span class="math inline">\(\alpha^{+}\)</span> either includes no attribute of <span class="math inline">\(R_i - \alpha\)</span> or includes all attributes of <span class="math inline">\(R_i\)</span>.</li>
</ul>
<p>If the condition is violated by some <span class="math inline">\(\alpha \to \beta\)</span> in <span class="math inline">\(F^{+}\)</span>, the dependency <span class="math inline">\(\alpha \to (\alpha^{+} - \alpha) \cap R_i\)</span> can be shown to hold on <span class="math inline">\(R_i\)</span> and <span class="math inline">\(R_i\)</span> violates BCNF.</p>
<p><strong>Algorithm 3</strong>. Decomposition algorithm for lossless schema in BCNF.</p>
<blockquote>
<ul>
<li><span class="math inline">\(F^{+}\)</span> is computed at first to determine whether or not <span class="math inline">\(\alpha\)</span> is the super key of sub-schema <span class="math inline">\(R_i\)</span>.</li>
<li>If other methods can be used to determine whether or not <span class="math inline">\(\alpha\)</span> is the super key of sub-schema <span class="math inline">\(R_i\)</span>, then <span class="math inline">\(F^{+}\)</span> need not be computed.</li>
</ul>
</blockquote>
<p>Given <span class="math inline">\(R\)</span>, <span class="math inline">\(F\)</span> holding on <span class="math inline">\(R\)</span>. We set <span class="math inline">\(res := \{R\}\)</span>. If there is a non-BCNF sub schema <span class="math inline">\(R_i\)</span> in <span class="math inline">\(res\)</span>, then let <span class="math inline">\(\alpha \to \beta\)</span> be a nontrivial FD that holds on <span class="math inline">\(R_i\)</span>, such that (1). <span class="math inline">\(\alpha\)</span> is not the super key for <span class="math inline">\(R_i\)</span>; (2). <span class="math inline">\(\alpha \cap \beta = \phi\)</span>. Then update <span class="math inline">\(res := \{(res - R_{i})\} \cup \{\{(R_i - \beta)\} \cup \{(\alpha, \beta)\}\}\)</span></p>
<blockquote>
<p><em>Note</em></p>
<ul>
<li><p>To determine whether or not <span class="math inline">\(R_i\)</span> is in BCNF, the restriction of <span class="math inline">\(F\)</span> to <span class="math inline">\(R_i\)</span> and the candidate keys of <span class="math inline">\(R_i\)</span> should be computed.</p></li>
<li><p><span class="math inline">\(R_i\)</span> is not in BCNF, because of <span class="math inline">\(\alpha \to \beta\)</span> on <span class="math inline">\(R_i\)</span>, <span class="math inline">\(\alpha\)</span> is not the super key of <span class="math inline">\(R_i\)</span>.</p></li>
<li><p>The algorithm replaces non-BCNF <span class="math inline">\(R_i\)</span> with <span class="math inline">\((R_i - \beta)\)</span> and <span class="math inline">\((\alpha, \beta)\)</span>.</p>
<ul>
<li><span class="math inline">\(R_i\)</span> is decomposed into <span class="math inline">\((R_i - \beta)\)</span> and BCNF <span class="math inline">\((\alpha, \beta)\)</span>.</li>
</ul></li>
<li><p>The restriction of <span class="math inline">\(F\)</span> to the schema <span class="math inline">\((\alpha, \beta)\)</span> is <span class="math inline">\(\alpha \to \beta\)</span>, and <span class="math inline">\(\alpha\)</span> is the super key for <span class="math inline">\((\alpha, \beta)\)</span>. so <span class="math inline">\((\alpha, \beta)\)</span> is in BCNF.</p></li>
</ul>
</blockquote>
<p>Here are three examples</p>
<p>(1). Consider <span class="math inline">\(R = (A, B, C)\)</span>, <span class="math inline">\(F = \{A \to B, B \to C\}\)</span>, Key $ = {A}$. <span class="math inline">\(R\)</span> is not in BCNF because <span class="math inline">\(B \to C\)</span> but <span class="math inline">\(B\)</span> is not super key, so we decompose it. <span class="math inline">\(R_1 = (B, C)\)</span>, <span class="math inline">\(F_1 = \{B \to C\}\)</span> and <span class="math inline">\(R_2 = (A, B)\)</span>, <span class="math inline">\(F_2 = \{A \to B\}\)</span>.</p>
<p>(2). Consider <em>class</em>(course_id, title, dept_name, credits, sec_id, semester, year, building, room_number, capacity, time_slot_id). FDs are</p>
<ul>
<li>course_id <span class="math inline">\(\to\)</span> title, dept_name, credits</li>
<li>building, room_number <span class="math inline">\(\to\)</span> capacity</li>
<li>course_id, sec_id, semester, year <span class="math inline">\(\to\)</span> building, room_number, time_slot_id</li>
</ul>
<p>A candidate key is {course_id, sec_id, semester, year}. Obviously, <em>class</em> is not BCNF. Firstly, focusing on course_id <span class="math inline">\(\to\)</span> title, dept_name, credits, we use <strong>algorithm 3</strong> to decompose <em>class</em> into <em>course</em>(course_id, title, dept_name, credits) and <em>class1</em>(course_id, sec_id, semester, year, building, room_number, capacity, time_slot_id). Then focusing on building, room_number <span class="math inline">\(\to\)</span> capacity, still using <strong>algorithm 3</strong>, we get final schemas: <em>classroom</em>(building, room_number, capacity) and <em>section</em>(course_id, sec_id, semester, year, building, room_number, time_slot_id).</p>
<p>(3). Consider <span class="math inline">\(R = (J, K, L)\)</span>, <span class="math inline">\(F = \{JK \to L, L \to K\}\)</span>, candidate keys are <span class="math inline">\(JK\)</span> and <span class="math inline">\(JL\)</span>. <span class="math inline">\(R\)</span> is not in BCNF because <span class="math inline">\(L \to K\)</span>. A BCNF decomposition is <span class="math inline">\(R_1 = (L, K)\)</span> with <span class="math inline">\(F_1 = \{L \to K\}\)</span> and <span class="math inline">\(R_2 = (J, L)\)</span> with no FD, <span class="math inline">\(JK \to L\)</span> being lost. Any decomposition of <span class="math inline">\(R\)</span> will fail to preserve <span class="math inline">\(JK \to L\)</span>. This implies that testing for <span class="math inline">\(JK \to L\)</span> requires a <strong>join</strong>.</p>
<h3 id="testing-for-3nf">Testing for 3NF</h3>
<blockquote>
<p>Why we decompose 3NF?</p>
<ul>
<li>There are some situations where
<ul>
<li>BCNF is not dependency preserving.</li>
<li>Whereas checking for FD violation is important.</li>
</ul></li>
<li>Solution: Define a weaker normal form, called the <strong>Third Normal Form</strong> (3NF)
<ul>
<li>Allows some redundancy (with resultant problems).</li>
<li>But check FDs on <strong>individual relations</strong> without computing a join.</li>
<li>There is a lossless-join, dependency-preserving decomposition into 3NF.</li>
</ul></li>
</ul>
</blockquote>
<p><strong>Algorithm 1</strong>. A decomposition algorithm that gives <strong>lossless</strong> and <strong>dependency preserving</strong> schema in 3NF.</p>
<blockquote>
<p><em>Note</em></p>
<ul>
<li>All candidate keys should be founded out.</li>
<li>Only one <span class="math inline">\(F_c\)</span> should be computed at first.</li>
</ul>
</blockquote>
<ol type="1">
<li><p>Find out all candidate keys for <span class="math inline">\(R\)</span>.</p></li>
<li><p>Find out a <strong>canonical over</strong> <span class="math inline">\(F_c\)</span> for F.</p></li>
<li><p>Do for each FD <span class="math inline">\(\alpha \to \beta\)</span> in <span class="math inline">\(F_c\)</span>. If none of the schema <span class="math inline">\(R_i\)</span>, <span class="math inline">\(1 \leq j \leq i\)</span> contains <span class="math inline">\(\alpha \beta\)</span>, then <span class="math inline">\(i := i + 1\)</span>, <span class="math inline">\(R_i := \alpha \beta\)</span>.</p></li>
<li><p>If none of the schemas <span class="math inline">\(R_j\)</span>, <span class="math inline">\(1 \leq j \leq i\)</span> contains a candidate key for <span class="math inline">\(R\)</span>, then <span class="math inline">\(i := i + 1\)</span>, <span class="math inline">\(R_{i} :=\)</span> any candidate key for <span class="math inline">\(R\)</span>.</p></li>
<li><p>Return <span class="math inline">\((R_1, R_2, \cdots, R_i)\)</span>.</p></li>
</ol>
<p>Here are two examples</p>
<p>(1). Consider schema <span class="math inline">\(R(X, Y, Z, W)\)</span> and <span class="math inline">\(F = \{X \to Z, Z \to X, Y \to XZ, W \to XZ\}\)</span> holds on <span class="math inline">\(R\)</span>. Give the lossless, dependency preserved decomposition into 3NF.</p>
<ol type="1">
<li><span class="math inline">\(\{YW\}\)</span> is the candidate key</li>
<li><span class="math inline">\(F_c = \{X \to Z, Z \to X, Y \to Z, W \to X\}\)</span> (not only)</li>
<li>On the basis of 3NF decomposition algorithm, the sub-schema responding to each functional dependency in <span class="math inline">\(F_c\)</span> are <span class="math inline">\(R_1 = (XZ)\)</span>, <span class="math inline">\(R_2 = (YZ)\)</span>, <span class="math inline">\(R_3 = (WX)\)</span></li>
<li><span class="math inline">\(R_4 = (YW)\)</span></li>
</ol>
<p>(2). Consider <span class="math inline">\(R\)</span> about <em>student</em> and FD <span class="math inline">\(F\)</span></p>
<ul>
<li><em>student</em>(stNo, Name, Telno, stID, ClassNo, CNo, CName, Grade)</li>
<li><span class="math inline">\(F =\)</span>
<ul>
<li>stNo <span class="math inline">\(\to\)</span> Name, Telno, stID, ClassNo</li>
<li>stID <span class="math inline">\(\to\)</span> stNo</li>
<li>stNo, CNo <span class="math inline">\(\to\)</span> Grade</li>
<li>CNo <span class="math inline">\(\to\)</span> CName</li>
</ul></li>
</ul>
<ol type="1">
<li>Candidate keys are {stNo, CNo}, {stID, CNo}</li>
<li><span class="math inline">\(F_c = F\)</span></li>
<li><span class="math inline">\(R_1\)</span>(stNo, Name, Telno, stID, ClassNo), <span class="math inline">\(R_2\)</span>(stID, CNo, Grade), <span class="math inline">\(R_3\)</span>(CNo, CName)</li>
<li>no operations</li>
</ol>
<h2 id="例题">例题</h2>
<p>(1). Consider the following relation schema <span class="math inline">\(R\)</span> and the functional dependency <span class="math inline">\(F\)</span> holds on <span class="math inline">\(R = (X, Y, Z, W, Q)\)</span>, <span class="math inline">\(F = \{XY \to ZQ, Q \to XY, Z \to W, Q \to Z\}\)</span>.</p>
<ol type="1">
<li><p>Compute <span class="math inline">\((XZ)^{+}\)</span>.</p>
<p><span class="math inline">\(XWZ\)</span></p></li>
<li><p>Is the decomposition <span class="math inline">\(\rhp = \{R_1(X, Y, Z), R_2(Z, W, Q)\}\)</span> on <span class="math inline">\(R\)</span> a lossless join? Why?</p>
<p>No. Because <span class="math inline">\(R_1 \cap R_2\)</span> can not infer both <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span>.</p></li>
<li></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" class="category-chain-item">数据库系统原理</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Chapter 7: Relational Database Design: Schema Normalization</div>
      <div>https://ddccffq.github.io/2025/12/20/数据库系统原理/Relational_Database_Design_Schema_Normalization/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ddccffq</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年12月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Database_Design_Using_the_ER_Model/" title="Chapter 6: Database Design Using the ER Model">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Chapter 6: Database Design Using the ER Model</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Advanced_SQL/" title="Chapter 5: Advanced SQL">
                        <span class="hidden-mobile">Chapter 5: Advanced SQL</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"ddccffq/ddccffq.github.io","repo-id":"R_kgDOPtFBqg","category":"Announcements","category-id":"DIC_kwDOPtFBqs4CvlN9","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"bottom","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <br> <span>&copy; 2025 <a href="https://github.com/ddccffq" target="_blank">ddccffq</a>. All Rights Reserved.</span> <br> <span style="font-size: 12px; color: #999;">用代码改变世界，以技术创造价值</span> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
