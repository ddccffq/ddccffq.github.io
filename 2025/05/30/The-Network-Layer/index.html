

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="任志诚 2023212020">
  <meta name="keywords" content="Computer Network,Network Layer">
  
    <meta name="description" content="Introduction网络层有如下功能：  将从 transport layer 传来的 segment 打包成 datagram，再将 datagram 中的 segment 分离开传给 transport layer。 网络层协议应用在 host 和 router 中。  Router 和 Switch 都属于 packet switch。 尽管路由器和链路层交换机都被称为packet sw">
<meta property="og:type" content="article">
<meta property="og:title" content="The Network Layer">
<meta property="og:url" content="https://ddccffq.github.io/2025/05/30/The-Network-Layer/index.html">
<meta property="og:site_name" content="ddccffq的技术博客">
<meta property="og:description" content="Introduction网络层有如下功能：  将从 transport layer 传来的 segment 打包成 datagram，再将 datagram 中的 segment 分离开传给 transport layer。 网络层协议应用在 host 和 router 中。  Router 和 Switch 都属于 packet switch。 尽管路由器和链路层交换机都被称为packet sw">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ddccffq.github.io/2025/05/30/The-Network-Layer/The-Network-Layer/IPv4%20datagram%20format.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/05/30/The-Network-Layer/The-Network-Layer/DHCP%20client-server%20interaction.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/05/30/The-Network-Layer/The-Network-Layer/Network%20address%20translation.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/05/30/The-Network-Layer/The-Network-Layer/Tunneling.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/05/30/The-Network-Layer/The-Network-Layer/AS%20structure.jpg">
<meta property="og:image" content="https://ddccffq.github.io/2025/05/30/The-Network-Layer/The-Network-Layer/Hierarchical%20OSPF.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/05/30/The-Network-Layer/The-Network-Layer/eBGP%20and%20iBGP%20sessions.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/05/30/The-Network-Layer/The-Network-Layer/Network%20address%20translation.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/05/30/The-Network-Layer/The-Network-Layer/P24.jpg">
<meta property="og:image" content="https://ddccffq.github.io/2025/05/30/The-Network-Layer/The-Network-Layer/P26.png">
<meta property="article:published_time" content="2025-05-30T13:43:21.000Z">
<meta property="article:modified_time" content="2025-06-17T04:48:23.000Z">
<meta property="article:author" content="ddccffq">
<meta property="article:tag" content="机器学习,计算机网络,算法,统计学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ddccffq.github.io/2025/05/30/The-Network-Layer/The-Network-Layer/IPv4%20datagram%20format.png">
  
  
  
  <title>The Network Layer - ddccffq的技术博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ddccffq.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ddccffq的技术博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Computer Networking, A Top-Down Approach, 5th Edition"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-30 21:43" pubdate>
          2025年5月30日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          39 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Computer Networking, A Top-Down Approach, 5th Edition</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>网络层有如下功能：</p>
<ul>
<li>将从 transport layer 传来的 <strong>segment</strong> 打包成 <strong>datagram</strong>，再将 <strong>datagram</strong> 中的 <strong>segment</strong> 分离开传给 transport layer。</li>
<li>网络层协议应用在 <strong>host</strong> 和 <strong>router</strong> 中。</li>
</ul>
<p><strong>Router</strong> 和 <strong>Switch</strong> 都属于 <strong>packet switch</strong>。</p>
<p>尽管路由器和链路层交换机都被称为<strong>packet switches</strong>（分组交换机），但它们有以下根本区别：</p>
<ol>
<li><p><strong>工作层次不同</strong>：</p>
<ul>
<li>路由器（Router）：工作在<strong>网络层</strong>（第3层）</li>
<li>链路层交换机：工作在<strong>链路层</strong>（第2层）</li>
</ul>
</li>
<li><p><strong>转发决策依据</strong>：</p>
<ul>
<li>路由器：基于<strong>IP地址</strong>（网络层地址）做出转发决策</li>
<li>链路层交换机：基于<strong>MAC地址</strong>（物理地址）做出转发决策</li>
</ul>
</li>
<li><p><strong>功能范围</strong>：</p>
<ul>
<li>路由器：能够连接<strong>不同网络</strong>，执行<strong>路由决策</strong>和<strong>网络互联</strong></li>
<li>链路层交换机：主要在<strong>同一网络内</strong>转发帧</li>
</ul>
</li>
<li><p><strong>网络视角</strong>：</p>
<ul>
<li>路由器：能看到网络的<strong>拓扑结构</strong>，具有全局视野</li>
<li>链路层交换机：仅限于<strong>局部链路</strong>的连接情况</li>
</ul>
</li>
</ol>
<p>路由器拥有的IP地址数量<strong>通常等于其活跃网络接口的数量</strong>。这是因为：</p>
<ul>
<li>路由器的<strong>每个接口</strong>都需要一个IP地址来参与其所连接网络的通信</li>
<li>不同接口连接到不同的网络，因此需要不同的IP地址</li>
</ul>
<h2 id="Forwarding-and-Routing"><a href="#Forwarding-and-Routing" class="headerlink" title="Forwarding and Routing"></a>Forwarding and Routing</h2><p>这两个功能十分好理解：</p>
<ul>
<li><strong>Forwarding：</strong> 一个 router 中，决定如何移动 datagram 到正确的输出。</li>
<li><strong>Routing：</strong> 决定 datagram 在整个网络中的传输路线。</li>
</ul>
<h2 id="Network-Service-Model"><a href="#Network-Service-Model" class="headerlink" title="Network Service Model"></a>Network Service Model</h2><p>需要保证，对 <strong>individual datagram</strong>：正确传输和传输时间；对 <strong>a flow of datagrams</strong>： 顺序接受，完整传输和传输最小带宽。</p>
<h1 id="Virtual-Circuit-and-Datagram-Networks"><a href="#Virtual-Circuit-and-Datagram-Networks" class="headerlink" title="Virtual Circuit and Datagram Networks"></a>Virtual Circuit and Datagram Networks</h1><p>网络层有两种服务：<strong>connectionless service</strong> 和 <strong>connection service</strong>；这两种服务分别应用在 <strong>datagram network</strong> 和 <strong>virtual circuit network</strong>。</p>
<h2 id="Datagram-Network"><a href="#Datagram-Network" class="headerlink" title="Datagram Network"></a>Datagram Network</h2><p>数据包网络使用的是<strong>动态路由</strong>，每一个数据包可以根据当前的网络状况独立地选择路径。</p>
<h3 id="Forwarding-Table"><a href="#Forwarding-Table" class="headerlink" title="Forwarding Table"></a>Forwarding Table</h3><p><strong>Forwarding table</strong> 应用在 <strong>router</strong> 中，决定如何移动 datagram 到正确的输出。</p>
<p>具体形式如下表格所示，可以看到就是一个简单的地址到接口的映射</p>
<div style="display: block; margin: 0 auto; width: fit-content;">

| **Destination Address Range**        | **Link Interface**     |
|:------------------------------------:|:----------------------:|
| $\sim$                               | $0$                    |
| $\sim$                               | $1$                    |
| otherwise                            | $2$                    |

</div>

<p><strong>需要注意的是</strong>：表格中的 <strong>Destination Address Range</strong> 可以不是完整的 IP address，而是其的一个前缀；比如 <strong>00111000</strong>，对应的地址范围是 <strong>00111000 00000000 00000000 00000000</strong> 到 <strong>00111000 11111111 11111111 11111111 11111111</strong>。这时 forwarding table 变成：</p>
<div style="display: block; margin: 0 auto; width: fit-content;">

| **Header**        | **Link Interface**     |
|:------------------------------------:|:----------------------:|
| $\sim$                               | $0$                    |
| $\sim$                               | $1$                    |
| otherwise                            | $2$                    |

</div>

<h1 id="What’s-inside-a-Router"><a href="#What’s-inside-a-Router" class="headerlink" title="What’s inside a Router"></a>What’s inside a Router</h1><p>有两个重要的路由功能：</p>
<ul>
<li>运行路由算法。</li>
<li>推送 datagram。</li>
</ul>
<h2 id="Input-Port"><a href="#Input-Port" class="headerlink" title="Input Port"></a>Input Port</h2><div align="center">

<pre><code class=" mermaid">flowchart LR
    A[Line Termination &lt;br&gt; bit-level reception] --&gt; B[Data Link Processing]
    B --&gt; C[Look up and Forwarding &lt;br&gt; Queueing]
    C --&gt; D[Switch Fabric]
</code></pre>

</div>

<p>这里涉及到的 <strong>look up and forwarding</strong> 的方式是 <strong>decentralized switching</strong>，也就是 <strong>forwarding table</strong> 已经存入到了 input port 的 <strong>memory</strong> 中。</p>
<h2 id="Switching-Fabric"><a href="#Switching-Fabric" class="headerlink" title="Switching Fabric"></a>Switching Fabric</h2><p>有三种 <strong>switching fabrics</strong>。</p>
<h3 id="Switching-via-Memory"><a href="#Switching-via-Memory" class="headerlink" title="Switching via Memory"></a>Switching via Memory</h3><p>这时可以把路由器看作是一个 <strong>computer</strong>。使用电脑的 <strong>CPU</strong> 来 switching。</p>
<p>这个流程是，先把 datagram 拷贝到电脑 <strong>memory</strong> 中，在从 memory 传到相应的 output port。</p>
<p>可以分析的是：<strong>memory bandwidth</strong> 是限制 <strong>switching rate</strong> 的主要因素。同时需要注意的是，每个 datagram 会经过两次 <strong>system bus</strong>。</p>
<h3 id="Switching-via-Bus"><a href="#Switching-via-Bus" class="headerlink" title="Switching via Bus"></a>Switching via Bus</h3><p>其中只用到一个 bus。bus bandwidth 限制了 <strong>switching speed</strong>。</p>
<h3 id="Switching-via-Interconnection-Network"><a href="#Switching-via-Interconnection-Network" class="headerlink" title="Switching via Interconnection Network"></a>Switching via Interconnection Network</h3><p>网状结构。先 <strong>fragmenting datagram</strong> into fixed length cells，再 switch cells through the fabric。</p>
<h2 id="Output-Port"><a href="#Output-Port" class="headerlink" title="Output Port"></a>Output Port</h2><div align="center">

<pre><code class=" mermaid">flowchart LR
    A[Switch Fabric] --&gt; B[Queueing: Buffer Management]
    B --&gt; C[Data Link Processing]
    C --&gt; D[Line Termination]
</code></pre>

</div>

<h3 id="Output-Port-Queueing"><a href="#Output-Port-Queueing" class="headerlink" title="Output Port Queueing"></a>Output Port Queueing</h3><p>Buffering when arrival rate via switch <strong>exceeds</strong> output line speed. Queueing (<strong>delay</strong>) and loss due to output port buffer overflows.</p>
<p>所以，需要多大的 buffer？假设 <strong>typical $\text{RTT}$</strong>（一般是 $250$ ms），link capacity $C$，有 $N$ 个 datagram flow。则：</p>
<script type="math/tex; mode=display">
\text{buffering} = \frac{\text{RTT} \cdot C}{\sqrt{N}}</script><h3 id="Input-Port-Queueing"><a href="#Input-Port-Queueing" class="headerlink" title="Input Port Queueing"></a>Input Port Queueing</h3><p>同样，输入端也会堵塞。应用了名叫 <strong>Head-of-the-Line (HOL) blocking</strong> 的机制，这个机制很好理解：就是排在前面的 datagram 传输了，其后面的 datagram 才能传输。</p>
<h1 id="Internet-Protocol"><a href="#Internet-Protocol" class="headerlink" title="Internet Protocol"></a>Internet Protocol</h1><p>这个协议干了三件事：<strong>addressing conventions</strong>（地址约定），<strong>datagram format</strong>，<strong>packet handling conventions</strong>（分组处理约定）。</p>
<h2 id="IP-Datagram-Format"><a href="#IP-Datagram-Format" class="headerlink" title="IP Datagram Format"></a>IP Datagram Format</h2><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><p><img src="The-Network-Layer/IPv4 datagram format.png" srcset="/img/loading.gif" lazyload alt="IPv4 datagram format">{style=”display: block; margin: 0 auto; width: 60%”}</p>
<p><strong>总结表格：</strong></p>
<div style="display: block; margin: 0 auto; width: fit-content;">

| 字段名                    | 长度      | 作用/说明                         |
|--------------------------|-----------|-----------------------------------|
| Version                  | 4 位     | IP 协议版本号                     |
| Header Length            | 4 位     | 首部长度（单位：$4$ 字节，最少 $5$ ）|
| Type of Service          | 8 位     | 服务类型/QoS                      |
| Datagram Length          | 16 位    | 数据报总长度（单位：$1$ 字节）      |
| Identifier               | 16 位    | 分片标识符                        |
| **Flags**                | 3 位     | 分片控制标志                      |
| **Fragmentation Offset** | 13 位    | 分片偏移量（单位：$8$ 字节）       |
| Time-to-Live (TTL)       | 8 位     | 生存时间/最大跳数                 |
| Upper-layer Protocol     | 8 位     | 上层协议类型                      |
| Header Checksum          | 16 位    | 首部校验和                        |
| Source IP Address        | 32 位    | 源 IP 地址                        |
| Destination IP Address   | 32 位    | 目的 IP 地址                      |
| Options                  | 可变     | 可选字段                          |
| Data                     | 可变     | 负载数据                          |

</div>

<p><strong>补充</strong>：</p>
<ul>
<li><strong>Flags</strong> 有 $3$ 位，第一位恒为 $0$，第二位表示 <strong>Don’t fragment</strong>（不可分片），第三位表示 <strong>More fragments</strong>（后续有分片）。为 $1$ 的时候相应功能开启。</li>
</ul>
<h3 id="IP-Fragmentation-and-Reassembly"><a href="#IP-Fragmentation-and-Reassembly" class="headerlink" title="IP Fragmentation and Reassembly"></a>IP Fragmentation and Reassembly</h3><p>从 IPv4 的 datagram format 中可以发现，必要时会对 datagram 切片。</p>
<p><strong>MTU</strong>：max transfer size。这是对 <strong>link</strong> 而言，也就是说不同的 <strong>link</strong> 有不同的 <strong>MTU</strong>。</p>
<p><strong>Fragmentation and Reassembly</strong> 的过程很简单，就是需要时切分 datagram，最后在最终目的主机的网络层进行：只有当所有分片都到达后，网络层才会将完整的数据报交给上层（如传输层）。</p>
<p>假设原 IP datagram 总长度为 $L$，待转发链路的 MTU 为 $M$，若 $L &gt; M$ 且 DF 为 $0$，则需要分片。</p>
<ul>
<li>先复制 <strong>Identifier</strong>。</li>
<li>一个切片可封装的数据为：<script type="math/tex">d = \left \lfloor \frac{M - 20}{8} \right \rfloor \times 8</script></li>
<li>需要的总片数为：<script type="math/tex">n = \left \lceil \frac{L - 20}{d} \right \rceil</script></li>
</ul>
<h2 id="IPv4-Addressing"><a href="#IPv4-Addressing" class="headerlink" title="IPv4 Addressing"></a>IPv4 Addressing</h2><h3 id="Subnet"><a href="#Subnet" class="headerlink" title="Subnet"></a>Subnet</h3><p><strong>IP address</strong>: subnet part (high order bits) $+$ host part (low order bits).</p>
<p>在一个 subnet 中的所有设备都可以直接<strong>物理意义上</strong>地连接。</p>
<p><strong>Subnet mask</strong>：用类似 <code>/24</code> 的形式表示。也就是说，前 $24$ 相同的 IP address 在同一个 subnet 中。</p>
<h4 id="Classes-Inter-Domain-Routing-CIDR"><a href="#Classes-Inter-Domain-Routing-CIDR" class="headerlink" title="Classes Inter Domain Routing: CIDR"></a>Classes Inter Domain Routing: CIDR</h4><p>规定了 address format 为 <code>a.b.c.d/x</code>。</p>
<h4 id="Dynamic-Host-Configuration-Protocol-DHCP"><a href="#Dynamic-Host-Configuration-Protocol-DHCP" class="headerlink" title="Dynamic Host Configuration Protocol: DHCP"></a>Dynamic Host Configuration Protocol: DHCP</h4><p><strong>Goal</strong>: allow host to dynamically get his IP address from a server when it joins network.</p>
<ul>
<li>Can renew its lease on address in use.</li>
<li>Allows reuse of address.</li>
<li>Support for mobile users who want to join network.</li>
</ul>
<p><strong>DHCP</strong>（Dynamic Host Configuration Protocol，动态主机配置协议）是一个<strong>网络管理协议</strong>，用于在IP网络中<strong>自动分配IP地址和其他网络配置参数</strong>给网络设备。DHCP运行在<strong>应用层</strong>，使用<strong>UDP协议</strong>，客户端使用<strong>端口68</strong>，服务器使用<strong>端口67</strong>。</p>
<p><img src="The-Network-Layer/DHCP client-server interaction.png" srcset="/img/loading.gif" lazyload alt="DHCP client-server interaction">{style=”display: block; margin: 0 auto; width: 50%”}</p>
<div style="display: block; margin: 0 auto; width: fit-content">

| 步骤 | 消息类型 | 发送者 | 接收者 | 主要内容 |
|------|----------|--------|--------|----------|
| 1 | DISCOVER | 客户端 | 广播 | "我需要一个IP地址" |
| 2 | OFFER | 服务器 | 客户端 | "你可以使用这个IP" |
| 3 | REQUEST | 客户端 | 广播 | "我想使用这个IP" |
| 4 | ACK | 服务器 | 客户端 | "IP已分配，租期为X" |

</div>

<p><strong>yiaddr</strong>（your IP address）是DHCP协议中表示<strong>服务器提供给客户端的IP地址</strong>的字段。</p>
<p><strong>补充</strong>：DHCP 还可以 return <strong>address of first-hop router for client</strong>，<strong>name and IP address of DNS server</strong>，<strong>network mask</strong>。</p>
<h3 id="Network-Address-Translation-NAT"><a href="#Network-Address-Translation-NAT" class="headerlink" title="Network Address Translation: NAT"></a>Network Address Translation: NAT</h3><p><img src="The-Network-Layer/Network address translation.png" srcset="/img/loading.gif" lazyload alt="Network address translation">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p>右边：局域网内通信，使用内部地址：<code>10.0.0/24</code>；左边：局域网外通信，共用唯一地址。注意，没有共用同一个端口号，因为端口号是用来区分的。比如：</p>
  <div style="display: block; margin: 0 auto; width: fit-content">

  | WAN 侧 (对外显示) | LAN 侧 (实际主机) |
  |:---------------:|:----------------:|
  | 203.0.113.5:50001 | 192.168.1.10:3345 |
  | 203.0.113.5:50002 | 192.168.1.10:3346 |
  | 203.0.113.5:50003 | 192.168.1.11:3345 |

  </div>

<p>这样布置有一个比较好的优势：可以更换 ISP 的同时不改变局域网内的地址。</p>
<p>注意到中间的 <strong>NAT router</strong>。它的功能如下：</p>
<ul>
<li>对 <strong>outgoing datagrams</strong>，把原始 IP address 和 port 更换为自己的 IP address 和 port。</li>
<li>再把上述转换记下来记为 <strong>NAT translation table</strong>。</li>
<li>对 <strong>incoming datagrams</strong>，更换。</li>
</ul>
<p>现在回顾 NAT，不难察觉几个问题：</p>
<ul>
<li>如果 LAN 中的 host 想要通过 P2P 进行 communication，此时该怎么办？</li>
<li>如果一个服务器是 NAT 的 LAN 地址，怎么办？</li>
</ul>
<h2 id="Internet-Control-Message-Protocol-ICMP"><a href="#Internet-Control-Message-Protocol-ICMP" class="headerlink" title="Internet Control Message Protocol: ICMP"></a>Internet Control Message Protocol: ICMP</h2><p>这个协议 used by hosts and routers to communicate network-level information。具体包括：</p>
<ul>
<li>Error reporting.</li>
<li>Echo request and reply.</li>
</ul>
<p><strong>ICMP message</strong> 的结构包括：<strong>type</strong>、<strong>code</strong>、<strong>checksum</strong> 以及数据部分。</p>
<p>具体用来干什么？</p>
<ul>
<li>通过发送 UDP segment，在 IP datagram header 内设置适当的 TTL，来计算 $\text{RTT}$。</li>
<li>还可以用来停止 source 持续发送 UDP segment。</li>
</ul>
<div style="display: block; margin: 0 auto; width: fit-content">

| 字段名 | 长度 | 作用/说明 |
|-------|------|----------|
| **Type** | 8位 | 消息类型（如0=回显回复，3=目的不可达，8=回显请求） |
| **Code** | 8位 | 消息子类型（进一步说明类型） |
| **Checksum** | 16位 | 校验和（覆盖整个ICMP消息） |
| **Rest of Header** | 32位 | 取决于Type和Code的其他信息 |
| **Data** | 可变 | 负载数据（例如原始数据包的片段） |

</div>

<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>为了解决 IPv4 地址不足。具体 format 不讲，但要注意 header 大小为 $40$ bytes，只有 address 大小变为 $128$ bits。</p>
<h3 id="Transition-from-IPv4-to-IPv6"><a href="#Transition-from-IPv4-to-IPv6" class="headerlink" title="Transition from IPv4 to IPv6"></a>Transition from IPv4 to IPv6</h3><p><img src="The-Network-Layer/Tunneling.png" srcset="/img/loading.gif" lazyload alt="Tunneling">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>Tunneling</strong>: IPv6 carried as payload in IPv4 datagram among Ipv4 routers.</p>
<h1 id="Routing-Algorithms"><a href="#Routing-Algorithms" class="headerlink" title="Routing Algorithms"></a>Routing Algorithms</h1><h2 id="Software-Defined-Networking-SDN"><a href="#Software-Defined-Networking-SDN" class="headerlink" title="Software-Defined Networking: SDN"></a>Software-Defined Networking: SDN</h2><p>实际上，network layer 可以分为 <strong>data plane</strong> 和 <strong>control plane</strong>，在 <strong>control plane</strong> 有一个 logically centralized routing controller，由它 compute paths。</p>
<h2 id="Link-State-Algorithm"><a href="#Link-State-Algorithm" class="headerlink" title="Link State Algorithm"></a>Link State Algorithm</h2><h3 id="Dijkstra’s-Link-State-Algorithm"><a href="#Dijkstra’s-Link-State-Algorithm" class="headerlink" title="Dijkstra’s Link-State Algorithm"></a>Dijkstra’s Link-State Algorithm</h3><p>伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">N = &#123;u&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : nodes) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isAdjacent</span>(u, a)) &#123;<br>      D[a] = <span class="hljs-built_in">Cost</span>(u, a);<br>      P[a] = u;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      D[a] = INF;<br>      P[a] = a;<br>      &#125;<br>&#125;<br><span class="hljs-keyword">while</span> (! all nodes in N) &#123;<br>    D[a] = <span class="hljs-built_in">min</span>(D)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> b : nodes) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isAdjacent</span>(b ,a)) &#123;<br>          D[b] = <span class="hljs-built_in">min</span>(D[b], <span class="hljs-built_in">Cost</span>(b, a) + D[a])<br>          <span class="hljs-keyword">if</span> (D[b] == <span class="hljs-built_in">Cost</span>(b, a) + D[a]) P[b] = a;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实际做题的时候可以参考书上的风格：</p>
<p>记 $N’$ 为<strong>已找到最短路径</strong>的点集合，函数 $D(x)$ 为到点 $x$ 的最短路径，函数 $P(x)$ 为点 $x$ 的父母结点。可以规范化求解过程如下，其中 $0$ 轮初始化。</p>
<div style="display: block; margin: 0 auto; width: fit-content;">

| **Step**        | **$N'$**     |**$D()\,P()$**|**$D()\,P()$**| **$\cdots$** |**$D()\,P()$**|
|:---------------:|:------------:|:------------:|:------------:|:------------:|:------------:|
| $0$             | $u$          |  dis  node   |  dis  node   |  dis  node   |  dis  node   |
| $1$             | $uv$         |  dis  node   |  dis  node   |  dis  node   |  dis  node   |
| $2$             | $uvw$        |  dis  node   |  dis  node   |  dis  node   |  dis  node   |
| $\cdots$        | $\cdots$     |  dis  node   |  dis  node   |  dis  node   |  dis  node   |
| $N$             |$uvw \cdots l$|  dis  node   |  dis  node   |  dis  node   |  dis  node   |

</div>

<p>这样可以求出从起点到图中其它点的所有最短路径。可以用来制作 forwarding table。</p>
<p>可以用<strong>优先队列</strong>优化时间复杂度。</p>
<p>这里需要提到一个概念 <strong>Oscillation possible</strong>，指的是网络路由状态可能出现反复波动、难以稳定的现象，是网络设计和协议实现中需要重点关注和避免的问题。这可能会导致在 Link State Algorithm 中计算到无穷的结果。</p>
<h2 id="Distance-Vector-Algorithm"><a href="#Distance-Vector-Algorithm" class="headerlink" title="Distance Vector Algorithm"></a>Distance Vector Algorithm</h2><p><strong>Distributed Bellman-Ford equation</strong>: <script type="math/tex">D(x \to y) = \min_{v} \{\text{Cost}_{x \to v} + D(v \to y), \, D(x \to y)\}</script></p>
<p>其中，$v$ 是 $x$ 的邻居。</p>
<p>这是一个 <strong>iterative</strong> 算法，需要多次计算，直到收敛。计算过程可以参考课本，如下表所述，结点 $z$ 的 table。</p>
<div style="display: block; margin: 0 auto; width: fit-content">

|   $z$  | cost to|        |        |        |        |
|:------:|:------:|:------:|:------:|:------:|:------:|
|        | $x$      | $y$      | $z$      | $u$      | $v$      |
| from $x$ | $2$      | $3$      | $\infty$ | $\infty$ | $3$      |
| from $y$ | $3$      | $\infty$ | $\infty$ | $2$      | $\infty$ |
| from $z$ | $2$      | $5$      | $0$      | $7$      | $5$      |
| from $u$ | $\infty$ | $2$      | $\infty$ | $\infty$ | $2$      |
| from $v$ | $3$      | $\infty$ | $6$      | $1$      | $\infty$ |

</div>

<h1 id="Hierarchical-Routing"><a href="#Hierarchical-Routing" class="headerlink" title="Hierarchical Routing"></a>Hierarchical Routing</h1><p><strong>Internet approach to scalable routing</strong>: aggregate routers into regions known as <strong>autonomous system (AS)</strong></p>
<p><img src="The-Network-Layer/AS structure.jpg" srcset="/img/loading.gif" lazyload alt="AS structure">{style=”display: block; margin: 0 auto; width: 100%”}</p>
<h2 id="Intra-AS-Routing-Protocol"><a href="#Intra-AS-Routing-Protocol" class="headerlink" title="Intra-AS Routing Protocol"></a>Intra-AS Routing Protocol</h2><ol>
<li>RIP: Routing Information Protocol (wasted).</li>
<li>OSPF: Open Shortest Path First (Link-State).</li>
<li>EIGRP: Enhanced Interior Gateway Routing Protocol.</li>
</ol>
<h3 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF: Open Shortest Path First"></a>OSPF: Open Shortest Path First</h3><p>classic link-state:</p>
<ol>
<li>Each router floods <strong>OSPF</strong> link-state advertisements (over IP) to all routers.</li>
<li>Multiple link costs metrics possible: bandwidth, delay.</li>
<li>Each router has full topology, Dijkstra algorithm.</li>
</ol>
<p>Security: all OSPF messages authenticated</p>
<p><img src="The-Network-Layer/Hierarchical OSPF.png" srcset="/img/loading.gif" lazyload alt="Hierarchical OSPF">{style=”display: block; margin: 0 auto; width: 80%”}</p>
<h2 id="Inter-AS-Protocol"><a href="#Inter-AS-Protocol" class="headerlink" title="Inter-AS Protocol"></a>Inter-AS Protocol</h2><h3 id="BGP-Border-Gateway-Protocol"><a href="#BGP-Border-Gateway-Protocol" class="headerlink" title="BGP: Border Gateway Protocol"></a>BGP: Border Gateway Protocol</h3><p>BGP provides each AS a means to:</p>
<ul>
<li>obtain destination network reachability information form neighboring ASes eBGP.</li>
<li>determine routers to other networks based on reachability information and policy.</li>
<li>propagate reachability information to all AS-internal routers: iBGP.</li>
<li>advertise (to neighboring networks) destination reachability information.</li>
</ul>
<p><img src="The-Network-Layer/eBGP and iBGP sessions.png" srcset="/img/loading.gif" lazyload alt="eBGP and iBGP sessions">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<ul>
<li>BGP对等体（BGP peers）通过<strong>半永久TCP连接</strong>（BGP会话）交换路由信息。</li>
<li>BGP会话不一定对应物理链路。</li>
<li>当AS2向AS1通告前缀时：<ul>
<li>AS2 <strong>承诺</strong>会为该前缀转发数据报。</li>
<li>AS2可以在通告中聚合前缀。</li>
</ul>
</li>
<li>通过eBGP会话，AS3将前缀可达性信息发送给AS1。</li>
<li>AS1内部的路由器（如1c）通过iBGP将新前缀信息分发给AS1内所有路由器。</li>
<li>AS1的1b路由器可以通过eBGP会话将新前缀信息再通告给AS2。</li>
<li>路由器学到新前缀后，会在转发表中为该前缀创建条目。</li>
<li>BGP通告的前缀包含<strong>BGP属性</strong>，前缀+属性即为<strong>路由</strong>。</li>
<li>两个重要属性：<ul>
<li><strong>AS-PATH</strong>：记录前缀通告经过的AS序列（如AS 67, AS 17）。</li>
<li><strong>NEXT-HOP</strong>：指明到下一个AS的具体内部路由器（可能有多条链路）。</li>
</ul>
</li>
<li>当网关路由器收到路由通告时，会根据<strong>import policy</strong>（导入策略）决定是否接受该路由。</li>
</ul>
<p>假设有以下网络拓扑结构：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">        +------+<br>        | AS65 |<br>        +------+<br>       /        \<br>      /          \<br>+------+        +------+<br>| AS23 |--------| AS17 |<br>+------+        +------+<br>   |                |<br>+------+        +------+<br>| AS45 |        | AS78 |<br>+------+        +------+<br>                 /<br>             +------+<br>             | AS99 |---前缀：192.168.99.0/24<br>             +------+<br></code></pre></td></tr></table></figure>

</div>

<p>AS-PATH传播过程</p>
<p>假设AS99宣告前缀192.168.99.0/24，我们跟踪这个前缀在网络中的传播：</p>
<ol>
<li><p><strong>AS99向AS78通告前缀</strong>：</p>
<ul>
<li>AS99向AS78发送BGP更新：<code>192.168.99.0/24, AS-PATH=&#123;99&#125;</code></li>
<li>AS78收到前缀后，将其存入路由表</li>
</ul>
</li>
<li><p><strong>AS78向AS17通告前缀</strong>：</p>
<ul>
<li>AS78在转发前，将自己的AS号添加到AS-PATH</li>
<li>AS78发送BGP更新：<code>192.168.99.0/24, AS-PATH=&#123;78, 99&#125;</code></li>
</ul>
</li>
<li><p><strong>AS17向多个AS传播</strong>：</p>
<ul>
<li>AS17向AS23发送：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li>
<li>AS17向AS65发送：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li>
</ul>
</li>
<li><p><strong>AS23收到两种路径</strong>：</p>
<ul>
<li>从AS17：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li>
<li>从AS45（假设AS45也与AS99间接相连）：<code>192.168.99.0/24, AS-PATH=&#123;45, ..., 99&#125;</code></li>
<li>AS23基于AS-PATH长度和其他策略选择最佳路径</li>
</ul>
</li>
<li><p><strong>AS65收到更新后</strong>：</p>
<ul>
<li>获得路由：<code>192.168.99.0/24, AS-PATH=&#123;65, 17, 78, 99&#125;</code></li>
<li>若之后收到AS23的路由通告，也会比较两条路径</li>
</ul>
</li>
</ol>
<h1 id="Subnet、Prefix和BGP-Route的对比分析"><a href="#Subnet、Prefix和BGP-Route的对比分析" class="headerlink" title="Subnet、Prefix和BGP Route的对比分析"></a>Subnet、Prefix和BGP Route的对比分析</h1><h2 id="Subnet（子网）"><a href="#Subnet（子网）" class="headerlink" title="Subnet（子网）"></a>Subnet（子网）</h2><p><strong>子网</strong>是指<strong>物理网络的逻辑划分</strong>，具有以下特征：</p>
<ul>
<li>由<strong>共享相同网络前缀</strong>的IP地址集合组成</li>
<li>通过<strong>网络地址</strong>和<strong>子网掩码</strong>定义（如192.168.1.0/24）</li>
<li>子网内设备可<strong>直接通信</strong>，无需路由器转发</li>
<li>代表<strong>单一广播域</strong>内的网络段</li>
<li>通常属于<strong>单一管理实体</strong></li>
</ul>
<h2 id="Prefix（前缀）"><a href="#Prefix（前缀）" class="headerlink" title="Prefix（前缀）"></a>Prefix（前缀）</h2><p><strong>前缀</strong>是<strong>IP地址空间中的地址块</strong>，具有以下特征：</p>
<ul>
<li>用<strong>CIDR表示法</strong>表示（如10.0.0.0/8）</li>
<li>表示IP地址中固定的<strong>网络部分位数</strong></li>
<li>是<strong>路由表聚合</strong>的基础单位</li>
<li>可以表示<strong>不同大小</strong>的地址块</li>
<li>是<strong>地址分配和路由通告</strong>的基本单位</li>
</ul>
<h2 id="BGP-Route（BGP路由）"><a href="#BGP-Route（BGP路由）" class="headerlink" title="BGP Route（BGP路由）"></a>BGP Route（BGP路由）</h2><p><strong>BGP路由</strong>是<strong>互联网核心路由系统</strong>中的路由条目：</p>
<ul>
<li>包含<strong>目的地前缀</strong>和<strong>完整路径属性</strong></li>
<li>核心属性包括<strong>AS_PATH</strong>（自治系统路径）、<strong>NEXT_HOP</strong>等</li>
<li>反映了<strong>网络政策</strong>和<strong>商业关系</strong></li>
<li>用于<strong>自治系统间</strong>的路由决策</li>
<li>通过BGP协议在全球互联网中<strong>传播和交换</strong></li>
</ul>
<p>NEXT-HOP属性在BGP中用于<strong>指明到达目标网络的下一跳路由器IP地址</strong>，具体使用方式如下：</p>
<ol>
<li><p><strong>路由转发决策</strong></p>
<ul>
<li>当路由器接收到目标数据包时，通过查询BGP表中的NEXT-HOP属性确定<strong>实际转发目标</strong></li>
<li>路由器必须能够通过IGP协议(如OSPF)到达NEXT-HOP地址</li>
</ul>
</li>
<li><p><strong>BGP会话中的传递规则</strong></p>
<ul>
<li><strong>eBGP传递</strong>：设置为发送更新的BGP对等体的IP地址</li>
<li><strong>iBGP传递</strong>：保持NEXT-HOP值不变（除非明确配置修改）</li>
<li><strong>多出口AS</strong>：帮助选择最佳出口点</li>
</ul>
</li>
<li><p><strong>策略实现</strong></p>
<ul>
<li>通过修改NEXT-HOP实现<strong>流量工程</strong></li>
<li>支持热备份和负载均衡策略</li>
<li>可设置为特定接口地址或第三方路由器地址</li>
</ul>
</li>
</ol>
<p>AS-PATH属性记录了<strong>路由通告经过的AS序列</strong>，在BGP中具有多重重要功能：</p>
<ol>
<li><p><strong>路由选择依据</strong></p>
<ul>
<li>作为BGP决策过程中的<strong>关键指标</strong>之一</li>
<li><strong>AS-PATH越短</strong>的路径通常被优先选择</li>
<li>影响决策优先级：Local Preference &gt; AS-PATH长度 &gt; Origin &gt; MED等</li>
</ul>
</li>
<li><p><strong>环路检测机制</strong></p>
<ul>
<li>当路由器在AS-PATH中发现<strong>自己的AS号</strong>时，自动拒绝该路由</li>
<li>避免路由环路产生，确保BGP路由收敛性</li>
<li>例如：AS17收到路径”AS23, AS45, AS17, AS78”会直接丢弃</li>
</ul>
</li>
<li><p><strong>路径操纵技术</strong></p>
<ul>
<li>通过<strong>AS-PATH预置</strong>(prepending)增加路径长度</li>
<li>例如：”AS78, AS78, AS78, AS99”使路径看起来更长</li>
<li>降低特定路径被选择的可能性，实现出站流量控制</li>
</ul>
</li>
<li><p><strong>路由过滤依据</strong></p>
<ul>
<li>基于AS-PATH中的特定AS创建<strong>过滤策略</strong></li>
<li>可拒绝包含竞争对手或不信任AS的路由</li>
<li>实现复杂的路由策略控制和商业关系维护</li>
</ul>
</li>
</ol>
<h2 id="三者关系对比"><a href="#三者关系对比" class="headerlink" title="三者关系对比"></a>三者关系对比</h2><div style="display: block; margin: 0 auto; width: fit-content">

| 特性 | Subnet | Prefix | BGP Route |
|------|--------|--------|-----------|
| **范围** | 局部网段 | 地址块 | 全球路由 |
| **用途** | 网络分段 | 地址分配与聚合 | 域间路由决策 |
| **包含信息** | 网络地址+掩码 | 地址块+长度 | 前缀+路径属性 |
| **管理层次** | 单一管理域内 | 可跨域使用 | 多AS协作 |
| **通告机制** | 不直接通告 | 内部路由协议 | BGP协议 |
| **聚合能力** | 固定大小 | 可变大小 | 可聚合或特定 |

</div>

<h2 id="层次关系"><a href="#层次关系" class="headerlink" title="层次关系"></a>层次关系</h2><p>这三个概念形成了一个层次结构：</p>
<ul>
<li><strong>Subnet</strong>：最基础，表示<strong>实际网络分段</strong></li>
<li><strong>Prefix</strong>：中间层，表示<strong>可路由的地址块</strong></li>
<li><strong>BGP Route</strong>：最高层，表示<strong>如何到达特定前缀的完整路径信息</strong></li>
</ul>
<p>一个BGP路由可以指向一个前缀，而一个前缀可以包含多个子网。</p>
<h1 id="End-of-chapter-exercises"><a href="#End-of-chapter-exercises" class="headerlink" title="End-of-chapter exercises"></a>End-of-chapter exercises</h1><h2 id="P-6"><a href="#P-6" class="headerlink" title="P.6"></a>P.6</h2><p><strong>Questions:</strong></p>
<p>In the text we have used the term connection-oriented service to describe a transport-layer service and connection service for a network-layer service. Why the subtle shades in terminology?</p>
<p><strong>Answer:</strong></p>
<p>The subtle difference in terminology reflects the distinct roles and responsibilities of the transport and network layers:</p>
<ul>
<li><p><strong>Connection-oriented service (Transport Layer):</strong><br>At the transport layer, a connection-oriented service (such as TCP) establishes, maintains, and terminates a logical end-to-end connection. This connection is defined <strong>between two processes</strong> on the end hosts (e.g., two TCP sockets). This service ensures reliable, ordered, and error-checked delivery of data across the entire network path, directly between the communicating applications.</p>
</li>
<li><p><strong>Connection service (Network Layer):</strong><br>At the network layer, a connection service (such as a virtual circuit) refers to the establishment of a logical path through the network, typically between routers or switches. This connection is defined <strong>between two hosts</strong> (and their intervening routers in the case of virtual-circuit networks). This path helps guide packets from source to destination but does not necessarily guarantee reliability or ordering. The focus here is on the route and forwarding of packets within the network infrastructure.</p>
</li>
</ul>
<p><strong>In summary:</strong><br>The term “connection-oriented service” at the transport layer emphasizes end-to-end reliability and communication, while “connection service” at the network layer highlights the setup of a path through the network, without necessarily providing full end-to-end guarantees. The nuanced terminology helps clarify the different scopes and guarantees provided by each layer.</p>
<h2 id="P-9"><a href="#P-9" class="headerlink" title="P.9"></a>P.9</h2><p><strong>Consider a datagram network using 32-bit host addresses. Suppose a router has four links, numbered 0 through 3, and packets are to be forwarded to the link interfaces as follows:</strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">

| Destination Address Range                                                                                                                                      | Link Interface |
|:--------------------------------------------------------------------------------------------------------------------------------------------------------------:|:--------------:|
| <div align = "center">11100000 00000000 00000000 00000000<br><strong>through</strong><br>11100000 00111111 11111111 11111111</div>                               |       0        |
| <div align = "center">11100000 01000000 00000000 00000000<br><strong>through</strong><br>11100000 01000000 11111111 11111111</div>                               |       1        |
| <div align = "center">11100000 01000001 00000000 00000000<br><strong>through</strong><br>11100001 01111111 11111111 11111111</div>                               |       2        |
| <div align = "center">otherwise</div>                                                                                                                            |       3        |

</div>

<p><strong>Questions and Answers:</strong></p>
<p><strong>a. Provide a forwarding table that has four entries, uses longest prefix matching, and forwards packets to the correct link interfaces.</strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">

| Header | Link Interface(output) |
|------------------------------|:--------------:|
| 11100000 00 | 0 |
| 11100000 01000000 | 1 |
| 1110000   | 2 |
| otherwise | 3 |

</div>

<p><strong>Explanation:</strong>  </p>
<ul>
<li>Each entry uses the longest prefix that matches the given address range.</li>
<li>The router checks the destination address against each prefix, starting from the longest, and forwards the packet to the corresponding interface.</li>
</ul>
<p><strong>b. Describe how your forwarding table determines the appropriate link interface for datagrams with destination addresses</strong>:  </p>
<div align = "center">11001000 10010001 01010001 01010101</div>  
<div align = "center">11100001 01000000 11000011 00111100</div>  
<div align = "center">11100001 10000000 00010001 01110111</div>

<ol>
<li><p><strong>11001000 10010001 01010001 01010101</strong>  </p>
<ul>
<li>This address does <strong>not</strong> match any of the specified prefixes (does not start with 111…), so it is forwarded to <strong>interface 3</strong>.</li>
</ul>
</li>
<li><p><strong>11100001 01000000 11000011 00111100</strong>  </p>
<ul>
<li>This address matches the third entry:  <ul>
<li>Prefix: <code>1110000</code></li>
<li>So, it is forwarded to <strong>interface 2</strong>.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>11100001 10000000 00010001 01110111</strong>  </p>
<ul>
<li>This address matches the third entry:  <ul>
<li>Prefix: <code>1110000</code></li>
<li>So, it is forwarded to <strong>interface 2</strong>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="P-10"><a href="#P-10" class="headerlink" title="P.10"></a>P.10</h2><p><strong>Consider a datagram network using 8-bit host addresses. Suppose a router uses longest-prefix matching and has the following forwarding table:</strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">

| Prefix Match | Interface |
|:------------:|:---------:|
| 00           | 0         |
| 010          | 1         |
| 011          | 2         |
| 10           | 2         |
| 11           | 3         |

</div>

<p><strong>Question and Answer:</strong></p>
<p>For each of the four interfaces, give the associated range of destination host addresses and the number of addresses in the range.</p>
<div style="display: block; margin: 0 auto; width: fit-content">

| Interface | Destination Address Range                            | Number of Addresses       |
|:--------:|:--------------------------------------------:|--------------:|
| 0        | 00000000 - 00111111                           | 64       |
| 1        | 01000000 - 01011111                           | 32       |
| 2        | 01100000 - 01111111<br>10000000 - 10111111       | 96  |
| 3        | 11000000 - 11111111                           | 64       |

</div>

<h2 id="P-17"><a href="#P-17" class="headerlink" title="P.17"></a>P.17</h2><p><strong>Question and Answer:</strong></p>
<p>Consider sending a 2400-byte datagram into a link that has an MTU of 700 bytes. Suppose the original datagram is stamped with the identification number 422. How many fragments are generated? What are the values in the various fields in the IP datagram(s) generated related to fragmentation?</p>
<p>According to IPv4 datagram format, each fragment includes a 20-bytes header.</p>
<p>先计算数据大小 $d = \lfloor \frac{700 - 20}{8} \rfloor \times 8 = 680$ bytes。</p>
<p>所以需要分成 $n = \lceil \frac{2400 - 20}{d} \rceil = 4$</p>
<p>主要变化在 <code>Offset</code> 和 <code>Flag</code>，所以：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

| Fragment | Datagram length | Offset | Flag |
|:--------:|:---------------:|:------:|:----:|
| 1        | 700             |    0   |   001  |
| 2        | 700             |   85   |   001  |
| 3        | 700             |   170  |   001  |
| 4        | 360             |   255  |   000  |

</div>

<h2 id="P-18"><a href="#P-18" class="headerlink" title="P.18"></a>P.18</h2><p><strong>Question and Answer:</strong></p>
<p>Suppose datagrams are limited to 1,500 bytes (including header) between source Host A and destination Host B. Assuming a 20-byte IP header, how many datagrams would be required to send an MP3 consisting of 5 million bytes? Explain how you computed your answer.</p>
<p>MTU 为 $1500$ bytes，一个 datagram 的 data 大小为 $d = \lfloor \frac{1500 -20}{8} \rfloor \times 8 = 1480$ bytes。</p>
<p>最终，datagram 的数目为 $n = \lceil \frac{5 \times 10^6}{d} \rceil = 3379$ 个。</p>
<h2 id="P-19"><a href="#P-19" class="headerlink" title="P.19"></a>P.19</h2><p><strong>Consider the network setup in Figure 4.22. Suppose that the ISP instead assigns the router the address 24.34.112.235 and that the network address of the home network is 192.168.1/24</strong>.</p>
<p><img src="The-Network-Layer/Network address translation.png" srcset="/img/loading.gif" lazyload alt="Network address translation">{style=”display: block; margin: 0 auto; width: 80%”}</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. Assign addresses to all interfaces in the home network.</strong></p>
<p>也即是说，中间的 router WAN 的 IP address 是 <code>24.34.112.235</code>，LAN 的是 <code>192.168.1/24</code>，不妨和原图一样，设为 <code>192.168.1.4</code>。则右边的三个 host 的 LAN IP address 分别为：</p>
<ul>
<li>Host 1 address is 192.168.1.1</li>
<li>Host 2 address is 192.168.1.2</li>
<li>Host 3 address is 192.168.1.3</li>
</ul>
<p><strong>b. Suppose each host has two ongoing TCP connections, all to port 80 at host 128.119.40.86. Provide the six corresponding entries in the NAT translation table.</strong></p>
<p>总共有 $6$ 个 TCP connection，随便分几个端口号：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

| WAN side | LAN side |
|:--------:|:---------------:|
| 24.34.112.235, 50001 | 192.168.1.1, 3345 |
| 24.34.112.235, 50002 | 192.168.1.1, 3346 |
| 24.34.112.235, 50003 | 192.168.1.2, 3345 |
| 24.34.112.235, 50004 | 192.168.1.2, 3346 |
| 24.34.112.235, 50005 | 192.168.1.3, 3345 |
| 24.34.112.235, 50006 | 192.168.1.3, 3346 |

</div>

<h2 id="P-24"><a href="#P-24" class="headerlink" title="P.24"></a>P.24</h2><p><img src="The-Network-Layer/P24.jpg" srcset="/img/loading.gif" lazyload alt="Graph P.24">{style=”display: block; margin: 0 auto; width: 80%”}</p>
<p><strong>Question:</strong></p>
<p>Consider the following network. With the indicated link costs, use Dijkstra’s shortest-path algorithm to compute the shortest path from x to all network nodes. Show how the algorithm works by computing a table similar to Table 4.3.</p>
<p><strong>Answer:</strong></p>
<p>$N’ = \{x\}$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">step</th>
<th style="text-align:center">$D(x)$ $P(x)$</th>
<th style="text-align:center">$D(y)$ $P(y)$</th>
<th style="text-align:center">$D(z)$ $P(z)$</th>
<th style="text-align:center">$D(v)$ $P(v)$</th>
<th style="text-align:center">$D(u)$ $P(u)$</th>
<th style="text-align:center">$D(w)$ $P(w)$</th>
<th style="text-align:center">$D(t)$ $P(t)$</th>
<th style="text-align:center">$N’$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center">$6$     $x$</td>
<td style="text-align:center">$8$     $x$</td>
<td style="text-align:center"><strong>$3$</strong>  $x$</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">$6$      $x$</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">$x$</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center"><strong>$6$</strong> $x$</td>
<td style="text-align:center">$8$     $x$</td>
<td style="text-align:center">$3$      $x$</td>
<td style="text-align:center">$6$     $v$</td>
<td style="text-align:center">$6$      $x$</td>
<td style="text-align:center">$7$     $v$</td>
<td style="text-align:center">$xv$</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center">$6$     $x$</td>
<td style="text-align:center">$8$     $x$</td>
<td style="text-align:center">$3$      $x$</td>
<td style="text-align:center"><strong>$6$</strong> $v$</td>
<td style="text-align:center">$6$      $x$</td>
<td style="text-align:center">$7$     $v$</td>
<td style="text-align:center">$xvy$</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center">$6$     $x$</td>
<td style="text-align:center">$8$     $x$</td>
<td style="text-align:center">$3$      $x$</td>
<td style="text-align:center">$6$     $v$</td>
<td style="text-align:center"><strong>$6$</strong>  $x$</td>
<td style="text-align:center">$7$     $v$</td>
<td style="text-align:center">$xvyu$</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center">$6$     $x$</td>
<td style="text-align:center">$8$     $x$</td>
<td style="text-align:center">$3$      $x$</td>
<td style="text-align:center">$6$     $v$</td>
<td style="text-align:center">$6$      $x$</td>
<td style="text-align:center"><strong>$7$</strong>  $v$</td>
<td style="text-align:center">$xvyuw$</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center">$6$     $x$</td>
<td style="text-align:center"><strong>$8$</strong> $x$</td>
<td style="text-align:center">$3$      $x$</td>
<td style="text-align:center">$6$     $v$</td>
<td style="text-align:center">$6$      $x$</td>
<td style="text-align:center">$7$     $v$</td>
<td style="text-align:center">$xvyuwt$</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">$0$    $x$</td>
<td style="text-align:center">$6$     $x$</td>
<td style="text-align:center">$8$     $x$</td>
<td style="text-align:center">$3$      $x$</td>
<td style="text-align:center">$6$     $v$</td>
<td style="text-align:center">$6$      $x$</td>
<td style="text-align:center">$7$     $v$</td>
<td style="text-align:center">$xvyuwtz$</td>
</tr>
</tbody>
</table>
</div>
<p>So the shortest path from $x$ to all nodes is follow.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Destination</th>
<th style="text-align:center">Shortest Distance</th>
<th style="text-align:center">Path</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$x$</td>
<td style="text-align:center">$0$</td>
<td style="text-align:center">$x$</td>
</tr>
<tr>
<td style="text-align:center">$v$</td>
<td style="text-align:center">$3$</td>
<td style="text-align:center">$x \to v$</td>
</tr>
<tr>
<td style="text-align:center">$y$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$x \to y$</td>
</tr>
<tr>
<td style="text-align:center">$w$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$x \to w$</td>
</tr>
<tr>
<td style="text-align:center">$u$</td>
<td style="text-align:center">$6$</td>
<td style="text-align:center">$x \to v \to u$</td>
</tr>
<tr>
<td style="text-align:center">$t$</td>
<td style="text-align:center">$7$</td>
<td style="text-align:center">$x \to v \to t$</td>
</tr>
<tr>
<td style="text-align:center">$z$</td>
<td style="text-align:center">$8$</td>
<td style="text-align:center">$x \to z$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="P-26"><a href="#P-26" class="headerlink" title="P.26"></a>P.26</h2><p><img src="The-Network-Layer/P26.png" srcset="/img/loading.gif" lazyload alt="Graph P.26">{style=”display: block; margin: 0 auto; width: 80%”}</p>
<p><strong>Question:</strong></p>
<p>Consider the network shown below, and assume that each node initially knows the costs to each of its neighbors. Consider the distance-vector algorithm and show the distance table entries at node z.</p>
<p><strong>Answer:</strong></p>
<p><strong>Node z table:</strong></p>
<p><strong><em>First round</em></strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">

|        | cost to|       ||||
|:------:|:------:|:------:|:------:|:------:|:------:|
|        | x      | y      | z      | u      | v      |
| from x | $\infty$ | $\infty$ | $\infty$ | $\infty$ | $\infty$ |
| from y | $\infty$ | $\infty$ | $\infty$ | $\infty$ | $\infty$ |
| from z | 2        | $\infty$   | 0      | $\infty$ | 6      |
| from u | $\infty$ | $\infty$ | $\infty$ | $\infty$ | $\infty$ |
| from v | $\infty$ | $\infty$ | $\infty$ | $\infty$ | $\infty$ |

</div>

<p><strong><em>Second round</em></strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">

|        | cost to|        |        |        |        |
|:------:|:------:|:------:|:------:|:------:|:------:|
|        | $x$      | $y$      | $z$      | $u$      | $v$      |
| from $x$ | $2$      | $3$      | $\infty$ | $\infty$ | $3$      |
| from $y$ | $3$      | $\infty$ | $\infty$ | $2$      | $\infty$ |
| from $z$ | $2$      | $5$      | $0$      | $7$      | $5$      |
| from $u$ | $\infty$ | $2$      | $\infty$ | $\infty$ | $2$      |
| from $v$ | $3$      | $\infty$ | $6$      | $1$      | $\infty$ |

</div>

<p>Because the question only asks to show the distance table entries at node z, we do not need to compute the full routing tables for all nodes. The Second round result about node z is also the finial result. 到这一步 from z to other 的 cost 表就收敛了，题目也只问了 node z。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Computer-Network/" class="category-chain-item">Computer Network</a>
  
  
    <span>></span>
    
  <a href="/categories/Computer-Network/Network-Layer/" class="category-chain-item">Network Layer</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>The Network Layer</div>
      <div>https://ddccffq.github.io/2025/05/30/The-Network-Layer/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>任志诚 2023212020</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/06/01/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/" title="条件随机场">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">条件随机场</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/30/%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/" title="提升方法">
                        <span class="hidden-mobile">提升方法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
