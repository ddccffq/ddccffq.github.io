

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="任志诚 2023212020">
  <meta name="keywords" content="Computer Network,Transport Layer">
  
    <meta name="description" content="Transport-Layer ServicesTransport protocols run in end systems:  Sending side: breaks app messages into segments, passes to  network layer. Receiving side: reassembles segments into messages, passes t">
<meta property="og:type" content="article">
<meta property="og:title" content="The Transport Layer">
<meta property="og:url" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/index.html">
<meta property="og:site_name" content="ddccffq的技术博客">
<meta property="og:description" content="Transport-Layer ServicesTransport protocols run in end systems:  Sending side: breaks app messages into segments, passes to  network layer. Receiving side: reassembles segments into messages, passes t">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/a-transport-layer-segment.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/UDP-segment-structure.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/Reliable-data-transfer.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/rdt1.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/rdt2.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/rdt2-1-sender.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/rdt2-1-receiver.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/rdt2-2-sender.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/rdt2-2-receiver.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/rdt3-0-receiver.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/Sender&#39;s-view-of-sequence-numbers-in-Go-Back-N.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/GBN-sender.png.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/GBN-receiver.png.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/RS-sender-receiver-view.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/TCP-segment-structure.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/rwnd-buffer.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/TCP%20window%20size%20as%20a%20function%20of%20time.png">
<meta property="article:published_time" content="2025-06-08T07:04:40.000Z">
<meta property="article:modified_time" content="2025-06-17T02:58:02.000Z">
<meta property="article:author" content="ddccffq">
<meta property="article:tag" content="机器学习,计算机网络,算法,统计学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/The-Transport-Layer/a-transport-layer-segment.png">
  
  
  
  <title>The Transport Layer - ddccffq的技术博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ddccffq.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ddccffq的技术博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Computer Networking, A Top-Down Approach, 5th Edition"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-08 15:04" pubdate>
          2025年6月8日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          3.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          30 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Computer Networking, A Top-Down Approach, 5th Edition</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Transport-Layer-Services"><a href="#Transport-Layer-Services" class="headerlink" title="Transport-Layer Services"></a>Transport-Layer Services</h1><p>Transport protocols run in <strong>end systems</strong>:</p>
<ul>
<li>Sending side: breaks app messages into <strong>segments</strong>, passes to  network layer.</li>
<li>Receiving side: reassembles segments into <strong>messages</strong>, passes to app layer.</li>
</ul>
<h1 id="Multiplexing-and-Demultiplexing"><a href="#Multiplexing-and-Demultiplexing" class="headerlink" title="Multiplexing and Demultiplexing"></a>Multiplexing and Demultiplexing</h1><p><strong>Multiplexing at sending host:</strong> gather data from multiple sockets, enveloping data with <strong>header</strong>(later used for demultiplexing).<br><strong>demultiplexing at receiving host:</strong> deliver segments to correct socket.</p>
<h2 id="Demultiplexing"><a href="#Demultiplexing" class="headerlink" title="Demultiplexing"></a>Demultiplexing</h2><p>Hosts receives <strong>IP datagrams</strong>. Each IP datagram has source IP address and destination IP address. Each IP datagram carries a transport-layer segment. Each segment has source port numbers and destination port numbers.</p>
<p><img src="The-Transport-Layer/a-transport-layer-segment.png" srcset="/img/loading.gif" lazyload alt="A transport layer segment">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<blockquote>
<p>将 segment 传到目标 host，host 再将 segment 通过 socket 传给对应的 application。</p>
</blockquote>
<h3 id="Connectionless-Demultiplexing"><a href="#Connectionless-Demultiplexing" class="headerlink" title="Connectionless Demultiplexing"></a>Connectionless Demultiplexing</h3><p>在 <strong>UDP</strong> 协议中使用。</p>
<p>Creates socket with <strong>port numbers</strong>. Each UDP socket identified with <code>(dest IP address, dest port numbers)</code>.</p>
<blockquote>
<p>当终端收到 IP datagrams 中是 UDP segment 时。 The host will check destination port in the segment and then directs the segment to corresponding socket。发生在 transport layer。</p>
</blockquote>
<h3 id="Connection-oriented-Demultiplexing"><a href="#Connection-oriented-Demultiplexing" class="headerlink" title="Connection-oriented Demultiplexing"></a>Connection-oriented Demultiplexing</h3><p><strong>Used in TCP protocol</strong>.</p>
<p>TCP socket identified by <strong>4</strong>-tuple: <code>(source IP address, source port numbers, dest IP address, dest port numbers)</code>.</p>
<h1 id="Connectionless-Transport-UDP"><a href="#Connectionless-Transport-UDP" class="headerlink" title="Connectionless Transport: UDP"></a>Connectionless Transport: UDP</h1><h2 id="UDP-Segment-Structure"><a href="#UDP-Segment-Structure" class="headerlink" title="UDP Segment Structure"></a>UDP Segment Structure</h2><p><img src="The-Transport-Layer/UDP-segment-structure.png" srcset="/img/loading.gif" lazyload alt="UDP segment structure">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<h2 id="UDP-Checksum"><a href="#UDP-Checksum" class="headerlink" title="UDP Checksum"></a>UDP Checksum</h2><p><strong>Goal</strong>: detect “errors” (e.g., flipped bits) in transmitted segment. 指的是位比特发生了 $01$ 翻转。</p>
<p>“Calculation:”</p>
<ol>
<li><p><strong>Group Data</strong>:</p>
<ul>
<li>Divide all fields of the UDP segment (including header and data) into 16-bit blocks. If the data length is odd, pad with a zero byte. 这里要注意，不同的比特排序方式会影响到最终结果，数据通常以<strong>大端序</strong>（高位字节在前）表示。</li>
</ul>
</li>
<li><p><strong>Compute Sum</strong>:</p>
<ul>
<li>Perform a 1’s complement sum of all 16-bit blocks。就是二进位加法。</li>
<li>If overflow occurs (exceeds 16 bits), wrap the overflow back into the result.</li>
</ul>
</li>
<li><p><strong>Take Complement</strong>:</p>
<ul>
<li>Take the 1’s complement of the computed sum to get the final checksum。这里可以看作进行了一次<strong>同位全 $1$</strong> 加法。</li>
</ul>
</li>
<li><p><strong>Fill Checksum Field</strong>:</p>
<ul>
<li>Place the computed checksum into the checksum field of the UDP segment.</li>
</ul>
</li>
</ol>
<h1 id="Principles-of-Reliable-Data-Transfer"><a href="#Principles-of-Reliable-Data-Transfer" class="headerlink" title="Principles of Reliable Data Transfer"></a>Principles of Reliable Data Transfer</h1><p><strong>应用程序即使运行在 UDP 之上，也可以实现可靠数据传输</strong>。虽然 UDP 本身是无连接、无保证的协议，不提供诸如数据包重传、顺序保证、丢包检测等机制，但<strong>应用层可以自行实现这些功能</strong>，从而达到可靠传输的目的。</p>
<p><img src="The-Transport-Layer/Reliable-data-transfer.png" srcset="/img/loading.gif" lazyload alt="Reliable data transfer: Service model and service implementation">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<h2 id="Reliable-Data-Transfer-over-a-Perfectly-Reliable-Channel-rdt-1-0"><a href="#Reliable-Data-Transfer-over-a-Perfectly-Reliable-Channel-rdt-1-0" class="headerlink" title="Reliable Data Transfer over a Perfectly Reliable Channel: rdt 1.0"></a>Reliable Data Transfer over a Perfectly Reliable Channel: rdt 1.0</h2><p><img src="The-Transport-Layer/rdt1.png" srcset="/img/loading.gif" lazyload alt="rdt1.0 - A protocol for a completely reliable channel">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>Unrealistic:</strong> underlying channel perfectly reliable</p>
<ul>
<li>no bit errors</li>
<li>no loss of packets</li>
</ul>
<h2 id="Reliable-Data-Transfer-over-a-Channel-with-Bit-Errors-rdt-2-0"><a href="#Reliable-Data-Transfer-over-a-Channel-with-Bit-Errors-rdt-2-0" class="headerlink" title="Reliable Data Transfer over a Channel with Bit Errors: rdt 2.0"></a>Reliable Data Transfer over a Channel with Bit Errors: rdt 2.0</h2><p>增添检查错误机制：checksum 和 ACK。</p>
<p><img src="The-Transport-Layer/rdt2.png" srcset="/img/loading.gif" lazyload alt="rdt 2.0 - A protocol for a channel with bit errors">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>New mechanism in rdt 2.0 (beyond rdt 1.0)</strong></p>
<ul>
<li>Error detection;<ul>
<li><strong>Checksum</strong>.</li>
</ul>
</li>
<li>Receiver feedback.<ul>
<li><strong>ACKs and NAKs</strong>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>rdt 2.0 有一个致命问题：如果 ACK/NAK 出错导致信息改变。</p>
</blockquote>
<h2 id="rdt-2-1"><a href="#rdt-2-1" class="headerlink" title="rdt 2.1"></a>rdt 2.1</h2><p><img src="The-Transport-Layer/rdt2-1-sender.png" srcset="/img/loading.gif" lazyload alt="rdt 2.1 sender">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p><img src="The-Transport-Layer/rdt2-1-receiver.png" srcset="/img/loading.gif" lazyload alt="rdt 2.1 receiver">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<blockquote>
<p>可以看到 rdt 2.1 新增了一个 sequence number。在 rdt 2.0 中提到过其有着一个致命的问题，这个问题可能会导致两个问题：重传和丢失。从 Figure P.6 和 Figure P.7 可以看到 rdt 2.1 能解决重传的问题，但是不能解决丢失的问题。</p>
</blockquote>
<h2 id="rdt-2-2"><a href="#rdt-2-2" class="headerlink" title="rdt 2.2"></a>rdt 2.2</h2><p><img src="The-Transport-Layer/rdt2-2-sender.png" srcset="/img/loading.gif" lazyload alt="rdt2.2 sender">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p><img src="The-Transport-Layer/rdt2-2-receiver.png" srcset="/img/loading.gif" lazyload alt="rdt2.2 receiver">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<blockquote>
<p>rdt 2.1 的机制是：如果是 NAK 或者 checksum 出错就重传。从 Figure P.8 和 Figure P.9 可以看出，receiver 收了什么序号的包就回什么序号，如果是自己要的包就 extract，然后 sender 发下个序号的包，如果重传导致 duplicate，那么只需要 delete 然后给 sender 发送 ACK。显然，receiver 回什么序号，sender 都会发下一个序号的包，也就是 rdt 2.2 没有使用 NAK 就解决了重传的问题。</p>
</blockquote>
<p>补充：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

| 变量/语句                | 作用说明                                               |
|-------------------------|--------------------------------------------------------|
| `oncethru == 1`         | 是否第一次进入该状态                                   |
| `udt_send(sndpkt)`      | 发送 ACK 包                                            |
| 结合使用                | 首次进入状态时主动重发 ACK，防止因 ACK 丢失而死锁      |

</div>

<h2 id="rdt-3-0"><a href="#rdt-3-0" class="headerlink" title="rdt 3.0"></a>rdt 3.0</h2><p><img src="The-Transport-Layer/rdt3-0-receiver.png" srcset="/img/loading.gif" lazyload alt="rdt3.0 sender">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<blockquote>
<p>增加了一个计时器，可以解决包丢失的问题，如果超时就重传，</p>
</blockquote>
<h2 id="Pipelined-Reliable-Data-Transfer-Protocols"><a href="#Pipelined-Reliable-Data-Transfer-Protocols" class="headerlink" title="Pipelined Reliable Data Transfer Protocols"></a>Pipelined Reliable Data Transfer Protocols</h2><p><strong>rdt 3.0 stop-and-wait operation</strong>: rdt 3.0 can work, but its performance stinks.</p>
<blockquote>
<p>这里是说 rdt 3.0 的机制一轮就处理一个包而效率低下。</p>
</blockquote>
<p>For example, we suppose condition with 1 Gbps link, 15 ms propagation delay, 8000 bits packet.</p>
<script type="math/tex; mode=display">
\text{d}_{trans} = \frac{L}{R} = \frac{8000 \text{bits}}{10^9 \text{bps}} = 8 \text{microseconds}</script><script type="math/tex; mode=display">
\text{Utilization} = \frac{\frac{L}{R}}{\text{RTT} + \frac{L}{R}} = 0.00027</script><p>So, we use <strong>Pipelined Reliable Data Transfer Protocols</strong> to increase utilization!</p>
<p><strong>Pipelining:</strong> sender allows multiple, “in-flight”,yet-to-be-acknowledged pkts.</p>
<ul>
<li>Range of sequence numbers must be <strong>increased</strong>.</li>
<li><strong>Buffering</strong> at sender and/or receiver.</li>
</ul>
<h3 id="Go-Back-N-GBN-Protocol"><a href="#Go-Back-N-GBN-Protocol" class="headerlink" title="Go-Back-N (GBN) Protocol"></a>Go-Back-N (GBN) Protocol</h3><p><img src="The-Transport-Layer/Sender&#39;s-view-of-sequence-numbers-in-Go-Back-N.png" srcset="/img/loading.gif" lazyload alt="Sender&#39;s view of sequence numbers in Go-Back-N">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>Timeout(n):</strong> retransmit pkt <code>n</code> and all higher seq <code>#</code> pkts in window</p>
<p><img src="The-Transport-Layer/GBN-sender.png.png" srcset="/img/loading.gif" lazyload alt="GBN sender">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p><img src="The-Transport-Layer/GBN-receiver.png.png" srcset="/img/loading.gif" lazyload alt="GBN receiver">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p>需要注意的是，上述图片中是<strong>覆盖确认</strong>：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

| 协议类型         | ACK 处理方式                         | base 变化方式           |
|------------------|--------------------------------------|------------------------|
| 累计确认（GBN）  | 只确认按序最大已收到的包              | base 只前进不回退      |
| 覆盖确认（图中） | 收到哪个 ACK 就直接覆盖 base          | base 可能跳跃前进      |

</div>

<h3 id="Selective-Repeat-SR"><a href="#Selective-Repeat-SR" class="headerlink" title="Selective Repeat (SR)"></a>Selective Repeat (SR)</h3><p>Sender only <strong>resends</strong> pkts for which ACK not received.</p>
<p><img src="The-Transport-Layer/RS-sender-receiver-view.png" srcset="/img/loading.gif" lazyload alt="Selective-repeat (SR) sender and receiver views of sequence-number space">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<script type="math/tex; mode=display">
\text{window size} \leq \frac{1}{2} \text{seq}</script><h4 id="Sender"><a href="#Sender" class="headerlink" title="Sender"></a>Sender</h4><ul>
<li><strong>Data from above</strong>:<ul>
<li>If next available sequence number is within the window, send the packet.</li>
</ul>
</li>
<li><strong>Timeout(n)</strong>:<ul>
<li>Resend packet <code>n</code>, restart the timer.</li>
</ul>
</li>
<li><strong>ACK(n) in [sendbase, sendbase $+$ $N$]</strong>:<ul>
<li>Mark packet <code>n</code> as received.</li>
<li>If <code>n</code> is the smallest unACKed packet, <strong>advance</strong> the window base to the next unACKed sequence number.</li>
</ul>
</li>
</ul>
<h4 id="Receiver"><a href="#Receiver" class="headerlink" title="Receiver"></a>Receiver</h4><ul>
<li><strong>Packet <code>n</code> in [rcvbase, rcvbase $+$ $N$ $-$ $1$]</strong>:<ul>
<li>Send ACK(n).</li>
<li><strong>Out-of-order</strong>: Buffer the packet.</li>
<li><strong>In-order</strong>: Deliver the packet (also deliver buffered, in-order packets), advance the window to the next not-yet-received packet.</li>
</ul>
</li>
<li><strong>Packet <code>n</code> in [rcvbase $-$ $N$, rcvbase $-$ $1$]</strong>:<ul>
<li>Send ACK(n). 解决 duplicate。</li>
</ul>
</li>
<li><strong>Otherwise</strong>:<ul>
<li>Ignore the packet.</li>
</ul>
</li>
</ul>
<h1 id="Connection-oriented-transport-TCP"><a href="#Connection-oriented-transport-TCP" class="headerlink" title="Connection-oriented transport: TCP"></a>Connection-oriented transport: TCP</h1><h2 id="TCP-Segment-Structure"><a href="#TCP-Segment-Structure" class="headerlink" title="TCP Segment Structure"></a>TCP Segment Structure</h2><p><img src="The-Transport-Layer/TCP-segment-structure.png" srcset="/img/loading.gif" lazyload alt="TCP segment structure">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>How to set sequence number and acknowledgment number?</strong></p>
<ul>
<li><strong>sequence number</strong>: represents the byte stream number of the first byte in the segment’s data.</li>
<li><strong>ACKs</strong>: indicates the sequence number of the next byte expected from the sender. Using cumulative acknowledgment.</li>
</ul>
<h2 id="TCP-Round-Trip-Time-and-Timeout"><a href="#TCP-Round-Trip-Time-and-Timeout" class="headerlink" title="TCP Round Trip Time and Timeout"></a>TCP Round Trip Time and Timeout</h2><p><strong>How to estimate $\mathbf{RTT}$?</strong></p>
<script type="math/tex; mode=display">
\text{EstimateRTT} = (1 - \alpha) \cdot \text{EstimateRTT} + \alpha \cdot \text{SampleRTT}, \quad \text{Typically } \alpha = 0.125</script><p><strong>How to set TCP timeout value?</strong></p>
<p>Longer than $\text{RTT}$, but $\text{RTT}$ varies.</p>
<script type="math/tex; mode=display">
\text{DevRTT} = (1 - \beta) \cdot \text{DevRTT} + \beta \cdot |\text{SampleRTT} - \text{EstimateRTT}|, \quad \text{Typically } \beta = 0.25</script><script type="math/tex; mode=display">
\text{TimeOutInterval} = \text{EstimateRTT} + 4 \cdot \text{DevRTT}</script><h2 id="TCP-Reliable-Data-Transfer"><a href="#TCP-Reliable-Data-Transfer" class="headerlink" title="TCP Reliable Data Transfer"></a>TCP Reliable Data Transfer</h2><h3 id="Fast-Retransmit"><a href="#Fast-Retransmit" class="headerlink" title="Fast  Retransmit"></a>Fast  Retransmit</h3><p>If sender receives $3$ ACKs for same data, it assumes that segment after ACKed data was lost.</p>
<h2 id="Flow-control"><a href="#Flow-control" class="headerlink" title="Flow control"></a>Flow control</h2><p>Receiver side of TCP connection has a <strong>receive buffer</strong>.</p>
<p><img src="The-Transport-Layer/rwnd-buffer.png" srcset="/img/loading.gif" lazyload alt="The receive window (rwnd) and the receive buffer (RcvBuffer)">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<h3 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works?"></a>How it works?</h3><ul>
<li><strong>Receiver:</strong> advertises unused buffer space by including $\text{rwnd}$ value in segment header.</li>
<li><strong>Sender:</strong> limits unAcked bytes to $\text{rwnd}$.</li>
</ul>
<script type="math/tex; mode=display">
\text{rwnd} = \text{RcvBuffer} - \left[\text{LastByteRcvd} - \text{LastByteRead} \right]</script><p><strong>字节编号</strong>的问题。在TCP中：</p>
<ul>
<li>如果初始序列号为0，发送50字节后：<ul>
<li>这些字节的序号为：0, 1, 2, …, 49</li>
<li><strong>最后一个字节</strong>的序号为49，即 LastByteRcvd = 49</li>
<li>根据公式 $y = \text{LastByteRcvd} + 1$，得到确认号 y = 50</li>
</ul>
</li>
</ul>
<p>其中 y 是 ACK。</p>
<h2 id="Connection-Management"><a href="#Connection-Management" class="headerlink" title="Connection Management"></a>Connection Management</h2><h3 id="Three-Way-Handshake"><a href="#Three-Way-Handshake" class="headerlink" title="Three Way Handshake"></a>Three Way Handshake</h3><p><strong>握手协议（Handshaking Protocol）</strong> 是指在两个通信实体（如客户端和服务器）之间建立通信连接之前，双方通过一系列消息的交换，协商通信参数、确认彼此身份、同步状态等，从而为后续的数据传输做好准备的过程。</p>
<ol>
<li><p><strong>Step 1</strong>:</p>
<ul>
<li>Client sends TCP <code>SYN</code> segment to server, specifying initial seq. No data.</li>
</ul>
</li>
<li><p><strong>Step 2</strong>:</p>
<ul>
<li>Server host receives <code>SYN</code>, replies with <code>SYNACK</code> segment. Server allocates buffers and specifies server initial seq.</li>
</ul>
</li>
<li><p><strong>Step 3</strong>:</p>
<ul>
<li>Client receives <code>SYNACK</code>, replies with ACK segment, which may contain data</li>
</ul>
</li>
</ol>
<h3 id="Closing-a-Connection"><a href="#Closing-a-Connection" class="headerlink" title="Closing a Connection"></a>Closing a Connection</h3><ol>
<li><p><strong>Step 1</strong>:</p>
<ul>
<li>Client sends TCP <code>FIN</code> segment to server, specifying initial seq. No data.</li>
</ul>
</li>
<li><p><strong>Step 2</strong>:</p>
<ul>
<li>Server receives <code>FIN</code>, replies with ACK. Closes connection, sends <code>FIN</code>.</li>
</ul>
</li>
<li><p><strong>Step 3</strong>:</p>
<ul>
<li>Client receives <code>FIN</code>, replies with ACK.</li>
</ul>
</li>
<li><p><strong>Step 4</strong>:</p>
<ul>
<li>Server, receives ACK.  Connection closed.</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">客户端A                                      服务器B<br>   | ----------- SYN, Seq=1000 ------------&gt; |<br>   |                                         |<br>   | &lt;------ SYN+ACK, Seq=2000, Ack=1001 --- |<br>   |                                         |<br>   | ----------- ACK, Seq=1001, Ack=2001 --&gt; |<br></code></pre></td></tr></table></figure>
<p>上面所说的 <code>SYN</code> 和 <code>FIN</code> 都在 TCP segment 结构 header 中。</p>
<h1 id="Principles-of-Congestion-control"><a href="#Principles-of-Congestion-control" class="headerlink" title="Principles of Congestion control"></a>Principles of Congestion control</h1><p>Too many sources sending too much data too fast for <strong>network (router)</strong> to handle.</p>
<h2 id="Approaches-towards-Congestion-Control"><a href="#Approaches-towards-Congestion-Control" class="headerlink" title="Approaches towards Congestion Control"></a>Approaches towards Congestion Control</h2><ul>
<li><strong>end-end congestion control</strong>: congestion inferred from end-system observed loss, delay.</li>
<li><strong>network-assisted congestion control</strong>: routers provide feedback to end systems.</li>
</ul>
<h1 id="TCP-Congestion-Control"><a href="#TCP-Congestion-Control" class="headerlink" title="TCP Congestion Control"></a>TCP Congestion Control</h1><p><strong>Goal:</strong>  TCP sender should transmit as fast as possible, but without congesting network</p>
<p><strong>probing for bandwidth:</strong> increase transmission rate on receipt of ACK, until eventually loss occurs, then decrease transmission rate. //一种贪心策略</p>
<p>Sender limits rate by limiting number of unACKed bytes “in pipeline”:</p>
<script type="math/tex; mode=display">
\text{LastByteSent} - \text{LastByteAcked} \leq \min \{\text{cwnd}, \text{rwnd} \}</script><script type="math/tex; mode=display">
\text{rate} \approx \frac{\text{cwnd}}{\text{RTT}}</script><h2 id="Slow-Start-Phase"><a href="#Slow-Start-Phase" class="headerlink" title="Slow Start Phase"></a>Slow Start Phase</h2><p>When connection begins, $\text{cwnd} = 1 \, \text{MSS}$.</p>
<blockquote>
<script type="math/tex; mode=display">\text{MSS} = \text{MTU} - \text{IP头部大小} - \text{TCP头部大小}</script></blockquote>
<div style="display: block; margin: 0 auto; width: fit-content">

| 特性         | MSS                        | MTU                        |
|--------------|----------------------------|----------------------------|
| 所属协议层   | 传输层 (TCP)               | 数据链路层                 |
| 计量对象     | TCP 数据部分               | 整个数据包（包括所有头部）  |
| 设置目的     | 避免 IP 分片               | 适应物理媒介的限制         |
| 典型值       | 1460 字节 (以太网)         | 1500 字节 (以太网)         |
| 协商方式     | TCP 三次握手时协商         | 网络设备固定或自动发现     |

</div>

<p>Increase rate exponentially until first <strong>loss event</strong> or when <strong>threshold reached</strong>.</p>
<ul>
<li><strong>Double</strong> cwnd every RTT. 没有发生 loss 就以指数函数增长。</li>
<li>Done by incrementing cwnd by $1$ for every ACK received. 超过 $\text{ssthresh}$ 后线性增长。</li>
</ul>
<h2 id="Congestion-Avoidance"><a href="#Congestion-Avoidance" class="headerlink" title="Congestion Avoidance"></a>Congestion Avoidance</h2><p>When $\text{cwnd} \geq \text{ssthresh}$, increase $\text{cwnd}$ by $1$ $\text{MSS}$ per $\text{RTT}$.</p>
<h2 id="TCP-RENO"><a href="#TCP-RENO" class="headerlink" title="TCP RENO"></a>TCP RENO</h2><p><strong>Fast recovery</strong>: When triple duplicate ACKs occurs, $\text{ssthresh}$ sets to $\frac{\text{cwnd}}{2}$, $\text{cwnd}$ sets to $\text{ssthresh}$. 传快了，适当减小。</p>
<p>But when <strong>timeout</strong> occurs, $\text{ssthresh}$ sets to $\frac{\text{cwnd}}{2}$, $\text{cwnd}$ sets to $1$ $\text{MSS}$. 丢包。</p>
<h2 id="TCP-throughput"><a href="#TCP-throughput" class="headerlink" title="TCP throughput"></a>TCP throughput</h2><p><strong>Question:</strong> What’s the average throughput of TCP as a function of window size and RTT?</p>
<p><strong>Assumptions:</strong></p>
<ul>
<li>Ignoring slow start.</li>
<li>Let <code>W</code> be the window size when loss occurs.</li>
</ul>
<p><strong>Throughput Analysis:</strong></p>
<ol>
<li><p><strong>When window size is <code>W</code></strong>:</p>
<ul>
<li>Throughput = $\frac{W}{\text{RTT}}$.</li>
</ul>
</li>
<li><p><strong>Just after loss</strong>:</p>
<ul>
<li>Window size drops to $\frac{W}{2}$.</li>
<li>Throughput = $\frac{W}{2 \cdot \text{RTT}}$.</li>
</ul>
</li>
<li><p><strong>Average throughput</strong>:</p>
<ul>
<li>Average throughput = $0.75 \cdot \frac{W}{\text{RTT}}$.</li>
</ul>
</li>
</ol>
<h1 id="End-of-chapter-exercises"><a href="#End-of-chapter-exercises" class="headerlink" title="End-of-chapter exercises"></a>End-of-chapter exercises</h1><h2 id="R-4"><a href="#R-4" class="headerlink" title="R.4"></a>R.4</h2><p><strong>Question:</strong></p>
<p>Describe why an application developer might choose to run an application over UDP rather than TCP.</p>
<p><strong>Answer:</strong></p>
<p>An application developer might choose to run an application over UDP rather than TCP for the following reasons:</p>
<ol>
<li><p><strong>Low Latency</strong>: UDP is a connectionless protocol, meaning it does not establish a connection before sending data. This reduces latency, making it suitable for real-time applications like video streaming, online gaming, and voice over IP (VoIP).</p>
</li>
<li><p><strong>No Overhead for Reliability</strong>: Unlike TCP, UDP does not provide reliability mechanisms such as retransmissions, acknowledgments, or congestion control. This reduces overhead and allows applications to handle reliability themselves if needed.</p>
</li>
<li><p><strong>Broadcast/Multicast Support</strong>: UDP supports broadcasting and multicasting, which is useful for applications like live video streaming or network discovery.</p>
</li>
<li><p><strong>Simple Protocol</strong>: UDP is simpler and requires fewer resources, making it ideal for lightweight applications or systems with limited processing power.</p>
</li>
<li><p><strong>Custom Error Handling</strong>: Some applications prefer to implement their own error handling and flow control mechanisms tailored to their specific needs, which is easier with UDP.</p>
</li>
<li><p><strong>Unordered Data Delivery</strong>: For applications where the order of data packets is not critical (e.g., DNS queries), UDP is a better choice as it does not enforce packet ordering.</p>
</li>
</ol>
<h2 id="P-4"><a href="#P-4" class="headerlink" title="P.4"></a>P.4</h2><p><strong>Question:</strong><br>a. Suppose you have the following $2$ bytes: $01011100$ and $01010110$. What is the $1$s complement of the sum of these $2$ bytes?<br>b. Suppose you have the following $2$ bytes: $11011010$ and $00110110$. What is the $1$s complement of the sum of these $2$ bytes?<br>c. For the bytes in part (a), give an example where one bit is flipped in each of the $2$ bytes and yet the $1$s complement doesn’t change.</p>
<p><strong>Answer:</strong></p>
<ul>
<li><strong>a.</strong> $10110010$.</li>
<li><strong>b.</strong> $00010001$.</li>
<li><strong>c.</strong> $01011110$ and $01010100$.</li>
</ul>
<h2 id="P-11"><a href="#P-11" class="headerlink" title="P.11"></a>P.11</h2><p><strong>Question:</strong></p>
<p>The sender side of $\text{rdt}3.0$ simply ignores (that is, takes no action on) all received packets that are either in error or have the wrong value in the acknum field of an acknowledgment packet. Suppose that in such circumstances, $\text{rdt}3.0$ were simply to retransmit the current data packet. Would the protocol still work? (Hint: Consider what would happen if there were only bit errors; there are no packet losses but premature timeouts can occur. Consider how many times the $n^{th}$ packet is sent, in the limit as $n$ approaches infinity.)</p>
<p><strong>Answer:</strong></p>
<p>在这种情况下，rdt $3.0$ 仍然是有效的。首先，该协议接收方可以通过检查 <strong>sequence number</strong> 来判断当前的包是否重复，这个检查方式一直有效。原本的 $\text{rdt}3.0$ 协议在超时后会重传，但现在只要检查出 <strong>acknowledgment packet</strong> 中出错就重传，这显然会增加网络负载，比如：在极端情况下，发送方可能会多次重传一个包，若 ACK 错误率为 $p$，则每个数据包平均需要发送 $1/(1-p)$ 次，直到接受到正确的 <strong>ACKs</strong>。总结：$\text{rdt}3.0$ 协议在这种情况下仍然是可靠的，但立即重传错误数据包会导致性能问题，因此这种修改并不是一个好的设计选择。</p>
<h2 id="P-14"><a href="#P-14" class="headerlink" title="P.14"></a>P.14</h2><p><strong>Question:</strong></p>
<p>Consider the cross-country example shown in Figure $3.17$. How big would the window size have to be for the channel utilization to be greater than $95$ percent? Suppose that the size of a packet is $1,500$ bytes, including both header fields and data.</p>
<p><strong>Complement:</strong> $1$ Gbps link. RTT, is approximately $30$ milliseconds.</p>
<p><strong>Answer:</strong></p>
<script type="math/tex; mode=display">
\text{d}_{trans} = \frac{L}{R} = \frac{1500 \times 8}{1 \times 10^9} = 1.2 \times 10^{-5} \, \text{s}</script><script type="math/tex; mode=display">
\text{Utilization} = \frac{\text{rwnd} \times \frac{L}{R}}{\text{RTT} + \text{rwnd} \times \frac{L}{R}} \geq 0.95</script><p>解得，$\text{rwnd} \geq 4750$。</p>
<h2 id="P-22"><a href="#P-22" class="headerlink" title="P.22"></a>P.22</h2><p><strong>Questions and Answers:</strong></p>
<p>Answer true or false to the following questions and briefly justify your answer:</p>
<p><strong>a. With the SR protocol, it is possible for the sender to receive an ACK for a packet that falls outside of its current window.</strong></p>
<p><strong>True</strong>; 在 <strong>SR</strong> 协议中，由于网络延迟等原因，发送方可能收到对应于已经滑出当前窗口的数据包的 ACK。</p>
<p><strong>b. With GBN, it is possible for the sender to receive an ACK for a packet that falls outside of its current window.</strong></p>
<p><strong>False</strong>; 在 <strong>GBN</strong> 协议中，<strong>ACK</strong> 是累积的，表示所有序列号小于等于 ACK 的包已经被正确接收。</p>
<p><strong>c. The alternating-bit protocol is the same as the SR protocol with a sender and receiver window size of $1$.</strong></p>
<p><strong>True</strong>; 交替位协议是 SR 协议的一个特例，其中发送方和接收方的窗口大小均为 $1$。它只允许发送一个未确认的包，并通过序列号（$0$ 或 $1$）来区分包。</p>
<p><strong>d. The alternating-bit protocol is the same as the GBN protocol with a sender and receiver window size of $1$.</strong></p>
<p><strong>True</strong>; 交替位协议也可以看作是 GBN 协议的一个特例，其中发送方和接收方的窗口大小均为 $1$。在这种情况下，GBN 的行为与交替位协议完全一致，因为它只允许发送一个未确认的包，并在超时或收到 NAK 时重传该包。</p>
<h2 id="P-24"><a href="#P-24" class="headerlink" title="P.24"></a>P.24</h2><p><strong>Questions and Answers:</strong></p>
<p>Consider transferring an enormous file of $L$ bytes from Host A to Host B. Assume an MSS of $536$ bytes.</p>
<p><strong>a. What is the maximum value of $L$ such that TCP sequence numbers are not exhausted? Recall that the TCP sequence number field has $4$ bytes.</strong></p>
<p>TCP segment structure 中 sequence number 有 $32$ bits，从 $0$ 开始。所以最大的 $L = 2^{32} - 1$。</p>
<p><strong>b. For the $L$ you obtain in (a), find how long it takes to transmit the file. Assume that a total of $66$ bytes of transport, network, and data-link header are added to each segment before the resulting packet is sent out over a $155$ Mbps link. Ignore flow control and congestion control so A can pump out the segments back to back and continuously.</strong></p>
<ul>
<li>MSS = $536$ bytes  </li>
<li>每报文附加头部 = $66$ bytes  </li>
<li>总报文尺寸 (536 + 66 = 602) bytes  </li>
<li>报文数量  <script type="math/tex; mode=display">
N = \left\lceil \frac{L_{\max}}{\text{MSS}} \right\rceil
  = \left\lceil \frac{2^{32}-1}{536} \right\rceil
  = 8\,012\,999</script></li>
<li>总传输位数  <script type="math/tex; mode=display">
B = N \times 602\ \text{bytes} \times 8\ \tfrac{\text{bits}}{\text{byte}}
  = 8\,012\,999 \times 602 \times 8
  \approx 3.85906\times 10^{10}\ \text{bits}</script></li>
<li>链路速率 (R = 155\ \text{Mbps})  </li>
<li>传输时间  <script type="math/tex; mode=display">
T = \frac{B}{R}
  = \frac{3.85906\times 10^{10}}{155\times 10^6}
  \approx 249\ \text{秒}
  \approx 4.15\ \text{分钟}</script></li>
</ul>
<h2 id="P-25"><a href="#P-25" class="headerlink" title="P.25"></a>P.25</h2><p>Host A and B are communicating over a TCP connection, and Host B has already received from A all bytes up through byte $126$. Suppose Host A then sends two segments to Host B back-to-back. The first and second segments contain $70$ and $50$ bytes of data, respectively. In the first segment, the sequence number is $127$, the source port number is $302$, and the destination port number is $80$. Host B sends an acknowledgement whenever it receives a segment from Host A.</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. In the second segment sent from Host A to B, what are the sequence number, source port number, and destination port number?</strong></p>
<ul>
<li>The sequence number is $197$, the source port number is $302$ and the dest port number is $80$.</li>
</ul>
<p><strong>b. If the first segment arrives before the second segment, in the acknowledgement of the first arriving segment, what is the acknowledgment number, the source port number, and the destination port number?</strong></p>
<ul>
<li>The acknowledgement number is $197$, the source port number is $80$ and the dest port number is $302$.</li>
</ul>
<p><strong>c. If the second segment arrives before the first segment, in the acknowledgement of the first arriving segment, what is the acknowledgment number?</strong></p>
<ul>
<li>The acknowledgement number is $127$.</li>
</ul>
<p><strong>d. Suppose the two segments sent by A arrive in order at B. The first acknowledgement is lost and the second acknowledgement arrives after the first timeout interval. Draw a timing diagram, showing these segments and all other segments and acknowledgements sent. (Assume there is no additional packet loss.) For each segment in your figure, provide the sequence number and the number of bytes of data; for each acknowledgement that you add, provide the acknowledgement number.</strong></p>
<ul>
<li>假设：  </li>
<li>A→B 连续发送两段  </li>
<li>B 收到每段即发 ACK  </li>
<li>第一条 ACK(197) 丢失，第二条 ACK(247) 成功到达  </li>
<li>超时重传未触发（因为第二条 ACK 收到后 A 已完成确认）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>Time →<br>Host A                          Host B<br>  |                                |<br>  |-- [Seq=127, Len=70] ----------&gt;|   接收 127-196，B 发送 ACK(197) → 丢失<br>  |                                |<br>  |-- [Seq=197, Len=50] ----------&gt;|   接收 197-246，B 发送 ACK(247)<br>  |                                |<br>  |      [超时等待 ACK(197)]       |<br>  |                                |<br>  |-- [Seq=127, Len=70] ----------&gt;|   重复包，B 再次发送 ACK(247)<br>  |                                |<br>  |&lt;----------- ACK(247) ----------|   A 收到确认，确认两段都已接收<br></code></pre></td></tr></table></figure>
<h2 id="P-31"><a href="#P-31" class="headerlink" title="P.31"></a>P.31</h2><p><strong>Question and Answer:</strong></p>
<p>What is the relationship between the variable SendBase in Section $3.5.4$ and the variable LastByteRcvd in Section $3.5.5$?</p>
<p>在理想网络条件下（无丢包、延迟较小）：</p>
<script type="math/tex; mode=display">\text{SendBase} - 1 = \text{LastByteRcvd}</script><p>这是因为：</p>
<ul>
<li>接收方接收到字节序号为 n 的数据后，LastByteRcvd = n</li>
<li>接收方发送 ACK(n+1)</li>
<li>发送方收到 ACK(n+1) 后，更新 SendBase = n+1</li>
</ul>
<p>由于网络延迟、丢包等因素：</p>
<ul>
<li>LastByteRcvd 可能<strong>小于</strong> SendBase-1（发送方已收到更新的确认）</li>
<li>LastByteRcvd 可能<strong>大于</strong> SendBase-1（某些已接收数据未被确认接收）</li>
</ul>
<h2 id="P-32"><a href="#P-32" class="headerlink" title="P.32"></a>P.32</h2><p><strong>Question and Answer:</strong></p>
<p>What is the relationship between the variable $\text{LastByteRcvd}$ in Section $3.5.5$ and the variable $\text{y}$ in Section $3.5.4$?</p>
<p>由上题所述：</p>
<script type="math/tex; mode=display">
\text{acknowledgement number} = \text{LastByteRcvd} + 1</script><h2 id="P-34"><a href="#P-34" class="headerlink" title="P.34"></a>P.34</h2><p>Compare GBN, SR, and TCP (no delayed ACK). Assume that the timeout values for all three protocols are sufficiently long such that $5$ consecutive data segments and their corresponding ACKs can be received (if not lost in the channel) by the receiving host (Host B) and the sending host (Host A) respectively. Suppose Host A sends $5$ data segments to Host B, and the $2^{nd}$ segment (sent from A) is lost. In the end, all $5$ data segments have been correctly received by Host B.</p>
<p><strong>Question and Answer:</strong></p>
<p><strong>a. How many segments has Host A sent in total and how many ACKs has Host B sent in total? What are their sequence numbers? Answer this question for all three protocols.</strong></p>
<p>题目没有指定 sequence number，这里默认从 $0$ 开始，所有 segment 大小为 $1$ byte。首先，receiver 收到多少个 segment 就会回多少个 ACK。</p>
<p>首先明确各协议的ACK机制：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

| **协议** | **确认机制** | **ACK含义** |
|---------|------------|-----------|
| GBN | 累积确认 | ACK(n)表示期望收到序号n的段 |
| SR | 选择确认 | ACK(n)表示已收到序号n的段 |
| TCP | 累积确认+SACK | ACK(n)表示期望收到序号n的段 |

</div>

<p>分析 GBN 协议，第一个 segment 的 sequence number 为 $0$，以此类推，接下来的 sequence number 分别为 $1$ $2$ $3$ $4$，相应的 ACK 为 $1$ $2$ $3$ $4$ $5$。但由于第二个包丢失，实际上的 ACK 为 $1$ 丢失 $1$ $1$ $1$， 再重发，$2$ $3$ $4$ $5$。再分析剩下两个协议，最终得到</p>
<div style="display: block; margin: 0 auto; width: fit-content;">

| **Protocol**        | **Segments Sent**     | **ACKs Received**                            | **Their Sequence**                  |
|---------------------|-----------------------|----------------------------------------------|-------------------------------------|
| GBN                 | 9                   | 8                                          | 1 1 1 1 2 3 4 5      |
| SR                  | 6                   | 5                                          | 0 2 3 4 1             |
| TCP                 | 6                   | 5                                          | 1 1 1 1 5        |

</div>

<p><strong>b. If the timeout values for all three protocol are much longer than $5$ RTT, then which protocol successfully delivers all five data segments in shortest time interval?</strong></p>
<p>SR 和 TCP，因为这两种协议都只发送了 $6$ 次包。</p>
<h2 id="P-37"><a href="#P-37" class="headerlink" title="P.37"></a>P.37</h2><p><strong>Questions and Answers:</strong></p>
<p><img src="The-Transport-Layer/TCP window size as a function of time.png" srcset="/img/loading.gif" lazyload alt="TCP window size as a function of time">{style=”display: block; margin: 0 auto; width: 90%”}</p>
<p>Assuming TCP <strong>Reno</strong> is the protocol experiencing the behavior shown above, answer the following questions. In all cases, you should provide a short discussion justifying your answer.</p>
<p><strong>a. Identify the intervals of time when TCP slow start is operating.</strong></p>
<p>根据 TCP congestion control 机制，slow start phase 期间 <strong>cwnd</strong> 是以指数函数增长，从图中可以得出大概是在 $\text{Transmission round} \in [1, 6] \cup [23, 26]$ 期间。</p>
<p><strong>b. Identify the intervals of time when TCP congestion avoidance is operating</strong></p>
<p>TCP congestion avoidance 期间的特点是 <strong>cwnd</strong> 以 $ k = 1 $ MSS 的速率线性增长，从图中可以得出大概是在 $\text{Transmission round} \in [6, 16] \cup [17, 22]$ 期间。</p>
<p><strong>c. After the 16th transmission round, is segment loss detected by a triple duplicate ACK or by a timeout?</strong></p>
<p>从图中可以分析出，$\text{ssthresh} = \frac{\text{cwnd}}{2}$，$\text{cwnd} = \text{ssthresh}$，然后线性增长，所以 detected by a triple duplicate ACK。</p>
<p><strong>d. After the 22nd transmission round, is segment loss detected by a triple duplicate ACK or by a timeout?</strong></p>
<p><strong>cwnd</strong> 归一，进入 slow start phase，所以 detected by a timeout。</p>
<p><strong>e. What is the initial value of $\text{ssthresh}$ at the first transmission round?</strong></p>
<p>大概是 $32$ MSS，当 ${\text{cwnd} \geq \text{ssthresh}}$ 会进入 congestion avoidance phase，然后线性增长。</p>
<p><strong>f. What is the value of ssthresh at the $18^{th}$ transmission round?</strong></p>
<p>减半了，所以是，$\text{ssthresh} = \frac{\text{cwnd}}{2} = 21$ MSS</p>
<p><strong>g. What is the value of ssthresh at the $24^{th}$ transmission round?</strong></p>
<p>减半了，所以是，$\text{ssthresh} = \frac{\text{cwnd}}{2} = 13$ MSS</p>
<p><strong>h. During what transmission round is the $70^{th}$ segment sent?</strong></p>
<p>第一次 slow start phase 阶段后传了 63 个，所在第 $6$ 和 $7$ 轮之间。</p>
<p><strong>i. Assuming a packet loss is detected after the $26^{th}$ round by the receipt of a triple duplicate ACK, what will be the values of the congestion window size and of ssthresh?</strong></p>
<p>$\text{ssthresh} = \frac{\text{cwnd}}{2}$，$\text{cwnd} = \text{ssthresh}$，都是 $4$ segment.</p>
<p><strong>j. Suppose TCP Tahoe is used (instead of TCP Reno), and assume that triple duplicate ACKs are received at the $16^{th}$ round. What are the ssthresh and the congestion window size at the $19^{th}$ round?</strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">

| 特性 | TCP Tahoe | TCP Reno |
|------|-----------|----------|
| **三次重复ACK时** | cwnd=1MSS, 进入慢启动 | cwnd=ssthresh, 进入拥塞避免 |
| **超时事件时** | cwnd=1MSS, 进入慢启动 | cwnd=1MSS, 进入慢启动 |
| **恢复速度** | 较慢(需要重新慢启动) | 较快(可能直接进入拥塞避免) |
| **快速恢复机制** | 不支持 | 支持 |

</div>

<p>第 $16^{th}$ 出现了 triple duplicate ACKs，所以，第 $17^{th}$ $\text{ssthresh} = \frac{\text{cwnd}}{2} = 21$，$\text{cwnd} = 1$，然后进入 slow start 阶段，第 $19^{th}$ $\text{cwnd} = 4$</p>
<p><strong>k. Again suppose TCP Tahoe is used, and there is a timeout event at $22^{nd}$ round. How many packets have been sent out from $17^{th}$ round till $22^{nd}$ round, inclusive?</strong></p>
<p>需要注意的是，在第 $16^{th}$ 收到了三个 ACKs，同时，在第 $22^{th}$ 到达 ssthresh 所以实际收到 $1 + 2 + 4 + 8 + 16 + 21 = 52$ MSS。</p>
<h2 id="P-43"><a href="#P-43" class="headerlink" title="P.43"></a>P.43</h2><p>Consider that only a single TCP (Reno) connection uses one $10$ Mbps link which does not buffer any data. Suppose that this link is the only congested link between the sending and receiving hosts. Assume that the TCP sender has a huge file to send to the receiver, and the receiver’s receive buffer is much larger than the congestion window. We also make the following assumptions: each TCP segment size is $1\,500$ bytes; the two-way propagation delay of this connection is $100$ msec; and this TCP connection <strong>is always in congestion avoidance phase, that is, ignore slow start</strong>.</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. What is the maximum window size (in segments) that this TCP connection can achieve?</strong></p>
<p>最大窗口大小由 <strong>带宽延迟积(BDP)</strong> 决定：</p>
<p>首先计算 RTT：</p>
<ul>
<li>传播延迟 = $100$ 毫秒</li>
<li>传输延迟 = 段大小/带宽 = ($1500 \times 8$) 比特/($10 \times 10^6$) 比特/秒 = $1.2$ 毫秒</li>
<li><strong>总RTT</strong> = $101.2$ 毫秒</li>
</ul>
<p>带宽延迟积：</p>
<script type="math/tex; mode=display">
\text{BDP} = 10\text{ Mbps} \times 0.1012\text{ s} = 1.012 \times 10^6 \text{ bits}</script><p>也就是 PPT 上的公式：</p>
<script type="math/tex; mode=display">
\text{rate} \approx \frac{\text{cwnd}}{\text{RTT}}</script><p>最大窗口大小(段数)：</p>
<script type="math/tex; mode=display">
\text{最大窗口} = \frac{\text{BDP}}{\text{段大小}} = \frac{1.012 \times 10^6}{1500 \times 8} \approx 84.33 = \boxed{84\text{ 段}}</script><p><strong>b. What is the average window size (in segments) and average throughput (in bps) of this TCP connection?</strong></p>
<p>根据TCP Reno特性，窗口大小在拥塞避免阶段会在 $\frac{W}{2}$ 和 $W$ 之间周期变化。</p>
<p>平均窗口大小：</p>
<script type="math/tex; mode=display">
\text{平均窗口} = 0.75 \times W = 0.75 \times 84 = \boxed{63\text{ 段}}</script><p>平均吞吐量：</p>
<script type="math/tex; mode=display">
\text{平均吞吐量} = 0.75 \times \frac{W \times \text{段大小} \times 8}{\text{RTT}} = 0.75 \times \frac{84 \times 1500 \times 8}{0.1012} \approx \boxed{7.5\text{ Mbps}}</script><p><strong>c. How long would it take for this TCP connection to reach its maximum window again after recovering from a packet loss?</strong></p>
<p>在TCP Reno中，丢包后窗口大小减半，然后每个RTT增加 $1$ 个MSS：</p>
<ul>
<li>初始窗口（丢包后）= $\frac{W}{2} = 42$ 段</li>
<li>每个RTT增加 $1$ 段</li>
<li>需要增加的段数 = $\frac{W}{2} = 42$ 段</li>
<li>所需RTT数 = $42$</li>
</ul>
<script type="math/tex; mode=display">
\text{恢复时间} = 42 \times 0.1012 = \boxed{4.25\text{ 秒}}</script>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Computer-Network/" class="category-chain-item">Computer Network</a>
  
  
    <span>></span>
    
  <a href="/categories/Computer-Network/Transport-Layer/" class="category-chain-item">Transport Layer</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>The Transport Layer</div>
      <div>https://ddccffq.github.io/2025/06/08/The-Transport-Layer/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>任志诚 2023212020</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年6月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/06/09/Wireless-and-Mobile-Networks/" title="Wireless and Mobile Networks">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Wireless and Mobile Networks</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/06/07/The-Application-Layer/" title="The Application Layer">
                        <span class="hidden-mobile">The Application Layer</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
