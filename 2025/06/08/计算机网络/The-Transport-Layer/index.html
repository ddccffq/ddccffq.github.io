

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="任志诚 2023212020">
  <meta name="keywords" content="Computer Network,Transport Layer">
  
    <meta name="description" content="Transport-Layer Services Transport protocols run in end systems: - Sending side: breaks app messages into segments, passes to network layer. - Receiving side: reassembles segments into messages, passe">
<meta property="og:type" content="article">
<meta property="og:title" content="The Transport Layer">
<meta property="og:url" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/index.html">
<meta property="og:site_name" content="ddccffq&#39;s Blog">
<meta property="og:description" content="Transport-Layer Services Transport protocols run in end systems: - Sending side: breaks app messages into segments, passes to network layer. - Receiving side: reassembles segments into messages, passe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/a-transport-layer-segment.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/UDP-segment-structure.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/Reliable-data-transfer.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt1.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2-1-sender.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2-1-receiver.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2-2-sender.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2-2-receiver.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt3-0-receiver.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/Sender&#39;s-view-of-sequence-numbers-in-Go-Back-N.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/GBN-sender.png.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/GBN-receiver.png.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/RS-sender-receiver-view.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/TCP-segment-structure.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rwnd-buffer.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/TCP%20window%20size%20as%20a%20function%20of%20time.png">
<meta property="article:published_time" content="2025-06-08T07:04:40.000Z">
<meta property="article:modified_time" content="2025-06-17T02:58:02.000Z">
<meta property="article:author" content="ddccffq">
<meta property="article:tag" content="���,�㷨,����ѧϰ,���������,��������,��������,ѧϰ�ʼ�">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ddccffq.github.io/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/a-transport-layer-segment.png">
  
  
  
  <title>The Transport Layer - ddccffq&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ddccffq.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Computer Networking, A Top-Down Approach, 5th Edition"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-08 15:04" pubdate>
          2025年6月8日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          3.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          29 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Computer Networking, A Top-Down Approach, 5th Edition</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="transport-layer-services">Transport-Layer Services</h1>
<p>Transport protocols run in <strong>end systems</strong>: - Sending
side: breaks app messages into <strong>segments</strong>, passes to
network layer. - Receiving side: reassembles segments into
<strong>messages</strong>, passes to app layer.</p>
<h1 id="multiplexing-and-demultiplexing">Multiplexing and
Demultiplexing</h1>
<p><strong>Multiplexing at sending host:</strong> gather data from
multiple sockets, enveloping data with <strong>header</strong>(later
used for demultiplexing). <strong>demultiplexing at receiving
host:</strong> deliver segments to correct socket.</p>
<h2 id="demultiplexing">Demultiplexing</h2>
<p>Hosts receives <strong>IP datagrams</strong>. Each IP datagram has
source IP address and destination IP address. Each IP datagram carries a
transport-layer segment. Each segment has source port numbers and
destination port numbers.</p>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/a-transport-layer-segment.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="A transport layer segment">
<figcaption aria-hidden="true">A transport layer segment</figcaption>
</figure>
<blockquote>
<p>将 segment 传到目标 host，host 再将 segment 通过 socket 传给对应的
application。</p>
</blockquote>
<h3 id="connectionless-demultiplexing">Connectionless
Demultiplexing</h3>
<p>在 <strong>UDP</strong> 协议中使用。</p>
<p>Creates socket with <strong>port numbers</strong>. Each UDP socket
identified with <code>(dest IP address, dest port numbers)</code>.</p>
<blockquote>
<p>当终端收到 IP datagrams 中是 UDP segment 时。 The host will check
destination port in the segment and then directs the segment to
corresponding socket。发生在 transport layer。</p>
</blockquote>
<h3 id="connection-oriented-demultiplexing">Connection-oriented
Demultiplexing</h3>
<p><strong>Used in TCP protocol</strong>.</p>
<p>TCP socket identified by <strong>4</strong>-tuple:
<code>(source IP address, source port numbers, dest IP address, dest port numbers)</code>.</p>
<h1 id="connectionless-transport-udp">Connectionless Transport: UDP</h1>
<h2 id="udp-segment-structure">UDP Segment Structure</h2>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/UDP-segment-structure.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="UDP segment structure">
<figcaption aria-hidden="true">UDP segment structure</figcaption>
</figure>
<h2 id="udp-checksum">UDP Checksum</h2>
<p><strong>Goal</strong>: detect “errors” (e.g., flipped bits) in
transmitted segment. 指的是位比特发生了 <span class="math inline">\(01\)</span> 翻转。</p>
<p>“Calculation:” 1. <strong>Group Data</strong>: - Divide all fields of
the UDP segment (including header and data) into 16-bit blocks. If the
data length is odd, pad with a zero byte.
这里要注意，不同的比特排序方式会影响到最终结果，数据通常以<strong>大端序</strong>（高位字节在前）表示。</p>
<ol start="2" type="1">
<li><strong>Compute Sum</strong>:
<ul>
<li>Perform a 1’s complement sum of all 16-bit
blocks。就是二进位加法。</li>
<li>If overflow occurs (exceeds 16 bits), wrap the overflow back into
the result.</li>
</ul></li>
<li><strong>Take Complement</strong>:
<ul>
<li>Take the 1’s complement of the computed sum to get the final
checksum。这里可以看作进行了一次<strong>同位全 <span class="math inline">\(1\)</span></strong> 加法。</li>
</ul></li>
<li><strong>Fill Checksum Field</strong>:
<ul>
<li>Place the computed checksum into the checksum field of the UDP
segment.</li>
</ul></li>
</ol>
<h1 id="principles-of-reliable-data-transfer">Principles of Reliable
Data Transfer</h1>
<p><strong>应用程序即使运行在 UDP
之上，也可以实现可靠数据传输</strong>。虽然 UDP
本身是无连接、无保证的协议，不提供诸如数据包重传、顺序保证、丢包检测等机制，但<strong>应用层可以自行实现这些功能</strong>，从而达到可靠传输的目的。</p>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/Reliable-data-transfer.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="Reliable data transfer: Service model and service implementation">
<figcaption aria-hidden="true">Reliable data transfer: Service model and
service implementation</figcaption>
</figure>
<h2 id="reliable-data-transfer-over-a-perfectly-reliable-channel-rdt-1.0">Reliable
Data Transfer over a Perfectly Reliable Channel: rdt 1.0</h2>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt1.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="rdt1.0 - A protocol for a completely reliable channel">
<figcaption aria-hidden="true">rdt1.0 - A protocol for a completely
reliable channel</figcaption>
</figure>
<p><strong>Unrealistic:</strong> underlying channel perfectly reliable -
no bit errors - no loss of packets</p>
<h2 id="reliable-data-transfer-over-a-channel-with-bit-errors-rdt-2.0">Reliable
Data Transfer over a Channel with Bit Errors: rdt 2.0</h2>
<p>增添检查错误机制：checksum 和 ACK。</p>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="rdt 2.0 - A protocol for a channel with bit errors">
<figcaption aria-hidden="true">rdt 2.0 - A protocol for a channel with
bit errors</figcaption>
</figure>
<p><strong>New mechanism in rdt 2.0 (beyond rdt 1.0)</strong> - Error
detection; - <strong>Checksum</strong>. - Receiver feedback. -
<strong>ACKs and NAKs</strong>.</p>
<blockquote>
<p>rdt 2.0 有一个致命问题：如果 ACK/NAK 出错导致信息改变。</p>
</blockquote>
<h2 id="rdt-2.1">rdt 2.1</h2>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2-1-sender.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="rdt 2.1 sender">
<figcaption aria-hidden="true">rdt 2.1 sender</figcaption>
</figure>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2-1-receiver.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="rdt 2.1 receiver">
<figcaption aria-hidden="true">rdt 2.1 receiver</figcaption>
</figure>
<blockquote>
<p>可以看到 rdt 2.1 新增了一个 sequence number。在 rdt 2.0
中提到过其有着一个致命的问题，这个问题可能会导致两个问题：重传和丢失。从
Figure P.6 和 Figure P.7 可以看到 rdt 2.1
能解决重传的问题，但是不能解决丢失的问题。</p>
</blockquote>
<h2 id="rdt-2.2">rdt 2.2</h2>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2-2-sender.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="rdt2.2 sender">
<figcaption aria-hidden="true">rdt2.2 sender</figcaption>
</figure>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2-2-receiver.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="rdt2.2 receiver">
<figcaption aria-hidden="true">rdt2.2 receiver</figcaption>
</figure>
<blockquote>
<p>rdt 2.1 的机制是：如果是 NAK 或者 checksum 出错就重传。从 Figure P.8
和 Figure P.9 可以看出，receiver
收了什么序号的包就回什么序号，如果是自己要的包就 extract，然后 sender
发下个序号的包，如果重传导致 duplicate，那么只需要 delete 然后给 sender
发送 ACK。显然，receiver 回什么序号，sender 都会发下一个序号的包，也就是
rdt 2.2 没有使用 NAK 就解决了重传的问题。</p>
</blockquote>
<p>补充：</p>
<div style="display: block; margin: 0 auto; width: fit-content">
<table>

<thead>
<tr>
<th>变量/语句</th>
<th>作用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>oncethru == 1</code></td>
<td>是否第一次进入该状态</td>
</tr>
<tr>
<td><code>udt_send(sndpkt)</code></td>
<td>发送 ACK 包</td>
</tr>
<tr>
<td>结合使用</td>
<td>首次进入状态时主动重发 ACK，防止因 ACK 丢失而死锁</td>
</tr>
</tbody>
</table>
</div>
<h2 id="rdt-3.0">rdt 3.0</h2>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt3-0-receiver.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="rdt3.0 sender">
<figcaption aria-hidden="true">rdt3.0 sender</figcaption>
</figure>
<blockquote>
<p>增加了一个计时器，可以解决包丢失的问题，如果超时就重传，</p>
</blockquote>
<h2 id="pipelined-reliable-data-transfer-protocols">Pipelined Reliable
Data Transfer Protocols</h2>
<p><strong>rdt 3.0 stop-and-wait operation</strong>: rdt 3.0 can work,
but its performance stinks.</p>
<blockquote>
<p>这里是说 rdt 3.0 的机制一轮就处理一个包而效率低下。</p>
</blockquote>
<p>For example, we suppose condition with 1 Gbps link, 15 ms propagation
delay, 8000 bits packet.</p>
<p><span class="math display">\[
\text{d}_{trans} = \frac{L}{R} = \frac{8000 \text{bits}}{10^9
\text{bps}} = 8 \text{microseconds}
\]</span></p>
<p><span class="math display">\[
\text{Utilization} = \frac{\frac{L}{R}}{\text{RTT} + \frac{L}{R}} =
0.00027
\]</span></p>
<p>So, we use <strong>Pipelined Reliable Data Transfer
Protocols</strong> to increase utilization!</p>
<p><strong>Pipelining:</strong> sender allows multiple,
“in-flight”,yet-to-be-acknowledged pkts. - Range of sequence numbers
must be <strong>increased</strong>. - <strong>Buffering</strong> at
sender and/or receiver.</p>
<h3 id="go-back-n-gbn-protocol">Go-Back-N (GBN) Protocol</h3>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/Sender&#39;s-view-of-sequence-numbers-in-Go-Back-N.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="Sender’s view of sequence numbers in Go-Back-N">
<figcaption aria-hidden="true">Sender’s view of sequence numbers in
Go-Back-N</figcaption>
</figure>
<p><strong>Timeout(n):</strong> retransmit pkt <code>n</code> and all
higher seq <code>#</code> pkts in window</p>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/GBN-sender.png.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="GBN sender">
<figcaption aria-hidden="true">GBN sender</figcaption>
</figure>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/GBN-receiver.png.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="GBN receiver">
<figcaption aria-hidden="true">GBN receiver</figcaption>
</figure>
<p>需要注意的是，上述图片中是<strong>覆盖确认</strong>：</p>
<div style="display: block; margin: 0 auto; width: fit-content">
<table>

<thead>
<tr>
<th>协议类型</th>
<th>ACK 处理方式</th>
<th>base 变化方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>累计确认（GBN）</td>
<td>只确认按序最大已收到的包</td>
<td>base 只前进不回退</td>
</tr>
<tr>
<td>覆盖确认（图中）</td>
<td>收到哪个 ACK 就直接覆盖 base</td>
<td>base 可能跳跃前进</td>
</tr>
</tbody>
</table>
</div>
<h3 id="selective-repeat-sr">Selective Repeat (SR)</h3>
<p>Sender only <strong>resends</strong> pkts for which ACK not
received.</p>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/RS-sender-receiver-view.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="Selective-repeat (SR) sender and receiver views of sequence-number space">
<figcaption aria-hidden="true">Selective-repeat (SR) sender and receiver
views of sequence-number space</figcaption>
</figure>
<p><span class="math display">\[
\text{window size} \leq \frac{1}{2} \text{seq}
\]</span></p>
<h4 id="sender">Sender</h4>
<ul>
<li><strong>Data from above</strong>:
<ul>
<li>If next available sequence number is within the window, send the
packet.</li>
</ul></li>
<li><strong>Timeout(n)</strong>:
<ul>
<li>Resend packet <code>n</code>, restart the timer.</li>
</ul></li>
<li><strong>ACK(n) in [sendbase, sendbase <span class="math inline">\(+\)</span> <span class="math inline">\(N\)</span>]</strong>:
<ul>
<li>Mark packet <code>n</code> as received.</li>
<li>If <code>n</code> is the smallest unACKed packet,
<strong>advance</strong> the window base to the next unACKed sequence
number.</li>
</ul></li>
</ul>
<h4 id="receiver">Receiver</h4>
<ul>
<li><strong>Packet <code>n</code> in [rcvbase, rcvbase <span class="math inline">\(+\)</span> <span class="math inline">\(N\)</span>
<span class="math inline">\(-\)</span> <span class="math inline">\(1\)</span>]</strong>:
<ul>
<li>Send ACK(n).</li>
<li><strong>Out-of-order</strong>: Buffer the packet.</li>
<li><strong>In-order</strong>: Deliver the packet (also deliver
buffered, in-order packets), advance the window to the next
not-yet-received packet.</li>
</ul></li>
<li><strong>Packet <code>n</code> in [rcvbase <span class="math inline">\(-\)</span> <span class="math inline">\(N\)</span>,
rcvbase <span class="math inline">\(-\)</span> <span class="math inline">\(1\)</span>]</strong>:
<ul>
<li>Send ACK(n). 解决 duplicate。</li>
</ul></li>
<li><strong>Otherwise</strong>:
<ul>
<li>Ignore the packet.</li>
</ul></li>
</ul>
<h1 id="connection-oriented-transport-tcp">Connection-oriented
transport: TCP</h1>
<h2 id="tcp-segment-structure">TCP Segment Structure</h2>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/TCP-segment-structure.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="TCP segment structure">
<figcaption aria-hidden="true">TCP segment structure</figcaption>
</figure>
<p><strong>How to set sequence number and acknowledgment
number?</strong></p>
<ul>
<li><strong>sequence number</strong>: represents the byte stream number
of the first byte in the segment’s data.</li>
<li><strong>ACKs</strong>: indicates the sequence number of the next
byte expected from the sender. Using cumulative acknowledgment.</li>
</ul>
<h2 id="tcp-round-trip-time-and-timeout">TCP Round Trip Time and
Timeout</h2>
<p><strong>How to estimate <span class="math inline">\(\mathbf{RTT}\)</span>?</strong></p>
<p><span class="math display">\[
\text{EstimateRTT} = (1 - \alpha) \cdot \text{EstimateRTT} + \alpha
\cdot \text{SampleRTT}, \quad \text{Typically } \alpha = 0.125
\]</span></p>
<p><strong>How to set TCP timeout value?</strong></p>
<p>Longer than <span class="math inline">\(\text{RTT}\)</span>, but
<span class="math inline">\(\text{RTT}\)</span> varies. <span class="math display">\[
\text{DevRTT} = (1 - \beta) \cdot \text{DevRTT} + \beta \cdot
|\text{SampleRTT} - \text{EstimateRTT}|, \quad \text{Typically } \beta =
0.25
\]</span></p>
<p><span class="math display">\[
\text{TimeOutInterval} = \text{EstimateRTT} + 4 \cdot \text{DevRTT}
\]</span></p>
<h2 id="tcp-reliable-data-transfer">TCP Reliable Data Transfer</h2>
<h3 id="fast-retransmit">Fast Retransmit</h3>
<p>If sender receives <span class="math inline">\(3\)</span> ACKs for
same data, it assumes that segment after ACKed data was lost.</p>
<h2 id="flow-control">Flow control</h2>
<p>Receiver side of TCP connection has a <strong>receive
buffer</strong>.</p>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rwnd-buffer.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="The receive window (rwnd) and the receive buffer (RcvBuffer)">
<figcaption aria-hidden="true">The receive window (rwnd) and the receive
buffer (RcvBuffer)</figcaption>
</figure>
<h3 id="how-it-works">How it works?</h3>
<ul>
<li><strong>Receiver:</strong> advertises unused buffer space by
including <span class="math inline">\(\text{rwnd}\)</span> value in
segment header.</li>
<li><strong>Sender:</strong> limits unAcked bytes to <span class="math inline">\(\text{rwnd}\)</span>.</li>
</ul>
<p><span class="math display">\[
\text{rwnd} = \text{RcvBuffer} - \left[\text{LastByteRcvd} -
\text{LastByteRead} \right]
\]</span></p>
<p><strong>字节编号</strong>的问题。在TCP中：</p>
<ul>
<li>如果初始序列号为0，发送50字节后：
<ul>
<li>这些字节的序号为：0, 1, 2, …, 49</li>
<li><strong>最后一个字节</strong>的序号为49，即 LastByteRcvd = 49</li>
<li>根据公式 <span class="math inline">\(y = \text{LastByteRcvd} +
1\)</span>，得到确认号 y = 50</li>
</ul></li>
</ul>
<p>其中 y 是 ACK。</p>
<h2 id="connection-management">Connection Management</h2>
<h3 id="three-way-handshake">Three Way Handshake</h3>
<p><strong>握手协议（Handshaking Protocol）</strong>
是指在两个通信实体（如客户端和服务器）之间建立通信连接之前，双方通过一系列消息的交换，协商通信参数、确认彼此身份、同步状态等，从而为后续的数据传输做好准备的过程。</p>
<ol type="1">
<li><strong>Step 1</strong>:
<ul>
<li>Client sends TCP <code>SYN</code> segment to server, specifying
initial seq. No data.</li>
</ul></li>
<li><strong>Step 2</strong>:
<ul>
<li>Server host receives <code>SYN</code>, replies with
<code>SYNACK</code> segment. Server allocates buffers and specifies
server initial seq.</li>
</ul></li>
<li><strong>Step 3</strong>:
<ul>
<li>Client receives <code>SYNACK</code>, replies with ACK segment, which
may contain data</li>
</ul></li>
</ol>
<h3 id="closing-a-connection">Closing a Connection</h3>
<ol type="1">
<li><strong>Step 1</strong>:
<ul>
<li>Client sends TCP <code>FIN</code> segment to server, specifying
initial seq. No data.</li>
</ul></li>
<li><strong>Step 2</strong>:
<ul>
<li>Server receives <code>FIN</code>, replies with ACK. Closes
connection, sends <code>FIN</code>.</li>
</ul></li>
<li><strong>Step 3</strong>:
<ul>
<li>Client receives <code>FIN</code>, replies with ACK.</li>
</ul></li>
<li><strong>Step 4</strong>:
<ul>
<li>Server, receives ACK. Connection closed.</li>
</ul></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">客户端A                                      服务器B<br>   | ----------- SYN, Seq=1000 ------------&gt; |<br>   |                                         |<br>   | &lt;------ SYN+ACK, Seq=2000, Ack=1001 --- |<br>   |                                         |<br>   | ----------- ACK, Seq=1001, Ack=2001 --&gt; |<br></code></pre></td></tr></table></figure>
<p>上面所说的 <code>SYN</code> 和 <code>FIN</code> 都在 TCP segment 结构
header 中。</p>
<h1 id="principles-of-congestion-control">Principles of Congestion
control</h1>
<p>Too many sources sending too much data too fast for <strong>network
(router)</strong> to handle.</p>
<h2 id="approaches-towards-congestion-control">Approaches towards
Congestion Control</h2>
<ul>
<li><strong>end-end congestion control</strong>: congestion inferred
from end-system observed loss, delay.</li>
<li><strong>network-assisted congestion control</strong>: routers
provide feedback to end systems.</li>
</ul>
<h1 id="tcp-congestion-control">TCP Congestion Control</h1>
<p><strong>Goal:</strong> TCP sender should transmit as fast as
possible, but without congesting network</p>
<p><strong>probing for bandwidth:</strong> increase transmission rate on
receipt of ACK, until eventually loss occurs, then decrease transmission
rate. //一种贪心策略</p>
<p>Sender limits rate by limiting number of unACKed bytes “in pipeline”:
<span class="math display">\[
\text{LastByteSent} - \text{LastByteAcked} \leq \min \{\text{cwnd},
\text{rwnd} \}
\]</span></p>
<p><span class="math display">\[
\text{rate} \approx \frac{\text{cwnd}}{\text{RTT}}
\]</span></p>
<h2 id="slow-start-phase">Slow Start Phase</h2>
<p>When connection begins, <span class="math inline">\(\text{cwnd} = 1
\, \text{MSS}\)</span>.</p>
<blockquote>
<p><span class="math display">\[ \text{MSS} = \text{MTU} -
\text{IP头部大小} - \text{TCP头部大小} \]</span></p>
</blockquote>
<div style="display: block; margin: 0 auto; width: fit-content">
<table>

<thead>
<tr>
<th>特性</th>
<th>MSS</th>
<th>MTU</th>
</tr>
</thead>
<tbody>
<tr>
<td>所属协议层</td>
<td>传输层 (TCP)</td>
<td>数据链路层</td>
</tr>
<tr>
<td>计量对象</td>
<td>TCP 数据部分</td>
<td>整个数据包（包括所有头部）</td>
</tr>
<tr>
<td>设置目的</td>
<td>避免 IP 分片</td>
<td>适应物理媒介的限制</td>
</tr>
<tr>
<td>典型值</td>
<td>1460 字节 (以太网)</td>
<td>1500 字节 (以太网)</td>
</tr>
<tr>
<td>协商方式</td>
<td>TCP 三次握手时协商</td>
<td>网络设备固定或自动发现</td>
</tr>
</tbody>
</table>
</div>
<p>Increase rate exponentially until first <strong>loss event</strong>
or when <strong>threshold reached</strong>. - <strong>Double</strong>
cwnd every RTT. 没有发生 loss 就以指数函数增长。 - Done by incrementing
cwnd by <span class="math inline">\(1\)</span> for every ACK received.
超过 <span class="math inline">\(\text{ssthresh}\)</span>
后线性增长。</p>
<h2 id="congestion-avoidance">Congestion Avoidance</h2>
<p>When <span class="math inline">\(\text{cwnd} \geq
\text{ssthresh}\)</span>, increase <span class="math inline">\(\text{cwnd}\)</span> by <span class="math inline">\(1\)</span> <span class="math inline">\(\text{MSS}\)</span> per <span class="math inline">\(\text{RTT}\)</span>.</p>
<h2 id="tcp-reno">TCP RENO</h2>
<p><strong>Fast recovery</strong>: When triple duplicate ACKs occurs,
<span class="math inline">\(\text{ssthresh}\)</span> sets to <span class="math inline">\(\frac{\text{cwnd}}{2}\)</span>, <span class="math inline">\(\text{cwnd}\)</span> sets to <span class="math inline">\(\text{ssthresh}\)</span>. 传快了，适当减小。</p>
<p>But when <strong>timeout</strong> occurs, <span class="math inline">\(\text{ssthresh}\)</span> sets to <span class="math inline">\(\frac{\text{cwnd}}{2}\)</span>, <span class="math inline">\(\text{cwnd}\)</span> sets to <span class="math inline">\(1\)</span> <span class="math inline">\(\text{MSS}\)</span>. 丢包。</p>
<h2 id="tcp-throughput">TCP throughput</h2>
<p><strong>Question:</strong> What’s the average throughput of TCP as a
function of window size and RTT?</p>
<p><strong>Assumptions:</strong> - Ignoring slow start. - Let
<code>W</code> be the window size when loss occurs.</p>
<p><strong>Throughput Analysis:</strong> 1. <strong>When window size is
<code>W</code></strong>: - Throughput = <span class="math inline">\(\frac{W}{\text{RTT}}\)</span>.</p>
<ol start="2" type="1">
<li><strong>Just after loss</strong>:
<ul>
<li>Window size drops to <span class="math inline">\(\frac{W}{2}\)</span>.</li>
<li>Throughput = <span class="math inline">\(\frac{W}{2 \cdot
\text{RTT}}\)</span>.</li>
</ul></li>
<li><strong>Average throughput</strong>:
<ul>
<li>Average throughput = <span class="math inline">\(0.75 \cdot
\frac{W}{\text{RTT}}\)</span>.</li>
</ul></li>
</ol>
<h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1>
<h2 id="r.4">R.4</h2>
<p><strong>Question:</strong></p>
<p>Describe why an application developer might choose to run an
application over UDP rather than TCP.</p>
<p><strong>Answer:</strong></p>
<p>An application developer might choose to run an application over UDP
rather than TCP for the following reasons:</p>
<ol type="1">
<li><p><strong>Low Latency</strong>: UDP is a connectionless protocol,
meaning it does not establish a connection before sending data. This
reduces latency, making it suitable for real-time applications like
video streaming, online gaming, and voice over IP (VoIP).</p></li>
<li><p><strong>No Overhead for Reliability</strong>: Unlike TCP, UDP
does not provide reliability mechanisms such as retransmissions,
acknowledgments, or congestion control. This reduces overhead and allows
applications to handle reliability themselves if needed.</p></li>
<li><p><strong>Broadcast/Multicast Support</strong>: UDP supports
broadcasting and multicasting, which is useful for applications like
live video streaming or network discovery.</p></li>
<li><p><strong>Simple Protocol</strong>: UDP is simpler and requires
fewer resources, making it ideal for lightweight applications or systems
with limited processing power.</p></li>
<li><p><strong>Custom Error Handling</strong>: Some applications prefer
to implement their own error handling and flow control mechanisms
tailored to their specific needs, which is easier with UDP.</p></li>
<li><p><strong>Unordered Data Delivery</strong>: For applications where
the order of data packets is not critical (e.g., DNS queries), UDP is a
better choice as it does not enforce packet ordering.</p></li>
</ol>
<h2 id="p.4">P.4</h2>
<p><strong>Question:</strong> a. Suppose you have the following <span class="math inline">\(2\)</span> bytes: <span class="math inline">\(01011100\)</span> and <span class="math inline">\(01010110\)</span>. What is the <span class="math inline">\(1\)</span>s complement of the sum of these <span class="math inline">\(2\)</span> bytes? b. Suppose you have the
following <span class="math inline">\(2\)</span> bytes: <span class="math inline">\(11011010\)</span> and <span class="math inline">\(00110110\)</span>. What is the <span class="math inline">\(1\)</span>s complement of the sum of these <span class="math inline">\(2\)</span> bytes? c. For the bytes in part (a),
give an example where one bit is flipped in each of the <span class="math inline">\(2\)</span> bytes and yet the <span class="math inline">\(1\)</span>s complement doesn’t change.</p>
<p><strong>Answer:</strong> - <strong>a.</strong> <span class="math inline">\(10110010\)</span>. - <strong>b.</strong> <span class="math inline">\(00010001\)</span>. - <strong>c.</strong> <span class="math inline">\(01011110\)</span> and <span class="math inline">\(01010100\)</span>.</p>
<h2 id="p.11">P.11</h2>
<p><strong>Question:</strong></p>
<p>The sender side of <span class="math inline">\(\text{rdt}3.0\)</span>
simply ignores (that is, takes no action on) all received packets that
are either in error or have the wrong value in the acknum field of an
acknowledgment packet. Suppose that in such circumstances, <span class="math inline">\(\text{rdt}3.0\)</span> were simply to retransmit
the current data packet. Would the protocol still work? (Hint: Consider
what would happen if there were only bit errors; there are no packet
losses but premature timeouts can occur. Consider how many times the
<span class="math inline">\(n^{th}\)</span> packet is sent, in the limit
as <span class="math inline">\(n\)</span> approaches infinity.)</p>
<p><strong>Answer:</strong></p>
<p>在这种情况下，rdt <span class="math inline">\(3.0\)</span>
仍然是有效的。首先，该协议接收方可以通过检查 <strong>sequence
number</strong> 来判断当前的包是否重复，这个检查方式一直有效。原本的
<span class="math inline">\(\text{rdt}3.0\)</span>
协议在超时后会重传，但现在只要检查出 <strong>acknowledgment
packet</strong>
中出错就重传，这显然会增加网络负载，比如：在极端情况下，发送方可能会多次重传一个包，若
ACK 错误率为 <span class="math inline">\(p\)</span>，则每个数据包平均需要发送 <span class="math inline">\(1/(1-p)\)</span> 次，直到接受到正确的
<strong>ACKs</strong>。总结：<span class="math inline">\(\text{rdt}3.0\)</span>
协议在这种情况下仍然是可靠的，但立即重传错误数据包会导致性能问题，因此这种修改并不是一个好的设计选择。</p>
<h2 id="p.14">P.14</h2>
<p><strong>Question:</strong></p>
<p>Consider the cross-country example shown in Figure <span class="math inline">\(3.17\)</span>. How big would the window size have
to be for the channel utilization to be greater than <span class="math inline">\(95\)</span> percent? Suppose that the size of a
packet is <span class="math inline">\(1,500\)</span> bytes, including
both header fields and data.</p>
<p><strong>Complement:</strong> <span class="math inline">\(1\)</span>
Gbps link. RTT, is approximately <span class="math inline">\(30\)</span>
milliseconds.</p>
<p><strong>Answer:</strong></p>
<p><span class="math display">\[
\text{d}_{trans} = \frac{L}{R} = \frac{1500 \times 8}{1 \times 10^9} =
1.2 \times 10^{-5} \, \text{s}
\]</span></p>
<p><span class="math display">\[
\text{Utilization} = \frac{\text{rwnd} \times \frac{L}{R}}{\text{RTT} +
\text{rwnd} \times \frac{L}{R}} \geq 0.95
\]</span></p>
<p>解得，<span class="math inline">\(\text{rwnd} \geq
4750\)</span>。</p>
<h2 id="p.22">P.22</h2>
<p><strong>Questions and Answers:</strong></p>
<p>Answer true or false to the following questions and briefly justify
your answer:</p>
<p><strong>a. With the SR protocol, it is possible for the sender to
receive an ACK for a packet that falls outside of its current
window.</strong></p>
<p><strong>True</strong>; 在 <strong>SR</strong>
协议中，由于网络延迟等原因，发送方可能收到对应于已经滑出当前窗口的数据包的
ACK。</p>
<p><strong>b. With GBN, it is possible for the sender to receive an ACK
for a packet that falls outside of its current window.</strong></p>
<p><strong>False</strong>; 在 <strong>GBN</strong>
协议中，<strong>ACK</strong> 是累积的，表示所有序列号小于等于 ACK
的包已经被正确接收。</p>
<p><strong>c. The alternating-bit protocol is the same as the SR
protocol with a sender and receiver window size of <span class="math inline">\(1\)</span>.</strong></p>
<p><strong>True</strong>; 交替位协议是 SR
协议的一个特例，其中发送方和接收方的窗口大小均为 <span class="math inline">\(1\)</span>。它只允许发送一个未确认的包，并通过序列号（<span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>）来区分包。</p>
<p><strong>d. The alternating-bit protocol is the same as the GBN
protocol with a sender and receiver window size of <span class="math inline">\(1\)</span>.</strong></p>
<p><strong>True</strong>; 交替位协议也可以看作是 GBN
协议的一个特例，其中发送方和接收方的窗口大小均为 <span class="math inline">\(1\)</span>。在这种情况下，GBN
的行为与交替位协议完全一致，因为它只允许发送一个未确认的包，并在超时或收到
NAK 时重传该包。</p>
<h2 id="p.24">P.24</h2>
<p><strong>Questions and Answers:</strong></p>
<p>Consider transferring an enormous file of <span class="math inline">\(L\)</span> bytes from Host A to Host B. Assume an
MSS of <span class="math inline">\(536\)</span> bytes.</p>
<p><strong>a. What is the maximum value of <span class="math inline">\(L\)</span> such that TCP sequence numbers are not
exhausted? Recall that the TCP sequence number field has <span class="math inline">\(4\)</span> bytes.</strong></p>
<p>TCP segment structure 中 sequence number 有 <span class="math inline">\(32\)</span> bits，从 <span class="math inline">\(0\)</span> 开始。所以最大的 <span class="math inline">\(L = 2^{32} - 1\)</span>。</p>
<p><strong>b. For the <span class="math inline">\(L\)</span> you obtain
in (a), find how long it takes to transmit the file. Assume that a total
of <span class="math inline">\(66\)</span> bytes of transport, network,
and data-link header are added to each segment before the resulting
packet is sent out over a <span class="math inline">\(155\)</span> Mbps
link. Ignore flow control and congestion control so A can pump out the
segments back to back and continuously.</strong></p>
<ul>
<li>MSS = <span class="math inline">\(536\)</span> bytes<br>
</li>
<li>每报文附加头部 = <span class="math inline">\(66\)</span> bytes<br>
</li>
<li>总报文尺寸 (536 + 66 = 602) bytes<br>
</li>
<li>报文数量<br>
<span class="math display">\[
N = \left\lceil \frac{L_{\max}}{\text{MSS}} \right\rceil
  = \left\lceil \frac{2^{32}-1}{536} \right\rceil
  = 8\,012\,999
\]</span></li>
<li>总传输位数<br>
<span class="math display">\[
B = N \times 602\ \text{bytes} \times 8\
\tfrac{\text{bits}}{\text{byte}}
  = 8\,012\,999 \times 602 \times 8
  \approx 3.85906\times 10^{10}\ \text{bits}
\]</span></li>
<li>链路速率 (R = 155 )<br>
</li>
<li>传输时间<br>
<span class="math display">\[
T = \frac{B}{R}
  = \frac{3.85906\times 10^{10}}{155\times 10^6}
  \approx 249\ \text{秒}
  \approx 4.15\ \text{分钟}
\]</span></li>
</ul>
<h2 id="p.25">P.25</h2>
<p>Host A and B are communicating over a TCP connection, and Host B has
already received from A all bytes up through byte <span class="math inline">\(126\)</span>. Suppose Host A then sends two
segments to Host B back-to-back. The first and second segments contain
<span class="math inline">\(70\)</span> and <span class="math inline">\(50\)</span> bytes of data, respectively. In the
first segment, the sequence number is <span class="math inline">\(127\)</span>, the source port number is <span class="math inline">\(302\)</span>, and the destination port number is
<span class="math inline">\(80\)</span>. Host B sends an acknowledgement
whenever it receives a segment from Host A.</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. In the second segment sent from Host A to B, what are the
sequence number, source port number, and destination port
number?</strong> - The sequence number is <span class="math inline">\(197\)</span>, the source port number is <span class="math inline">\(302\)</span> and the dest port number is <span class="math inline">\(80\)</span>.</p>
<p><strong>b. If the first segment arrives before the second segment, in
the acknowledgement of the first arriving segment, what is the
acknowledgment number, the source port number, and the destination port
number?</strong> - The acknowledgement number is <span class="math inline">\(197\)</span>, the source port number is <span class="math inline">\(80\)</span> and the dest port number is <span class="math inline">\(302\)</span>.</p>
<p><strong>c. If the second segment arrives before the first segment, in
the acknowledgement of the first arriving segment, what is the
acknowledgment number?</strong> - The acknowledgement number is <span class="math inline">\(127\)</span>.</p>
<p><strong>d. Suppose the two segments sent by A arrive in order at B.
The first acknowledgement is lost and the second acknowledgement arrives
after the first timeout interval. Draw a timing diagram, showing these
segments and all other segments and acknowledgements sent. (Assume there
is no additional packet loss.) For each segment in your figure, provide
the sequence number and the number of bytes of data; for each
acknowledgement that you add, provide the acknowledgement
number.</strong></p>
<ul>
<li>假设：<br>
</li>
<li>A→B 连续发送两段<br>
</li>
<li>B 收到每段即发 ACK<br>
</li>
<li>第一条 ACK(197) 丢失，第二条 ACK(247) 成功到达<br>
</li>
<li>超时重传未触发（因为第二条 ACK 收到后 A 已完成确认）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>Time →<br>Host A                          Host B<br>  |                                |<br>  |-- [Seq=127, Len=70] ----------&gt;|   接收 127-196，B 发送 ACK(197) → 丢失<br>  |                                |<br>  |-- [Seq=197, Len=50] ----------&gt;|   接收 197-246，B 发送 ACK(247)<br>  |                                |<br>  |      [超时等待 ACK(197)]       |<br>  |                                |<br>  |-- [Seq=127, Len=70] ----------&gt;|   重复包，B 再次发送 ACK(247)<br>  |                                |<br>  |&lt;----------- ACK(247) ----------|   A 收到确认，确认两段都已接收<br></code></pre></td></tr></table></figure>
<h2 id="p.31">P.31</h2>
<p><strong>Question and Answer:</strong></p>
<p>What is the relationship between the variable SendBase in Section
<span class="math inline">\(3.5.4\)</span> and the variable LastByteRcvd
in Section <span class="math inline">\(3.5.5\)</span>?</p>
<p>在理想网络条件下（无丢包、延迟较小）：</p>
<p><span class="math display">\[\text{SendBase} - 1 =
\text{LastByteRcvd}\]</span></p>
<p>这是因为： - 接收方接收到字节序号为 n 的数据后，LastByteRcvd = n -
接收方发送 ACK(n+1) - 发送方收到 ACK(n+1) 后，更新 SendBase = n+1</p>
<p>由于网络延迟、丢包等因素： - LastByteRcvd 可能<strong>小于</strong>
SendBase-1（发送方已收到更新的确认） - LastByteRcvd
可能<strong>大于</strong> SendBase-1（某些已接收数据未被确认接收）</p>
<h2 id="p.32">P.32</h2>
<p><strong>Question and Answer:</strong></p>
<p>What is the relationship between the variable <span class="math inline">\(\text{LastByteRcvd}\)</span> in Section <span class="math inline">\(3.5.5\)</span> and the variable <span class="math inline">\(\text{y}\)</span> in Section <span class="math inline">\(3.5.4\)</span>?</p>
<p>由上题所述：</p>
<p><span class="math display">\[
\text{acknowledgement number} = \text{LastByteRcvd} + 1
\]</span></p>
<h2 id="p.34">P.34</h2>
<p>Compare GBN, SR, and TCP (no delayed ACK). Assume that the timeout
values for all three protocols are sufficiently long such that <span class="math inline">\(5\)</span> consecutive data segments and their
corresponding ACKs can be received (if not lost in the channel) by the
receiving host (Host B) and the sending host (Host A) respectively.
Suppose Host A sends <span class="math inline">\(5\)</span> data
segments to Host B, and the <span class="math inline">\(2^{nd}\)</span>
segment (sent from A) is lost. In the end, all <span class="math inline">\(5\)</span> data segments have been correctly
received by Host B.</p>
<p><strong>Question and Answer:</strong></p>
<p><strong>a. How many segments has Host A sent in total and how many
ACKs has Host B sent in total? What are their sequence numbers? Answer
this question for all three protocols.</strong></p>
<p>题目没有指定 sequence number，这里默认从 <span class="math inline">\(0\)</span> 开始，所有 segment 大小为 <span class="math inline">\(1\)</span> byte。首先，receiver 收到多少个 segment
就会回多少个 ACK。</p>
<p>首先明确各协议的ACK机制：</p>
<div style="display: block; margin: 0 auto; width: fit-content">
<table>
<thead>
<tr>
<th><strong>协议</strong></th>
<th><strong>确认机制</strong></th>
<th><strong>ACK含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>GBN</td>
<td>累积确认</td>
<td>ACK(n)表示期望收到序号n的段</td>
</tr>
<tr>
<td>SR</td>
<td>选择确认</td>
<td>ACK(n)表示已收到序号n的段</td>
</tr>
<tr>
<td>TCP</td>
<td>累积确认+SACK</td>
<td>ACK(n)表示期望收到序号n的段</td>
</tr>
</tbody>
</table>
</div>
<p>分析 GBN 协议，第一个 segment 的 sequence number 为 <span class="math inline">\(0\)</span>，以此类推，接下来的 sequence number
分别为 <span class="math inline">\(1\)</span> <span class="math inline">\(2\)</span> <span class="math inline">\(3\)</span>
<span class="math inline">\(4\)</span>，相应的 ACK 为 <span class="math inline">\(1\)</span> <span class="math inline">\(2\)</span>
<span class="math inline">\(3\)</span> <span class="math inline">\(4\)</span> <span class="math inline">\(5\)</span>。但由于第二个包丢失，实际上的 ACK 为
<span class="math inline">\(1\)</span> 丢失 <span class="math inline">\(1\)</span> <span class="math inline">\(1\)</span>
<span class="math inline">\(1\)</span>， 再重发，<span class="math inline">\(2\)</span> <span class="math inline">\(3\)</span>
<span class="math inline">\(4\)</span> <span class="math inline">\(5\)</span>。再分析剩下两个协议，最终得到</p>
<div style="display: block; margin: 0 auto; width: fit-content;">
<table>

<thead>
<tr>
<th><strong>Protocol</strong></th>
<th><strong>Segments Sent</strong></th>
<th><strong>ACKs Received</strong></th>
<th><strong>Their Sequence</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>GBN</td>
<td>9</td>
<td>8</td>
<td>1 1 1 1 2 3 4 5</td>
</tr>
<tr>
<td>SR</td>
<td>6</td>
<td>5</td>
<td>0 2 3 4 1</td>
</tr>
<tr>
<td>TCP</td>
<td>6</td>
<td>5</td>
<td>1 1 1 1 5</td>
</tr>
</tbody>
</table>
</div>
<p><strong>b. If the timeout values for all three protocol are much
longer than <span class="math inline">\(5\)</span> RTT, then which
protocol successfully delivers all five data segments in shortest time
interval?</strong></p>
<p>SR 和 TCP，因为这两种协议都只发送了 <span class="math inline">\(6\)</span> 次包。</p>
<h2 id="p.37">P.37</h2>
<p><strong>Questions and Answers:</strong></p>
<figure>
<img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/TCP%20window%20size%20as%20a%20function%20of%20time.png" srcset="/img/loading.gif" lazyload style="display: block; margin: 0 auto; width: 90%" alt="TCP window size as a function of time">
<figcaption aria-hidden="true">TCP window size as a function of
time</figcaption>
</figure>
<p>Assuming TCP <strong>Reno</strong> is the protocol experiencing the
behavior shown above, answer the following questions. In all cases, you
should provide a short discussion justifying your answer.</p>
<p><strong>a. Identify the intervals of time when TCP slow start is
operating.</strong></p>
<p>根据 TCP congestion control 机制，slow start phase 期间
<strong>cwnd</strong> 是以指数函数增长，从图中可以得出大概是在 <span class="math inline">\(\text{Transmission round} \in [1, 6] \cup [23,
26]\)</span> 期间。</p>
<p><strong>b. Identify the intervals of time when TCP congestion
avoidance is operating</strong></p>
<p>TCP congestion avoidance 期间的特点是 <strong>cwnd</strong> 以 $ k =
1 $ MSS 的速率线性增长，从图中可以得出大概是在 <span class="math inline">\(\text{Transmission round} \in [6, 16] \cup [17,
22]\)</span> 期间。</p>
<p><strong>c. After the 16th transmission round, is segment loss
detected by a triple duplicate ACK or by a timeout?</strong></p>
<p>从图中可以分析出，<span class="math inline">\(\text{ssthresh} =
\frac{\text{cwnd}}{2}\)</span>，<span class="math inline">\(\text{cwnd}
= \text{ssthresh}\)</span>，然后线性增长，所以 detected by a triple
duplicate ACK。</p>
<p><strong>d. After the 22nd transmission round, is segment loss
detected by a triple duplicate ACK or by a timeout?</strong></p>
<p><strong>cwnd</strong> 归一，进入 slow start phase，所以 detected by a
timeout。</p>
<p><strong>e. What is the initial value of <span class="math inline">\(\text{ssthresh}\)</span> at the first transmission
round?</strong></p>
<p>大概是 <span class="math inline">\(32\)</span> MSS，当 <span class="math inline">\({\text{cwnd} \geq \text{ssthresh}}\)</span> 会进入
congestion avoidance phase，然后线性增长。</p>
<p><strong>f. What is the value of ssthresh at the <span class="math inline">\(18^{th}\)</span> transmission round?</strong></p>
<p>减半了，所以是，<span class="math inline">\(\text{ssthresh} =
\frac{\text{cwnd}}{2} = 21\)</span> MSS</p>
<p><strong>g. What is the value of ssthresh at the <span class="math inline">\(24^{th}\)</span> transmission round?</strong></p>
<p>减半了，所以是，<span class="math inline">\(\text{ssthresh} =
\frac{\text{cwnd}}{2} = 13\)</span> MSS</p>
<p><strong>h. During what transmission round is the <span class="math inline">\(70^{th}\)</span> segment sent?</strong></p>
<p>第一次 slow start phase 阶段后传了 63 个，所在第 <span class="math inline">\(6\)</span> 和 <span class="math inline">\(7\)</span> 轮之间。</p>
<p><strong>i. Assuming a packet loss is detected after the <span class="math inline">\(26^{th}\)</span> round by the receipt of a triple
duplicate ACK, what will be the values of the congestion window size and
of ssthresh?</strong></p>
<p><span class="math inline">\(\text{ssthresh} =
\frac{\text{cwnd}}{2}\)</span>，<span class="math inline">\(\text{cwnd}
= \text{ssthresh}\)</span>，都是 <span class="math inline">\(4\)</span>
segment.</p>
<p><strong>j. Suppose TCP Tahoe is used (instead of TCP Reno), and
assume that triple duplicate ACKs are received at the <span class="math inline">\(16^{th}\)</span> round. What are the ssthresh and
the congestion window size at the <span class="math inline">\(19^{th}\)</span> round?</strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">
<table style="width:100%;">

<thead>
<tr>
<th>特性</th>
<th>TCP Tahoe</th>
<th>TCP Reno</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>三次重复ACK时</strong></td>
<td>cwnd=1MSS, 进入慢启动</td>
<td>cwnd=ssthresh, 进入拥塞避免</td>
</tr>
<tr>
<td><strong>超时事件时</strong></td>
<td>cwnd=1MSS, 进入慢启动</td>
<td>cwnd=1MSS, 进入慢启动</td>
</tr>
<tr>
<td><strong>恢复速度</strong></td>
<td>较慢(需要重新慢启动)</td>
<td>较快(可能直接进入拥塞避免)</td>
</tr>
<tr>
<td><strong>快速恢复机制</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody>
</table>
</div>
<p>第 <span class="math inline">\(16^{th}\)</span> 出现了 triple
duplicate ACKs，所以，第 <span class="math inline">\(17^{th}\)</span>
<span class="math inline">\(\text{ssthresh} = \frac{\text{cwnd}}{2} =
21\)</span>，<span class="math inline">\(\text{cwnd} =
1\)</span>，然后进入 slow start 阶段，第 <span class="math inline">\(19^{th}\)</span> <span class="math inline">\(\text{cwnd} = 4\)</span></p>
<p><strong>k. Again suppose TCP Tahoe is used, and there is a timeout
event at <span class="math inline">\(22^{nd}\)</span> round. How many
packets have been sent out from <span class="math inline">\(17^{th}\)</span> round till <span class="math inline">\(22^{nd}\)</span> round, inclusive?</strong></p>
<p>需要注意的是，在第 <span class="math inline">\(16^{th}\)</span>
收到了三个 ACKs，同时，在第 <span class="math inline">\(22^{th}\)</span>
到达 ssthresh 所以实际收到 <span class="math inline">\(1 + 2 + 4 + 8 +
16 + 21 = 52\)</span> MSS。</p>
<h2 id="p.43">P.43</h2>
<p>Consider that only a single TCP (Reno) connection uses one <span class="math inline">\(10\)</span> Mbps link which does not buffer any
data. Suppose that this link is the only congested link between the
sending and receiving hosts. Assume that the TCP sender has a huge file
to send to the receiver, and the receiver’s receive buffer is much
larger than the congestion window. We also make the following
assumptions: each TCP segment size is <span class="math inline">\(1\,500\)</span> bytes; the two-way propagation
delay of this connection is <span class="math inline">\(100\)</span>
msec; and this TCP connection <strong>is always in congestion avoidance
phase, that is, ignore slow start</strong>.</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. What is the maximum window size (in segments) that this
TCP connection can achieve?</strong></p>
<p>最大窗口大小由 <strong>带宽延迟积(BDP)</strong> 决定：</p>
<p>首先计算 RTT： - 传播延迟 = <span class="math inline">\(100\)</span>
毫秒 - 传输延迟 = 段大小/带宽 = (<span class="math inline">\(1500 \times
8\)</span>) 比特/(<span class="math inline">\(10 \times 10^6\)</span>)
比特/秒 = <span class="math inline">\(1.2\)</span> 毫秒 -
<strong>总RTT</strong> = <span class="math inline">\(101.2\)</span>
毫秒</p>
<p>带宽延迟积： <span class="math display">\[
\text{BDP} = 10\text{ Mbps} \times 0.1012\text{ s} = 1.012 \times 10^6
\text{ bits}
\]</span></p>
<p>也就是 PPT 上的公式： <span class="math display">\[
\text{rate} \approx \frac{\text{cwnd}}{\text{RTT}}
\]</span></p>
<p>最大窗口大小(段数)： <span class="math display">\[
\text{最大窗口} = \frac{\text{BDP}}{\text{段大小}} = \frac{1.012 \times
10^6}{1500 \times 8} \approx 84.33 = \boxed{84\text{ 段}}
\]</span></p>
<p><strong>b. What is the average window size (in segments) and average
throughput (in bps) of this TCP connection?</strong></p>
<p>根据TCP Reno特性，窗口大小在拥塞避免阶段会在 <span class="math inline">\(\frac{W}{2}\)</span> 和 <span class="math inline">\(W\)</span> 之间周期变化。</p>
<p>平均窗口大小： <span class="math display">\[
\text{平均窗口} = 0.75 \times W = 0.75 \times 84 = \boxed{63\text{ 段}}
\]</span></p>
<p>平均吞吐量： <span class="math display">\[
\text{平均吞吐量} = 0.75 \times \frac{W \times \text{段大小} \times
8}{\text{RTT}} = 0.75 \times \frac{84 \times 1500 \times 8}{0.1012}
\approx \boxed{7.5\text{ Mbps}}
\]</span></p>
<p><strong>c. How long would it take for this TCP connection to reach
its maximum window again after recovering from a packet
loss?</strong></p>
<p>在TCP Reno中，丢包后窗口大小减半，然后每个RTT增加 <span class="math inline">\(1\)</span> 个MSS：</p>
<ul>
<li>初始窗口（丢包后）= <span class="math inline">\(\frac{W}{2} =
42\)</span> 段</li>
<li>每个RTT增加 <span class="math inline">\(1\)</span> 段</li>
<li>需要增加的段数 = <span class="math inline">\(\frac{W}{2} =
42\)</span> 段</li>
<li>所需RTT数 = <span class="math inline">\(42\)</span></li>
</ul>
<p><span class="math display">\[
\text{恢复时间} = 42 \times 0.1012 = \boxed{4.25\text{ 秒}}
\]</span></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Computer-Network/" class="category-chain-item">Computer Network</a>
  
  
    <span>></span>
    
  <a href="/categories/Computer-Network/Transport-Layer/" class="category-chain-item">Transport Layer</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>The Transport Layer</div>
      <div>https://ddccffq.github.io/2025/06/08/计算机网络/The-Transport-Layer/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>任志诚 2023212020</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年6月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireless-and-Mobile-Networks/" title="Wireless and Mobile Networks">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Wireless and Mobile Networks</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/" title="The Application Layer">
                        <span class="hidden-mobile">The Application Layer</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"ddccffq/ddccffq.github.io","repo-id":"R_kgDOPtFBqg","category":"Announcements","category-id":"DIC_kwDOPtFBqs4CvlN9","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"bottom","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <br> <span>&copy; 2025 <a href="https://github.com/ddccffq" target="_blank">ddccffq</a>. All Rights Reserved.</span> <br> <span style="font-size: 12px; color: #999;">用代码改变世界，以技术创造价值</span> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
