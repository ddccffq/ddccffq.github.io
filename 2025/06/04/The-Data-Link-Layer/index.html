

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="任志诚 2023212020">
  <meta name="keywords" content="Computer Network,Data Link Layer">
  
    <meta name="description" content="交换机网络通信原理解析 交换机接口MAC地址的实际用途 交换机每个接口虽有MAC地址，但并非用于普通数据转发，而主要用于：  管理访问（Telnet&#x2F;SSH&#x2F;Web界面登录） 协议通信（STP生成树协议、LLDP等） 故障诊断和监控  数据帧如何通过交换机转发 关键误解在于认为数据帧的目标MAC需要是交换机的MAC。实际上：   正常帧转发过程：  主机A发送数据到F时，帧中目标MAC是路由器的M">
<meta property="og:type" content="article">
<meta property="og:title" content="The Data Link Layer">
<meta property="og:url" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/index.html">
<meta property="og:site_name" content="ddccffq的技术博客">
<meta property="og:description" content="交换机网络通信原理解析 交换机接口MAC地址的实际用途 交换机每个接口虽有MAC地址，但并非用于普通数据转发，而主要用于：  管理访问（Telnet&#x2F;SSH&#x2F;Web界面登录） 协议通信（STP生成树协议、LLDP等） 故障诊断和监控  数据帧如何通过交换机转发 关键误解在于认为数据帧的目标MAC需要是交换机的MAC。实际上：   正常帧转发过程：  主机A发送数据到F时，帧中目标MAC是路由器的M">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/Network%20adapter.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/AdaptorsCommunicating.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/Error-detectionAnd-correctionScenario.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/Two-dimensional-even-parity.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/CRCSample.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/TDA-and-FDA-example.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/pure-ALOHA-sample.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/MACAddress.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/619.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/620.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/621.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/hub.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/624.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/Three%20subnets,%20interconnected%20by%20routers.png">
<meta property="og:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/A%20link-layer%20switch%20inter-connecting%20six%20nodes.png">
<meta property="article:published_time" content="2025-06-04T07:53:36.000Z">
<meta property="article:modified_time" content="2025-06-17T05:04:04.000Z">
<meta property="article:author" content="ddccffq">
<meta property="article:tag" content="机器学习,计算机网络,算法,统计学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/The-Data-Link-Layer/Network%20adapter.png">
  
  
  
  <title>The Data Link Layer - ddccffq的技术博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ddccffq.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ddccffq的技术博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Computer Networking, A Top-Down Approach, 5th Edition"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-04 15:53" pubdate>
          2025年6月4日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          42 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Computer Networking, A Top-Down Approach, 5th Edition</h1>
            
            
              <div class="markdown-body">
                
                <h1>交换机网络通信原理解析</h1>
<h2 id="交换机接口MAC地址的实际用途">交换机接口MAC地址的实际用途</h2>
<p>交换机每个接口虽有MAC地址，但<strong>并非用于普通数据转发</strong>，而主要用于：</p>
<ul>
<li><strong>管理访问</strong>（Telnet/SSH/Web界面登录）</li>
<li><strong>协议通信</strong>（STP生成树协议、LLDP等）</li>
<li><strong>故障诊断和监控</strong></li>
</ul>
<h2 id="数据帧如何通过交换机转发">数据帧如何通过交换机转发</h2>
<p>关键误解在于认为数据帧的目标MAC需要是交换机的MAC。实际上：</p>
<ol>
<li>
<p><strong>正常帧转发过程</strong>：</p>
<ul>
<li>主机A发送数据到F时，帧中<strong>目标MAC是路由器的MAC</strong>（不是交换机）</li>
<li>交换机收到帧后<strong>不检查&quot;这是否发给我&quot;</strong></li>
<li>交换机仅通过<strong>MAC地址表查询</strong>决定从哪个端口转发出去</li>
</ul>
</li>
<li>
<p><strong>交换机的核心工作原理</strong>：</p>
<ul>
<li>交换机维护一个<strong>MAC地址表</strong>，记录&quot;哪个MAC地址在哪个端口&quot;</li>
<li>收到帧后，查表找到目标MAC对应端口</li>
<li>从对应端口转发，<strong>不修改帧内容</strong></li>
</ul>
</li>
<li>
<p><strong>同网段和跨网段通信区别</strong>：</p>
<ul>
<li><strong>同网段</strong>：源MAC→主机A，目标MAC→主机B</li>
<li><strong>跨网段</strong>：源MAC→主机A，目标MAC→<strong>路由器</strong>接口</li>
</ul>
</li>
</ol>
<h2 id="结论">结论</h2>
<p>交换机处理所有收到的有效帧，<strong>不会因为目标MAC不是自己而丢弃</strong>。这与路由器不同，路由器只处理目标MAC是自己接口MAC的帧。</p>
<p><strong>正是因为交换机不修改MAC地址并且不以自身MAC为转发判断依据</strong>，才使得以太网能够高效透明地工作。</p>
<h1>Introduction and Service</h1>
<h2 id="Some-terminology">Some terminology</h2>
<p>我们规定：</p>
<ul>
<li><strong>Nodes</strong>: hosts and routers;</li>
<li><strong>Links</strong>: communication <strong>channels</strong> that connect adjacent nodes along communication path;
<ul>
<li>wired links</li>
<li>wireless links</li>
<li>LANs</li>
</ul>
</li>
<li>layer-2 packet is a <strong>frame</strong>, encapsulates datagram.</li>
</ul>
<blockquote>
<p>这里就是在说 data link layer 的数据包叫做 frame。</p>
</blockquote>
<h2 id="Link-layer-context">Link layer: context</h2>
<p>Datagram transferred by different link protocols over different links, each  link protocol provides different services.</p>
<blockquote>
<p>不同的 link 用不同的 protocol。</p>
</blockquote>
<h2 id="Link-Layer-Services">Link Layer Services</h2>
<ul>
<li><strong>framing, link access</strong>
<ul>
<li>encapsulate datagram into frame, adding header, trailer.</li>
<li>channel access if shared medium.</li>
<li><strong>MAC</strong> addresses used in frame headers to identify source, dest.</li>
</ul>
</li>
<li><strong>reliable delivery between adjacent nodes</strong>
<ul>
<li>seldom used on low bit-error link (fiber, some twisted pair).</li>
</ul>
</li>
<li><strong>flow control</strong>
<ul>
<li>pacing between adjacent sending and receiving nodes.</li>
</ul>
</li>
<li><strong>error detection</strong>
<ul>
<li>errors caused by signal <strong>attenuation, noise</strong>.</li>
<li>receiver detects presence of errors: signals sender for retransmission or drops frame.</li>
</ul>
</li>
<li><strong>error correction</strong>
<ul>
<li>receiver identifies and <strong>corrects</strong> bit error(s) without resorting to retransmission.</li>
</ul>
</li>
<li><strong>half-duplex and full-duplex</strong>（半双工和全双工）
<ul>
<li>with half duplex, nodes at both ends of link can transmit, but not at same time.</li>
</ul>
</li>
</ul>
<h2 id="Where-is-the-link-layer-implemented">Where is the link layer implemented?</h2>
<ul>
<li>The <strong>link layer is implemented in every host</strong>.</li>
<li>It is realized through an <strong>adaptor</strong>, also known as a <strong>Network Interface Card (NIC)</strong>.
<ul>
<li>Examples include: <strong>Ethernet cards</strong>, <strong>PCMCIA cards</strong>, and <strong>802.11 wireless cards</strong>.</li>
</ul>
</li>
<li>The adaptor is responsible for implementing both the <strong>link layer</strong> and the <strong>physical layer</strong>.</li>
<li>It connects to the host via the <strong>system buses</strong>.</li>
<li>The adaptor is a <strong>combination of hardware, software, and firmware</strong>.</li>
</ul>
<p>In essence, the NIC handles the lower layers of network communication and serves as the interface between the host and the physical network.</p>
<p><img src="The-Data-Link-Layer/Network%20adapter.png" srcset="/img/loading.gif" lazyload alt="Network adapter">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p>
<h2 id="Adaptors-Communicating">Adaptors Communicating</h2>
<p><img src="The-Data-Link-Layer/AdaptorsCommunicating.png" srcset="/img/loading.gif" lazyload alt="Adaptors Communicating}">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p>
<h3 id="Sending-Side">Sending Side</h3>
<ul>
<li><strong>Encapsulates the network-layer datagram into a link-layer frame</strong>.</li>
<li><strong>Adds</strong>:
<ul>
<li><strong>Error checking bits</strong> (e.g., CRC).</li>
<li><strong>Reliable data transfer (rdt)</strong> mechanisms (if needed).</li>
<li><strong>Flow control</strong> to manage data rate between sender and receiver.</li>
</ul>
</li>
</ul>
<h3 id="Receiving-Side">Receiving Side</h3>
<ul>
<li><strong>Checks</strong> the frame for:
<ul>
<li><strong>Errors</strong> using error detection codes.</li>
<li><strong>Reliable data transfer</strong> mechanisms.</li>
<li><strong>Flow control</strong> compliance.</li>
</ul>
</li>
<li><strong>Extracts</strong> the datagram from the frame.</li>
</ul>
<h1>Error Detection and Correction</h1>
<p><img src="The-Data-Link-Layer/Error-detectionAnd-correctionScenario.png" srcset="/img/loading.gif" lazyload alt="Error detection And correction Scenario">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p>
<ul>
<li>
<p><strong>EDC (Error Detection and Correction bits)</strong>:</p>
<ul>
<li>Extra <strong>redundant bits</strong> added to data to detect and possibly correct errors during transmission.</li>
</ul>
</li>
<li>
<p><strong>D (Data)</strong>:</p>
<ul>
<li>The actual data being protected by error checking.</li>
<li>May include <strong>header fields</strong> along with the payload.</li>
</ul>
</li>
</ul>
<blockquote>
<p>也就是整个 IP datagram。</p>
</blockquote>
<ul>
<li><strong>Important Notes</strong>:
<ul>
<li><strong>Error detection is not 100% reliable</strong>.
<ul>
<li>Some errors may go undetected, though this is <strong>rare</strong>.</li>
</ul>
</li>
<li>A <strong>larger EDC field</strong> generally provides:
<ul>
<li><strong>Better error detection</strong> capability.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Parity-Checks">Parity Checks</h2>
<ul>
<li><strong>Even Parity Scheme:</strong> the total number of $1$s in the $ d + 1 $ bits is even.</li>
<li><strong>Odd Parity Scheme:</strong> the total number of $1$s in the $ d + 1 $ bits is odd.</li>
</ul>
<blockquote>
<p>偶校验和奇校验。</p>
</blockquote>
<p>If an odd number of $1$-valued bits are found with an even parity schemes, the receiver knows that at least one bit error has occurred.</p>
<h3 id="Two-dimensional-Parity">Two-dimensional Parity</h3>
<p>The receiver can thus not only <strong>detect</strong> the fact that a single bit error has occurred, but can use the column and row indices of the column and row with parity errors to actually identify the bit that was corrupted<br>
and <strong>correct</strong> that error!</p>
<p><img src="The-Data-Link-Layer/Two-dimensional-even-parity.png" srcset="/img/loading.gif" lazyload alt="Two dimensional even parity">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p>
<h2 id="Cyclic-Redundancy-Check-CRC">Cyclic Redundancy Check (CRC)</h2>
<p>An error-detection technique used widely in today’s computer networks is based on <strong>cyclic redundancy check (CRC) codes</strong>. CRC codes are also known as <strong>polynomial codes</strong>, since it is possible to view the bit string to be sent as a polynomial whose coefficients are the $0$ and $1$ values in the bit string, with operations on the bit string interpreted as polynomial arithmetic.</p>
<ul>
<li><strong>数据表示</strong>：将要发送的 $d$ 位数据 $D$ 看作一个二进制多项式。</li>
<li><strong>生成多项式 $G$</strong>：发送方和接收方事先约定一个 $r + 1$ 位的生成多项式 $G$。</li>
<li><strong>附加冗余位 $R$</strong>：发送方为 $D$ 选择 $r$ 位冗余位 $R$，并将其附加到 $D$ 后面，形成 $d + r$ 位的发送数据，使得整个 $d + r$ 位数据能被 $G$ 整除（模 2 运算下）。</li>
</ul>
<h3 id="How-the-Sender-Computes-R">How the Sender Computes $R$?</h3>
<p>简单地来讲：</p>
<ul>
<li>发送方将 $D$ 左移 $r$ 位（即在 $D$ 后面补 $r$ 个 0），得到 $D \cdot 2^r$。</li>
<li>用 $D \cdot 2^r$ 除以 $G$，得到余数 $R$。</li>
<li>将 $R$ 附加到 $D$ 后面，形成最终发送的数据。</li>
</ul>
<p><strong>公式表示：</strong><br>
$$<br>
R = \operatorname{remainder} \frac{D \cdot 2^r}{G}<br>
$$</p>
<p><img src="The-Data-Link-Layer/CRCSample.png" srcset="/img/loading.gif" lazyload alt="CRC Sample">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p>
<p>需要注意，$1 - 0 = 1$，$0 - 1 = 1$，$1 - 1 =0$，$0 - 0 = 0$，没有借位，最后的结果，比如：$11$，但是 $r = 3$，则在左侧高位补充 $0$，也就是 $R = 011$。</p>
<h1>Multiple Access Links and Protocols</h1>
<h2 id="Two-Types-of-Links">Two Types of Links</h2>
<h3 id="Point-to-Point-Links"><strong>Point-to-Point Links</strong></h3>
<ul>
<li><strong>定义</strong>：点对点链路是指仅有两个设备直接相连的通信链路。</li>
<li><strong>典型例子</strong>：
<ul>
<li>拨号上网时使用的 PPP（Point-to-Point Protocol）协议。</li>
<li>以太网交换机与主机之间的连接。</li>
</ul>
</li>
<li><strong>特点</strong>：
<ul>
<li>通信双方唯一，链路专用。</li>
<li>通常无需考虑信道竞争或冲突问题。</li>
<li>实现简单，性能稳定。</li>
</ul>
</li>
</ul>
<h3 id="Broadcast-Links"><strong>Broadcast Links</strong></h3>
<ul>
<li><strong>定义</strong>：广播链路是指多个设备共享同一个物理通信介质的链路，所有设备都能&quot;听到&quot;同一信道上的数据。</li>
<li><strong>典型例子</strong>：
<ul>
<li>早期以太网（同轴电缆共享）。</li>
<li>HFC（Hybrid Fiber-Coaxial）上行链路。</li>
<li>802.11 WiFi（无线局域网）。</li>
</ul>
</li>
<li><strong>特点</strong>：
<ul>
<li>多个节点共享信道，可能发生冲突。</li>
<li>需要多路访问协议（如CSMA/CD、ALOHA等）协调各节点的发送时机。</li>
<li>支持广播和组播通信。</li>
</ul>
</li>
</ul>
<h2 id="Multiple-Access-Protocol">Multiple Access Protocol</h2>
<ul>
<li>A <strong>single shared broadcast channel</strong> is used by multiple nodes.
<ul>
<li>If two or more nodes transmit at the same time, their signals interfere, causing a <strong>collision</strong>.</li>
</ul>
</li>
<li>A <strong>multiple access protocol</strong> is needed to coordinate transmissions.
<ul>
<li>This protocol is a distributed algorithm that determines when each node can transmit.</li>
<li>All coordination and communication about channel sharing must occur over the same channel—there is <strong>no separate control channel</strong>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>多个结点共用一条 channel 进行传输，这条 channel 同一时间只能供一个结点传输。应用 multiple access protocol 来协调。</p>
</blockquote>
<ul>
<li><strong>链路（link）</strong> 更强调<strong>连接关系</strong>，即两个节点之间的直接连接。如上文介绍的两种 <strong>links</strong>。</li>
<li><strong>信道（channel）</strong> 更强调<strong>传输资源</strong>，即数据传输所依赖的物理或逻辑媒介。</li>
<li>在点对点链路中，link 和 channel 通常是一一对应的。</li>
<li>在广播链路中，多个 link（设备间的连接）共享同一个 channel（信道）。</li>
</ul>
<h3 id="Ideal-Multiple-Access-Protocol">Ideal Multiple Access Protocol</h3>
<ul>
<li>The broadcast channel has a total rate of <strong>$R$ bps</strong>.</li>
<li>If only one node transmits, it can use the full rate <strong>$R$</strong>.</li>
<li>If <strong>$M$</strong> nodes transmit simultaneously, each gets an average rate of <strong>$R/M$</strong>.</li>
<li>The system is <strong>fully decentralized</strong>:
<ul>
<li>No central coordinator.</li>
<li>No clock or slot synchronization required.</li>
</ul>
</li>
<li>The approach is simple and efficient for sharing the channel.</li>
</ul>
<h2 id="MAC-Protocols-a-taxonomy">MAC Protocols: a taxonomy</h2>
<h3 id="Three-Broad-Classes-of-MAC-Protocols">Three Broad Classes of MAC Protocols</h3>
<ol>
<li>
<p><strong>Channel Partitioning</strong></p>
<ul>
<li>The channel is divided into smaller pieces (such as time slots, frequency bands, or codes).</li>
<li>Each node is allocated a piece for exclusive use.</li>
</ul>
</li>
<li>
<p><strong>Random Access</strong></p>
<ul>
<li>The channel is not divided; all nodes can transmit at any time.</li>
<li>Collisions may occur, but protocols are designed to <strong>detect and recover</strong> from collisions.</li>
</ul>
</li>
<li>
<p><strong>Taking Turns</strong></p>
<ul>
<li>Nodes take turns using the channel.</li>
<li>Nodes with more data to send can take longer turns.</li>
</ul>
</li>
</ol>
<h2 id="Channel-Partitioning-Protocols">Channel Partitioning Protocols</h2>
<p><strong>TDMA</strong>: Time Division Multiple Access<br>
<strong>FDMA</strong>: Frequency Division Multiple Access<br>
<strong>CDMA</strong>: Code Division Multiple Access</p>
<h3 id="TDMA">TDMA</h3>
<ul>
<li><strong>Mechanism:</strong>
<ul>
<li>Divides time into frames, and each frame into $N$ time slots (for $N$ nodes).</li>
<li>Each node is assigned a specific time slot in each frame.</li>
<li>When a node has data to send, it transmits only during its assigned slot.</li>
</ul>
</li>
<li><strong>Example:</strong>
<ul>
<li>In a four-node TDMA system, each node gets one slot per frame, and the slots repeat in a fixed order.</li>
</ul>
</li>
<li><strong>Advantages:</strong>
<ul>
<li>No collisions; perfectly fair (each node gets $R/N$ bps).</li>
</ul>
</li>
<li><strong>Drawbacks:</strong>
<ul>
<li>Each node is limited to $R/N$ bps even if others are idle.</li>
<li>Nodes must wait for their turn, even if they are the only one with data to send.</li>
</ul>
</li>
</ul>
<blockquote>
<p>只能用自己的。</p>
</blockquote>
<h3 id="FDMA">FDMA</h3>
<ul>
<li><strong>Mechanism:</strong>
<ul>
<li>Divides the total channel bandwidth ($R$ bps) into $N$ frequency bands, each with bandwidth $R/N$.</li>
<li>Each node is assigned a <strong>unique frequency band</strong> for exclusive use.</li>
</ul>
</li>
<li><strong>Example:</strong>
<ul>
<li>In a four-node FDM system, each node gets a $4$ KHz band out of a total $16$ KHz channel.</li>
</ul>
</li>
<li><strong>Advantages:</strong>
<ul>
<li>No collisions; fair bandwidth allocation.</li>
</ul>
</li>
<li><strong>Drawbacks:</strong>
<ul>
<li>Each node is limited to R/N bps, even if others are idle (same as TDMA).</li>
</ul>
</li>
</ul>
<p><img src="The-Data-Link-Layer/TDA-and-FDA-example.png" srcset="/img/loading.gif" lazyload alt="TDA and FDA example">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p>
<h3 id="CDMA">CDMA</h3>
<ul>
<li><strong>Mechanism:</strong>
<ul>
<li>Each node is assigned a unique code.</li>
<li>Nodes encode their data using their code and transmit simultaneously over the same channel.</li>
<li>Receivers use the sender’s code to decode the intended message, even in the presence of other transmissions.</li>
</ul>
</li>
<li><strong>Features:</strong>
<ul>
<li>Allows multiple nodes to transmit at the same time without collisions, as long as codes are chosen carefully.</li>
<li>Widely used in wireless and cellular networks due to its anti-jamming properties.</li>
</ul>
</li>
<li><strong>Note:</strong>
<ul>
<li>CDMA codes serve a similar role as time slots in TDMA and frequency bands in FDMA, enabling multiple access to the channel.</li>
</ul>
</li>
</ul>
<blockquote>
<p>每个节点分配一个唯一的编码，所有节点可同时发送，接收端用对应的码提取目标信号。详细过程参考第六章。</p>
</blockquote>
<h2 id="Random-Access-Protocols">Random Access Protocols</h2>
<ul>
<li>When a node has a packet to send, it transmits at the full channel data rate $\mathbf{R}$.</li>
<li>There is <strong>no prior coordination</strong> among nodes before transmission.（也就是说这个结点传输前不会考虑其它因素）</li>
<li>If two or more nodes transmit at the same time, a <strong>collision</strong> occurs.</li>
<li>A <strong>random access MAC protocol</strong> defines:（干了两件事）
<ul>
<li><strong>How to detect collisions</strong>.</li>
<li><strong>How to recover from collisions (e.g., by delaying and retransmitting)</strong>.（后传和重传）</li>
<li><strong>Examples:</strong>
<ul>
<li>Slotted ALOHA</li>
<li>ALOHA</li>
<li>CSMA, CSMA/CD, CSMA/CA</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Slotted-ALOHA">Slotted ALOHA</h3>
<p><strong>Assumptions:</strong></p>
<ul>
<li>All frames are the same size.</li>
<li>Time is divided into equal-sized slots (each slot = time to transmit one frame).</li>
<li>Nodes can only begin transmission at the start of a slot.</li>
<li>All nodes are synchronized.</li>
<li>If two or more nodes transmit in the same slot, a collision occurs and is detected by all.</li>
</ul>
<p><strong>Operation:</strong></p>
<ul>
<li>When a node has a new frame, it transmits in the next available slot.</li>
<li>If there is no collision, the node can send a new frame in the next slot.</li>
<li>If a collision occurs, the node retransmits the frame in each subsequent slot with probability $p$ until successful.</li>
</ul>
<p><strong>Pros of Slotted ALOHA:</strong></p>
<ul>
<li>A single active node can continuously transmit at the full channel rate.</li>
<li>Highly decentralized; only slot synchronization among nodes is needed.</li>
<li>Simple to implement.</li>
</ul>
<p><strong>Cons of Slotted ALOHA:</strong></p>
<ul>
<li>Collisions can occur, wasting slots.</li>
<li>Idle slots may occur, reducing efficiency.</li>
<li><strong>Nodes may detect collisions before a full packet is transmitted</strong>.</li>
<li><strong>Requires clock synchronization among all nodes</strong>.</li>
</ul>
<blockquote>
<p>前提假设不太现实，要求所有的 frame 大小相同，这样才能确保将时间分为等长的时隙有用。</p>
</blockquote>
<p><strong>同步(synchronize)</strong> 指的是：</p>
<ul>
<li>所有网络节点<strong>共享一个统一的时钟参考</strong></li>
<li>每个节点能够<strong>准确识别时隙的开始和结束时刻</strong></li>
<li>通常通过<strong>集中式时钟信号</strong>或<strong>同步协议</strong>实现</li>
</ul>
<p><strong>Slotted Aloha efficiency</strong></p>
<ul>
<li><strong>Efficiency</strong> is defined as the long-run fraction of slots that contain a successful transmission (i.e., exactly one node transmits).</li>
<li>Suppose there are $N$ nodes, each always has frames to send, and each transmits in a slot with probability $p$.</li>
<li>The probability that a given node has a successful transmission in a slot:<br>
$$p(1-p)^{N-1}$$</li>
<li>The probability that any node has a successful transmission in a slot:<br>
$$Np(1-p)^{N-1}$$</li>
<li><strong>Maximum efficiency</strong> is achieved by choosing $p^*$ that maximizes $Np(1-p)^{N-1}$.</li>
<li>As $N$ becomes very large, the maximum efficiency approaches:<br>
$$\boxed{1/e \approx 0.37}$$</li>
<li><strong>Interpretation:</strong><br>
At best, the channel is used for successful transmissions only 37% of the time.</li>
</ul>
<blockquote>
<p>当前时隙有结点传输的概率。</p>
</blockquote>
<h1>TDMA与Slotted ALOHA对比分析</h1>
<p><strong>TDMA和Slotted ALOHA并不矛盾，它们是两种不同设计理念的多址接入协议</strong>，尽管都使用了时间分片的概念。</p>
<h2 id="关键区别">关键区别</h2>
<div style="display: block; margin: 0 auto; width: fit-content">
<table>
<thead>
<tr>
<th>特性</th>
<th>TDMA</th>
<th>Slotted ALOHA</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>时隙分配</strong></td>
<td><strong>预先固定分配</strong>给特定节点</td>
<td><strong>动态竞争</strong>，任何节点可使用任何时隙</td>
</tr>
<tr>
<td><strong>传输决策</strong></td>
<td>只能在<strong>自己的专属时隙</strong>中传输</td>
<td>可以在<strong>任何时隙</strong>开始传输</td>
</tr>
<tr>
<td><strong>冲突可能性</strong></td>
<td><strong>无冲突</strong>（每个时隙专属一个节点）</td>
<td><strong>有冲突</strong>（多节点可能同时选择一个时隙）</td>
</tr>
<tr>
<td><strong>资源使用</strong></td>
<td>节点不传输时其时隙<strong>浪费</strong></td>
<td>任何节点都可以利用空闲时隙</td>
</tr>
<tr>
<td><strong>控制方式</strong></td>
<td><strong>集中式</strong>或预先协调</td>
<td><strong>分散式</strong>（各节点独立决策）</td>
</tr>
<tr>
<td><strong>最大效率</strong></td>
<td>理论上100%（无冲突）</td>
<td>理论上约37%（1/e）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="本质区别">本质区别</h2>
<ul>
<li>
<p><strong>TDMA</strong>：<strong>预分配固定时隙</strong>的&quot;预约&quot;系统</p>
<ul>
<li>类似于餐厅固定座位：每人只能坐自己的座位</li>
<li>优点：无冲突，确定性高</li>
<li>缺点：资源可能浪费，缺乏灵活性</li>
</ul>
</li>
<li>
<p><strong>Slotted ALOHA</strong>：<strong>随机竞争时隙</strong>的&quot;抢座&quot;系统</p>
<ul>
<li>类似于餐厅先到先得：谁想坐就尝试坐，有冲突就重试</li>
<li>优点：简单实现，适应突发流量</li>
<li>缺点：存在冲突，效率有限</li>
</ul>
</li>
</ul>
<p>这两种协议代表了多址接入的两种不同设计思路：<strong>静态分配</strong>与<strong>动态竞争</strong>，各有优缺点，适用于不同应用场景。</p>
<h3 id="Pure-unslotted-ALOHA">Pure (unslotted) ALOHA</h3>
<p><img src="The-Data-Link-Layer/pure-ALOHA-sample.png" srcset="/img/loading.gif" lazyload alt="pure ALOHA sample">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p>
<ul>
<li>Simpler than slotted ALOHA; <strong>no synchronization</strong> required.</li>
<li>When a frame arrives, the node <strong>transmits immediately</strong>.</li>
<li><strong>Higher collision probability</strong>:
<ul>
<li>A frame sent at time $t_0$ will collide with any other frame sent in the interval $[t_0-1, t_0+1]$.</li>
</ul>
</li>
</ul>
<p><strong>Pure (Unslotted) ALOHA Efficiency:</strong></p>
<ul>
<li>Probability of success for a given node:
<ul>
<li>$P(\text{success}) = P(\text{node transmits}) \times P(\text{no other node transmits in } [t_0-1, t_0]) \times P(\text{no other node transmits in } [t_0, t_0+1])$</li>
<li>$= p \cdot (1-p)^{N-1} \cdot (1-p)^{N-1}$</li>
<li>$= p \cdot (1-p)^{2(N-1)}$</li>
</ul>
</li>
<li><strong>Maximum efficiency</strong> (choosing optimal $p$ and letting $N \to \infty$):
<ul>
<li>$\boxed{1/(2e) \approx 0.18}$</li>
</ul>
</li>
<li><strong>Interpretation:</strong><br>
At best, the channel is used for successful transmissions only 18% of the time in pure ALOHA.</li>
</ul>
<blockquote>
<p>$t_0, , t_0 - 1, , t_0 + 1$ 三个时隙。</p>
</blockquote>
<h3 id="Carrier-Sense-Multiple-Access-CSMA">Carrier Sense Multiple Access (CSMA)</h3>
<p>发送前先侦听，发送时检测碰撞，以太网核心技术</p>
<p><strong>Carrier Sensing</strong>: a node listens to the channel before transmitting. <strong>If a frame from another node is currently being transmitted into the channel</strong>, a node then waits until it detects no transmissions for a short amount of time and then begins transmission.</p>
<p>In networks using CSMA (like <strong>traditional Ethernet or wireless</strong>), all nodes communicate over a single shared physical channel. Many network interfaces operating under CSMA protocols are designed for half-duplex communication, meaning they can either transmit OR receive at any given moment, but not both simultaneously. This is why a node can not transmit while receiving.</p>
<blockquote>
<p>半双工机制。</p>
</blockquote>
<h3 id="CSMA-with-collision-detection-CSMA-CD">CSMA with collision detection (CSMA/CD)</h3>
<p><strong>Collision Detection</strong>: a transmitting node listens to the channel while it is transmitting. If it detects that another node is transmitting an interfering frame, it stops transmitting and waits <strong>a random amount</strong> of time before repeating the sense-and-transmit-when-idle cycle.</p>
<blockquote>
<p>自己正在传的时候检测到有其他结点开始传了，停止自己的传输，随机等待一段时间后重试。</p>
</blockquote>
<h2 id="Taking-Turns-Protocols">Taking-Turns Protocols</h2>
<h3 id="Polling-Protocol">Polling Protocol</h3>
<p><strong>Polling Protocol（轮询协议）<strong>是一种</strong>轮流访问</strong>型的多路访问协议，常用于多个节点共享同一信道的场景。其核心思想是：</p>
<ul>
<li>网络中指定一个节点为<strong>主节点（master node）</strong>。</li>
<li>主节点按照固定顺序依次<strong>轮询</strong>每个从节点，询问它们是否有数据要发送。</li>
<li>只有被轮询到的节点才被允许发送数据。</li>
</ul>
<p>这个协议有着如下缺陷：</p>
<ol>
<li><strong>轮询延迟</strong>：每个节点都要等主节点轮询到自己才能发送数据，可能会有等待延迟，尤其是节点数量多时。</li>
<li><strong>主节点单点故障</strong>：如果主节点出现故障，整个信道就无法正常工作，所有通信都会中断。</li>
</ol>
<p><em><strong>Bluetooth protocol</strong></em></p>
<h3 id="Token-Passing-Protocol">Token-Passing Protocol</h3>
<p>A small, special-purpose frame known as a <strong>token</strong> is exchanged among the nodes in some fixed order.</p>
<blockquote>
<p>When a node receives a token, it holds onto the token only if it has some frames to transmit; otherwise, it immediately forwards the token to the next node. If a node does have frames to transmit when it receives the token, it sends up to a maximum number of frames and then forwards the token to the next node.</p>
</blockquote>
<p>But it has its problems as well. For example, the failure of one node can crash the entire channel. Or if a node accidentally neglects to release the token, then some recovery procedure must be invoked to get the token back in circulation.</p>
<p>将一个特制的 <strong>frame</strong> 视作一个 <strong>token</strong>，这个 token 会在结点中以一个固定的顺序传输，收到 token 的结点可以选择发送自己的 frames 或者立即传给下一个结点。缺陷：时延和崩坏。</p>
<p><em><strong>fiber distributed data interface (FDDI) protocol</strong></em></p>
<h1>Link-Layer Addressing and ARP</h1>
<h2 id="Addressing-in-Computer-Networks">Addressing in Computer Networks</h2>
<p>先回顾一下之前学过的 address。</p>
<h3 id="IP-Address-32-bit">IP Address (32-bit)</h3>
<ul>
<li><strong>Layer</strong>: Network layer address</li>
<li><strong>Primary function</strong>: Used to route datagrams to their destination IP subnet</li>
<li><strong>Scope</strong>: Global addressing for internet-wide routing</li>
</ul>
<h3 id="MAC-Address-48-bit">MAC Address (48-bit)</h3>
<ul>
<li><strong>Layer</strong>: Data link layer (physical addressing)</li>
<li><strong>Primary function</strong>: Used to transfer frames between directly connected interfaces on the same physical network</li>
<li><strong>Implementation</strong>: Permanently burned into NIC ROM hardware, though sometimes software-configurable</li>
<li><strong>Scope</strong>: Local addressing limited to a single network segment</li>
</ul>
<p>The fundamental distinction is that IP addresses enable routing across multiple networks, while MAC addresses handle the physical delivery between devices on the same network segment.</p>
<ul>
<li><strong>IP 地址</strong>：用于在不同网络之间进行路由，确保数据能够跨越多个网络到达最终目标。</li>
<li><strong>MAC 地址</strong>：用于在同一个网络段（如同一个局域网）内实现设备之间的物理交付。</li>
<li><strong>IP 地址</strong>负<strong>找路</strong>，确定数据应该到哪个网络。</li>
<li><strong>MAC 地址</strong>负责<strong>最后一公里</strong>，在本地网络中找到具体的设备。</li>
<li>路由器转发数据时，每经过一跳，都会用新的 MAC 地址封装数据帧，但 IP 地址保持不变。</li>
</ul>
<p>假设主机 A 要给主机 B 发送数据：</p>
<ol>
<li><strong>跨网传输</strong>：数据包通过多个路由器，依靠 IP 地址进行路由选择。</li>
<li><strong>到达目标网络</strong>：最后一跳，数据包到达 B 所在的局域网。</li>
<li><strong>本地交付</strong>：A 通过 ARP 协议获取 B 的 MAC 地址，将数据帧封装后，通过以太网物理传输到 B。</li>
</ol>
<h2 id="MAC-Addresses-and-ARP">MAC Addresses and ARP</h2>
<p><img src="The-Data-Link-Layer/MACAddress.png" srcset="/img/loading.gif" lazyload alt="MAC Address">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p>
<p>Broadcast address = <code>FF-FF-FF-FF-FF-FF</code></p>
<h3 id="MAC-Address-Administration">MAC Address Administration</h3>
<ul>
<li>
<p><strong>分配权威（Allocation Authority）</strong><br>
MAC 地址空间由 <strong>IEEE（电气和电子工程师协会）</strong> 统一管理和分配，确保全球唯一性。</p>
</li>
<li>
<p><strong>分配流程（Assignment Process）</strong><br>
各网络设备制造商需要向 IEEE 购买一批 MAC 地址块。这样，每个厂商生产的设备都能分配到唯一的 MAC 地址，避免地址冲突。</p>
</li>
<li>
<p><strong>结构（Structure）</strong><br>
MAC 地址总长 48 位，<strong>前 24 位</strong>通常用来标识制造商（称为 OUI，Organizationally Unique Identifier，组织唯一标识符），后 24 位由厂商自行分配给各自的设备。</p>
</li>
</ul>
<h3 id="Conceptual-Comparison">Conceptual Comparison</h3>
<ul>
<li>
<p><strong>MAC Address</strong>: Similar to a Social Security Number</p>
<ul>
<li>Permanent identifier tied to hardware</li>
<li>Remains with the device regardless of location</li>
</ul>
</li>
<li>
<p><strong>IP Address</strong>: Similar to a postal address</p>
<ul>
<li>Indicates location in the network topology</li>
<li>Changes when moving between networks</li>
</ul>
</li>
</ul>
<h3 id="Address-Structure-Implications">Address Structure Implications</h3>
<ul>
<li>
<p><strong>MAC Address (Flat)</strong>:</p>
<ul>
<li>Provides portability</li>
<li>LAN card maintains its address when moved between networks</li>
<li>No inherent network location information</li>
</ul>
</li>
<li>
<p><strong>IP Address (Hierarchical)</strong>:</p>
<ul>
<li>Not portable across networks</li>
<li>Contains network prefix that identifies subnet</li>
<li>Must change when moving to a different subnet</li>
<li>Enables efficient routing across internet</li>
</ul>
</li>
</ul>
<p>This fundamental difference in addressing philosophy reflects the different purposes of each address type: MAC for unique hardware identification, IP for routable network location.</p>
<h2 id="Address-Resolution-Protocol-ARP">Address Resolution Protocol (ARP)</h2>
<p>The Address Resolution Protocol (ARP) is used to discover the MAC address associated with a known IP address on the same local network:</p>
<ol>
<li>
<p><strong>Check Local ARP Table First</strong></p>
<ul>
<li>Every IP-enabled device maintains an ARP table</li>
<li>The table contains mappings of IP addresses to MAC addresses</li>
<li>Each entry format: <code>&lt;IP address; MAC address; TTL&gt;</code></li>
<li>TTL (Time To Live): Typically 20 minutes before entry expires</li>
</ul>
</li>
<li>
<p><strong>If MAC Address Not in Table:</strong></p>
<ul>
<li>Device broadcasts an ARP request to all devices on LAN</li>
<li>Uses broadcast MAC address: FF-FF-FF-FF-FF-FF</li>
<li>The request asks: &quot;Who has IP address B? Send your MAC address&quot;</li>
</ul>
</li>
<li>
<p><strong>Resolution Process:</strong></p>
<ul>
<li>Only the device with IP address B responds</li>
<li>Device B sends its MAC address directly to requester</li>
<li>Requester adds the IP-to-MAC mapping to its ARP table</li>
<li>Communication can now proceed using the discovered MAC address</li>
</ul>
</li>
<li>
<p><strong>When Entry Expires:</strong></p>
<ul>
<li>After TTL expires, the mapping is removed from ARP table</li>
<li>A new ARP request must be sent if communication is needed again</li>
</ul>
</li>
</ol>
<p>ARP is essential because link-layer delivery requires MAC addresses, while applications and higher protocols use IP addresses.</p>
<h2 id="ARP-Protocol-Same-LAN-Network">ARP Protocol: Same LAN (Network)</h2>
<p>When host A wants to send a datagram to host B on the same local network but doesn’t have B’s MAC address:</p>
<h3 id="ARP-Request-Process">ARP Request Process</h3>
<ul>
<li>Host A broadcasts an ARP query packet containing B’s IP address</li>
<li>Destination MAC address = <code>FF-FF-FF-FF-FF-FF</code> (broadcast address)</li>
<li>All machines on the LAN receive the ARP query</li>
<li>Only host B (with the matching IP address) processes and responds</li>
</ul>
<h3 id="ARP-Response">ARP Response</h3>
<ul>
<li>Host B replies to A with its (B’s) MAC address</li>
<li>Frame is sent directly to A’s MAC address (unicast)</li>
<li>A adds the IP-to-MAC mapping to its ARP table</li>
</ul>
<h3 id="Caching-Mechanism">Caching Mechanism</h3>
<ul>
<li>A caches (saves) the IP-to-MAC address pair in its ARP table</li>
<li>Mapping remains until the information becomes old (times out)</li>
<li>This is &quot;soft state&quot;: information expires unless refreshed through use</li>
</ul>
<h3 id="Key-Characteristics">Key Characteristics</h3>
<ul>
<li><strong>Self-configuring</strong>: ARP is &quot;plug-and-play&quot;</li>
<li><strong>Distributed</strong>: Nodes create their ARP tables without intervention from network administrators</li>
<li><strong>Automatic</strong>: Mappings are created and maintained dynamically as needed</li>
</ul>
<blockquote>
<p>自己也会创建置换表</p>
</blockquote>
<h2 id="Addressing-routing-to-another-LAN">Addressing: routing to another LAN</h2>
<p><img src="The-Data-Link-Layer/619.png" srcset="/img/loading.gif" lazyload alt="routing to another LAN">{style=&quot;display: block; margin: 0 auto; width: 100%&quot;}</p>
<h2 id="Routing-Between-Different-LANs-Link-Layer-Process">Routing Between Different LANs: Link-Layer Process</h2>
<p>When data travels between hosts on different networks, the router plays a critical intermediary role:</p>
<h3 id="Initial-Transmission-Source-Network">Initial Transmission (Source Network)</h3>
<ol>
<li>
<p>Host A creates an IP datagram with:</p>
<ul>
<li>Source IP address: Host A’s address</li>
<li>Destination IP address: Host B’s address (on different LAN)</li>
</ul>
</li>
<li>
<p>Host A determines B is on another network, so packet must go through router R:</p>
<ul>
<li>A uses ARP to resolve router interface IP (111.111.111.110) to R’s MAC address</li>
<li>A creates an Ethernet frame with:
<ul>
<li>Destination: R’s MAC address</li>
<li>Source: A’s MAC address</li>
<li>Payload: The A-to-B IP datagram</li>
</ul>
</li>
</ul>
</li>
<li>
<p>A’s network interface card transmits this frame onto the LAN</p>
</li>
</ol>
<blockquote>
<p>从此可以看出，LAN 内部是通过以太网传输数据的，用的是 MAC address。</p>
</blockquote>
<h3 id="Router-Processing">Router Processing</h3>
<ol start="4">
<li>
<p>Router R’s interface receives the frame (recognizes its MAC address)</p>
</li>
<li>
<p>R extracts the IP datagram from the frame, examines the IP header:</p>
<ul>
<li>Sees destination IP is for host B on another network</li>
<li>Consults routing table to determine next hop</li>
</ul>
</li>
<li>
<p>R prepares to forward to the destination network:</p>
<ul>
<li>Uses ARP to resolve B’s IP address to B’s MAC address</li>
<li>Creates a new Ethernet frame with:
<ul>
<li>Destination: B’s MAC address</li>
<li>Source: R’s MAC address (interface on B’s network)</li>
<li>Payload: The original A-to-B IP datagram (unchanged)</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>R 在不同网络段代表不同的路由器接口。</p>
</blockquote>
<h3 id="Final-Delivery-Destination-Network">Final Delivery (Destination Network)</h3>
<ol start="7">
<li>
<p>Router’s interface on B’s network transmits the new frame</p>
</li>
<li>
<p>Host B receives the frame, extracts and processes the IP datagram</p>
</li>
</ol>
<p>Note: The IP datagram remains unchanged throughout this process, while the frame addressing changes at each network segment.</p>
<h1>Ethernet</h1>
<h2 id="The-Dominant-Wired-LAN-Technology">The Dominant Wired LAN Technology</h2>
<ul>
<li><strong>Cost-effective</strong>: Extremely affordable - approximately $20 for a Network Interface Card</li>
<li><strong>Pioneer technology</strong>: First widely used LAN technology, establishing the foundation for modern networks</li>
<li><strong>Simplicity and economy</strong>: Significantly simpler and more economical than token LANs and ATM alternatives</li>
<li><strong>Scalable performance</strong>: Successfully kept pace with speed requirements over decades:
<ul>
<li>Started at 10 Mbps</li>
<li>Evolved through 100 Mbps and 1 Gbps</li>
<li>Now supports up to 10 Gbps and beyond</li>
</ul>
</li>
</ul>
<p>Ethernet’s combination of low cost, simplicity, and adaptability to increasing performance demands has secured its position as the predominant wired networking technology in local area networks worldwide.</p>
<h2 id="Ethernet-Physical-Topologies">Ethernet Physical Topologies</h2>
<h3 id="Historical-Evolution">Historical Evolution</h3>
<ul>
<li><strong>Bus topology</strong>: Popular through mid-1990s
<ul>
<li>All nodes connected to a common shared cable</li>
<li><strong>Single collision domain</strong>: All nodes could interfere with each other’s transmissions</li>
<li>When one node transmitted, all others had to wait</li>
<li>Limited scalability due to increasing collision probability with more nodes</li>
</ul>
</li>
</ul>
<blockquote>
<p>前面提到过</p>
</blockquote>
<h3 id="Modern-Configuration">Modern Configuration</h3>
<ul>
<li><strong>Star topology</strong>: Dominant configuration today
<ul>
<li><strong>Central active switch</strong>: Intelligent device at center of network</li>
<li>Point-to-point links between switch and end devices</li>
<li><strong>Separate collision domains</strong>: Each link operates as an independent Ethernet segment</li>
<li>Nodes connected to different switch ports cannot directly collide with each other</li>
<li>Dramatically improved performance and reliability compared to bus topology</li>
</ul>
</li>
</ul>
<p>The shift from bus to star topology represents a fundamental advance in Ethernet technology, effectively eliminating the collision problems that limited earlier implementations.</p>
<h2 id="Ethernet-frame-structure">Ethernet frame structure</h2>
<p><img src="The-Data-Link-Layer/620.png" srcset="/img/loading.gif" lazyload alt="Ethernet frame structure">{style=&quot;display: block; margin: 0 auto; width: 100%&quot;}</p>
<ul>
<li>
<p><strong>Preamble</strong>:</p>
<ul>
<li>7 bytes with pattern 10101010 followed by one byte with pattern 10101011</li>
<li>Used to synchronize receiver and sender clock rates</li>
<li>Allows receivers to &quot;lock onto&quot; the sender’s transmission timing</li>
</ul>
</li>
<li>
<p><strong>Addresses</strong>: 6 bytes each</p>
<ul>
<li>Destination MAC address (first)</li>
<li>Source MAC address (second)</li>
<li>Processing logic:
<ul>
<li>If adapter receives frame with matching destination address or broadcast address (FF-FF-FF-FF-FF-FF), it passes data to network layer</li>
<li>Otherwise, adapter <strong>discards the frame</strong></li>
<li>Broadcast frames (e.g., ARP packets) are processed by all recipients</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Type</strong>: 2 bytes</p>
<ul>
<li>Indicates the higher layer protocol encapsulated in the frame payload</li>
<li>Common values:
<ul>
<li>0x0800: IPv4</li>
<li>0x0806: ARP</li>
<li>0x86DD: IPv6</li>
<li>Other protocols: Novell IPX, AppleTalk, etc.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>CRC</strong>: 4 bytes (32 bits)</p>
<ul>
<li>Cyclic Redundancy Check for error detection</li>
<li>Checked at receiver</li>
<li>If error is detected, frame is <strong>immediately dropped</strong></li>
<li>No error correction or retransmission at Ethernet level</li>
</ul>
</li>
<li>
<p>**Preamble（前导码）**是以太网帧结构中的一个字段。</p>
</li>
<li>
<p>由<strong>7 个字节的 10101010 模式</strong>，后跟<strong>1 个字节的 10101011</strong> 组成。</p>
</li>
<li>
<p><strong>时钟同步</strong>：用于同步接收端和发送端的时钟速率。</p>
</li>
<li>
<p><strong>锁定信号</strong>：让接收方能够<strong>锁定</strong>到发送方的传输时序，确保后续数据能被准确采样和解析。</p>
</li>
</ul>
<h2 id="Ethernet-Key-Characteristics">Ethernet: Key Characteristics</h2>
<h3 id="Connectionless-Protocol">Connectionless Protocol</h3>
<ul>
<li><strong>No handshaking</strong> between transmitting and receiving Network Interface Cards (NICs)</li>
<li>Each frame is sent independently without establishing a connection first</li>
<li>Sender simply transmits frames when the medium is available</li>
<li>No session establishment or termination phases</li>
</ul>
<h3 id="Unreliable-Service">Unreliable Service</h3>
<ul>
<li><strong>No acknowledgments (ACKs)</strong> or negative acknowledgments (NACKs) sent by receiving NICs</li>
<li>Sending NIC has no built-in way to know if frames were successfully delivered</li>
<li>Corrupted frames are simply discarded by the receiver (detected via CRC)</li>
<li>No automatic retransmission mechanism at the Ethernet level</li>
</ul>
<h3 id="Implications-for-Data-Delivery">Implications for Data Delivery</h3>
<ul>
<li>Stream of datagrams passed to the network layer may contain <strong>gaps</strong> (missing datagrams)</li>
<li>If the application uses TCP (Transport layer):
<ul>
<li>Gaps will be detected and filled through TCP’s reliable delivery mechanisms</li>
<li>End users won’t see missing data</li>
</ul>
</li>
<li>If using UDP or other unreliable protocols:
<ul>
<li>Application will see the gaps and must handle them if needed</li>
<li>Responsibility for reliability shifts to the application layer</li>
</ul>
</li>
</ul>
<h3 id="Medium-Access-Control">Medium Access Control</h3>
<ul>
<li>Ethernet’s MAC protocol: <strong>unslotted CSMA/CD</strong> (Carrier Sense Multiple Access with Collision Detection)</li>
<li>Provides a way to share the communication medium among multiple devices</li>
<li>Modern switched Ethernet largely eliminates collisions, but the protocol foundation remains</li>
</ul>
<h2 id="CSMA-CD-Algorithm-in-Ethernet">CSMA/CD Algorithm in Ethernet</h2>
<p>Ethernet’s original medium access control protocol uses CSMA/CD (Carrier Sense Multiple Access with Collision Detection) to handle shared medium access:</p>
<h3 id="Step-by-Step-Process">Step-by-Step Process</h3>
<ol>
<li>
<p><strong>Frame Creation</strong></p>
<ul>
<li>NIC receives datagram from network layer</li>
<li>Creates an Ethernet frame with appropriate headers</li>
</ul>
</li>
<li>
<p><strong>Channel Sensing</strong></p>
<ul>
<li>If NIC senses channel is <strong>idle</strong>: begins frame transmission immediately</li>
<li>If NIC senses channel is <strong>busy</strong>: waits until channel becomes idle, then transmits</li>
</ul>
</li>
<li>
<p><strong>Successful Transmission</strong></p>
<ul>
<li>If NIC transmits the entire frame without detecting another transmission</li>
<li>Transmission is complete and successful</li>
</ul>
</li>
<li>
<p><strong>Collision Handling</strong></p>
<ul>
<li>If NIC detects another transmission while transmitting</li>
<li>Immediately aborts transmission</li>
<li><strong>Sends a brief jam signal to ensure all stations recognize the collision</strong></li>
</ul>
</li>
<li>
<p><strong>Exponential Backoff</strong></p>
<ul>
<li>After aborting, NIC enters exponential backoff procedure:</li>
<li>After the mᵗʰ collision, NIC chooses K randomly from {0,1,2,…,2ᵐ-1}</li>
<li>NIC waits <strong>K·512 bit times</strong> before attempting retransmission</li>
<li>Returns to Step 2 to attempt transmission again</li>
</ul>
</li>
</ol>
<p>The exponential backoff mechanism ensures that after repeated collisions, stations spread their retransmission attempts over increasingly longer intervals, reducing the probability of repeated collisions.</p>
<h2 id="Ethernet’s-CSMA-CD-Technical-Details">Ethernet’s CSMA/CD: Technical Details</h2>
<h3 id="Collision-Handling-Components">Collision Handling Components</h3>
<ul>
<li>
<p><strong>Jam Signal</strong>:</p>
<ul>
<li>48-bit signal transmitted after detecting a collision</li>
<li>Purpose: Ensures all transmitting stations are aware of the collision</li>
<li>Small, fixed size makes collision detection efficient</li>
<li>Contains a deliberate pattern that cannot be mistaken for valid data</li>
</ul>
</li>
<li>
<p><strong>Bit Time</strong>:</p>
<ul>
<li>The time required to transmit one bit on the network</li>
<li><strong>For $10$ Mbps Ethernet: $0.1$ microseconds per bit</strong></li>
<li>Used as the basic time unit for backoff calculations</li>
<li>For <strong>$K = 1023$ (maximum backoff value)</strong>, wait time is approximately $50$ milliseconds</li>
</ul>
</li>
</ul>
<h3 id="Exponential-Backoff-Algorithm">Exponential Backoff Algorithm</h3>
<ul>
<li>
<p><strong>Goal</strong>: Adaptively adjust retransmission timing based on estimated network load</p>
<ul>
<li>Under heavy load conditions, stations wait longer before retrying</li>
<li>Helps prevent collision cascades when multiple stations are competing for access</li>
</ul>
</li>
<li>
<p><strong>Progressive Backoff Process</strong>:</p>
<ul>
<li>After first collision: Choose K randomly from ${0,1}$
<ul>
<li>Wait time = $K × 512$ bit transmission times</li>
</ul>
</li>
<li>After second collision: Choose K randomly from ${0,1,2,3}$</li>
<li>After third collision: Choose K randomly from ${0,1,2,3,4,5,6,7}$</li>
<li>Pattern continues: After nth collision, range is ${0,1,2,…,2^n-1}$</li>
<li>After tenth collision: Choose K randomly from ${0,1,2,…,1023}$</li>
<li><strong>Maximum range is capped at ${0,1,2,…,1023}$ even after more collisions</strong></li>
</ul>
</li>
</ul>
<p>This adaptive algorithm ensures efficient channel utilization by dynamically adjusting to network congestion levels, minimizing repeated collisions while maintaining reasonable access times.</p>
<h2 id="CSMA-CD-efficiency">CSMA/CD efficiency</h2>
<ul>
<li>$t_{prop}$: max prop delay between $2$ nodes in LAN;</li>
<li>$t_{trans}$: time to transmit max-size frame.</li>
</ul>
<p>$$<br>
\text{efficiency} = \frac{1}{1 + \frac{5 t_{prop}}{t_{trans}}}<br>
$$</p>
<h2 id="Ethernet-Standards-Link-Physical-Layers">Ethernet Standards: Link &amp; Physical Layers</h2>
<p><img src="The-Data-Link-Layer/621.png" srcset="/img/loading.gif" lazyload alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 100%&quot;}</p>
<ul>
<li>
<p><strong>Common Foundation</strong>:</p>
<ul>
<li>All Ethernet variants share the same <strong>MAC protocol</strong> principles</li>
<li><strong>Frame format</strong> remains consistent across implementations</li>
<li>Upper layers interact with Ethernet through the same interface regardless of physical medium</li>
</ul>
</li>
<li>
<p><strong>Speed Evolution</strong>:</p>
<ul>
<li><strong>2 Mbps</strong>: Early experimental implementations</li>
<li><strong>10 Mbps</strong>: Original Ethernet standard (10BASE-T)</li>
<li><strong>100 Mbps</strong>: Fast Ethernet (100BASE-TX, 100BASE-FX)</li>
<li><strong>1 Gbps</strong>: Gigabit Ethernet (1000BASE-T, 1000BASE-SX/LX)</li>
<li><strong>10 Gbps</strong>: 10 Gigabit Ethernet (10GBASE-T, 10GBASE-SR/LR)</li>
<li><strong>Higher speeds</strong>: 40 Gbps, 100 Gbps, 400 Gbps technologies now available</li>
</ul>
</li>
<li>
<p><strong>Physical Media Diversity</strong>:</p>
<ul>
<li><strong>Copper cable</strong>:
<ul>
<li>Twisted pair (Cat5e, Cat6, Cat6a, Cat7)</li>
<li>Coaxial cable (older implementations)</li>
</ul>
</li>
<li><strong>Optical fiber</strong>:
<ul>
<li>Multimode fiber (shorter distances)</li>
<li>Single-mode fiber (longer distances)</li>
<li>Various wavelengths and transmission techniques</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This standardized approach allows equipment from different manufacturers to interoperate while enabling continuous performance improvements through new physical layer technologies.</p>
<h1>Link-Layer Switches</h1>
<h2 id="Hubs">Hubs</h2>
<p>physical-layer (dumb) repeaters:</p>
<ul>
<li>bits coming in one link go out all other links at same rate</li>
<li>all nodes connected to hub can collide with one another</li>
<li>no frame buffering</li>
<li>no CSMA/CD at hub: host NICs detect collisions</li>
</ul>
<p><img src="The-Data-Link-Layer/hub.png" srcset="/img/loading.gif" lazyload alt="hub">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p>
<h2 id="Switch">Switch</h2>
<ul>
<li>
<p><strong>Link-layer intelligence</strong>:</p>
<ul>
<li>Smarter than hubs, taking an active role in network traffic management</li>
<li>Process frames at the data link layer (Layer 2) rather than merely repeating signals</li>
<li>Make forwarding decisions based on MAC addresses</li>
</ul>
</li>
<li>
<p><strong>Store-and-forward operation</strong>:</p>
<ul>
<li>Receive complete frames before forwarding</li>
<li>Buffer frames in memory, allowing for collision domain isolation</li>
<li>Check frames for errors (using CRC) before forwarding, improving network reliability</li>
</ul>
</li>
<li>
<p><strong>Selective forwarding</strong>:</p>
<ul>
<li>Examine incoming frame’s destination MAC address</li>
<li>Forward frame only to the specific port where destination device is connected</li>
<li>Send to multiple ports only when necessary (broadcasts, unknown destinations)</li>
<li>When forwarding frames onto a segment, uses CSMA/CD to access the medium</li>
</ul>
</li>
<li>
<p><strong>Transparent operation</strong>:</p>
<ul>
<li>Hosts are completely unaware of switches’ presence in the network</li>
<li>End devices communicate as if directly connected</li>
<li>No modification of frame content during transit through switch</li>
</ul>
</li>
<li>
<p><strong>Plug-and-play functionality</strong>:</p>
<ul>
<li>Self-learning capability builds forwarding tables automatically</li>
<li>Observes source MAC addresses of incoming frames to learn device locations</li>
<li>Dynamically updates tables when devices move to different ports</li>
<li>No manual configuration required for basic operation</li>
</ul>
</li>
</ul>
<p>These capabilities allow switches to significantly improve network performance by creating separate collision domains for each port while maintaining the same Ethernet protocol standards.</p>
<h3 id="Switch-Advanced-Link-Layer-Functionality">Switch: Advanced Link-Layer Functionality</h3>
<ul>
<li>
<p><strong>Simultaneous transmissions</strong>:</p>
<ul>
<li>Allows multiple pairs of nodes to transmit concurrently</li>
<li>Different ports can carry independent data streams at the same time</li>
<li>Dramatically increases total network throughput compared to hubs</li>
</ul>
</li>
<li>
<p><strong>Dedicated connections</strong>:</p>
<ul>
<li>Each host has a dedicated, direct connection to the switch</li>
<li>Full bandwidth of the link is available to each host-switch connection</li>
<li>No competition for bandwidth between devices on different ports</li>
</ul>
</li>
<li>
<p><strong>Frame buffering</strong>:</p>
<ul>
<li>Switches contain memory to store frames temporarily</li>
<li>Can hold frames when output ports are busy</li>
<li>Prevents frame loss during periods of network congestion</li>
<li>Enables handling of traffic between different speed interfaces</li>
</ul>
</li>
<li>
<p><strong>Collision elimination</strong>:</p>
<ul>
<li>Ethernet protocol used on each link but without collisions</li>
<li>Full-duplex operation: simultaneous transmission and reception</li>
<li>Each link is its own separate collision domain</li>
<li>CSMA/CD no longer needed on point-to-point links to switch</li>
</ul>
</li>
<li>
<p><strong>Parallel communications</strong>:</p>
<ul>
<li>Host A can transmit to host A’ while host B simultaneously transmits to host B’</li>
<li>No interference between unrelated data flows</li>
<li>Example: In a network with hosts A, A’, B, and B’ all connected to a switch:
<ul>
<li>A→A’ and B→B’ transmissions occur in parallel</li>
<li>Network throughput effectively multiplied by number of concurrent transmissions</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Contrast with hubs</strong>:</p>
<ul>
<li>Hubs force a single shared collision domain among all connected devices</li>
<li>Only one device can transmit at any given time with a hub</li>
<li>Switches enable parallel, independent data flows that hubs cannot support</li>
</ul>
</li>
</ul>
<h2 id="Switch-Table">Switch Table</h2>
<p>Q: How does switch know that A’ reachable via interface 4, B’ reachable via interface 5?</p>
<p>A: Each switch has a switch table, each entry contains</p>
<ul>
<li>MAC address of host</li>
<li>Interface to reach host</li>
<li>Time stamp</li>
</ul>
<p>This structure is similar to a routing table, but operates at Layer 2 (MAC addresses) rather than Layer 3 (IP addresses).</p>
<p>Q: How are entries created, maintained in switch table? Something like a routing protocol?</p>
<p>A: Switch tables are built through self-learning</p>
<ol>
<li>
<p><strong>Self-learning process</strong>:</p>
<ul>
<li>Initially the switch table is empty</li>
<li>When a frame arrives, the switch records the sender’s MAC address and the interface on which it arrived</li>
<li>The switch learns the location of hosts based on the source MAC address of incoming frames</li>
</ul>
</li>
<li>
<p><strong>Table maintenance</strong>:</p>
<ul>
<li>Each entry has a time-to-live (typically 20-30 minutes)</li>
<li>Entries are refreshed when new frames from the same source arrive</li>
<li>Entries timeout and are removed if not refreshed before TTL expires</li>
</ul>
</li>
<li>
<p><strong>Handling unknown destinations</strong>:</p>
<ul>
<li>If destination MAC is unknown (not in table), the switch floods the frame to all interfaces except the one it arrived on</li>
<li>Once the destination host responds, its location is learned</li>
</ul>
</li>
<li>
<p><strong>Key differences from routing protocols</strong>:</p>
<ul>
<li>No explicit protocol messages exchanged between switches for MAC learning</li>
<li>Learning is passive, based solely on observing normal traffic</li>
<li>Completely automatic with no configuration required</li>
</ul>
</li>
</ol>
<h2 id="Switch-Self-Learning">Switch: Self-Learning</h2>
<h3 id="Learning-Host-Locations">Learning Host Locations</h3>
<ul>
<li><strong>Basic principle</strong>: Switches automatically learn which hosts are located on which interfaces</li>
<li><strong>No configuration required</strong>: Learning happens dynamically as frames traverse the switch</li>
<li><strong>Process for each incoming frame</strong>:
<ol>
<li>Switch examines the <strong>source MAC address</strong> in the frame header</li>
<li>Switch records the <strong>interface</strong> on which the frame arrived</li>
<li>Switch associates this MAC address with this interface in its table</li>
<li>Timestamp is recorded for the entry for aging purposes</li>
</ol>
</li>
</ul>
<h3 id="Switch-Table-Management">Switch Table Management</h3>
<ul>
<li><strong>Dynamic updates</strong>: If a host moves to a different port, the switch updates its table when the host transmits</li>
<li><strong>Aging mechanism</strong>: Each entry includes a time-to-live (typically 20-30 minutes)
<ul>
<li>Entries are refreshed when new frames from the same source arrive</li>
<li>If no frames are received from a MAC address before TTL expires, entry is removed</li>
</ul>
</li>
<li><strong>Adaptation to network changes</strong>: Tables automatically adjust when:
<ul>
<li>New devices connect to the network</li>
<li>Existing devices are moved to different switch ports</li>
<li>Devices are removed from the network</li>
</ul>
</li>
</ul>
<h3 id="Handling-Unknown-Destinations">Handling Unknown Destinations</h3>
<ul>
<li><strong>Initial state</strong>: Empty table when switch boots up</li>
<li><strong>Flooding</strong>: When destination is unknown (not in table), switch forwards frame out all interfaces except the arrival interface</li>
<li><strong>Progressive learning</strong>: Table builds up as hosts send frames, gradually reducing the need for flooding</li>
<li><strong>Self-correcting</strong>: If an entry becomes outdated, flooding will occur until the host location is relearned</li>
</ul>
<p>This passive learning approach enables plug-and-play networking with minimal administrative overhead.</p>
<h2 id="Switch-Frame-Filtering-Forwarding">Switch: Frame Filtering/Forwarding</h2>
<h3 id="Frame-Processing-Algorithm">Frame Processing Algorithm</h3>
<p>When a frame is received by a switch, it follows this decision process:</p>
<ol>
<li>
<p><strong>Record source information</strong>:</p>
<ul>
<li>Record the link/interface associated with the sending host</li>
<li>Update or create switch table entry for source MAC address</li>
</ul>
</li>
<li>
<p><strong>Destination lookup</strong>:</p>
<ul>
<li>Index the switch table using the destination MAC address</li>
</ul>
</li>
<li>
<p><strong>Forwarding decision</strong>:</p>
<ul>
<li>If destination MAC entry is found in table:
<ul>
<li>If destination is on same segment from which frame arrived:
<ul>
<li>Drop the frame (no need to forward to the same segment)</li>
</ul>
</li>
<li>Else:
<ul>
<li>Forward the frame on the interface indicated in the table entry</li>
</ul>
</li>
</ul>
</li>
<li>Else (destination not found in table):
<ul>
<li>Flood the frame (forward on all interfaces except the one on which it arrived)</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Flooding process</strong>:</p>
<ul>
<li>When flooding is required, the frame is sent out all switch ports</li>
<li>Exception: Never send the frame back on the interface where it was received</li>
<li>This ensures the destination will receive the frame if it exists on the network</li>
<li>Subsequent replies will help the switch learn the destination’s location</li>
</ul>
</li>
</ol>
<p>This algorithm combines the efficiency of direct forwarding with the reliability of flooding when necessary, while also preventing unnecessary network traffic through frame filtering.</p>
<h2 id="Switches-vs-Routers-Key-Differences">Switches vs. Routers: Key Differences</h2>
<h3 id="Similarities">Similarities</h3>
<ul>
<li>Both are <strong>store-and-forward devices</strong>
<ul>
<li>Receive complete packets/frames before processing and forwarding</li>
<li>Buffer data during processing</li>
</ul>
</li>
</ul>
<h3 id="Fundamental-Differences">Fundamental Differences</h3>
<table>
<thead>
<tr>
<th>Characteristic</th>
<th>Switches</th>
<th>Routers</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>OSI Layer</strong></td>
<td>Link layer (Layer 2)</td>
<td>Network layer (Layer 3)</td>
</tr>
<tr>
<td><strong>Addressing</strong></td>
<td>Use MAC addresses</td>
<td>Use IP addresses</td>
</tr>
<tr>
<td><strong>Header Examination</strong></td>
<td>Examine frame headers</td>
<td>Examine packet headers</td>
</tr>
<tr>
<td><strong>Decision Making</strong></td>
<td>Simple forwarding based on MAC address</td>
<td>Complex routing decisions based on network topology</td>
</tr>
</tbody>
</table>
<h3 id="Table-Management">Table Management</h3>
<ul>
<li>
<p><strong>Switches</strong>:</p>
<ul>
<li>Maintain switch tables mapping MAC addresses to interfaces</li>
<li>Implement self-learning algorithms (passive learning from traffic)</li>
<li>Use filtering to prevent unnecessary traffic propagation</li>
<li>Tables built automatically without configuration</li>
</ul>
</li>
<li>
<p><strong>Routers</strong>:</p>
<ul>
<li>Maintain routing tables mapping network addresses to next hops</li>
<li>Implement dynamic routing algorithms (RIP, OSPF, BGP, etc.)</li>
<li>Exchange routing protocol messages with other routers</li>
<li>Often require explicit configuration</li>
</ul>
</li>
</ul>
<h3 id="Operational-Scope">Operational Scope</h3>
<ul>
<li><strong>Switches</strong>: Operate within a single network (broadcast domain)</li>
<li><strong>Routers</strong>: Connect multiple networks and provide inter-network communication</li>
</ul>
<p>These fundamental differences reflect their different roles in network architecture: switches optimize local traffic flow within networks, while routers enable traffic to traverse between different networks.</p>
<p><img src="The-Data-Link-Layer/624.png" srcset="/img/loading.gif" lazyload alt="Route">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p>
<h2 id="Virtual-Local-Area-Networks-VLANs">Virtual Local Area Networks (VLANs)</h2>
<h3 id="802-1Q-VLAN-Frame-Format">802.1Q VLAN Frame Format</h3>
<ul>
<li>Compares standard 802.1 Ethernet frame with 802.1Q VLAN frame</li>
<li>802.1Q frame adds a 2-byte Tag Protocol Identifier (value: 81-00)</li>
<li>Includes Tag Control Information with 12-bit VLAN ID field and 3-bit priority field</li>
<li>CRC is recomputed to account for the added header fields</li>
<li>Allows frames to carry VLAN identification information</li>
</ul>
<h3 id="VLANs-Spanning-Multiple-Switches">VLANs Spanning Multiple Switches</h3>
<ul>
<li>VLANs can extend across multiple physical switches</li>
<li>Trunk ports connect switches and carry frames between VLANs</li>
<li>Frames forwarded between switches must use 802.1Q protocol to maintain VLAN information</li>
<li>Example shows Electrical Engineering VLAN (ports 1-8) and Computer Science VLAN (ports 9-15) spanning two switches</li>
<li>Trunk ports ensure proper VLAN segregation across the extended network</li>
</ul>
<h3 id="Port-based-VLAN">Port-based VLAN</h3>
<ul>
<li>Provides traffic isolation between different port groups</li>
<li>Supports dynamic membership where port</li>
<li>s can be reassigned to different VLANs</li>
<li>Communication between VLANs requires routing, similar to separate physical networks</li>
<li>VLANs can be defined by port numbers or by MAC addresses of endpoints</li>
<li>Vendors typically offer combined switch/router devices to facilitate inter-VLAN routing</li>
</ul>
<h3 id="VLAN-Concept-Overview">VLAN Concept Overview</h3>
<ul>
<li>Defines VLANs as virtual networks created on a single physical infrastructure</li>
<li>A single physical switch operates as multiple virtual switches</li>
<li>Logically separates networks (e.g., Electrical Engineering from Computer Science)</li>
<li>Provides network segmentation without requiring separate physical switches</li>
<li>Increases network flexibility, security, and management capabilities</li>
</ul>
<h1>End-of-chapter exercises</h1>
<h2 id="R-8">R.8</h2>
<p><strong>Question</strong></p>
<p>How big is the $\text{MAC}$ address space? The $\text{IPv4}$ address space? The $\text{IPv6}$ address space?</p>
<p><strong>Answer</strong></p>
<p>The sizes of the three address spaces are:</p>
<h3 id="MAC-Address-Space">MAC Address Space</h3>
<ul>
<li><strong>Size</strong>: $2^{48}$ possible addresses</li>
<li><strong>Format</strong>: $48$-bit addresses, typically represented as six groups of two hexadecimal digits (e.g., <code>00:1A:2B:3C:4D:5E</code>)</li>
</ul>
<h3 id="IPv4-Address-Space">IPv4 Address Space</h3>
<ul>
<li><strong>Size</strong>: $2^{32}$ possible addresses</li>
<li><strong>Format</strong>: $32$-bit addresses, typically represented as four decimal numbers separated by dots (e.g., <code>192.168.1.1</code>)</li>
</ul>
<h3 id="IPv6-Address-Space">IPv6 Address Space</h3>
<ul>
<li><strong>Size</strong>: $2^{128}$ possible addresses</li>
<li><strong>Format</strong>: $128$-bit addresses, typically represented as eight groups of four hexadecimal digits separated by colons (e.g., <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>)</li>
</ul>
<p>The IPv6 address space is vastly larger than both MAC and IPv4 address spaces, which was designed to address the IPv4 address exhaustion problem.</p>
<h2 id="P-4">P.4</h2>
<p><strong>Consider the previous problem, but instead of containing the binary of the numbers 0 through 9 suppose these 10 bytes contain.</strong></p>
<p><strong>Questions and Answers:</strong></p>
<p>a. the binary representation of the numbers 1 through 10.<br>
b. the ASCII representation of the letters A through J (uppercase).<br>
c. the ASCII representation of the letters a through j (lowercase).<br>
Compute the Internet checksum for this data.</p>
<p>下面按 16-bit 大端顺序（高字节在前）计算 Internet 校验和（ones’complement sum）：</p>
<ol>
<li>每两个字节组成一个 16-bit 字，超出 0xFFFF 时将高位环回加到低位。</li>
<li>对所有字求和后取反。</li>
</ol>
<p>a. 数值 1 ～ 10（二进制，字节值 0x01～0x0A）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x01 0x02 → 0x0102  <br>0x03 0x04 → 0x0304  <br>0x05 0x06 → 0x0506  <br>0x07 0x08 → 0x0708  <br>0x09 0x0A → 0x090A  <br>Sum = 0x0102+0x0304+0x0506+0x0708+0x090A = 0x191E  <br>Checksum = ~0x191E = 0xE6E1<br></code></pre></td></tr></table></figure>
<p>b. 大写字母 A ～ J（ASCII 0x41～0x4A）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x41 0x42 → 0x4142  <br>0x43 0x44 → 0x4344  <br>0x45 0x46 → 0x4546  <br>0x47 0x48 → 0x4748  <br>0x49 0x4A → 0x494A  <br>Sum = 0x4142+0x4344+0x4546+0x4748+0x494A = 0x5A5F  <br>Checksum = ~0x5A5F = 0xA5A0<br></code></pre></td></tr></table></figure>
<p>c. 小写字母 a ～ j（ASCII 0x61～0x6A）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x61 0x62 → 0x6162  <br>0x63 0x64 → 0x6364  <br>0x65 0x66 → 0x6566  <br>0x67 0x68 → 0x6768  <br>0x69 0x6A → 0x696A  <br>Sum = 0x6162+0x6364+0x6566+0x6768+0x696A = 0xFAFF  <br>Checksum = ~0xFAFF = 0x0500<br></code></pre></td></tr></table></figure>
<h2 id="P-11">P.11</h2>
<p>Suppose four active nodes—nodes A, B, C and D—are competing for access to a channel using slotted ALOHA. Assume each node has an infinite number of packets to send. Each node attempts to transmit in each slot with probability p. The first slot is numbered slot 1, the second slot is numbered slot 2, and so on.</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. What is the probability that node A succeeds for the first time in slot 5?</strong></p>
<p>在单个 slot 中成功的概率：$$P_{\text{succ}} = p (1 - p)^{3}$$</p>
<p>在前 4 个 slot 中都未成功的概率：$$P_{\text{4s}} = \left(1 - P_{\text{succ}}\right)^{4}$$</p>
<p>也就是：$$P(\text{first success in slot 5}) = \bigl[1 - p(1-p)<sup>3\bigr]</sup>4 \times p(1-p)^3.$$</p>
<p><strong>b. What is the probability that some node (either A, B, C or D) succeeds in slot 4?</strong></p>
<p>总共有 $N = 4$ 个结点，某个结点在 slot4 成功的概率为：<br>
$$<br>
P_{\text{succ}} = 4 \cdot p \cdot (1 - p)^{3}<br>
$$</p>
<p><strong>c. What is the probability that the first success occurs in slot 3?</strong></p>
<p>第一次成功出现在 slot3 的概率<br>
$$<br>
P = (1-4p(1-p)<sup>3)</sup>2 \cdot 4p(1-p)^3<br>
$$</p>
<p><strong>d. What is the efficiency of this four-node system?</strong></p>
<p>我们需要计算出使得 $Np(1-p)^{N-1}$ 最大的 $p$，记原式子为 $L(p)$，最优解为 $p^{\ast}$。对 $p$ 求偏导：<br>
$$<br>
\frac{\partial L(p)}{\partial p} = 4(1 - p)^{3} - 12p(1 - p)^{2}<br>
$$</p>
<p>得到<br>
$$<br>
p^{\ast} = 0.25<br>
$$</p>
<p>所以，效率为：<br>
$$<br>
\text{efficiency} = 4 \times 0.25 \times 0.75^3 = \frac{27}{64}<br>
$$</p>
<h2 id="P-17">P.17</h2>
<p><strong>Question and Answer:</strong></p>
<p>Recall that with the CSMA/CD protocol, the adapter waits $K \cdot 512$ bit times after a collision, where $K$ is drawn randomly. For $K = 100$, how long does the adapter wait until returning to Step 2 for a $10$ Mbps Ethernet? For a $100$ Mbps Ethernet?</p>
<p>等待时间的计算公式为：<br>
$$<br>
T = K \cdot 512 \cdot t_{\text{bit}}<br>
$$</p>
<p>其中，$t_{\text{bit}}$ 是比特时间，其计算公式为：<br>
$$<br>
t_{\text{bit}} = \frac{1}{\text{传输速率}}<br>
$$</p>
<p>分别带入 $10$ Mbps 和 $100$ Mbps，解得分别等待时间为 <strong>$5.12$ ms</strong> 和 <strong>$0.512$ ms</strong>。</p>
<h2 id="P-18">P.18</h2>
<p><strong>Question and Answer:</strong></p>
<p>Suppose nodes A and B are on the same $10$ Mbps Ethernet bus, and the propagation delay between the two nodes is $325$ bit times. Suppose node A begins transmitting a frame and, before it finishes, node B begins transmitting a frame. Can A finish transmitting before it detects that B has transmitted? Why or why not? If the answer is yes, then A incorrectly believes that its frame was successfully transmitted without a collision. <em>Hint</em>: Suppose at time $t = 0$ bit times, A begins transmitting a frame. In the worst case, A transmits a minimum-sized frame of $512 + 64$ bit times. So A would finish transmitting the frame at $t = 512 + 64$ bit times. Thus, the answer is no, if B’s signal reaches A before bit time $t = 512 + 64$ bits. In the worst case, when does B’s signal reach A?</p>
<ol>
<li>
<p><strong>传播延迟计算</strong></p>
<ul>
<li>两节点之间的传播延迟为 $325$ 比特时间。</li>
<li>因此，B 的信号从 B 传播到 A 所需的时间为 $325$ 比特时间。</li>
</ul>
</li>
<li>
<p><strong>最小帧传输时间</strong></p>
<ul>
<li>A 传输一个最小帧所需的时间为 $512 + 64 = 576$ 比特时间。</li>
</ul>
</li>
<li>
<p><strong>碰撞检测条件</strong></p>
<ul>
<li>如果 B 的信号在 A 完成帧传输之前到达 A，则 A 可以检测到碰撞。</li>
<li>在最坏情况下，B 在传播延迟的最后一刻（即 $t = 325$ 比特时间）开始传输。</li>
<li>B 的信号需要 $325$ 比特时间到达 A，因此 B 的信号到达 A 的时间为：<br>
$$<br>
t_{\text{到达}} = 325 + 325 = 650 , \text{比特时间}<br>
$$</li>
</ul>
</li>
<li>
<p><strong>结论</strong></p>
<ul>
<li>A 在 $t = 576$ 比特时间完成帧传输，而 B 的信号在 $t = 650$ 比特时间到达 A。</li>
<li>因此，A <strong>无法检测到碰撞</strong>，并会错误地认为其帧已成功传输。</li>
</ul>
</li>
</ol>
<h2 id="P-27">P.27</h2>
<p><strong>Question and Answer:</strong></p>
<p>Consider Figure $5.38$ in problem P$14$. Provide MAC addresses and IP addresses for the interfaces at Host A, both routers, and Host F. Suppose Host A sends a datagram to Host F. Give the source and destination MAC addresses in the frame encapsulating this IP datagram as the frame is transmitted <em>(i)</em> from A to the left router, <em>(ii)</em> from the left router to the right router, <em>(iii)</em> from the right router to F. Also give the source and destination IP addresses in the IP datagram encapsulated within the frame at each of these points in time.</p>
<p><img src="The-Data-Link-Layer/Three%20subnets,%20interconnected%20by%20routers.png" srcset="/img/loading.gif" lazyload alt="Figure 5.38">{ style=&quot;display: block; margin: 0 auto; width: 50%&quot; }</p>
<p>Assign IP addresses to all of the interfaces. For Subnet $1$ use addresses of the form <code>192.168.1.xxx</code>; for Subnet $2$ uses addresses of the form <code>192.168.2.xxx</code>; and for Subnet $3$ use addresses of the form <code>192.168.3.xxx</code>. Assign MAC addresses to all of the adapters.</p>
<p>$14$ 和 $27$ 都没有明确说明 IP address 和 MAC address。先分配接口，如下表所示。</p>
<div style="display: block; margin: 0 auto; width: fit-content">
<table>
<thead>
<tr>
<th>设备/接口</th>
<th>子网</th>
<th>IP 地址</th>
<th>MAC 地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Host A</td>
<td>Subnet 1</td>
<td>192.168.1.1</td>
<td>AA-AA-AA-AA-AA-AA</td>
</tr>
<tr>
<td>Host B</td>
<td>Subnet 1</td>
<td>192.168.1.2</td>
<td>BB-BB-BB-BB-BB-BB</td>
</tr>
<tr>
<td>Router1-接口1</td>
<td>Subnet 1</td>
<td>192.168.1.254</td>
<td>A1-B1-C1-D1-E1-F1</td>
</tr>
<tr>
<td>Router1-接口2</td>
<td>Subnet 2</td>
<td>192.168.2.1</td>
<td>A1-B2-C2-D2-E2-F2</td>
</tr>
<tr>
<td>Router2-接口1</td>
<td>Subnet 2</td>
<td>192.168.2.254</td>
<td>A2-B1-C1-D1-E1-F1</td>
</tr>
<tr>
<td>Router2-接口2</td>
<td>Subnet 3</td>
<td>192.168.3.1</td>
<td>A2-B2-C2-D2-E2-F2</td>
</tr>
<tr>
<td>Host C</td>
<td>Subnet 2</td>
<td>192.168.2.2</td>
<td>CC-CC-CC-CC-CC-CC</td>
</tr>
<tr>
<td>Host D</td>
<td>Subnet 2</td>
<td>192.168.2.3</td>
<td>DD-DD-DD-DD-DD-DD</td>
</tr>
<tr>
<td>Host E</td>
<td>Subnet 3</td>
<td>192.168.3.2</td>
<td>EE-EE-EE-EE-EE-EE</td>
</tr>
<tr>
<td>Host F</td>
<td>Subnet 3</td>
<td>192.168.3.3</td>
<td>FF-FF-FF-FF-FF-FF</td>
</tr>
</tbody>
</table>
</div>
<p><strong><em>(i)</em> from A to the left router</strong></p>
<ul>
<li><strong>Source MAC address</strong>: <code>AA-AA-AA-AA-AA-AA</code>.</li>
<li><strong>Destination MAC address</strong>: <code>A1-B1-C1-D1-E1-F1</code>.</li>
</ul>
<p><strong><em>(ii)</em> from the left router to the right router</strong></p>
<ul>
<li><strong>Source MAC address</strong>: <code>A1-B2-C2-D2-E2-F2</code>.</li>
<li><strong>Destination MAC address</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</li>
</ul>
<p><strong><em>(iii)</em> from the right router to F</strong></p>
<ul>
<li><strong>Source MAC address</strong>: <code>A2-B2-C2-D2-E2-F2</code>.</li>
<li><strong>Destination MAC address</strong>: <code>FF-FF-FF-FF-FF-FF</code>.</li>
</ul>
<h2 id="P-28">P.28</h2>
<p>Suppose now that the leftmost router in Figure $5.38$ is replaced by a switch. Hosts A, B, C, and D and the right router are all star-connected into this switch. Give the source and destination MAC addresses in the frame encapsulating this IP datagram as the frame is transmitted <em>(i)</em> from A to the switch, <em>(ii)</em> from the switch to the right router, <em>(iii)</em> from the right router to F. Also give the source and destination IP addresses in the IP datagram encapsulated within the frame at each of these points in time.</p>
<p>首先需要明确的是，switch 的每个接口都有一个 MAC address，但由于 switch 并不会修改经过它的 frame，这里简单地用一个 MAC address 概括。同时，理论上 subnet1 和 subnet2 应该合为一个 subnet，但接下来的结果仍做区分（因为题目要仍在问 MAC address）。</p>
<p>接上题的接口配置，做简单修改：</p>
<div style="display: block; margin: 0 auto; width: fit-content">
<table>
<thead>
<tr>
<th>设备/接口</th>
<th>子网</th>
<th>IP 地址</th>
<th>MAC 地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Host A</td>
<td>Subnet 1</td>
<td>192.168.1.1</td>
<td>AA-AA-AA-AA-AA-AA</td>
</tr>
<tr>
<td>Host B</td>
<td>Subnet 1</td>
<td>192.168.1.2</td>
<td>BB-BB-BB-BB-BB-BB</td>
</tr>
<tr>
<td>Switch</td>
<td>Subnet 1 2</td>
<td>192.168.1.254</td>
<td>A1-B1-C1-D1-E1-F1</td>
</tr>
<tr>
<td>Router2-接口1</td>
<td>Subnet 2</td>
<td>192.168.2.254</td>
<td>A2-B1-C1-D1-E1-F1</td>
</tr>
<tr>
<td>Router2-接口2</td>
<td>Subnet 3</td>
<td>192.168.3.1</td>
<td>A2-B2-C2-D2-E2-F2</td>
</tr>
<tr>
<td>Host C</td>
<td>Subnet 2</td>
<td>192.168.2.2</td>
<td>CC-CC-CC-CC-CC-CC</td>
</tr>
<tr>
<td>Host D</td>
<td>Subnet 2</td>
<td>192.168.2.3</td>
<td>DD-DD-DD-DD-DD-DD</td>
</tr>
<tr>
<td>Host E</td>
<td>Subnet 3</td>
<td>192.168.3.2</td>
<td>EE-EE-EE-EE-EE-EE</td>
</tr>
<tr>
<td>Host F</td>
<td>Subnet 3</td>
<td>192.168.3.3</td>
<td>FF-FF-FF-FF-FF-FF</td>
</tr>
</tbody>
</table>
</div>
<p><strong><em>(i)</em> from A to the switch</strong></p>
<ul>
<li><strong>Source MAC address</strong>: <code>AA-AA-AA-AA-AA-AA</code>.</li>
<li><strong>Destination MAC address</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</li>
</ul>
<p><strong><em>(ii)</em> from the switch to the right router</strong></p>
<ul>
<li><strong>Source MAC address</strong>: <code>A1-B1-C1-D1-E1-F1</code>.</li>
<li><strong>Destination MAC address</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</li>
</ul>
<p><strong><em>(iii)</em> from the right router to F</strong></p>
<ul>
<li><strong>Source MAC address</strong>: <code>A2-B2-C2-D2-E2-F2</code>.</li>
<li><strong>Destination MAC address</strong>: <code>FF-FF-FF-FF-FF-FF</code>.</li>
</ul>
<h2 id="P-32">P.32</h2>
<p><img src="The-Data-Link-Layer/A%20link-layer%20switch%20inter-connecting%20six%20nodes.png" srcset="/img/loading.gif" lazyload alt="A link-layer switch inter-connecting six nodes">{ style=&quot;display: block; margin: 0 auto; width: 60%&quot; }</p>
<p>Let’s consider the operation of a learning switch in the context of Figure $5.24$. Suppose that <em>(i)</em> B sends a frame to E, <em>(ii)</em> E replies with a frame to B, <em>(iii)</em> A sends a frame to B, <em>(iv)</em> B replies with a frame to A. The switch table is initially empty. Show the state of the switch table before and after each of these events. For each of these events, identify the link(s) on which the transmitted frame will be forwarded, and briefly justify your answers.</p>
<p>按字典序从小到大的顺序分配接口，用如下表格总结题目所述过程：</p>
<div style="display: block; margin: 0 auto; width: fit-content">
<table>
<thead>
<tr>
<th>步骤</th>
<th>事件</th>
<th>表项变化</th>
<th>转发链路</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>B→E</td>
<td>+B@2</td>
<td>1,3,4,5,6</td>
<td>泛洪</td>
</tr>
<tr>
<td>2</td>
<td>E→B</td>
<td>+E@5</td>
<td>2</td>
<td>定向转发</td>
</tr>
<tr>
<td>3</td>
<td>A→B</td>
<td>+A@1</td>
<td>2</td>
<td>定向转发</td>
</tr>
<tr>
<td>4</td>
<td>B→A</td>
<td>B@2 刷新</td>
<td>1</td>
<td>定向转发</td>
</tr>
</tbody>
</table>
</div>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Computer-Network/" class="category-chain-item">Computer Network</a>
  
  
    <span>></span>
    
  <a href="/categories/Computer-Network/Data-Link-Layer/" class="category-chain-item">Data Link Layer</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>The Data Link Layer</div>
      <div>https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>任志诚 2023212020</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年6月4日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/06/05/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/" title="统计学习及监督学习概论">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">统计学习及监督学习概论</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/06/04/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/" title="朴素贝叶斯法">
                        <span class="hidden-mobile">朴素贝叶斯法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
