<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>微分方程</title>
    <link href="/2025/09/11/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    <url>/2025/09/11/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="常见的一阶微分方程的解法">常见的一阶微分方程的解法</h2><ol type="1"><li><p>最简单的一阶微分方程形式为 <span class="math inline">\(f(x)\text{d}x = g(y) \text{d}y\)</span>，此时等式两端积分即可。</p></li><li><p>齐次方程标准形式如下：<span class="math inline">\(y&#39; =f(\frac{y}{x})\)</span>，其中 <span class="math inline">\(f\)</span>有连续的导数，此时只需要令 <span class="math inline">\(u =\frac{y}{x}\)</span>。</p></li><li><p>伯努利方程的标准形式为 <spanclass="math inline">\(\frac{\text{d}y}{\text{d}x} + P(x)y = Q(x)y^\alpha\)</span>，其中 <span class="math inline">\(P(x)\)</span> 和<span class="math inline">\(Q(x)\)</span> 均为连续函数，且 <spanclass="math inline">\(\alpha \neq 0, 1\)</span>，两端同时除以 <spanclass="math inline">\(y^\alpha\)</span>，再令 <spanclass="math inline">\(z = y^{1 - \alpha}\)</span></p></li><li><p>一阶线性方程的标准形式为 <spanclass="math inline">\(\frac{\text{d}y}{\text{d}x} + P(x)y =Q(x)\)</span>，其中 <span class="math inline">\(P(x)\)</span> 和 <spanclass="math inline">\(Q(x)\)</span> 均为连续函数，该方程的通解为 <spanclass="math inline">\(y = \text{e}^{-\int P(x) \text{d}x} \bigl(\intQ(x) \text{e}^{\int P(x) \text{d}x}\text{d}x + C\bigr)\)</span></p></li><li><p>凑全微分需要技巧</p></li></ol><h2 id="高阶微分方程">高阶微分方程</h2><ol type="1"><li>有些高阶微分方程可以降阶，比如 <span class="math inline">\(F(x,y&#39;, y&#39;&#39;)\)</span> 和 <span class="math inline">\(F(y,y&#39;, y&#39;&#39;)\)</span></li></ol><h2 id="常系数高阶线性微分方程">常系数高阶线性微分方程</h2><h3 id="齐次线性微分方程">齐次线性微分方程</h3><p>标准形式：<span class="math inline">\(y^{(n)} + a_1 y^{(n-1)} +\cdots + a_{n-1} y&#39; + a_n y = 0\)</span></p><ol type="1"><li><p><strong>特征方程法</strong>：令 <spanclass="math inline">\(I(\lambda) = \lambda^n + a_1 \lambda^{n - 1} +\cdots + a_{n - 1} \lambda + a_n = 0\)</span>，解出所有特征根</p></li><li><p><strong>根据特征根类型构造通解</strong>：</p><ul><li><p><strong>单实根</strong> <spanclass="math inline">\(\lambda\)</span>：对应解为 <spanclass="math inline">\(C e^{\lambda x}\)</span></p></li><li><p><strong><span class="math inline">\(k\)</span> 重实根</strong><span class="math inline">\(\lambda\)</span>：对应解为 <spanclass="math inline">\((C_1 + C_2 x + \cdots + C_k x^{k-1}) e^{\lambdax}\)</span></p></li><li><p><strong>单复根</strong> <span class="math inline">\(\alpha \pm\beta i\)</span>：对应解为 <span class="math inline">\(e^{\alpha x}(C_1\cos \beta x + C_2 \sin \beta x)\)</span></p></li><li><p><strong><span class="math inline">\(k\)</span> 重复根</strong><span class="math inline">\(\alpha \pm \beta i\)</span>：对应解为 <spanclass="math inline">\(e^{\alpha x}[(C_1 + C_2 x + \cdots + C_k x^{k-1})\cos \beta x + (D_1 + D_2 x + \cdots + D_k x^{k-1}) \sin \betax]\)</span></p></li></ul></li></ol><h3 id="非齐次线性微分方程">非齐次线性微分方程</h3><p>标准形式：<span class="math inline">\(y^{(n)} + a_1 y^{(n-1)} +\cdots + a_{n-1} y&#39; + a_n y = f(x)\)</span></p><p><strong>通解</strong> = <strong>齐次方程通解</strong> +<strong>非齐次方程特解</strong></p><ol type="1"><li><p><strong>特解的求法</strong>（待定系数法）：</p><ul><li><strong><span class="math inline">\(f(x) = P_m(x) e^{\alphax}\)</span></strong> 型：<ul><li>若 <span class="math inline">\(\alpha\)</span> 不是特征根，设特解<span class="math inline">\(y^* = Q_m(x) e^{\alpha x}\)</span></li><li>若 <span class="math inline">\(\alpha\)</span> 是 <spanclass="math inline">\(k\)</span> 重特征根，设特解 <spanclass="math inline">\(y^* = x^k Q_m(x) e^{\alpha x}\)</span></li></ul></li><li><strong><span class="math inline">\(f(x) = e^{\alpha x}[P_l(x) \cos\beta x + P_m(x) \sin \beta x]\)</span></strong> 型：<ul><li>若 <span class="math inline">\(\alpha \pm \beta i\)</span>不是特征根，设特解 <span class="math inline">\(y^* = e^{\alpha x}[Q_n(x)\cos \beta x + R_n(x) \sin \beta x]\)</span></li><li>若 <span class="math inline">\(\alpha \pm \beta i\)</span> 是 <spanclass="math inline">\(k\)</span> 重特征根，设特解 <spanclass="math inline">\(y^* = x^k e^{\alpha x}[Q_n(x) \cos \beta x +R_n(x) \sin \beta x]\)</span></li></ul>其中 <span class="math inline">\(n = \max\{l, m\}\)</span>，<spanclass="math inline">\(Q_n(x)\)</span>，<spanclass="math inline">\(R_n(x)\)</span> 是 <spanclass="math inline">\(n\)</span> 次多项式</li></ul></li><li><p><strong>解题步骤</strong>：</p><ol type="1"><li>写出特征方程并求解特征根</li><li>根据特征根写出齐次方程的通解</li><li>根据 <span class="math inline">\(f(x)\)</span>的形式设特解并求出</li><li>写出非齐次方程的通解</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>无穷级数</title>
    <link href="/2025/09/11/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/"/>
    <url>/2025/09/11/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多元函数积分学</title>
    <link href="/2025/08/22/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/"/>
    <url>/2025/08/22/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="二重积分和三重积分的存在性">二重积分和三重积分的存在性</h2><ol type="1"><li><p>如果 <span class="math inline">\(f(x, y)\)</span>在平面有界闭区域 <span class="math inline">\(D\)</span>上连续，则二重积分 <span class="math inline">\(\iint\limits_{D} f(x, y)\text{d} \delta\)</span> 存在。</p></li><li><p>如果 <span class="math inline">\(f(x, y, z)\)</span>在空间有界闭区域 <span class="math inline">\(\Omega\)</span>上连续，则三重积分 <span class="math inline">\(\iiint\limits_{D} f(x, y,z) \text{d} v\)</span> 存在。</p></li></ol><h2 id="二重积分的计算">二重积分的计算</h2><ol type="1"><li><p>直角坐标系下，可以分别对 <spanclass="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>求积分。</p></li><li><p>极坐标系下，有 <span class="math inline">\(\iint\limits_{D} f(x,y) \text{d}x \text{d}y = \iint\limits_{D&#39;} f(r \cos \theta, r \sin\theta) r \text{d}r \text{d} \theta\)</span> &gt; 一般而言，若变换 <spanclass="math inline">\(T : x = x(u, v)\)</span>，<spanclass="math inline">\(y = y(u, v)\)</span>，将 <spanclass="math inline">\(uOv\)</span> 平面上的区域 <spanclass="math inline">\(D_{uv}\)</span> 一一对应地映射成 <spanclass="math inline">\(xOy\)</span> 平面上的区域 <spanclass="math inline">\(D_{xy}\)</span>，函数 <spanclass="math inline">\(x = x(u, v)\)</span>，<spanclass="math inline">\(y = y(u, v)\)</span> 在 <spanclass="math inline">\(D_{uv}\)</span> 上有连续的偏导数。变换 <spanclass="math inline">\(T\)</span> 的雅可比行列式定义为 <spanclass="math display">\[J(u, v) =\begin{vmatrix}x_u &amp; x_v \\y_u &amp; y_v\end{vmatrix}\]</span> 也可以记为： <span class="math display">\[\frac{\partial (x, y)}{\partial (u, v)}\]</span> 如果被积函数 <span class="math inline">\(f(x, y)\)</span>在区域 <span class="math inline">\(D_{xy}\)</span> 上连续，且 <spanclass="math inline">\(J(u, v) \neq 0\)</span>，则有被积公式： <spanclass="math display">\[\iint\limits_{D_{xy}} f(x, y) \text{d}x \text{d}y =\iint\limits_{D_{uv}} f[x(u, v), y(u, v)] |J(u, v)| \text{d}u \text{d}v\]</span></p></li></ol><h2 id="含有参数的积分">含有参数的积分</h2><p>设 <span class="math inline">\(f(x, y)\)</span> 在矩形区域 <spanclass="math inline">\([a, b] \times [c, d]\)</span> 上可积，则积分 <spanclass="math inline">\(I(x) = \int_{c}^{d} f(x, y) \text{d}y\)</span>称为含有参数 <span class="math inline">\(x\)</span> 的积分。</p><ol type="1"><li><p>如果 <span class="math inline">\(f(x, y)\)</span> 在区域 <spanclass="math inline">\([a, b] \times [c, d]\)</span> 上连续，则 <spanclass="math inline">\(I(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上连续。</p></li><li><p>如果 <span class="math inline">\(f(x, y)\)</span> 及 <spanclass="math inline">\(f_x(x, y)\)</span> 在区域 <spanclass="math inline">\([a, b] \times [c, d]\)</span> 上连续，则 <spanclass="math inline">\(I(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上可导，且 <span class="math display">\[\frac{\text{d}}{\text{d}x} I(x) = \int_{c}^{d} f_x(x, y) \text{d} y\]</span></p></li></ol><h2 id="三重积分变量代换">三重积分变量代换</h2><ol type="1"><li><p>空间点 <span class="math inline">\(P(x, y, z)\)</span> 的柱坐标为<span class="math inline">\(P(r, \theta, z)\)</span>，变换为 <spanclass="math inline">\(x = r \cos \theta\)</span>，<spanclass="math inline">\(y = r \sin \theta\)</span>，<spanclass="math inline">\(z = z\)</span>，此时，三重积分可以表示为： <spanclass="math display">\[\iiint\limits_{\Omega} f(x, y, z) \text{d} x \text{d} y \text{d} z =\iiint\limits_{\Omega&#39;} f(r \cos \theta, r \sin \theta, z) r\text{d} z \text{d} r \text{d} \theta\]</span></p></li><li><p>空间点 <span class="math inline">\(P(x, y, z)\)</span> 的球坐标为<span class="math inline">\(P(r, \varphi, \theta)\)</span>，变换为 <spanclass="math inline">\(x = r \sin \varphi \cos \theta\)</span>，<spanclass="math inline">\(y = r \sin \varphi \sin \theta\)</span>，<spanclass="math inline">\(z = r \cos\varphi\)</span>，此时，三重积分可以表示为： <spanclass="math display">\[\iiint\limits_{\Omega} f(x, y, z) \text{d} x \text{d} y \text{d} z =\iiint\limits_{\Omega&#39;} f(r \sin \varphi \cos \theta, r \sin \varphi\sin \theta, r \cos \varphi) r^2 \sin \varphi \text{d} r \text{d}\varphi \text{d} \theta\]</span></p><blockquote><p>其中 <span class="math inline">\(\varphi\)</span>，<spanclass="math inline">\(\theta\)</span> 分别是与 <spanclass="math inline">\(z\)</span>正轴，<spanclass="math inline">\(x\)</span>正轴的夹角</p></blockquote></li><li><p>三重积分的一般变量代换，类似二重积分。</p></li></ol><h2 id="曲面面积和质心公式">曲面面积和质心公式</h2><ol type="1"><li><p>设曲面 <span class="math inline">\(\Sigma : z = f(x, y)\)</span>在 <span class="math inline">\(xOy\)</span> 做表面上的无重叠投影为 <spanclass="math inline">\(D_{xy}\)</span>，<span class="math inline">\(f(x,y)\)</span> 在 <span class="math inline">\(D_{xy}\)</span>上有连续的偏导数，则曲面面积为 <span class="math display">\[S = \iint\limits_{D_{xy}} \sqrt{1 + \biggl(\frac{\partial z}{\partial x}\biggr)^2 + \biggl( \frac{\partial z}{\partial y} \biggr)^2} \text{d}x\text{d}y\]</span></p></li><li><p>空间区域的质心是 <span class="math inline">\((\bar{x}, \bar{y},\bar{z})\)</span>，则 <span class="math inline">\(\bar{x} =\frac{\iiint\limits_{\Omega} x \text{d}v}{|\Omega|}\)</span>，其中 <spanclass="math inline">\(|\Omega|\)</span> 指的是体积。</p></li></ol><p>设直径为 <span class="math inline">\(d\)</span>，解方程： <spanclass="math display">\[3 + \sqrt{d^2 + 8^2} = 1 + \sqrt{d^2 + 12^2}\]</span></p><h2 id="曲线积分与曲面积分">曲线积分与曲面积分</h2><h3 id="对弧长的曲线积分">对弧长的曲线积分</h3><blockquote><p>灵活利用<strong>曲线的对称性</strong>和被积函数的<strong>奇偶性</strong></p></blockquote><p>设 <span class="math inline">\(C\)</span> 是平面光滑曲线，<spanclass="math inline">\(f(x, y)\)</span> 在 <spanclass="math inline">\(C\)</span> 上连续，则曲线积分 <spanclass="math inline">\(\int_{C} f(x, y) \text{d}s\)</span> 存在： <spanclass="math display">\[\int_{C} f(x, y) \text{d}s = \int_{\alpha}^{\beta} f[x(t), y(t)]\sqrt{x&#39;^2(t) + y&#39;^2(t)} \text{d}t\]</span></p><p>其中曲线 <span class="math inline">\(C\)</span> 表示为参数形式：<spanclass="math inline">\(l : x = x(t), y = y(t)\)</span>，<spanclass="math inline">\(\alpha \leq t \leq \beta\)</span>。</p><blockquote><p>空间同理。</p></blockquote><h3 id="对坐标的曲线积分">对坐标的曲线积分</h3><blockquote><p>与对弧长的曲线积分相比，对坐标的曲线积分<strong>不再</strong>具有单调性、积分中值公式、对称奇偶性。</p></blockquote><p>设 <span class="math inline">\(C\)</span>为平面上一条有向光滑曲线，<span class="math inline">\(\mathbf{F} =\mathbf{F}(x, y) = (P(x, y), Q(x, y))\)</span>，为定义在 <spanclass="math inline">\(C\)</span> 上的向量场，其中 <spanclass="math inline">\(P(x, y)\)</span>，<span class="math inline">\(Q(x,y)\)</span> 在 <span class="math inline">\(C\)</span>上连续，则对坐标的曲线积分为： <span class="math display">\[\int_{C} P(x, y) \text{d}x + Q(x, y) \text{d}y = \int_{C} \mathbf{F}\cdot \text{d} \mathbf{r} = \int_{C} \mathbf{F} \cdot (\cos \alpha, \sin\alpha) \text{d}s\]</span></p><p>若 <span class="math inline">\(C\)</span> 由参数方程 <spanclass="math inline">\(x = x(t), y = y(t)(\alpha \leq t \leq\beta)\)</span> 给出，起点终点分别对应区间端点，则： <spanclass="math display">\[\int_{C} P(x, y) \text{d}x + Q(x, y) \text{d}y = \int_{\alpha}^{\beta}\{P[x(t), y(t)]x&#39;(t) + Q[x(t), y(t)]y&#39;(t)\} \text{d}t\]</span></p><blockquote><p>空间同理</p></blockquote><h3 id="格林公式">格林公式</h3><p>设 <span class="math inline">\(D\)</span> 是以光滑闭曲线 <spanclass="math inline">\(C\)</span> 为边界的平面区域，函数 <spanclass="math inline">\(P(x, y), Q(x, y)\)</span> 在 <spanclass="math inline">\(D\)</span> 及 <spanclass="math inline">\(C\)</span> 上有连续偏导数，则有格林公式： <spanclass="math display">\[\iint\limits_{D} (\frac{\partial Q}{\partial x} - \frac{\partialP}{\partial y}) \text{d}x \text{d}y = \oint_{C} P \text{d}x + Q\text{d}y\]</span></p><p>其中 <span class="math inline">\(C\)</span> 是 <spanclass="math inline">\(D\)</span> 的取正向的边界曲线。</p><h3 id="对面积的曲面积分">对面积的曲面积分</h3><p>设光滑曲面 <span class="math inline">\(\Sigma\)</span> 在 <spanclass="math inline">\(xOy\)</span> 平面上的无重叠投影为 <spanclass="math inline">\(D\)</span>，则其方程可表示为 <spanclass="math inline">\(\Sigma : z = z(x, y)\)</span>，<spanclass="math inline">\((x, y) \in D\)</span>。其中偏导数 <spanclass="math inline">\(z_x\)</span>，<spanclass="math inline">\(z_y\)</span> 在 <spanclass="math inline">\(D\)</span> 上连续，则有： <spanclass="math display">\[\iint\limits_{\Sigma} f(x, y, z) \text{d}S = \iint\limits_{D} f[x, y,z(x, y)] \sqrt{1 + z_x^2 + z_y^2} \text{d}x \text{d}y\]</span></p><blockquote><p>其他坐标面同理</p></blockquote><h3 id="对坐标的曲面积分">对坐标的曲面积分</h3><p>设 <span class="math inline">\(\Sigma\)</span> 是有向光滑曲面，<spanclass="math inline">\(P(x, y, z)\)</span>，<spanclass="math inline">\(Q(x, y, z)\)</span>，<spanclass="math inline">\(R(x, y, z)\)</span> 在 <spanclass="math inline">\(\Sigma\)</span> 上连续。</p><h3 id="高斯公式">高斯公式</h3><p>设三维空间中闭区域 <span class="math inline">\(\Omega\)</span>是由分片光滑的闭曲面 <span class="math inline">\(\Sigma\)</span>围成，函数 <span class="math inline">\(P(x, y, z)\)</span>，<spanclass="math inline">\(Q(x, y, z)\)</span> 和 <spanclass="math inline">\(R(x, y, z)\)</span> 在 <spanclass="math inline">\(\Omega\)</span> 上偏导数连续，则有高斯公式： <spanclass="math display">\[\iiint\limits_{\Omega} (\frac{\partial P}{\partial x} + \frac{\partialQ}{\partial y} + \frac{\partial R}{\partial z}) \text{d}v =\oiint\limits_{\Sigma} P\text{d}y \text{d}z + Q\text{d}z \text{d}x +R\text{d}x \text{d}y\]</span></p><p>成立，其中 <span class="math inline">\(\Sigma\)</span> 为 <spanclass="math inline">\(\Omega\)</span> 整个边界曲面的外侧。</p><h3 id="斯托克斯公式">斯托克斯公式</h3><p>设光滑曲面 <span class="math inline">\(\Sigma\)</span> 的光滑边界曲线<span class="math inline">\(C\)</span>，函数 <spanclass="math inline">\(P(x, y, z)\)</span>，<spanclass="math inline">\(Q(x, y, z)\)</span> 和 <spanclass="math inline">\(R(x, y, z)\)</span> 在 <spanclass="math inline">\(\Sigma\)</span>，<spanclass="math inline">\(C\)</span> 上具有连续的偏导数，则有斯托克斯公式：<span class="math display">\[\oint_{C} P\text{d}x + Q\text{d}y + R\text{d}z =\iint\limits_{\Sigma}(\frac{\partial R}{\partial y} - \frac{\partialQ}{\partial z})\text{d}y \text{d}z + (\frac{\partial P}{\partial z} -\frac{\partial R}{\partial x})\text{d}z \text{d}x + (\frac{\partialQ}{\partial x} - \frac{\partial P}{\partial y})\text{d}x \text{d}y\]</span></p><p>成立。其中 <span class="math inline">\(C\)</span> 和 <spanclass="math inline">\(\Sigma\)</span> 的方向符合右手法则。</p><h2 id="例题">例题</h2><ol type="1"><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在闭区间 <spanclass="math inline">\([0, 1]\)</span> 上连续，且 <spanclass="math inline">\(\int_0^1 f(x) \text{d}x = m\)</span>，计算： <spanclass="math display">\[I = \int_0^1 \text{d}x \int_x^1 \text{d}y \int_x^y f(x) f(y) f(z)\text{d}z\]</span></p></blockquote><p>设 <span class="math inline">\(F(u) = \int_0^u f(t)\text{d}t\)</span>，则： <span class="math display">\[\begin{align*}I &amp;= \int_0^1 \text{d}x \int_x^1 \text{d}y \int_x^y f(x) f(y)\text{d} F(z)\\&amp;= \int_0^1 \text{d}x \int_x^1 \text{d}y f(x) f(y) (F(y) - F(x))\\&amp;= \int_0^1 \text{d}x \int_x^1 f(x)(F(y) - F(x)) \text{d} F(y)\\&amp;= \int_0^1 \text{d} F(x) [\frac{F(1)^2}{2} - F(x)F(1) -\frac{F(x)^2}{2} + F(x)^2]\\&amp;= \frac{m^3}{6}\end{align*}\]</span></p></li><li><blockquote><p>计算 <span class="math display">\[I = \iiint\limits_{\Omega} (x^2 + y^2 + z^2) \text{d}v\]</span> 其中，<span class="math inline">\(\Omega: x^2 + y^2 \leq z\leq \sqrt{2 - x^2 - y^2}\)</span></p></blockquote><p>构建球坐标系，参数方程为：<span class="math inline">\(x = r \sin\varphi \cos \theta\)</span>，<span class="math inline">\(y = r \sin\varphi \sin \theta\)</span>，<span class="math inline">\(z = r \cos\varphi\)</span>，<span class="math inline">\(0 \leq \theta \leq2\pi\)</span>，<span class="math inline">\(0 \leq \varphi \leq\frac{\pi}{2}\)</span>，以 <span class="math inline">\(\varphi =\frac{\pi}{4}\)</span> 为界限，将原积分分为上下积分，同时通过 <spanclass="math inline">\(z\)</span> 的范围得出两个区域对应 <spanclass="math inline">\(r\)</span> 的范围。</p><p><span class="math display">\[\begin{align*}I &amp;= \iiint\limits_{\Omega^1} + \iiint\limits_{\Omega^2}\\&amp;= \int_{0}^{2\pi} \text{d} \theta \int_{0}^{\frac{\pi}{4}} \sin\varphi \text{d} \varphi \int_{0}^{\sqrt{2}} r^4 \text{d} r +\int_{0}^{2\pi} \text{d} \theta \int_{\frac{\pi}{4}}^{\frac{\pi}{2}}\sin \varphi \text{d} \varphi \int_{0}^{\frac{\cos \varphi}{\sin^2\varphi}} r^4 \text{d} r\\&amp;= \frac{\pi}{60}(96\sqrt{2} - 89)\end{align*}\]</span></p></li><li><blockquote><p>设区域 <span class="math inline">\(\Omega: \frac{x^2}{a^2} +\frac{y^2}{b^2} + \frac{z^2}{c^2} \leq 1\)</span>。计算下列积分： <spanclass="math display">\[I = \iiint\limits_{\Omega}(x^2 + y^2 + z^2) \text{d}v\]</span></p></blockquote><p><span class="math display">\[\begin{align*}I &amp;= \iiint\limits_{\Omega} x^2 \text{d}v + \iiint\limits_{\Omega}y^2 \text{d}v + \iiint\limits_{\Omega} z^2 \text{d}v\\&amp;= \frac{4\pi abc}{15}(a^2 + b^2 + c^2)\end{align*}\]</span></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多元函数微分学</title>
    <link href="/2025/08/20/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/"/>
    <url>/2025/08/20/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2id="邻域内点外点边界开区域闭区域以及多元函数的概念与性质">邻域、内点、外点、边界、开区域、闭区域以及多元函数的概念与性质</h2><h3 id="邻域">邻域</h3><p><strong>定义</strong>：设 <span class="math inline">\(P_0(x_0,y_0)\)</span> 是平面上一点，<span class="math inline">\(\delta &gt;0\)</span>，称集合 <span class="math display">\[U(P_0, \delta) = \{P(x,y) | |P - P_0| &lt; \delta\} = \{(x, y) | \sqrt{(x - x_0)^2 + (y -y_0)^2} &lt; \delta\}\]</span> 为点 <spanclass="math inline">\(P_0\)</span> 的 <strong><spanclass="math inline">\(\delta\)</span> 邻域</strong>，也记作 <spanclass="math inline">\(U(P_0)\)</span>。</p><p><strong>去心邻域</strong>：<spanclass="math inline">\(\stackrel{\circ}{U}(P_0, \delta) = \{P | 0 &lt; |P- P_0| &lt; \delta\}\)</span></p><h3 id="内点外点边界点">内点、外点、边界点</h3><p>设 <span class="math inline">\(E\)</span> 是平面上的一个点集，<spanclass="math inline">\(P_0\)</span> 是平面上的一点：</p><p><strong>内点</strong>：如果存在 <spanclass="math inline">\(P_0\)</span> 的某个邻域 <spanclass="math inline">\(U(P_0)\)</span> 使得 <spanclass="math inline">\(U(P_0) \subset E\)</span>，则称 <spanclass="math inline">\(P_0\)</span> 为 <spanclass="math inline">\(E\)</span> 的<strong>内点</strong>。</p><p><strong>外点</strong>：如果存在 <spanclass="math inline">\(P_0\)</span> 的某个邻域 <spanclass="math inline">\(U(P_0)\)</span> 使得 <spanclass="math inline">\(U(P_0) \cap E = \emptyset\)</span>，则称 <spanclass="math inline">\(P_0\)</span> 为 <spanclass="math inline">\(E\)</span> 的<strong>外点</strong>。</p><p><strong>边界点</strong>：如果 <spanclass="math inline">\(P_0\)</span> 的任意邻域内既有属于 <spanclass="math inline">\(E\)</span> 的点，又有不属于 <spanclass="math inline">\(E\)</span> 的点，则称 <spanclass="math inline">\(P_0\)</span> 为 <spanclass="math inline">\(E\)</span> 的<strong>边界点</strong>。</p><p><strong>聚点</strong>（极限点）：如果 <spanclass="math inline">\(P_0\)</span> 的任意去心邻域内都有 <spanclass="math inline">\(E\)</span> 中的点，则称 <spanclass="math inline">\(P_0\)</span> 为 <spanclass="math inline">\(E\)</span> 的<strong>聚点</strong>。</p><p><strong>孤立点</strong>：如果 <span class="math inline">\(P_0 \inE\)</span> 但 <span class="math inline">\(P_0\)</span> 不是 <spanclass="math inline">\(E\)</span> 的聚点，则称 <spanclass="math inline">\(P_0\)</span> 为 <spanclass="math inline">\(E\)</span> 的<strong>孤立点</strong>。</p><h3 id="开区域与闭区域">开区域与闭区域</h3><p><strong>开集</strong>：如果集合 <spanclass="math inline">\(E\)</span> 的每一点都是 <spanclass="math inline">\(E\)</span> 的内点，则称 <spanclass="math inline">\(E\)</span> 为<strong>开集</strong>。</p><p><strong>闭集</strong>：如果集合 <spanclass="math inline">\(E\)</span> 的所有聚点都属于 <spanclass="math inline">\(E\)</span>，则称 <spanclass="math inline">\(E\)</span> 为<strong>闭集</strong>。</p><p><strong>区域</strong>（开区域）：连通的开集称为<strong>区域</strong>或<strong>开区域</strong>。</p><p><strong>闭区域</strong>：开区域连同它的边界一起称为<strong>闭区域</strong>。</p><p><strong>有界集</strong>：如果存在正数 <spanclass="math inline">\(M\)</span>，使得集合 <spanclass="math inline">\(E\)</span> 中的所有点到原点的距离都不超过 <spanclass="math inline">\(M\)</span>，则称 <spanclass="math inline">\(E\)</span> 为<strong>有界集</strong>。</p><p><strong>无界集</strong>：不是有界集的集合称为<strong>无界集</strong>。</p><h2 id="方程">方程</h2><h3 id="曲面方程">曲面方程</h3><ol type="1"><li><p>有解三元方程 <span class="math inline">\(\Sigma : F(x, y, z) =0\)</span> &gt;  也有可能是点或直线</p></li><li><p>参数方程 <span class="math inline">\(\Sigma&#39; : x = x(u,v)\)</span>，<span class="math inline">\(y = y(u, v)\)</span>，<spanclass="math inline">\(z = z(u, v)\)</span></p></li><li><p><span class="math inline">\(\Sigma&#39;\)</span> 是 <spanclass="math inline">\(\Sigma\)</span> 的一部分的充要条件为：<spanclass="math inline">\(F(x(u, v), y(u, v), z(u, v)) \equiv0\)</span></p></li></ol><h3 id="空间曲线方程">空间曲线方程</h3><ol type="1"><li><p>有解方程组 [ l :</p><span class="math display">\[\begin{cases}F(x, y, z) = 0\\G(x, y, z) = 0\end{cases}\]</span><p>]</p><p>称为一般式</p></li><li><p>参数方程：<span class="math inline">\(l&#39; : x =x(t)\)</span>，<span class="math inline">\(y = y(t)\)</span>，<spanclass="math inline">\(z = z(t)\)</span></p></li><li><p><span class="math inline">\(l&#39;\)</span> 是 <spanclass="math inline">\(l\)</span> 的一部分的充要条件为：<spanclass="math inline">\(F[x(t), y(t), z(t)] \equiv 0\)</span> 且 <spanclass="math inline">\(G[x(t), y(t), z(t)] \equiv 0\)</span></p></li><li><p>以弧长为参数的曲线方程：<span class="math inline">\(\bar{l} :\bar{x}(s)\)</span>，<spanclass="math inline">\(\bar{y}(s)\)</span>，<spanclass="math inline">\(\bar{z}(s)\)</span>，恒有 <spanclass="math inline">\([\bar{x}&#39;(s)]^2 + [\bar{y}&#39;(s)]^2 +[\bar{z}&#39;(s)]^2 \equiv 1\)</span></p></li><li><p>对一般式同解变形可以分别得到在各坐标面上的投影方程</p></li></ol><h3 id="平面方程">平面方程</h3><ol type="1"><li><p>点法式</p></li><li><p>一般式</p></li><li><p>截距式</p></li><li><p>点到平面距离公式</p></li></ol><h3 id="直线方程">直线方程</h3><ol type="1"><li><p>一般式</p></li><li><p>对称式</p></li><li><p>参数式</p></li><li><p>向量式</p></li></ol><h2 id="偏导数">偏导数</h2><ol type="1"><li><p>可偏导未必连续</p></li><li><p>二阶混合偏导数在某点连续则在该点它们相等</p></li></ol><h2 id="全微分">全微分</h2><ol type="1"><li><p>如果全增量 <span class="math inline">\(\Delta z = f(x + \Delta x,y + \Delta y) - f(x, y)\)</span> 可以表示为 <spanclass="math inline">\(\Delta z = A \Delta x + B \Delta y + o(\rho)(\rho\rightarrow 0)\)</span>，其中 <span class="math inline">\(\rho =\sqrt{\Delta^2 x + \Delta^2 y}\)</span>，则说可微分。</p></li><li><p>如果可微，则 <span class="math inline">\(\text{d} z =\frac{\partial z}{\partial x} \text{d} x + \frac{\partial z}{\partial y}\text{d} y\)</span>。</p></li><li><p>如果函数的偏导数在某点连续，则在某点可微分。</p></li></ol><h2 id="曲线切线">曲线切线</h2><p>已知空间曲线的参数方程，如果导数连续且不同时为零，则可以用如下公式</p><p>切线方程的对称式： <span class="math display">\[\frac{x - x_0}{x&#39;(t_0)} = \frac{y - y_0}{y&#39;(t_0)} = \frac{z -z_0}{z&#39;(t_0)}\]</span></p><p>切向量： <span class="math display">\[\mathbf{T} = \pm (x&#39;(t_0), y&#39;(t_0), z&#39;(t_0))\]</span></p><p>法平面方程： <span class="math display">\[x&#39;(t_0)(x - x_0) + y&#39;(t_0)(y - y_0) + z&#39;(t_0)(z - z_0) = 0\]</span></p><h2 id="曲面的切平面">曲面的切平面</h2><p>已知空间曲面的方程，若各偏导数连续且不同时为零，则可以用如下公式：</p><p>切平面方程为： <span class="math display">\[F_x(x_0, y_0, z_0)(x - x_0) + F_y(x_0, y_0, z_0)(y - y_0) + F_z(x_0,y_0, z_0)(z - z_0) = 0\]</span></p><p>法线方程： <span class="math display">\[\frac{x - x_0}{F_x(x_0, y_0, z_0)} = \frac{y - y_0}{F_y(x_0, y_0, z_0)}= \frac{z - z_0}{F_z(x_0, y_0, z_0)}\]</span></p><h2 id="多元函数无条件极值">多元函数无条件极值</h2><ol type="1"><li><p>必要条件：在点有<strong>偏导数</strong>，且满足所有偏导数<strong>同时</strong>为零，得到<strong>驻点</strong></p></li><li><p>充分条件：在驻点某领域内如果有<strong>二阶</strong>偏导数，设<span class="math inline">\(f_{xx}(x_0, y_0) = A\)</span>，<spanclass="math inline">\(f_{xy}(x_0, y_0) = B\)</span>，<spanclass="math inline">\(f_{yy}(x_0, y_0) = C\)</span>，<spanclass="math inline">\(\Delta = AC - B^2\)</span>，则：</p><ol type="1"><li><span class="math inline">\(\Delta &gt; 0\)</span> 时是极值，且<span class="math inline">\(A &lt; 0\)</span> 是极大值。</li><li><span class="math inline">\(\Delta &lt; 0\)</span> 时不是极值。</li></ol></li></ol><h2 id="多元函数条件极值">多元函数条件极值</h2><p>拉格朗日乘数法</p><h2 id="习题汇编">习题汇编</h2><ol type="1"><li><blockquote><p>设 <span class="math inline">\(z = 2x^2 + y^2\)</span> 截出平面 <spanclass="math inline">\(4x + 2y + z = 1\)</span>的一个椭圆，求这个椭圆的面积 <spanclass="math inline">\(A\)</span>。</p></blockquote><p>先求出截面面积与其在 <span class="math inline">\(xOy\)</span>平面的投影的比例系数 <span class="math display">\[\cos \alpha = \frac{1}{\sqrt{4^2 + 2^2 + 1^2}} = \sqrt{\frac{1}{21}}\]</span></p><p>交线方程为： <span class="math display">\[\begin{cases}z = 2x^2 + y^2\\4x + 2y + z = 1\end{cases}\]</span></p><p>消去变量 <span class="math inline">\(z\)</span> 得到交线在 <spanclass="math inline">\(xOy\)</span> 平面的投影 <spanclass="math display">\[\frac{(x + 1)^2}{2} + \frac{(y + 1)^2}{4} = 1\]</span></p><p>面积为 <span class="math inline">\(2\sqrt{2}\pi\)</span>，从而截面面积为 <span class="math inline">\(2\sqrt{2} \pi\times \sqrt{21} = 2\pi \sqrt{42}\)</span></p></li><li><blockquote><p>设 <span class="math inline">\(a &gt; 0\)</span>，<spanclass="math inline">\(b &gt; 0\)</span>，<span class="math inline">\(c&gt; 0\)</span>，证明：单叶双曲面 <span class="math inline">\(\Sigma :\frac{x^2}{a^2} + \frac{y^2}{b^2} - \frac{z^2}{c^2} = 1\)</span>上任意一点都有经过该点并且完全位于 <spanclass="math inline">\(\Sigma\)</span> 上的直线通过。</p></blockquote></li><li><blockquote><p>求空间曲线 <span class="math inline">\(L: x(t) = t(\text{e}^t -1)\)</span>，<span class="math inline">\(y(t) = t \sin t\)</span>，<spanclass="math inline">\(z(t) = t^3 + t^2 + 1\)</span>，在点 <spanclass="math inline">\(P_0(0, 0, 1)\)</span> 的切线。</p></blockquote><p>参数 <span class="math inline">\(t_0 =0\)</span>，解得参数方程一阶导数同时为0，此时只需要计算二阶导数，得到切线方向为 <spanclass="math inline">\((1, 1, 1)\)</span>，方程为 <spanclass="math inline">\(x = y = z - 1\)</span>。</p></li><li><blockquote><p>求过直线 <span class="math display">\[L:\begin{cases}3x - 2y - z = 5\\x + y + z = 0\end{cases}\]</span> 与曲面 <span class="math display">\[2x^2 - 2y^2 +2z = \frac{5}{8}\]</span> 相切的切平面方程</p></blockquote><p>曲面上的点 <span class="math inline">\((x_0, y_0, z_0)\)</span>的切平面法向量为 <span class="math inline">\((4x_0, -4y_0,2)\)</span>，过直线 <span class="math inline">\(L\)</span>的平面簇方程为 <span class="math inline">\(3x - 2y - z - 5 + \lambda(x +y + z) = 0 = (3 + \lambda)x + (\lambda - 2)y + (\lambda - 1)z -5\)</span>。得到该平面的法向量为 <span class="math inline">\((3 +\lambda, \lambda - 2, \lambda - 1)\)</span>。整理得： <spanclass="math display">\[\begin{cases}\frac{3 + \lambda}{4x_0} = \frac{\lambda - 2}{-4y_0} = \frac{\lambda -1}{2}\\2x_0^2 - 2y_0^2 + 2z_0 = \frac{5}{8}\\(3 + \lambda)x_0 + (\lambda - 2)y_0 + (\lambda - 1)z_0 - 5 = 0\end{cases}\]</span></p><p>解得 $= $</p></li><li><blockquote><p>长度为 <span class="math inline">\(a\)</span> 的线段两端分别在 <spanclass="math inline">\(x\)</span> 轴和 <spanclass="math inline">\(y\)</span> 轴上滑动，求这样的线段簇的包络线</p></blockquote><p>设在 <span class="math inline">\(x\)</span> 轴上的位置为 <spanclass="math inline">\(c\)</span>，则该线段所在直线的方程为 <spanclass="math display">\[\frac{x}{c} + \frac{y}{\sqrt{a^2 - c^2}} = 1\]</span></p><p>设 <span class="math inline">\(\sin \theta =\frac{c}{a}\)</span>，则直线方程为 <span class="math display">\[F(x, y, \theta) = \frac{x}{\sin \theta} + \frac{y}{\cos \theta}-\frac{1}{a} = 0\]</span></p><p>则包络线方程为： <span class="math display">\[\begin{cases}F(x, y, \theta) = \frac{x}{\sin \theta} + \frac{y}{\cos \theta}-\frac{1}{a} = 0\\F_\theta(x, y, \theta) = \frac{-x \cos \theta}{\sin^2 \theta} + \frac{y\sin \theta}{\cos^2 \theta} = 0\end{cases}\]</span></p><p>从而，<span class="math inline">\(x = a \sin^3 \theta\)</span>，<spanclass="math inline">\(y = a \cos^3 \theta\)</span>。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>不定积分与定积分</title>
    <link href="/2025/08/01/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
    <url>/2025/08/01/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="基本积分公式">基本积分公式</h2><ol type="1"><li><p><span class="math display">\[\int \frac{1}{x^2 + a^2} \text{d} x = \frac{1}{a} \arctan \frac{x}{a} +C\]</span></p></li><li><p><span class="math display">\[\int \frac{1}{x^2 - a^2} \text{d} x = \frac{1}{2a} \ln \biggl | \frac{x- a}{x + a} \biggr | + C\]</span></p></li><li><p><span class="math display">\[\int \frac{1}{\sqrt{a^2 - x^2}} \text{d} x = \arcsin \frac{x}{a} + C\]</span></p></li><li><p><span class="math display">\[\int \frac{1}{\sqrt{x^2 \pm a^2}} \text{d} x = \ln \bigl | x + \sqrt{x^2\pm a^2} \bigr | + C\]</span></p></li><li><p><span class="math display">\[\int \sqrt{a^2 - x^2} \text{d} x = \frac{1}{2} \bigl (x\sqrt{a^2 - x^2}+ a^2 \arcsin \frac{x}{a} \bigr) + C\]</span></p></li><li><p><span class="math display">\[\int \sqrt{x^2 \pm a^2} \text{d} x = \frac{1}{2} \bigl ( x\sqrt{x^2 \pma^2} \pm a^2 \ln \bigl| x + x \sqrt{x^2 \pm a^2} \bigr| \bigr) + C\]</span></p></li><li><p><span class="math display">\[\int \sec x \text{d} x = \ln |\sec x + \tan x| + C\]</span></p></li><li><p><span class="math display">\[\int \csc x \text{d} x = \ln |\csc x - \cot x| + C\]</span></p></li><li><p><span class="math display">\[\int \tan x \text{d} x = - \ln | \cos x | + C\]</span></p></li><li><p><span class="math display">\[\int \cot x \text{d} x = \ln |\sin x| + C\]</span></p></li></ol><h2 id="不能表示为初等函数的积分">不能表示为初等函数的积分</h2><ol type="1"><li><p><span class="math display">\[\int \text{e}^{\pm x^2} \text{d} x\]</span></p></li><li><p><span class="math display">\[\int \frac{\sin x}{x} \text{d} x\]</span></p></li><li><p><span class="math display">\[\int \sin x^2 \text{d} x\]</span></p></li><li><p><span class="math display">\[\int \frac{\text{d} x}{\ln x}\]</span></p></li><li><p><span class="math display">\[\int \frac{\text{d} x}{\sqrt{1 + x^4}}\]</span></p></li><li><p><span class="math display">\[\int \sqrt{1 + x^3} \text{d} x\]</span></p></li><li><p><span class="math display">\[\int \sqrt{1 - k^2 \sin^2 x}\text{d} x\]</span></p></li></ol><h2 id="有理函数积分">有理函数积分</h2><ol type="1"><li><p>两种最简分式形式</p><ol type="1"><li><span class="math display">\[ \int \frac{1}{(x - a)^k} \text{d} x\]</span></li><li><span class="math display">\[ \int \frac{Ax + B}{(x^2 + px + q)^k}\text{d} x \ (p^2 - 4q &lt; 0)\]</span></li></ol></li><li><p>对于积分 <span class="math display">\[\int \frac{\text{d} x}{(x^2 + r^2)^k} = I_k\]</span></p><p>有递推公式： <span class="math display">\[I_k = \frac{1}{2(k - 1)r^2}(\frac{t}{(t^2 + r^2)^{k - 1}} + (2k - 3)I_{k- 1})\]</span></p></li><li><p>特例 <span class="math display">\[\int \frac{1}{(x^2 + a^2)^2} \text{d} x = \frac{1}{2a^3} \biggl( \arctan\frac{x}{a}  + \frac{ax}{x^2 + a^2}\biggr) + C\]</span></p></li></ol><h2 id="三角函数有理式积分">三角函数有理式积分</h2><ol type="1"><li><p>通解：<span class="math inline">\(t = \tan\frac{x}{2}\)</span></p></li><li><p>若 <span class="math inline">\(R(\sin x, -\cos x) = -R(\sin x,\cos x)\)</span>，令 <span class="math inline">\(t = \sinx\)</span>。</p></li><li><p>若 <span class="math inline">\(R(-\sin x, \cos x) = -R(\sin x,\cos x)\)</span>，令 <span class="math inline">\(t = \cosx\)</span>。</p></li><li><p>若 <span class="math inline">\(R(-\sin x, -\cos x) = R(\sin x,\cos x)\)</span>，令 <span class="math inline">\(t = \tanx\)</span>。</p></li><li><p><span class="math inline">\(I_n = \int \tan^n x \text{d} x =\frac{\tan^{n - 1} x}{n - 1} - I_{n - 2}\)</span></p></li><li><p><span class="math inline">\(I_n = \int \sin^n x \text{d} x =-\frac{\sin^{n - 1} \cos x}{n} + \frac{n - 1}{n} I_{n -2}\)</span></p></li></ol><h2 id="三角函数代换法">三角函数代换法</h2><ol type="1"><li><p>若积分形式为$ R(x, ) x$，则令 <span class="math inline">\(x =a\sin t\)</span></p></li><li><p>若积分形式为$ R(x, ) x$，则令 <span class="math inline">\(x =a\tan t\)</span></p></li><li><p>若积分形式为$ R(x, ) x$，则令 <span class="math inline">\(x =a\sec t\)</span></p></li></ol><h2 id="某些根式的换元法">某些根式的换元法</h2><ol type="1"><li><p>若积分形式为$ R(x, ) x$，则令 <span class="math inline">\(u =\sqrt[n]{ax + b}\)</span></p></li><li><p>若积分形式为$ R(x, ) x$，则令 <span class="math inline">\(u =\sqrt[n]{\frac{ax + b}{cx + d}}\)</span></p></li><li><p>若积分形式为$ R(, ) x$，则令 <span class="math inline">\(x =u^{n}\)</span></p></li></ol><h2 id="可积性">可积性</h2><ol type="1"><li><p>可积则有界</p></li><li><p>连续则可积</p></li><li><p>有界且有有限个间断点，则可积</p></li></ol><h2 id="定积分的性质">定积分的性质</h2><ol type="1"><li><p>积分恒等性：设函数 <spanclass="math inline">\(f(x)\)</span>，<spanclass="math inline">\(g(x)\)</span> 在区间 <spanclass="math inline">\([a, b]\)</span> 上连续，且恒有 <spanclass="math inline">\(f(x) \leq g(x)\)</span>。若 <spanclass="math inline">\(\int_{a}^{b} f(x) \text{d} x = \int_{a}^{b} g(x)\text{d} x\)</span>，则在 <span class="math inline">\([a, b]\)</span> 上<span class="math inline">\(f(x) \equiv g(x)\)</span></p></li><li><p>积分中值定理：设函数 <span class="math inline">\(f(x)\)</span>在区间 <span class="math inline">\([a, b]\)</span> 上连续，<spanclass="math inline">\(g(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上可积且不变号，则至少存在一点 <spanclass="math inline">\(\xi \in [a, b]\)</span>，使得 <spanclass="math inline">\(\int_{a}^{b} f(x) g(x) \text{d} x = f(\xi)\int_{a}^{b} g(x) \text{d} x\)</span></p></li></ol><h2 id="定积分简化运算">定积分简化运算</h2><ol type="1"><li><p>设 <span class="math inline">\(n\)</span> 为自然数，则有 <spanclass="math display">\[I_n = \int_{0}^{\frac{\pi}{2}} \sin^n x \text{d} x =\int_{0}^{\frac{\pi}{2}} \cos^n x \text{d} x\]</span></p><p>并有递推公式 <span class="math display">\[I_n = \frac{n - 1}{n} I_{n - 2}\]</span></p></li><li><p>对于任意整数 <span class="math inline">\(k_1\)</span>，<spanclass="math inline">\(k_2\)</span>，<spanclass="math inline">\(n\)</span>，以下积分都等于积分区间的一半 <spanclass="math display">\[\int_{\frac{\pi}{2} k_1}^{\frac{\pi}{2} k_2} \sin^2 nx \text{d} x\]</span></p><p>和 <span class="math display">\[\int_{\frac{\pi}{2} k_1}^{\frac{\pi}{2} k_2} \cos^2 nx \text{d} x\]</span></p></li><li><p>正交性 以三角函数为例子，函数的集合 <span class="math inline">\(F= \{1, \cos x, \sin x, \cos 2x, \sin 2x, \cdots\}\)</span>，任取其中的两个函数相乘，乘积在区间 <spanclass="math inline">\([0, 2\pi]\)</span> 上的积分为零。</p></li></ol><h2 id="广义积分">广义积分</h2><h3 id="重要的判定方法">重要的判定方法</h3><h4 id="比较判定法">1. 比较判定法</h4><p>设 <span class="math inline">\(0 \leq f(x) \leq g(x)\)</span> 在<span class="math inline">\([a, +\infty)\)</span> 上成立：</p><ul><li>若 <span class="math inline">\(\int_a^{+\infty} g(x)\text{d}x\)</span> 收敛，则 <span class="math inline">\(\int_a^{+\infty}f(x) \text{d}x\)</span> 收敛</li><li>若 <span class="math inline">\(\int_a^{+\infty} f(x)\text{d}x\)</span> 发散，则 <span class="math inline">\(\int_a^{+\infty}g(x) \text{d}x\)</span> 发散</li></ul><h4 id="极限判定法">2. 极限判定法</h4><p>设 <span class="math inline">\(f(x) \geq 0\)</span>，<spanclass="math inline">\(g(x) &gt; 0\)</span>，且 <spanclass="math inline">\(\lim_{x \to +\infty} \frac{f(x)}{g(x)} =l\)</span>：</p><ul><li>若 <span class="math inline">\(0 &lt; l &lt; +\infty\)</span>，则<span class="math inline">\(\int_a^{+\infty} f(x) \text{d}x\)</span> 与<span class="math inline">\(\int_a^{+\infty} g(x) \text{d}x\)</span>同敛散</li><li>若 <span class="math inline">\(l = 0\)</span> 且 <spanclass="math inline">\(\int_a^{+\infty} g(x) \text{d}x\)</span> 收敛，则<span class="math inline">\(\int_a^{+\infty} f(x) \text{d}x\)</span>收敛</li><li>若 <span class="math inline">\(l = +\infty\)</span> 且 <spanclass="math inline">\(\int_a^{+\infty} g(x) \text{d}x\)</span> 发散，则<span class="math inline">\(\int_a^{+\infty} f(x) \text{d}x\)</span>发散</li></ul><h3 id="常用的标准广义积分">常用的标准广义积分</h3><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>积分</th><th>收敛条件</th><th>结果</th></tr></thead><tbody><tr><td><span class="math inline">\(\int_1^{+\infty} \frac{1}{x^p}\text{d}x\)</span></td><td><span class="math inline">\(p &gt; 1\)</span></td><td><span class="math inline">\(\frac{1}{p-1}\)</span></td></tr><tr><td><span class="math inline">\(\int_0^1 \frac{1}{x^p}\text{d}x\)</span></td><td><span class="math inline">\(p &lt; 1\)</span></td><td><span class="math inline">\(\frac{1}{1-p}\)</span></td></tr><tr><td><span class="math inline">\(\int_0^{+\infty} e^{-ax}\text{d}x\)</span></td><td><span class="math inline">\(a &gt; 0\)</span></td><td><span class="math inline">\(\frac{1}{a}\)</span></td></tr><tr><td><span class="math inline">\(\int_{-\infty}^{+\infty} e^{-x^2}\text{d}x\)</span></td><td>总是收敛</td><td><span class="math inline">\(\sqrt{\pi}\)</span></td></tr></tbody></table></div><h3 id="特殊的广义积分">特殊的广义积分</h3><ol type="1"><li>伽马函数 <span class="math inline">\(\Gamma(s) = \int_{0}^{+\infty}x^{s - 1} \text{e}^{-x} \text{d} x(s &gt; 0)\)</span>，递推公式 <spanclass="math inline">\(\Gamma(s + 1) =s\Gamma(s)\)</span>，对于任意正整数 <spanclass="math inline">\(n\)</span> 有 <span class="math inline">\(\Gamma(n+ 1) = n!\)</span></li></ol><h3 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h3><ul><li><strong>绝对收敛</strong>：如果 <spanclass="math inline">\(\int_a^{+\infty} |f(x)| \text{d}x\)</span>收敛，则称 <span class="math inline">\(\int_a^{+\infty} f(x)\text{d}x\)</span> <strong>绝对收敛</strong></li><li><strong>条件收敛</strong>：如果 <spanclass="math inline">\(\int_a^{+\infty} f(x) \text{d}x\)</span> 收敛但<span class="math inline">\(\int_a^{+\infty} |f(x)| \text{d}x\)</span>发散，则称原积分<strong>条件收敛</strong></li></ul><h2 id="重要公式">重要公式</h2><ol type="1"><li><p>始终存在 <span class="math display">\[\arctan \text{e}^x + \arctan \text{e}^{-x} \equiv \frac{\pi}{2}\]</span></p></li><li><p>设 <span class="math inline">\(f(x)\)</span> 在区间 <spanclass="math inline">\([0, 1]\)</span> 上连续，有如下公式： <spanclass="math display">\[\int_{0}^{\pi} x f(\sin x) \text{d} x = \frac{\pi}{2} \int_{0}^{\pi}f(\sin x) \text{d} x\]</span></p><blockquote><p>证明过程只需要令 <span class="math inline">\(x = \pi - u\)</span></p></blockquote></li></ol><h2 id="例题讲解">例题讲解</h2><h3 id="不定积分">不定积分</h3><ol type="1"><li><blockquote><p>求积分 <span class="math display">\[\int \frac{\text{d} x}{x^4 + 1}\]</span></p></blockquote><p><span class="math display">\[\int \frac{\text{d} x}{x^4 + 1} = \frac{1}{2} \int \frac{1 +\frac{1}{x^2}}{x^2 + \frac{1}{x^2}} \text{d}x - \frac{1}{2} \int \frac{1- \frac{1}{x^2}}{x^2 + \frac{1}{x^2}} \text{d} x = \frac{1}{2} \int\frac{\text{d}(x - \frac{1}{x})}{(x - \frac{1}{x})^2 + 2} -\frac{1}{2}\int \frac{\text{d} (x + \frac{1}{x})}{(x + \frac{1}{x})^2 - 2}\]</span></p><p>最终结果为： <span class="math display">\[\frac{1}{2 \sqrt{2}} \arctan \frac{x^2 - 1}{\sqrt{2} x} - \frac{1}{4\sqrt{2}} \ln \biggl | \frac{x^2 - \sqrt{2} x + 1}{x^2 + \sqrt{2} x + 1}\biggr | + C\]</span></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一元函数微分学</title>
    <link href="/2025/07/26/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/"/>
    <url>/2025/07/26/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="必备知识点">必备知识点</h2><ol type="1"><li><blockquote><p>导数的定义</p></blockquote><p>设函数 <span class="math inline">\(f(x)\)</span> 在点 <spanclass="math inline">\(x_0\)</span> 的某个领域内有定义，如果极限： <spanclass="math display">\[\lim_{\Delta x \to 0} \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x}\]</span></p><p>存在，则称函数 <span class="math inline">\(f(x)\)</span> 在点 <spanclass="math inline">\(x_0\)</span> 处可导，并称此极限值为函数 <spanclass="math inline">\(f(x)\)</span> 在点 <spanclass="math inline">\(x_0\)</span> 处的导数，记作： <spanclass="math display">\[f&#39;(x) = \lim_{\Delta x \to 0} \frac{f(x_0 + \Delta x) -f(x_0)}{\Delta x}\]</span></p></li><li><blockquote><p>微分的定义</p></blockquote><p>设函数 <span class="math inline">\(y = f(x)\)</span> 在点 <spanclass="math inline">\(x_0\)</span> 处可导，则称 <spanclass="math display">\[dy = f&#39;(x_0) \cdot dx\]</span></p><p>为函数 <span class="math inline">\(f(x)\)</span> 在点 <spanclass="math inline">\(x_0\)</span> 处的<strong>微分</strong>，其中 <spanclass="math inline">\(dx\)</span> 是自变量的增量。 如果函数 <spanclass="math inline">\(y = f(x)\)</span> 在点 <spanclass="math inline">\(x\)</span> 处可微，则： <spanclass="math display">\[\Delta y = f&#39;(x) \cdot \Delta x + o(\Delta x)\]</span></p><p>其中 <span class="math inline">\(o(\Delta x)\)</span> 是比 <spanclass="math inline">\(\Delta x\)</span> 高阶的无穷小量。</p></li><li><p>存在极限 <span class="math display">\[\lim_{h \to 0} \frac{f[(x + h)^2] - f(x^2)}{h} = [f(x^2)]&#39;\]</span></p></li><li><p>设函数 <span class="math inline">\(y = f(x)\)</span> 在区间 <spanclass="math inline">\(I\)</span> 上可导，若在 <spanclass="math inline">\(I\)</span> 上恒有 <spanclass="math inline">\(f&#39;(x) \geq 0\)</span>，且在 <spanclass="math inline">\(I\)</span> 中的任何区间上不存在 <spanclass="math inline">\(f&#39;(x) \equiv 0\)</span>，则 <spanclass="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(I\)</span> 上严格单调增加。</p></li><li><blockquote><p>函数的凹凸性</p></blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是在区间 <spanclass="math inline">\(I\)</span> 上的连续函数</p><ol type="1"><li><span class="math inline">\(f(q_1 x_1 + q_2 x_2) \leq q_1 f(x_1) +q_2 f(x_2)\)</span></li><li><span class="math inline">\(f(\frac{x_1 + x_2}{2}) \leq \frac{1}{2}f(x_1) + \frac{1}{2} f(x_2)\)</span></li><li><span class="math inline">\(f(q_1 x_1 + q_2 x_2 + \cdots + q_n x_n)\leq q_1 f(x_1) + q_2 f(x_2) + \cdots + q_n f(x_n)\)</span></li><li>若可导，<span class="math inline">\(f&#39;(x)\)</span> 在 <spanclass="math inline">\(I\)</span> 上单调递增</li><li>若二阶可导，<span class="math inline">\(f&#39;&#39;(x) \geq0\)</span></li></ol></li><li><blockquote><p>常用的高阶导数公式</p></blockquote><ol type="1"><li><span class="math inline">\((a^x)^{(n)} = a^x \ln^na\)</span>，<span class="math inline">\(a &gt; 0\)</span></li><li><span class="math inline">\((\log_a x)^{(n)} = (-1)^{n - 1} \frac{(n- 1)!}{x^n \ln a}\)</span>，<span class="math inline">\(a &gt;0\)</span>，<span class="math inline">\(a \neq 1\)</span></li><li><span class="math inline">\((\cos x)^{(n)} = \cos(x + n \cdot\frac{\pi}{2})\)</span></li><li><span class="math inline">\((\sin x)^{(n)} = \sin(x + n \cdot\frac{\pi}{2})\)</span></li><li><span class="math inline">\((\frac{1}{x + a})^{(n)} = (-1)^n\frac{n!}{(x + a)^{n + 1}}\)</span></li><li><span class="math inline">\((\frac{1}{a - x})^{(n)} = \frac{n!}{(a -x)^{n + 1}}\)</span></li></ol></li></ol><h2 id="例题讲解">例题讲解</h2><h3 id="导数微分中值定理">导数、微分中值定理</h3><ol type="1"><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(x = a\)</span> 处连续，并有 <spanclass="math inline">\(\lim\limits_{x \to a} \frac{f(x)}{x - a} =k\)</span>。证明：<span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(x = a\)</span> 处可导，且 <spanclass="math inline">\(f&#39;(a) = k\)</span>。</p></blockquote><p>首先由连续性得到 <span class="math inline">\(\lim\limits_{x \to a}f(x) = f(a)\)</span>，由极限与无穷小的关系得到：存在 <spanclass="math inline">\(a(x)\)</span>，其中 <spanclass="math inline">\(\lim\limits_{x \to a} a(x) = 0\)</span>，使得<span class="math inline">\(\frac{f(x)}{x - a} = k + a(x) \Rightarrowf(x) = (x - a)(k + a(x)) \Rightarrow \lim\limits_{x \to a} f(x) = f(a) =\lim\limits_{x \to a} (x - a)(k + a(x)) = 0\)</span>。所以存在 <spanclass="math inline">\(\lim\limits_{x \to a} \frac{f(x) - f(a)}{x - a} =k\)</span>，由导数定义知，题目结论成立。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在点 <spanclass="math inline">\(x_0\)</span> 可导，<span class="math inline">\(a_n&lt; x_0 &lt; b_n\)</span> 且 <span class="math inline">\(\lim\limits_{n\to \infty} a_n = \lim\limits_{n \to \infty} b_n = x_0\)</span>。证明：<span class="math display">\[\lim_{n \to \infty} \frac{f(b_n) - f(a_n)}{b_n - a_n} = f&#39;(x_0)\]</span></p></blockquote></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在点 <spanclass="math inline">\(x_0\)</span> 有二阶导数，证明： <spanclass="math display">\[\lim_{h \to 0} \frac{f(x_0 + h) - 2f(x_0) + f(x_0 - h)}{h^2} =f&#39;&#39;(x_0)\]</span></p></blockquote><p>此时存在 <span class="math inline">\(x_0\)</span> 的领域 <spanclass="math inline">\((x_0 - \delta, x_0 + \delta)\)</span>，在此领域上<span class="math inline">\(f&#39;(x)\)</span>存在。有洛必达法则及二阶导数的定义得到： <span class="math display">\[\lim_{h \to 0} \frac{f(x_0 + h) - 2f(x_0) + f(x_0 - h)}{h^2} = \lim_{h\to 0} \frac{f&#39;(x_0 + h) - f&#39;(x_0 - h)}{2h} = \frac{1}{2}\lim_{h \to 0} \frac{f&#39;(x_0 + h) - f&#39;(x_0) + f&#39;(x_0) -f&#39;(x_0 - h)}{h} = f&#39;&#39;(x_0)\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(x = 1\)</span> 点附近有定义，且在 <spanclass="math inline">\(x = 1\)</span> 点可导，<spanclass="math inline">\(f(1) = 0\)</span>，<spanclass="math inline">\(f&#39;(1) = 2\)</span>。求 <spanclass="math display">\[\lim_{x \to 0} \frac{f(\sin^2 x + \cos x)}{x^2 + x \tan x}\]</span></p></blockquote><p>由一阶导数定义得到： <span class="math display">\[\lim_{x \to 0} \frac{f(\sin^2 x + \cos x)}{x^2 + x \tan x} = \lim_{x \to0} \frac{f(\sin^2 x + \cos x) - f(1)}{\sin^2 x + \cos x - 1} \cdot\frac{\sin^2 x + \cos x - 1}{x^2 + x \tan x} = \frac{1}{2}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(a &gt; 0\)</span>，<spanclass="math inline">\(f(x)\)</span> 在闭区间 <spanclass="math inline">\([a, b]\)</span> 上连续，在 <spanclass="math inline">\((a, b)\)</span> 内可导，<spanclass="math inline">\(f(a) = 0\)</span>。证明：存在 <spanclass="math inline">\(\xi \in (a, b)\)</span> 使得 <spanclass="math inline">\(f(\xi) = \frac{b - \xi}{a}f&#39;(\xi)\)</span>。</p></blockquote><p>与欲证等式相对应的微分方程为 <span class="math inline">\(y = \frac{b- x}{a} y&#39;\)</span>，解得 <span class="math inline">\((b - x)^a y =C\)</span>，做辅助函数 <span class="math inline">\(F(x) = (b - x)^af(x)\)</span>，有 <span class="math inline">\(F(a) = F(b) =0\)</span>，由罗尔定理得到，存在 <span class="math inline">\(\xi \in (a,b)\)</span>，使得 <span class="math inline">\(F&#39;(\xi) = -a(b -\xi)^{a - 1} f(\xi) + (b - \xi)^{a} f&#39;(\xi) =0\)</span>，从而得证。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在闭区间 <spanclass="math inline">\([a, b]\)</span> 上连续，在 <spanclass="math inline">\((0, 1)\)</span> 内可导，试证：存在 <spanclass="math inline">\(\xi \in (0, 1)\)</span> 使得 <spanclass="math display">\[\frac{\pi}{4} (1 + \xi^2) f(1) = f(\xi) + (1 + \xi^2) \arctan \xi \cdotf&#39;(\xi)\]</span></p></blockquote></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\([a, b]\)</span> 上有 <span class="math inline">\(n+ 1\)</span> 阶导数，且 <span class="math inline">\(f^{(k)}(a)=  f^{(k)}(b) = 0(k = 0, 1, 2, \cdots, n)\)</span>。证明：存在 <spanclass="math inline">\(\xi \in (a, b)\)</span>，使得 <spanclass="math inline">\(f^{(n + 1)} (\xi) = f(\xi)\)</span>。</p></blockquote><p>构造函数 <span class="math inline">\(F(x) = (f(x) + f^{(1)}(x) +f^{(2)}(x) + \cdots + f^{(n)}(x)) \text{e}^{-x}\)</span>，<spanclass="math inline">\(F(a) = F(b) = 0\)</span>，所以存在 <spanclass="math inline">\(\xi \in (a, b)\)</span>，使得 <spanclass="math inline">\(F&#39;(\xi) = (f^{(n + 1)}(x) - f(x))\text{e}^{-x} = 0\)</span>，即 <span class="math inline">\(f^{(n + 1)}(\xi) = f(\xi)\)</span>。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>函数、极限、连续</title>
    <link href="/2025/07/12/%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%81%E9%99%90%E3%80%81%E8%BF%9E%E7%BB%AD/"/>
    <url>/2025/07/12/%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%81%E9%99%90%E3%80%81%E8%BF%9E%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="必备知识点">必备知识点</h2><ol type="1"><li><p><span class="math display">\[\lim_{n \to \infty} \sqrt[n]{a_1^n + a_2^n \dots + a_m^n} = \max_{1 \leqi \leq m}\{a_i\}\]</span></p><p>这个公式用<strong>夹逼定理</strong>证明，证明如下：记 <spanclass="math inline">\(\max\limits_{1 \leq i \leq m} = a\)</span>，则<span class="math display">\[a = \sqrt[n]{a^n} \leq \sqrt[n]{a_1^n + a_2^n \dots + a_m^n} \leq\sqrt[n]{m \times a^n} = a \sqrt[n]{m}\]</span></p><p>而<span class="math inline">\(\lim\limits_{n \to \infty} \sqrt[n]{m}= 1\)</span>，所有根号下变量要求 <span class="math inline">\(\geq0\)</span>。</p></li><li><p>拉格朗日中值定理 如果函数 <spanclass="math inline">\(f(x)\)</span> 满足以下条件：</p><ol type="1"><li>在闭区间 <span class="math inline">\([a, b]\)</span> 上连续</li><li>在开区间 <span class="math inline">\((a, b)\)</span> 上可导</li></ol><p>那么，至少存在一点 <span class="math inline">\(\xi \in (a,b)\)</span>，使得： <span class="math display">\[f&#39;(\xi) = \frac{f(b) - f(a)}{b - a}\]</span></p></li><li><p>立方和公式与立方差公式 [ <spanclass="math display">\[\begin{align*}a^3 + b^3 &amp;= (a + b)(a^2 - ab + b^2)\\a^3 - b^3 &amp;= (a - b)(a^2 + ab + b^2)\end{align*}\]</span> ]</p></li><li><p>几个常用函数的麦克劳林公式 <span class="math inline">\((n = 0, 1,\cdots)\)</span> [ <span class="math display">\[\begin{align*}\text{e}^x &amp;= 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots +\frac{x^n}{n!} + o(x^n)\\\sin x &amp;= x - \frac{x^3}{3!} + \frac{x^5}{5!} - \cdots + (-1)^{n }\frac{x^{2n + 1}}{(2n + 1)!} + o(x^{2n + 2})\\\cos x &amp;= 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \cdots + (-1)^n\frac{x^{2n}}{(2n)!} + o(x^{2n + 1})\\\ln (1 + x) &amp;= x - \frac{x^2}{2} + \frac{x^3}{3} - \cdots + (-1)^{n}\frac{x^{n + 1}}{n + 1} + o(x^{n + 1})\\(1 + x)^{\alpha} &amp;= 1 + \alpha x + \frac{\alpha(\alpha - 1)}{2!} x^2+ \cdots + \frac{\alpha(\alpha - 1) \cdots (\alpha - n + 1)}{n!} x^n +o(x^n)\\\frac{1}{1- x} &amp;= 1 + x + x^2 + \cdots + x^n + o(x^n)\\\frac{1}{1 + x} &amp;= 1 - x + x^2 - \cdots + (-1)^{n} x^n + o(x^n)\\\arctan x &amp;= x - \frac{1}{3} x^3 + \frac{1}{5} x^5 - \cdots + (-1)^n\frac{1}{2n + 1} x^{2n + 1} + o(x^{2n + 1})\end{align*}\]</span> ]</p></li><li><p>若函数 <span class="math inline">\(f(x)\)</span> 和 <spanclass="math inline">\(g(x)\)</span> 在区间 <spanclass="math inline">\(I\)</span>上连续，对于 <spanclass="math inline">\(x \in I\)</span>，构造函数 <spanclass="math inline">\(M(x) = \max\{f(x), g(x)\} = \frac{f(x) + g(x) +|f(x) - g(x)|}{2}\)</span>，<span class="math inline">\(m(x) =\min\{f(x), g(x)\} =\frac{f(x) + g(x) - |f(x) -g(x)|}{2}\)</span></p></li></ol><h2 id="例题讲解">例题讲解</h2><ol type="1"><li><p>设<br /><span class="math display">\[x_n=\prod_{k = 1}^n\Bigl(1 + \frac1{2^{2^k}}\Bigr)=(1 + \frac12)(1 + \frac1{2^2})(1 + \frac1{2^4})\cdots(1 +\frac1{2^{2^n}})\]</span><br />求 <span class="math inline">\(\lim\limits_{n \to \infty}x_n\)</span>。&gt; 一般而言，这类题目都需要构造望远镜乘积的形式</p><p>注意到 <span class="math display">\[\frac{1}{2^{2^n}} + 1 = \frac{\frac{1}{2^{2^{n + 1}}} -1}{\frac{1}{2^{2^n}} - 1}\]</span></p><p>替换所有元素的形式，最终得到： <span class="math display">\[\lim_{n \to \infty}x_n = \lim_{n \to \infty} \frac{\frac{1}{2^{2^{n +1}}} - 1}{\frac{1}{2^{2^0}} - 1} = 2\]</span></p></li><li><p>求 <span class="math display">\[\lim_{n \to \infty} \sin(\pi \sqrt{n^2 + 1})\]</span></p><p>变形： <span class="math display">\[\lim_{n \to \infty} \sin(\pi \sqrt{n^2 + 1}) = (-1)^n\lim_{n \to \infty}\sin(\pi \sqrt{1 + n^2} -n\pi) = (-1)^n \lim_{n \to \infty}\sin(\frac{\pi}{\sqrt{1 + n^2} + n}) = 0\]</span></p></li><li><p>求 <span class="math display">\[\lim_{n \to \infty} \frac{(1 + 1/n)^{n^{2}}}{\text{e}^n}\]</span></p><p>变形： <span class="math display">\[\text{e}^{\ln \lim\limits_{n \to \infty} \frac{(1 +1/n)^{n^{2}}}{\text{e}^n}} = \text{e}^{\lim\limits_{n \to \infty} n^2\ln (1 + \frac{1}{n}) - n} = \text{e}^{\lim\limits_{n \to \infty} n^2(\frac{1}{n} - \frac{1}{2n^2} + o(\frac{1}{n^2})) - n} =\text{e}^{-\frac{1}{2}}\]</span></p></li><li><p>设 <span class="math inline">\(\alpha &gt; 0\)</span>，求 <spanclass="math display">\[\lim_{n \to \infty} \Bigl(\cos \frac{1}{n^\alpha}\Bigr)^n\]</span></p><p>变形： <span class="math display">\[\text{e}^{\lim\limits_{n \to \infty} n \ln (1 - \frac{1}{2! \cdotn^{2\alpha}} + o(\frac{1}{n^{3 \alpha}}))} = \text{e}^{\lim\limits_{n\to \infty} n \cdot(- \frac{1}{2! \cdot n^{2\alpha}} + o(\frac{1}{n^{3\alpha}}) + o(- \frac{1}{2! \cdot n^{2\alpha}} + o(\frac{1}{n^{3\alpha}})))}\]</span></p><p>可以分析： [ _{n } ()^n =</p><span class="math display">\[\begin{cases}0, &amp;\alpha &lt; \frac{1}{2}\\\text{e}^{-\frac{1}{2}}, &amp;\alpha = \frac{1}{2}\\1, &amp;\alpha &gt; \frac{1}{2}\end{cases}\]</span><p>]</p></li><li><p>求极限 <span class="math display">\[\lim_{n \to \infty} \sqrt[n]{\ln n}\]</span></p><p>对 <span class="math inline">\(\ln n\)</span> 放缩，<spanclass="math inline">\(1 - \frac{1}{n} &lt; \ln n &lt; n - 1\)</span>，而<span class="math inline">\(\lim\limits_{n \to \infty} \sqrt[n]{1 -\frac{1}{n}} = \lim\limits_{n \to \infty} \sqrt[n]{n - 1} =1\)</span>，再由夹逼定理，得到问题极限结果也为 1</p></li><li><p>设 <span class="math display">\[x_n = \frac{1}{2} \cdot \frac{3}{4} \cdot \cdots \cdot \frac{2n - 1}{2n}\]</span></p><p>求 <span class="math display">\[\lim_{n \to \infty} x_n\]</span></p><p>注意到 <span class="math inline">\(0 &lt; x_n &lt; \frac{1}{\sqrt{2n+ 1}}\)</span>，所以，该极限结果为 0</p></li><li><p>设数列 <span class="math inline">\(\{a_n\}\)</span>有界，对于任何 <span class="math inline">\(n\)</span> 总有 <spanclass="math inline">\(a_n \leq a_{n + 2}\)</span>，<spanclass="math inline">\(a_n \leq a_{n + 3}\)</span> 成立，证明 <spanclass="math inline">\(\lim\limits_{n \to \infty} a_n\)</span> 存在。此时有，<span class="math inline">\(a_{2n} \leq a_{2n +2}\)</span>，<span class="math inline">\(a_{2n - 1} \leq a_{2n +1}\)</span>，<span class="math inline">\(a_{3n} \leq a_{3n +3}\)</span>，<span class="math inline">\((n = 1, 2,\cdots)\)</span>，这表明子数列 <spanclass="math inline">\(\{a_{2n}\}\)</span>，<spanclass="math inline">\(\{a_{2n - 1}\}\)</span> 和 <spanclass="math inline">\(\{a_{3n}\}\)</span>都是单调有界的，故都存在极限，分别设为 <spanclass="math inline">\(a\)</span>，<spanclass="math inline">\(b\)</span>，<spanclass="math inline">\(c\)</span>。由于数列 <spanclass="math inline">\(\{a_{2n}\}\)</span> 和 <spanclass="math inline">\(\{a_{3n}\}\)</span> 有公共数列 <spanclass="math inline">\(\{a_{6n}\}\)</span>，所以 <spanclass="math inline">\(a = c\)</span>；又由于数列 <spanclass="math inline">\(\{a_{2n - 1}\}\)</span> 和 <spanclass="math inline">\(\{a_{3n}\}\)</span> 有公共数列 <spanclass="math inline">\(\{a_{6n -3}\}\)</span>，所以 <spanclass="math inline">\(b = c\)</span>，从而 <span class="math inline">\(a= b\)</span>，所以 <span class="math inline">\(\lim\limits_{n \to\infty} a_n\)</span> 存在。</p></li><li><p>如果存在正整数 <span class="math inline">\(p\)</span>，使得 <spanclass="math display">\[\lim_{n \to \infty} (a_{n + p} - a_n) = \lambda\]</span></p><p>则， <span class="math display">\[\lim_{n \to \infty} \frac{a_n}{n} = \frac{\lambda}{p}\]</span></p><p>将数列 <spanclass="math inline">\(\{\frac{a_n}{n}\}\)</span>，划分为如下互不相交的子数列，<spanclass="math inline">\(\{\frac{a_{1 + (n - 1)p}}{1 + (n -1)p}\}\)</span>，<span class="math inline">\(\{\frac{a_{2 + (n - 1)p}}{2+ (n - 1)p}\}\)</span>，<spanclass="math inline">\(\cdots\)</span>，<spanclass="math inline">\(\{\frac{a_{p + (n - 1)p}}{p + (n -1)p}\}\)</span>，<span class="math inline">\(n \geq 1\)</span>，记为<span class="math inline">\(\{\frac{a_{i + (n - 1)p}}{i + (n -1)p}\}\)</span>，<span class="math inline">\(1 \leq i \leqp\)</span>，只需要证明对于所有的 <spanclass="math inline">\(i\)</span>，都有 <span class="math display">\[\lim_{n \to \infty} \frac{a_{i + (n - 1)p}}{i + (n - 1)p} =\frac{\lambda}{p}\]</span></p><p>由 stolz 定理，得 <span class="math inline">\(\lim\limits_{n \to\infty} \frac{a_{i + (n - 1)p}}{i + (n - 1)p} = \frac{\lim\limits_{n \to\infty} a_{i + (n - 1)p} - a_{i + (n - 2)p}}{p} =\frac{\lambda}{p}\)</span>。综上，题目推论成立</p></li><li><p>设 <span class="math inline">\(x_0 = a\)</span>，<spanclass="math inline">\(x_1 = b\)</span>，<span class="math inline">\(x_{n+ 1} = \frac{1}{2} (x_n + x_{n - 1})(n = 1, 2,\cdots)\)</span>。证明数列 <span class="math inline">\(\{x_n\}\)</span>有极限，并求 <span class="math inline">\(\lim\limits_{n \to \infty}x_n\)</span>。</p><blockquote><p>还没有证明极限存在</p></blockquote><p>由题目可得： [ <span class="math display">\[\begin{align*}x_{n + 1} &amp;= \frac{1}{2} (x_n + x_{n - 1})\\x_{n} &amp;= \frac{1}{2} (x_{n - 1} + x_{n - 2})\\&amp;\cdots\\x_{2} &amp;= \frac{1}{2} (x_{1} + x_{0})\end{align*}\]</span> ]</p><p>左右两边分别相加，并消项，得到 <span class="math inline">\(x_{n + 1}+ \frac{1}{2} x_n = x_1 + \frac{1}{2} x_0\)</span></p></li><li><p>设数列：<span class="math inline">\(x_0 = a\)</span>，<spanclass="math inline">\(x_1 = 1 + b x_0\)</span>，<spanclass="math inline">\(\cdots\)</span>，<span class="math inline">\(x_{n+ 1} = 1 + b x_n\)</span>，<spanclass="math inline">\(\cdots\)</span>，求 <spanclass="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>使得该数列收敛。</p><p>由题目可得： [ <span class="math display">\[\begin{align*}x_{n} &amp;= 1 + b x_{n - 1}\\x_{n - 1} &amp;= 1 + b x_{n - 2}\\&amp;\cdots\\x_1 &amp;= 1 + b x_0\end{align*}\]</span> ]</p><p>从而推出 <span class="math inline">\(x_n = 1 + b + b^2 + \cdots +b^{n - 1} + b^n \cdot a = \frac{b^n - 1}{b - 1} + b^n \cdot a =\frac{-1}{b - 1} + b^n (\frac{1}{b - 1} + a)\)</span>，分析得：当 <spanclass="math inline">\(|b| &lt; 1\)</span> 时，收敛；当 <spanclass="math inline">\(b \leq -1\)</span> 和 <spanclass="math inline">\(b &gt; 1\)</span> 时，<spanclass="math inline">\(a = \frac{1}{1 - b}\)</span> 时，收敛。</p></li><li><p>设 <span class="math inline">\(x_0 = a\)</span>，<spanclass="math inline">\(x_1 = b\)</span>，<span class="math inline">\(x_{n+ 1} = \frac{x_{n - 1} + (2n - 1) x_n}{2n}(n = 1, 2,\cdots)\)</span>，求 <span class="math inline">\(\lim\limits_{n \to\infty} x_n\)</span>。</p></li><li><p>设数列由递推公式 <span class="math inline">\(u_1 =b\)</span>，<span class="math inline">\(u_{n + 1} = u_n^2 + (1 - 2a) u_n+ a^2 (n = 1, 2, \cdots)\)</span> 所确定。当 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 为何值时，数列 <spanclass="math inline">\(\{u_n\}\)</span> 收敛？它的极限等于什么？</p></li><li><p>设数列 <span class="math inline">\(\{x_n\}\)</span>定义如下：<span class="math inline">\(x_1 = \sqrt{5}\)</span>，<spanclass="math inline">\(x_{n + 1} = x_n^2 - 2(n = 1, 2,\cdots)\)</span>。求极限 <span class="math inline">\(\lim\limits_{n \to\infty} \frac{x_1 x_2 \cdots x_n}{x_{n + 1}}\)</span>。</p></li><li><p>设 <span class="math inline">\(x_1 \in (0, 1)\)</span>，<spanclass="math inline">\(x_{n + 1} = x_n (1 - x_n)\)</span>，证明 <spanclass="math inline">\(\lim\limits_{n \to \infty} n x_n =1\)</span>。</p><p>易证 <span class="math inline">\(\lim\limits_{n \to \infty} x_n =0\)</span>，证明 <span class="math inline">\(\lim\limits_{n \to \infty}n x_n = 1\)</span> 等价于证明 <span class="math inline">\(\lim\limits_{n\to \infty} \frac{1}{n x_n} = 1\)</span>。由 stolz 定理得： <spanclass="math display">\[\lim_{n \to \infty} \frac{1}{n x_n} = \lim_{n \to \infty} \frac{1}{x_n}- \frac{1}{x_{n - 1}} = \lim_{n \to \infty} \frac{x_{n - 1} - x_n}{x_nx_{n - 1}} = \lim_{n \to \infty} \frac{x_{n - 1}^2}{x_{n - 1}^2 (1 -x_{n - 1})} = 1\]</span></p></li><li><p>设 <span class="math inline">\(x_1 = \sin x_0 &gt;0\)</span>，<span class="math inline">\(x_{n + 1} = \sin x_n(n = 1, 2,\cdots)\)</span>，证明 <span class="math inline">\(\lim\limits_{n \to\infty} x_n \sqrt{\frac{n}{3}} = 1\)</span></p><p>易证 <span class="math inline">\(\lim\limits_{n \to \infty} x_n =0\)</span>，证明 <span class="math inline">\(\lim\limits_{n \to \infty}x_n \sqrt{\frac{n}{3}} = 1\)</span> 等价于证明 <spanclass="math inline">\(\lim\limits_{n \to \infty} \frac{1}{n x_n^2} =\frac{1}{3}\)</span>，由 stolz 定理和洛必达法则得： <spanclass="math display">\[\lim_{n \to \infty} \frac{1}{n x_n^2} = \lim_{n \to \infty}\frac{1}{x_n^2} - \frac{1}{x_{n - 1}^2} = \lim_{n \to \infty} \frac{x_{n- 1}^2 - x_{n}^2}{x_n^2 x_{n - 1}^2} = \lim_{x \to 0^+} \frac{x^2 -\sin^2 x}{x^4} = \frac{1}{3}\]</span></p></li><li><p>设 <span class="math inline">\(x_n = (1 + \frac{1}{n + 1})^{n +1} -(1 + \frac{1}{n})^n (n = 1, 2, 3, \cdots)\)</span>。证明 <spanclass="math inline">\(\{x_n\}\)</span> 与 <spanclass="math inline">\(\{\frac{1}{n^2}\}\)</span> 是同阶无穷小。</p><p>只需要证明 $<em>{n } = c = </em>{n } $</p></li><li><p>求极限 <span class="math display">\[\lim_{n \to \infty} \frac{\sqrt[n]{n} - 1}{\frac{1}{n^{\alpha}}}(0 &lt;\alpha &lt; 1)\]</span></p><p>由等价无穷小，原极限为： <span class="math display">\[\lim_{n \to \infty} \frac{\sqrt[n]{n} - 1}{\frac{1}{n^{\alpha}}} =\lim_{n \to \infty} \frac{\text{e}^{\frac{\ln n}{n}} -1}{\frac{1}{n^{\alpha}}} = \lim_{n \to \infty} \frac{\frac{\lnn}{n}}{\frac{1}{n^{\alpha}}} = \lim_{n \to \infty} \frac{\ln n}{ n^{1 -\alpha}} = 0\]</span></p></li><li><p>设 <span class="math inline">\(x_1 = \sqrt{2}\)</span>，<spanclass="math inline">\(x_{n + 1} = \sqrt{2 + x_n}(n = 1, 2,\cdots)\)</span>，证明 <span class="math inline">\(x_n - 2 =o(\frac{1}{3^n})(n \to \infty)\)</span></p></li><li><p>设 <span class="math inline">\(f(x) = \frac{2 + x}{1 +x}\)</span>，<span class="math inline">\(x_0 = 1\)</span>，<spanclass="math inline">\(x_{n + 1} = f(x_n)(n = 0, 1, 2,\cdots)\)</span>，求 <span class="math inline">\(\lim\limits_{n \to\infty} x_n\)</span>，并尽可能估计数列趋于极限得速度。</p></li><li><p>设 <span class="math inline">\(x_1\)</span>，<spanclass="math inline">\(x_2\)</span>，<spanclass="math inline">\(x_3\)</span>，<spanclass="math inline">\(\cdots\)</span>，<spanclass="math inline">\(x_n\)</span>，<spanclass="math inline">\(\cdots\)</span> 是将方程 <spanclass="math inline">\(\tan x = x\)</span>的全部正根按由小到大的次序编号而成的，求极限 <spanclass="math inline">\(\lim\limits_{n \to \infty} (x_{n} - x_{n -1})\)</span>。</p></li><li><p>设 <span class="math inline">\(a &gt; 0\)</span>，<spanclass="math inline">\(f_n(x) = x^n + nx - a(n = 1, 2,\cdots)\)</span>，<span class="math inline">\(x_n\)</span> 是 <spanclass="math inline">\(f_n(x)\)</span> 在 <span class="math inline">\((0,+\infty)\)</span> 上的唯一零点，求 <spanclass="math inline">\(\lim\limits_{n \to \infty} (1 +x_n)^n\)</span></p></li><li><p>设 <span class="math inline">\(x_1 = a\)</span>，<spanclass="math inline">\(y_1 = b(0 &lt; a &lt; b)\)</span>；<spanclass="math inline">\(x_{n + 1} = \sqrt{x_n y_n}\)</span>，<spanclass="math inline">\(y_{n + 1} = \frac{x_n +y_n}{2}\)</span>。证明：数列 <spanclass="math inline">\(\{x_n\}\)</span>，<spanclass="math inline">\(\{y_n\}\)</span> 的极限都存在且相同。</p><p>由均值不等式得到 <span class="math inline">\(y_{n + 1} = \frac{x_n +y_n}{2} \geq \sqrt{x_n y_n} = x_{n + 1}\)</span>，若存在等号成立的 <spanclass="math inline">\(x_n\)</span> 和 <spanclass="math inline">\(y_n\)</span>，记为 <spanclass="math inline">\(a\)</span>，则有 <span class="math inline">\(x_{n+ 1} = x_n = y_{n + 1} = y_{n} =a\)</span>，此时显然存在极限且相同。若不存在等号成立的 <spanclass="math inline">\(x_n\)</span> 和 <spanclass="math inline">\(y_n\)</span>，此时严格有 <spanclass="math inline">\(y_{n} &gt; x_{n}\)</span>，从而可以推出，<spanclass="math inline">\(x_{n + 1} = \sqrt{x_n y_n} &gt; x_{n}\)</span> 和<span class="math inline">\(y_{n + 1} = \frac{x_n + y_n}{2} &lt;y_n\)</span>，且 <span class="math inline">\(x_n &lt; y_n &lt; y_1 =b\)</span> 和 <span class="math inline">\(y_n &gt; x_n &gt; x_1 =a\)</span>，所以数列 <span class="math inline">\(\{x_n\}\)</span>严格单调递增且有界，数列 <span class="math inline">\(\{y_n\}\)</span>严格单调递减且有界，故数列 <spanclass="math inline">\(\{x_n\}\)</span>，<spanclass="math inline">\(\{y_n\}\)</span> 的极限都存在，分别设极限为 <spanclass="math inline">\(x_0\)</span> 和 <spanclass="math inline">\(y_0\)</span>，由 <spanclass="math inline">\(\lim\limits_{n \to \infty} y_{n + 1} =\lim\limits_{n \to \infty} \frac{x_n + y_n}{2}\)</span> 得 <spanclass="math inline">\(x_0 = y_0\)</span>，所以极限相等。</p></li><li><p>求极限 <span class="math display">\[\lim_{x \to 0^{+}} \frac{x^x - (\sin)^x}{x^3}\]</span></p><p>原极限为： <span class="math display">\[\lim_{x \to 0^{+}} \frac{x^x - (\sin)^x}{x^3} = \lim_{x \to 0^{+}}\frac{\text{e}^{x \ln x} - \text{e}^{x \ln \sin x}}{x^3} = \lim_{x \to0^{+}} \frac{\text{e}^{\xi}(x \ln x - x \ln \sin x)}{x^3} = \frac{1}{6}\]</span></p></li><li><p>求极限 <span class="math display">\[\lim_{x \to + \infty} (\frac{x^{1 + x}}{(1 + x)^{x}} - \text{e}^{-1} x)\]</span></p><p>原极限为： <span class="math display">\[\lim_{x \to + \infty} (\frac{x^{1 + x}}{(1 + x)^{x}} - \text{e}^{-1} x)= \lim_{x \to + \infty} x \cdot (\frac{1}{(1 + \frac{1}{x})^x} -\frac{1}{\text{e}}) = \lim_{t \to 0^{+}} \frac{\text{e} - (1 +t)^{\frac{1}{t}}}{t(1 + t)^{\frac{1}{t}} \text{e}} = \frac{1}{\text{e}}\lim_{t \to 0^{+}} \frac{1 - \text{e}^{\frac{1}{t} \ln (1 + t) - 1}}{t}= \frac{1}{2\text{e}}\]</span></p></li><li><p>设 <span class="math inline">\(f(x)\)</span> 在区间 <spanclass="math inline">\([0, 1]\)</span> 上连续，<spanclass="math inline">\(f(0) = 0\)</span>，<spanclass="math inline">\(f(1) = 1\)</span>。证明：<spanclass="math inline">\(F(x) = f(x)(1 - f(x)) - x(1 - x)\)</span> 在 <spanclass="math inline">\([0, 1]\)</span> 上至少有 <spanclass="math inline">\(3\)</span> 个不同的零点。</p><p><span class="math inline">\(x = 0\)</span> 和 <spanclass="math inline">\(x = 1\)</span> 是两个零点，故只需要证明在区间<span class="math inline">\((0, 1)\)</span> 上至少有一个零点。<spanclass="math inline">\(F(x) = f(x) - f^2(x) - x + x^2 = (f(x) - x) -(f(x)- x)(f(x) + x) = (f(x) - x)(1 - f(x) - x)\)</span>，令 <spanclass="math inline">\(g(x) = 1 - f(x) - x\)</span>，有 <spanclass="math inline">\(g(0) = 1\)</span>，<spanclass="math inline">\(g(1) = -1\)</span>，由零点定理得，至少存在一点<span class="math inline">\(c\)</span>，使得 <spanclass="math inline">\(g(c) = 0\)</span>，所以至少有 <spanclass="math inline">\(3\)</span> 个零点。</p></li><li><p>设 <span class="math inline">\(f(x)\)</span> 在闭区间 <spanclass="math inline">\([0, 1]\)</span> 上连续，<spanclass="math inline">\(f(0) = f(1)\)</span>。证明：对于任何自然数 <spanclass="math inline">\(n\)</span>，总存在 <spanclass="math inline">\(\xi_n \in (0, 1)\)</span> 使得 <spanclass="math inline">\(f(\xi_n) = f(\frac{1}{n} + \xi_n)\)</span></p><p>令 <span class="math inline">\(F(x) = f(x) - f(\frac{1}{n} +x)\)</span>，只需要证明 <span class="math inline">\(F(x)\)</span> 在区间<span class="math inline">\([0, 1 - \frac{1}{n}]\)</span>上有零点。假设不存在零点，此时不妨设恒有 <spanclass="math inline">\(F(x) &gt; 0\)</span>，因此有 $F(0) + F() + + F()&gt; 0 $，也就是 <span class="math inline">\(f(0) - f(\frac{1}{n}) +f(\frac{1}{n}) - f(\frac{2}{n}) - \cdots - f(1) = f(0) - f(1) &gt;0\)</span>，显然出现矛盾，因为 <span class="math inline">\(f(0) - f(1) =0\)</span>，因此必然有零点。</p></li><li><p>设 <span class="math inline">\(f(x)\)</span>，<spanclass="math inline">\(g(x)\)</span> 在闭区间 <spanclass="math inline">\([a, b]\)</span> 上连续，并由数列 <spanclass="math inline">\(\{x_0\} \subset [a, b]\)</span>，使得 <spanclass="math inline">\(f(x_{n + 1}) = g(x_n) (n = 1, 2,\cdots)\)</span>。证明：存在一点 <spanclass="math inline">\(x_0\)</span>，使得 <spanclass="math inline">\(f(x_0) = g(x_0)\)</span>。</p><p>设 <span class="math inline">\(F(x) = f(x) - g(x)\)</span>，假设<span class="math inline">\(F(x)\)</span> 在区间 <spanclass="math inline">\([a, b]\)</span> 不存在零点，其在区间内的最小值为<span class="math inline">\(m\)</span>，不妨设恒有 <spanclass="math inline">\(F(x) &gt; 0\)</span>，<spanclass="math inline">\(f(x_{n + 1}) = g(x_n) = g(x_n) - f(x_n) + g(x_{n -1}) = [g(x_n) - f(x_n)] + [g(x_{n - 1}) - f(x_{n - 1})] + \cdots +[g(x_2) - f(x_2)] + g(x_1) = -F(x_n) - F(x_{n - 1}) - \cdots - F(x_2) +g(x_1) \leq (1 - n)m + g(x_1)\)</span>，显然 <spanclass="math inline">\(\lim\limits_{n \to \infty} f(x_n) =-\infty\)</span> 和 <span class="math inline">\(f(x)\)</span>有界条件矛盾，所以必然存在一点 <spanclass="math inline">\(x_0\)</span>，使得 <spanclass="math inline">\(f(x_0) = g(x_0)\)</span>。</p></li><li><p>设函数 <span class="math inline">\(f(x)\)</span> 在闭区间 <spanclass="math inline">\([a, b]\)</span> 上连续，其值域 <spanclass="math inline">\(f([a, b]) \subseteq [a,b]\)</span>。证明：该函数存在不动点，即存在 <spanclass="math inline">\(x_0 \in [a, b]\)</span> 使得 <spanclass="math inline">\(f(x_0) = x_0\)</span>。</p><p>设函数 <span class="math inline">\(F(x) = f(x)-x\)</span>，由题知：<span class="math inline">\(a \leq f(x) \leqb\)</span>，所以有 <span class="math inline">\(F(a) = f(a) - a \geq0\)</span> 和 <span class="math inline">\(F(b) = f(b) - b \leq0\)</span>，有零点定理得：至少存在一点 <spanclass="math inline">\(x_0\)</span> 使得 <spanclass="math inline">\(f(x_0) = x_0\)</span>。</p></li><li><p>设函数 <span class="math inline">\(f(x)\)</span> 在区间 <spanclass="math inline">\((0, 1)\)</span> 内有定义，且 <spanclass="math inline">\(\text{e}^{x} f(x)\)</span> 与 <spanclass="math inline">\(\text{e}^{-f(x)}\)</span> 在区间 <spanclass="math inline">\((0, 1)\)</span> 内都是单调递加的函数，证明：<spanclass="math inline">\(f(x)\)</span> 在 <span class="math inline">\((0,1)\)</span> 内连续。</p><p>根据 <span class="math inline">\(\text{e}^{-f(x)}\)</span>的单调性，可知，函数 <span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\((0, 1)\)</span> 上单调递减。任取 <spanclass="math inline">\(x_0 \in (0, 1)\)</span>，当 <spanclass="math inline">\(x \in (x_0, 1)\)</span>，有 <spanclass="math inline">\(\text{e}^{x_0 - x} f(x_0) \leq f(x) &lt;f(x_0)\)</span>，由夹逼定理得到 <spanclass="math inline">\(\lim\limits_{x \to x_0^+} f(x) =f(x_0)\)</span>；当 <span class="math inline">\(x \in (0,x_0)\)</span>，同理可得 <span class="math inline">\(f(x_0) &lt; f(x)&lt; \text{e}^{x_0 - x} f(x)\)</span>，由夹逼定理得 <spanclass="math inline">\(\lim\limits_{x \to x_0^{-}} f(x) =f(x_0)\)</span>，综上，<span class="math inline">\(\lim\limits_{x \tox_0} f(x) =f(x_0)\)</span>，得连续性。</p></li><li><p>设 <span class="math inline">\(f(x)\)</span> 在区间 <spanclass="math inline">\((0, +\infty)\)</span> 上有定义，在 <spanclass="math inline">\(x = 1\)</span> 处连续且 <spanclass="math inline">\(f(1) = 3\)</span>。如果对任意正数 <spanclass="math inline">\(x\)</span> 都有 <span class="math inline">\(f(x^2)= f(x)\)</span> 成立，求 <span class="math inline">\(f(x)\)</span>的表达式。</p><p><span class="math inline">\(f(x) = f(\sqrt{x}) = f(\sqrt[4]{x}) =\cdots = f(\sqrt[2^n]{x})\)</span>，<spanclass="math inline">\(\lim\limits_{n \to \infty} f(\sqrt[2^n]{x}) = f(1)= 3\)</span>，由于在 <span class="math inline">\(x = 1\)</span>处连续，所以有 <span class="math inline">\(f(x) \equiv3\)</span>。</p></li><li><p>设函数 <span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\((-\infty, +\infty)\)</span> 上有定义，在 <spanclass="math inline">\(x = 0\)</span> 处连续且 <spanclass="math inline">\(f(0) = 2\)</span>。证明：恒等式 <spanclass="math inline">\(f(2x) = f(x) \text{e}^x\)</span> 成立的充要条件是<span class="math inline">\(f(x) = 2 \text{e}^{x}\)</span>。</p><p>充分性显然，下面证明必要性。<span class="math inline">\(f(x) =f(\frac{x}{2}) \text{e}^{\frac{x}{2}} = f(\frac{x}{4})\text{e}^{\frac{x}{4}} \text{e}^{\frac{x}{2}} = \cdots =f(\frac{x}{2^n}) \text{e}^{x(\frac{\frac{1}{2} - \frac{1}{2^{n + 1}}}{1- \frac{1}{2}})}\)</span>，所以 <spanclass="math inline">\(\lim\limits_{n \to \infty} f(x) = f(0)\text{e}^{x} = 2 \text{e}^{x}\)</span>，由于 <spanclass="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x =0\)</span> 处连续，所以 <span class="math inline">\(f(x) = 2\text{e}^{x}\)</span>。综上，得证充分必要性。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\((-\infty. +\infty)\)</span> 上有定义，在点 <spanclass="math inline">\(x = 0\)</span> 处连续且 <spanclass="math inline">\(f(1) = 2\)</span>。又对于任何 <spanclass="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>满足函数方程 <span class="math inline">\(f(x + y) = f(x) + f(y)\)</span>成立。求 <span class="math inline">\(f(x)\)</span> 的表达式。</p></blockquote><p>先证明，<span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\((-\infty. +\infty)\)</span> 上连续，<spanclass="math inline">\(f(0) = 0\)</span> 且在点 <spanclass="math inline">\(x = 0\)</span> 处连续，所以 <spanclass="math inline">\(\lim\limits_{x \to 0} f(x) = 0\)</span>，对任意<span class="math inline">\(x_0 \in (-\infty, +\infty)\)</span>，<spanclass="math inline">\(\lim\limits_{\Delta x \to 0} f(x + \Delta x) =f(x) + \lim\limits_{\Delta x \to 0} f(\Delta x) =f(x)\)</span>，故证明连续性。对于任意正整数 <spanclass="math inline">\(n\)</span>，有 <span class="math inline">\(f(1) =f(\frac{1}{n}) + f(\frac{1}{n}) + \cdots + f(\frac{1}{n}) = nf(\frac{1}{n})\)</span>，也就是 <span class="math inline">\(f(1)\frac{1}{n} = f(\frac{1}{n})\)</span>；同理，对于任意正有理数 <spanclass="math inline">\(\frac{m}{n}\)</span>，有 <spanclass="math inline">\(f(\frac{m}{n}) = m f(\frac{1}{n}) = 2\frac{m}{n}\)</span>，也就是 <span class="math inline">\(f(x) =2x\)</span>。对任意负有理数 <spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(-x\)</span> 是正有理数，所以 <spanclass="math inline">\(f(0) = f(x) + f(-x)\)</span>，得到 <spanclass="math inline">\(f(-x) = 2 \cdot -x\)</span>，同样说明了 <spanclass="math inline">\(f(x) = 2x\)</span>。对于任何无理数 <spanclass="math inline">\(x\)</span>，存在有理数列 <spanclass="math inline">\(r_n\)</span>，<spanclass="math inline">\(\lim\limits_{n \to \infty} r_n =x\)</span>，由函数及其连续性知 <span class="math inline">\(f(x) =\lim\limits_{n \to \infty} f(r_n) = \lim\limits_{n \to \infty} 2r_n =2x\)</span>。综上，<span class="math inline">\(f(x) =2x\)</span>。</p></li><li><blockquote><p>设有一非负连续函数，对于所有的实数 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 满足函数方程 <spanclass="math inline">\(f(\sqrt{x^2 + y^2}) = f(x)f(y)\)</span> 及 <spanclass="math inline">\(f(1) = 2\)</span>，证明：<spanclass="math inline">\(f(x) = 2^{x^{2}}\)</span>。</p></blockquote><p><span class="math inline">\(f(1) = f(0)f(1)\)</span>，所以 <spanclass="math inline">\(f(0) = 1\)</span>。对任意正整数 <spanclass="math inline">\(n\)</span>，有 <span class="math inline">\(f(n) =f^{n}(\frac{n^{2^n}}{2^{2^n - 1}})\)</span></p></li><li><blockquote><p>求极限 <span class="math display">\[\lim_{x \to 0^-} -\frac{1}{x^2} \text{e}^{\frac{1}{x}}\]</span></p></blockquote><p><span class="math display">\[\lim_{x \to 0^-} -\frac{1}{x^2} \text{e}^{\frac{1}{x}} = \lim_{t \to+\infty} - \frac{t^2}{\text{e}^t} = 0\]</span></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Wireshark Homework</title>
    <link href="/2025/06/17/Wireshark-Homework/"/>
    <url>/2025/06/17/Wireshark-Homework/</url>
    
    <content type="html"><![CDATA[<h2 id="提取的请求信息">提取的请求信息</h2><figure><img src="Wireshark-Homework/get%20request.png" alt="get request" /><figcaption aria-hidden="true">get request</figcaption></figure><figure><img src="Wireshark-Homework/request%20right.png" alt="request right" /><figcaption aria-hidden="true">request right</figcaption></figure><figure><img src="Wireshark-Homework/response.png" alt="response" /><figcaption aria-hidden="true">response</figcaption></figure><figure><img src="Wireshark-Homework/response%20more%20details.png"alt="response more details" /><figcaption aria-hidden="true">response more details</figcaption></figure><figure><img src="Wireshark-Homework/response%20right.png"alt="response right" /><figcaption aria-hidden="true">response right</figcaption></figure><h3 id="源和目标ip地址">源和目标IP地址</h3><ul><li><strong>源IP地址</strong>:10.21.205.40（本机IP，如ipconfig截图所示）</li><li><strong>目标IP地址</strong>: 104.110.191.133（服务器IP）</li></ul><h3 id="端口号">端口号</h3><ul><li><strong>源端口</strong>: 54283（随机分配的客户端端口）</li><li><strong>目标端口</strong>: 80（标准HTTP端口）</li></ul><h3 id="host字段">Host字段</h3><ul><li><strong>Host</strong>: <code>www.msftconnecttest.com</code></li></ul><h3 id="user-agent字段">User-Agent字段</h3><ul><li><strong>User-Agent</strong>: Microsoft NCSI</li></ul><h2 id="提取的响应信息">提取的响应信息</h2><h3 id="状态码">状态码</h3><ul><li><strong>状态码</strong>: 200 OK</li></ul><h3 id="content-type字段">Content-Type字段</h3><ul><li><strong>Content-Type</strong>: text/plain</li></ul><h3 id="server字段">Server字段</h3><ul><li>在提供的截图中没有明确显示Server字段，该字段可能不存在于此HTTP响应中，或位于未捕获到的响应头部分</li></ul><h2 id="问题思考">问题思考</h2><h3id="http请求的目标端口通常是多少">HTTP请求的目标端口通常是多少？</h3><p>HTTP请求的<strong>标准目标端口是80</strong>，如截图中所示。HTTPS则使用443端口。</p><h3 id="报文中的字段形式是怎样的">报文中的字段形式是怎样的？</h3><p>HTTP报文使用<strong>纯文本格式</strong>，以”字段名:字段值”的形式组织，每行一个字段，如截图中所示： -<code>Host: www.msftconnecttest.com</code> -<code>User-Agent: Microsoft NCSI</code> -<code>Content-Type: text/plain</code></p><p>Wireshark同时提供了三种查看方式： 1.<strong>解析后的纯文本视图</strong>（HTTP协议字段被解析为易读形式） 2.<strong>十六进制原始数据视图</strong>（数据包的二进制表现形式） 3.<strong>结构化协议树</strong>（按协议层级组织的视图）</p><p>在Wireshark中可以看到，虽然在网络上传输时是二进制字节流，但HTTP协议本身是<strong>基于文本</strong>的协议。</p><h2 id="dns">DNS</h2><figure><img src="Wireshark-Homework/四条信息.png" alt="四条信息" /><figcaption aria-hidden="true">四条信息</figcaption></figure><figure><img src="Wireshark-Homework/config.png" alt="config" /><figcaption aria-hidden="true">config</figcaption></figure><figure><img src="Wireshark-Homework/A%20request.png" alt="A request" /><figcaption aria-hidden="true">A request</figcaption></figure><figure><img src="Wireshark-Homework/AAAA%20request.png" alt="AAAA request" /><figcaption aria-hidden="true">AAAA request</figcaption></figure><figure><img src="Wireshark-Homework/A%20response.png" alt="A response" /><figcaption aria-hidden="true">A response</figcaption></figure><figure><img src="Wireshark-Homework/AAAA%20response.png" alt="AAAA response" /><figcaption aria-hidden="true">AAAA response</figcaption></figure><h2 id="清除dns缓存">清除DNS缓存</h2><p>从终端截图可以看到，已使用命令<code>ipconfig /flushdns</code>成功清除了DNS缓存：- 终端显示：<strong>“已成功刷新 DNS 解析缓存”</strong> -使用<code>nslookup</code>确认DNS服务器为<strong>10.3.9.5</strong></p><h2 id="dns查询与响应报文分析">DNS查询与响应报文分析</h2><h3 id="查询报文分析">查询报文分析</h3><p>根据截图，可以看到多个DNS查询：</p><ol type="1"><li><strong>查询域名</strong>：www.163.com</li><li><strong>查询类型</strong>：<ul><li>A记录查询（IPv4地址）- Type: A (1)</li><li>AAAA记录查询（IPv6地址）- Type: AAAA (28)</li></ul></li><li><strong>查询特征</strong>：<ul><li>Transaction ID: 0x8d99（A记录查询）和0xaa7c（AAAA记录查询）</li><li>源端口：55570、59624（随机客户端端口）</li><li>目标端口：<strong>53</strong>（标准DNS端口）</li><li>使用<strong>UDP协议</strong>传输</li></ul></li></ol><h3 id="响应报文分析">响应报文分析</h3><ol type="1"><li><strong>查询域名</strong>：<code>www.163.com</code></li><li><strong>响应IP地址</strong>：多个IP地址返回，包括：<ul><li><strong>IPv4地址</strong>（A记录）：<ul><li>220.181.171.126</li><li>220.181.10.69</li><li>220.181.10.67</li><li>220.181.10.70</li><li>220.181.10.66</li><li>等多个IP地址</li></ul></li><li><strong>CNAME记录</strong>：<ul><li><code>www.163.com.163jiasu.com</code></li><li><code>www.163.com.w.kunluncan.com</code></li></ul></li></ul></li></ol><h2 id="dns协议特性分析">DNS协议特性分析</h2><h3 id="dns使用的端口号">DNS使用的端口号</h3><p>从截图中可以明确看到： -<strong>服务器端口</strong>：53（固定标准端口） -<strong>客户端端口</strong>：随机高位端口（如55570、59624）</p><h3 id="dns使用的传输协议">DNS使用的传输协议</h3><p>截图中可以看到： - <strong>主要使用UDP协议</strong>，因为： -数据包标识为”User Datagram Protocol” - 相比TCP更快速，适合简短的DNS查询- 标准DNS查询通常小于512字节，适合UDP传输</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>DNS特性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>查询域名</td><td><code>www.163.com</code></td><td>中国网易公司网站</td></tr><tr><td>查询类型</td><td>A 和 AAAA</td><td>分别查询IPv4和IPv6地址</td></tr><tr><td>客户端端口</td><td>55570、59624等</td><td>随机高位端口</td></tr><tr><td>服务器端口</td><td>53</td><td>DNS标准端口</td></tr><tr><td>传输协议</td><td>UDP</td><td>无连接、快速、适合短查询</td></tr><tr><td>查询事务ID</td><td>0x8d99、0xaa7c</td><td>确保请求和响应匹配的唯一标识符</td></tr></tbody></table></div><p><strong>补充说明</strong>：虽然本次抓包显示使用UDP，但DNS协议在某些情况下也会使用TCP：- 当响应大小超过512字节时 - 进行区域传送(AXFR)等操作时 -需要可靠连接时</p>]]></content>
    
    
    <categories>
      
      <category>Wireshark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Introduction</title>
    <link href="/2025/06/10/Introduction/"/>
    <url>/2025/06/10/Introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="network-edge">Network Edge</h1><p>applications and hosts</p><h1 id="client-program-and-server-program">Client Program and ServerProgram</h1><p>一般而言，客户端程序是 <strong>发送请求</strong> 的，而服务器端程序是<strong>接受请求</strong> 的。</p><h1 id="access-technologies">Access Technologies</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>接入技术</th><th>分类</th><th>简要说明</th></tr></thead><tbody><tr><td>数字用户线（DSL）</td><td>居家接入</td><td>通过电话线为家庭用户提供宽带互联网接入</td></tr><tr><td>电缆调制解调器</td><td>居家接入</td><td>通过有线电视网络为家庭用户提供互联网接入</td></tr><tr><td>光纤到户（FTTH）</td><td>居家接入/公司接入</td><td>通过光纤直接连接家庭或公司，提供高速接入</td></tr><tr><td>以太网</td><td>公司接入</td><td>企业内部常用的局域网接入方式</td></tr><tr><td>Wi-Fi</td><td>居家接入/公司接入</td><td>无线局域网，常用于家庭和公司内部无线接入</td></tr><tr><td>蜂窝移动网络（3G/4G/5G）</td><td>移动接入</td><td>通过移动运营商网络为移动设备提供互联网接入</td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>接入技术</th><th>典型速率范围</th><th>速率共享性</th><th>说明</th></tr></thead><tbody><tr><td>拨号调制解调器</td><td>最高 56 Kbps</td><td>专用</td><td>每户独占电话线</td></tr><tr><td>HFC</td><td>10 Mbps ~ 1 Gbps（下行）</td><td>共享</td><td>同轴电缆段内用户共享带宽</td></tr><tr><td>DSL</td><td>256 Kbps ~ 100 Mbps（下行）</td><td>专用</td><td>每户独占电话线，汇聚点可能有瓶颈</td></tr><tr><td>FTTH</td><td>100 Mbps ~ 10 Gbps</td><td>通常专用</td><td>部分PON架构下分光器后带宽被共享</td></tr></tbody></table></div><h1 id="hfc-hybrid-fiber-coax">HFC: hybrid fiber coax</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>问题</th><th>答案</th></tr></thead><tbody><tr><td>HFC 传输速率是专用还是共享？</td><td>共享</td></tr><tr><td>下行 HFC 信道是否可能发生冲突？</td><td>不会</td></tr><tr><td>原因</td><td>只有头端设备发送，无多发冲突</td></tr></tbody></table></div><h1 id="ethernet-lans">Ethernet LANs</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>以太网类型</th><th>典型速率</th><th>每用户能否持续满速发送？</th></tr></thead><tbody><tr><td>10BASE-T</td><td>10 Mbps</td><td>否</td></tr><tr><td>100BASE-TX</td><td>100 Mbps</td><td>否</td></tr><tr><td>1000BASE-T</td><td>1 Gbps</td><td>否</td></tr><tr><td>10GBASE-T</td><td>10 Gbps</td><td>否</td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>物理介质类型</th><th>典型应用场景</th><th>传输距离</th><th>传输速率</th></tr></thead><tbody><tr><td>双绞线</td><td>局域网、办公、家庭</td><td>最远可达100米</td><td>10 Mbps ~ 40 Gbps</td></tr><tr><td>光纤</td><td>数据中心、骨干网</td><td>数百米至数十公里</td><td>100 Mbps ~ 400 Gbps</td></tr><tr><td>同轴电缆</td><td>早期局域网</td><td>数百米</td><td>10 Mbps</td></tr></tbody></table></div><h1 id="wireless-internet-access-technologies">Wireless Internet AccessTechnologies</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>技术类型</th><th>典型速率范围</th><th>覆盖范围</th><th>主要应用场景</th><th>延迟</th><th>主要优缺点</th></tr></thead><tbody><tr><td>Wi-Fi</td><td>数十 Mbps ~ 数 Gbps</td><td>局部（几十米）</td><td>家庭、办公、热点</td><td>低</td><td>速率高、成本低、覆盖范围有限</td></tr><tr><td>蜂窝网络（4G/5G）</td><td>数十 Mbps ~ 数 Gbps</td><td>广域（城市/乡村）</td><td>移动设备、车载、物联网</td><td>低（5G更优）</td><td>覆盖广、速率高、需付流量费用</td></tr><tr><td>卫星互联网</td><td>数十 Mbps ~ 数百 Mbps</td><td>全球（含偏远区）</td><td>偏远地区、应急通信</td><td>中~高</td><td>覆盖广、不依赖地面设施、延迟较高</td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><table style="width:100%;"><thead><tr><th>设备类型</th><th style="text-align: center;">物理层</th><th style="text-align: center;">链路层</th><th style="text-align: center;">网络层</th><th style="text-align: center;">传输层</th><th style="text-align: center;">应用层</th></tr></thead><tbody><tr><td>路由器</td><td style="text-align: center;"><spanclass="math display">\[\surd\]</span></td><td style="text-align: center;"><spanclass="math display">\[\surd\]</span></td><td style="text-align: center;"><spanclass="math display">\[\surd\]</span></td><td style="text-align: center;"><spanclass="math display">\[\times\]</span></td><td style="text-align: center;"></td></tr><tr><td>链路层交换机</td><td style="text-align: center;"><spanclass="math display">\[\surd\]</span></td><td style="text-align: center;"><spanclass="math display">\[\surd\]</span></td><td style="text-align: center;"><spanclass="math display">\[\times\]</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td>主机</td><td style="text-align: center;"><spanclass="math display">\[\surd\]</span></td><td style="text-align: center;"><spanclass="math display">\[\surd\]</span></td><td style="text-align: center;"><spanclass="math display">\[\surd\]</span></td><td style="text-align: center;"><spanclass="math display">\[\surd\]</span></td><td style="text-align: center;"><spanclass="math display">\[\surd\]</span></td></tr></tbody></table></div><h1 id="packet-switching-and-circuit-switching">Packet Switching andCircuit Switching</h1><ul><li><strong>带宽保证</strong>：电路交换网络（如传统电话网）在通信双方建立连接时，会为其分配一条固定的物理路径和带宽，整个通信期间该带宽专属使用，不会被其他用户占用。</li><li><strong>通信延迟低且稳定</strong>：由于路径和带宽在会话期间独占，数据传输延迟固定且可预测，适合对实时性要求高的应用（如语音通话）。</li><li><strong>无拥塞丢包</strong>：通信过程中不会因网络拥塞导致丢包或重传，通信质量有保障。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>网络类型</th><th>主要优势</th></tr></thead><tbody><tr><td>电路交换网络</td><td>带宽独占、延迟稳定、无拥塞丢包</td></tr><tr><td>分组交换网络</td><td>资源利用率高、灵活、适合突发性数据传输</td></tr></tbody></table></div><h2 id="statistical-multiplexing">Statistical Multiplexing</h2><p>分组交换（PacketSwitching）中，网络资源（如链路带宽）是<strong>按需动态分配</strong>给各个数据流的。每个用户的数据被分成分组（包），这些分组在网络中独立传输，多个用户的分组在同一链路上<strong>交错传输</strong>。<br />由于不是每个用户都持续发送数据，链路带宽可以被“活跃”的用户动态共享，这种方式称为<strong>统计复用（StatisticalMultiplexing）</strong>。</p><ul><li><strong>核心思想</strong>：利用用户流量的突发性和不均匀性，通过动态分配资源，提高链路利用率。</li><li><strong>资源分配</strong>：没有为每个用户预留固定带宽，资源按需分配。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>复用方式</th><th>资源分配方式</th><th>利用率</th><th>适用场景</th><th>主要特点</th></tr></thead><tbody><tr><td>统计复用</td><td>动态分配，按需使用</td><td>高</td><td>分组交换网络</td><td>用户多时可能拥塞，利用率高</td></tr><tr><td>TDM（时分复用）</td><td>固定分配，每用户固定时隙</td><td>低（有空闲浪费）</td><td>电路交换网络</td><td>时隙空闲时无法被他人利用</td></tr></tbody></table></div><h2 id="store-and-forward-packet-switching">Store-and-Forward PacketSwitching</h2><p><strong>存储转发</strong>：交换机必须在收到整个分组后，才能开始向下一个链路转发。</p><h1 id="isp">ISP</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>ISP 类型</th><th>互联方式</th><th>是否需购买上网带宽</th><th>网络覆盖范围</th></tr></thead><tbody><tr><td>Tier-1 ISP</td><td>与其他 Tier-1 ISP 结算互免互联</td><td>否</td><td>全球骨干</td></tr><tr><td>Tier-2 ISP</td><td>部分互联+向上级 ISP 购买带宽</td><td>是</td><td>区域/国家级</td></tr></tbody></table></div><h1 id="delay">Delay</h1><ul><li>ProcessingDelay：每个路由器或主机在接收到分组时进行首部检查、差错检测等处理所需的时间。</li><li>QueuingDelay：分组在路由器的输出队列中等待转发的时间，取决于当前队列的长度和网络拥塞状况。</li><li>Transmission Delay：分组所有比特从路由器或主机的输出端口“上线”所需的时间，计算公式为 <spanclass="math display">\[\text{传输时延} = \frac{L}{R}\]</span> 其中，<span class="math inline">\(L\)</span>为分组长度（比特），<span class="math inline">\(R\)</span>为链路带宽（比特/秒）。</li><li>Propagation Delay： 分组在物理链路上传播所需的时间，计算公式为：<span class="math display">\[\text{传播时延} = \frac{d}{s}\]</span> 其中，<span class="math inline">\(d\)</span> 为链路长度，<spanclass="math inline">\(s\)</span> 为信号在介质中的传播速率。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>时延类型</th><th>公式</th><th>是否依赖分组长度 L</th><th>是否依赖传输速率 R</th></tr></thead><tbody><tr><td>传播时延</td><td><span class="math display">\[\frac{d}{s}\]</span></td><td>否</td><td>否</td></tr><tr><td>传输时延</td><td><span class="math display">\[\frac{L}{R}\]</span></td><td>是</td><td>是</td></tr><tr><td>总时延</td><td><span class="math display">\[\frac{L}{R} + \frac{d}{s}\]</span></td><td>部分依赖</td><td>部分依赖</td></tr></tbody></table></div><h1 id="throughput">Throughput</h1><p>吞吐量：传输速率，单位 <span class="math inline">\(\text{bits} /\text{time}\)</span>。</p><p>每一个用于传输比特流的 <strong>pipe</strong>的吞吐量可能不一致，这时如何计算端到端的吞吐量？ <spanclass="math display">\[\min \, \{R_C, R_S, \dots\}\]</span></p><p>这种情况下，端到端的吞吐量取决于整个传输路径中最慢的通道</p><h1 id="layer-structure">Layer Structure</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>任务名称</th><th>可能涉及的层级</th><th>是否可多层实现</th></tr></thead><tbody><tr><td>分段与重组</td><td>传输层、网络层</td><td>是</td></tr><tr><td>差错检测与纠正</td><td>数据链路层、传输层</td><td>是</td></tr><tr><td>流量控制</td><td>数据链路层、传输层</td><td>是</td></tr><tr><td>寻址与路由选择</td><td>网络层</td><td>否（主要网络层）</td></tr><tr><td>封装与解封装</td><td>各层均有</td><td>是</td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>层级</th><th>数据单元名称</th><th>主要内容说明</th></tr></thead><tbody><tr><td>应用层</td><td>应用层消息</td><td>应用协议数据（如HTTP请求、邮件内容等）</td></tr><tr><td>传输层</td><td>报文段（Segment）</td><td>传输层首部 + 应用层消息</td></tr><tr><td>网络层</td><td>数据报（Datagram）</td><td>网络层首部 + 传输层报文段</td></tr><tr><td>链路层</td><td>帧（Frame）</td><td>链路层首部 + 网络层数据报 + 链路层尾部</td></tr></tbody></table></div><h1 id="security">Security</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>类型</th><th style="text-align: center;">是否自我复制</th><th style="text-align: center;">是否依附宿主</th><th style="text-align: center;">是否主动传播</th><th>主要危害方式</th></tr></thead><tbody><tr><td>病毒</td><td style="text-align: center;">是</td><td style="text-align: center;">是</td><td style="text-align: center;">否</td><td>破坏文件、传播感染</td></tr><tr><td>蠕虫</td><td style="text-align: center;">是</td><td style="text-align: center;">否</td><td style="text-align: center;">是</td><td>网络传播、资源消耗</td></tr><tr><td>特洛伊木马</td><td style="text-align: center;">否</td><td style="text-align: center;">否</td><td style="text-align: center;">否</td><td>窃密、远控、伪装攻击</td></tr></tbody></table></div><ul><li><strong>僵尸网络（Botnet）</strong>：由大量被恶意控制的设备组成的分布式网络。</li><li><strong>DDoS攻击（分布式拒绝服务攻击）</strong>：利用僵尸网络同时发起大规模攻击，瘫痪目标服务。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td>恶意软件传播</td><td>通过多种方式感染大量设备</td></tr><tr><td>设备感染与控制</td><td>感染设备与C&amp;C服务器建立联系，成为“僵尸”</td></tr><tr><td>集中管理</td><td>攻击者统一管理所有僵尸设备</td></tr><tr><td>发起DDoS攻击</td><td>僵尸设备同时向目标发起流量，导致目标服务瘫痪</td></tr></tbody></table></div><h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1><h2 id="r.15">R.15</h2><p>Suppose users share a <span class="math inline">\(2\)</span> Mbpslink. Also suppose each user transmits continuously at <spanclass="math inline">\(1\)</span> Mbps when transmitting, but each usertransmits only <span class="math inline">\(20\)</span> percent of thetime. (See the discussion of statistical multiplexing in Section <spanclass="math inline">\(1.3\)</span>.)</p><p><strong>Questions and Answers:</strong></p><p><strong>a. When circuit switching is used, how many users can besupported?</strong></p><p>在电路交换中，每个用户需要预留 <span class="math inline">\(1\)</span>Mbps 的带宽，而链路总带宽为 <span class="math inline">\(2\)</span>Mbps。因此，最多可以支持：</p><p><span class="math display">\[\text{用户数} = \frac{\text{总带宽}}{\text{每用户带宽}} = \frac{2 \,\text{Mbps}}{1 \, \text{Mbps}} = 2 \, \text{用户}\]</span></p><p><strong>b. For the remainder of this problem, suppose packetswitching is used. Why will there be essentially no queuing delay beforethe link if two or fewer users transmit at the same time? Why will therebe a queuing delay if three users transmit at the sametime?</strong></p><ul><li>如果两名或更少的用户同时传输，每个用户的传输速率为 <spanclass="math inline">\(1\)</span> Mbps，总传输速率为 <spanclass="math inline">\(2\)</span> Mbps或更少，等于链路的总带宽。因此，数据可以立即通过链路传输，不会产生排队延迟。</li><li>如果三名用户同时传输，总传输速率为 <span class="math inline">\(3 \,\text{Mbps}\)</span>，超过了链路的总带宽 <span class="math inline">\(2\,\text{Mbps}\)</span>。此时，链路无法立即传输所有数据，导致数据在队列中等待，从而产生排队延迟。</li></ul><p><strong>c. Find the probability that a given user istransmitting.</strong></p><p>每个用户有 <span class="math inline">\(20\%\)</span>的时间在传输数据，因此某个用户正在传输的概率为：</p><p><span class="math display">\[P(\text{用户传输}) = 0.2\]</span></p><p><strong>d. Suppose now there are three users. Find the probabilitythat at any given time, all three users are transmitting simultaneously.Find the fraction of time during which the queue grows.</strong></p><ul><li>每个用户独立传输的概率为 <spanclass="math inline">\(0.2\)</span>，因此三名用户同时传输的概率为：</li></ul><p><span class="math display">\[P(\text{三名用户同时传输}) = P(\text{用户1传输}) \cdotP(\text{用户2传输}) \cdot P(\text{用户3传输}) = 0.2 \cdot 0.2 \cdot 0.2= 0.008\]</span></p><ul><li>队列增长的时间比例等于三名用户同时传输的概率，因为只有在这种情况下，传输速率超过链路带宽：</li></ul><p><span class="math display">\[\text{队列增长的时间比例} = 0.008\]</span></p><h2 id="r.19">R.19</h2><p>Suppose Host A wants to send a large file to Host B. The path fromHost A to Host B has three links, of rates <spanclass="math inline">\(R_1\)</span> = <spanclass="math inline">\(500\)</span> Kbps, <spanclass="math inline">\(R_2\)</span> = <spanclass="math inline">\(2\)</span> Mbps, and <spanclass="math inline">\(R_3\)</span> = <spanclass="math inline">\(1\)</span> Mbps.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. Assuming no other traffic in the network, what is thethroughput for the file transfer.</strong></p><ul><li>用公式 <span class="math inline">\(\min {R_i}\)</span>计算得到实际吞吐量是 <span class="math inline">\(500\)</span>Kbps。</li></ul><p><strong>b. Suppose the file is 4 million bytes. Dividing the filesize by the throughput, roughly how long will it take to transfer thefile to Host B?</strong></p><ul><li><span class="math display">\[\text{传输时间} = \frac{4 \times 10^{6}\times 8}{500 \times 1000} = 64 \, \text{s}\]</span></li></ul><p><strong>c. Repeat (a) and (b), but now with R2 reduced to 100Kbps.</strong></p><ul><li>用公式 <span class="math inline">\(\min {R_i}\)</span>计算得到实际吞吐量是 <span class="math inline">\(100\)</span>Kbps。</li><li><span class="math display">\[\text{传输时间} = \frac{4 \times 10^{6}\times 8}{100 \times 1000} = 320 \, \text{s}\]</span></li></ul><h2 id="r.23">R.23</h2><p><strong>Questions and Answers:</strong></p><p><strong>What are the five layers in the Internet protocol stack? Whatare the principal responsibilities of each of these layers?</strong></p><p>There are application layer, transport layer, network layer, datalink layer and physical layer. Their principal responsibilities are asfollow:</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>层级</strong></th><th><strong>名称</strong></th><th><strong>主要职责</strong></th><th><strong>典型协议举例</strong></th></tr></thead><tbody><tr><td><strong>第5层</strong></td><td>应用层 (Application)</td><td>提供<strong>网络服务的接口</strong>，支持应用程序间的通信</td><td>HTTP, FTP, SMTP, DNS</td></tr><tr><td><strong>第4层</strong></td><td>传输层 (Transport)</td><td>提供<strong>端到端的传输服务</strong>，负责分段、重组、流量控制和差错恢复</td><td>TCP, UDP</td></tr><tr><td><strong>第3层</strong></td><td>网络层 (Network)</td><td>负责<strong>数据包的路由和转发</strong>，实现<strong>端到端的寻址和路径选择</strong></td><td>IP, ICMP, OSPF, BGP</td></tr><tr><td><strong>第2层</strong></td><td>数据链路层 (Data Link)</td><td>提供<strong>相邻节点间可靠传输</strong>，处理帧的封装、寻址、差错检测和媒体访问控制</td><td>Ethernet, PPP, HDLC, Wi-Fi</td></tr><tr><td><strong>第1层</strong></td><td>物理层 (Physical)</td><td>负责<strong>比特流的传输</strong>，定义物理介质、信号编码和传输速率等物理特性</td><td>RS-232, USB, SONET, 以太网物理标准</td></tr></tbody></table></div><h2 id="p.8">P.8</h2><p>Consider the discussion in Section <spanclass="math inline">\(1.3\)</span> of statistical multiplexing in whichan example is provided with a <span class="math inline">\(1\)</span>Mbps link. Users are generating data at a rate of <spanclass="math inline">\(100\)</span> Kbps when busy, but are busygenerating data only with probability <span class="math inline">\(p =0.1\)</span>. Suppose that the <span class="math inline">\(1\)</span>Mbps link is replaced by a <span class="math inline">\(1\)</span> Gbpslink.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is <span class="math inline">\(N\)</span>, themaximum number of users that can be supported simultaneously undercircuit switching?</strong></p><p><span class="math display">\[N = \frac{1 \, \text{Gbps}}{100 \, \text{Kbps}} = 10000\]</span></p><p><strong>b. Now consider packet switching and a user population of<span class="math inline">\(M\)</span> users. Give a formula (in termsof <span class="math inline">\(p\)</span>, <spanclass="math inline">\(M\)</span>, <spanclass="math inline">\(N\)</span>) for the probability that more than<span class="math inline">\(N\)</span> users are sendingdata.</strong></p><p>假设用户的发送行为是独立的，则发送数据的用户数目服从二项分布，只考虑<span class="math inline">\(M \geq N\)</span>： <spanclass="math display">\[P_{ &gt; N} = 1 - \sum_{k = 0}^{N} \binom{M}{k} p^k (1 - p)^{M - k}\]</span></p><h2 id="p.22">P.22</h2><p>Consider Figure <span class="math inline">\(1.19(a)\)</span>. Assumethat we know the bottleneck link along the path from the server to theclient is the first link with rate <spanclass="math inline">\(R_s\)</span> <spanclass="math inline">\(\text{bits/sec}\)</span>. Suppose we send a pairof packets back to back from the server to the client, and there is noother traffic on this path. Assume each packet of size <spanclass="math inline">\(L\)</span> <spanclass="math inline">\(\text{bits}\)</span>, and both links have the samepropagation delay <span class="math inline">\(d_{prop}\)</span>.</p><figure><imgsrc="Introduction/Throughput%20for%20a%20file%20transfer%20from%20server%20to%20client.png"style="display: block; margin: 0 auto; width: 90%"alt="Figure 1.19(a)" /><figcaption aria-hidden="true">Figure 1.19(a)</figcaption></figure><p>back-to-back 指的是一组数据包在没有间隔的情况下连续发送</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is the packet inter-arrival time at the destination?That is, how much time elapses from when the last bit of the firstpacket arrives until the last bit of the second packetarrives?</strong></p><p>从图中我们可以看到有两条 <strong>link</strong>，速率分别是 <spanclass="math inline">\(R_s\)</span> 和 <spanclass="math inline">\(R_c\)</span>，前者导致瓶颈，也就是 <spanclass="math inline">\(R_c\)</span> &gt; <spanclass="math inline">\(R_s\)</span>。所以，<strong>inter-arrivaltime</strong>： <span class="math display">\[t = \frac{L}{R_s}\]</span></p><p><strong>b. Now assume that the second link is the bottleneck link(i.e., <span class="math inline">\(R_c\)</span> &lt; <spanclass="math inline">\(R_s\)</span>). Is it possible that the secondpacket queues at the input queue of the second link? Explain. Nowsuppose that the server sends the second packet <spanclass="math inline">\(T\)</span> seconds after sending the first packet.How large must <span class="math inline">\(T\)</span> be to ensure noqueuing before the second link? Explain.</strong></p><p>有可能第二个包在第二条 link 输入处排队，因为 <spanclass="math inline">\(R_c\)</span> &lt; <spanclass="math inline">\(R_s\)</span>导致，第一包仍在传输。只要保证当第二个包到达第二条 link输入时，第一个包已经传完了，也就是： <span class="math display">\[T = \frac{L}{R_c}\]</span></p><h2 id="p.28">P.28</h2><p>Suppose there is a <span class="math inline">\(10\)</span> <spanclass="math inline">\(\text{Mbps}\)</span> microwave link between ageostationary satellite and its base station on Earth. Every minute thesatellite takes a digital photo and sends it to the base station. Assumea propagation speed of <span class="math inline">\(2.4 \cdot10^8\)</span> <spanclass="math inline">\(\text{meters/sec}\)</span>.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is the propagation delay of the link?</strong></p><p>地球静止卫星轨道高度约为 <span class="math inline">\(d \approx 3.5786\times 10^7 \, \text{m}\)</span>，再由公式 <spanclass="math inline">\(d_{prop} = \frac{d}{s}\)</span> 得到 <spanclass="math inline">\(d_{prop} \approx 150 \, \text{ms}\)</span></p><p><strong>b. What is the bandwidth-delay product, <spanclass="math inline">\(R \cdot d_{prop}\)</span>?</strong></p><p>这个乘式中的 <span class="math inline">\(R\)</span> 是 link的传输速率，表示的是因延迟而没有传输的数据大小。结果是 <spanclass="math inline">\(10 \times 10^6 \times 0.15 = 1.5 \times 10^6 \,\text{bits}\)</span>。</p><p><strong>c. Let <span class="math inline">\(x\)</span> denote the sizeof the photo. What is the minimum value of <spanclass="math inline">\(x\)</span> for the microwave link to becontinuously transmitting?</strong></p><p>设照片大小为 <span class="math inline">\(x\)</span>（单位：<spanclass="math inline">\(\text{bits}\)</span>），要使链路持续发送，需满足传输时间<span class="math inline">\(\frac{x}{R}\)</span> 不小于拍照间隔 <spanclass="math inline">\(60\,\text{s}\)</span>，即<br /><span class="math display">\[\frac{x}{R} \geq 60 \, \Longrightarrow \; x \geq R \times 60 =10\times10^6\ \text{bps} \times 60\ \text{s} = 600\times10^6\\text{bits} = 75\ \text{MB}.\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Introduction</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Wireless and Mobile Networks</title>
    <link href="/2025/06/09/Wireless-and-Mobile-Networks/"/>
    <url>/2025/06/09/Wireless-and-Mobile-Networks/</url>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><h2 id="elements-of-a-wireless-networks">Elements of a WirelessNetworks</h2><ul><li><strong>Wireless Hosts:</strong> laptop, PDA, IP phone.</li><li><strong>Base Station:</strong><ul><li>connected to a <strong>wired network</strong>.</li><li><strong>relays</strong><ul><li>responsible for sending packets between wired network and wirelesshosts in its area.</li></ul></li></ul></li><li><strong>Wireless Link:</strong><ul><li>typically used to connect mobiles to bas stations.</li><li><strong>multiple access protocol</strong> coordinates linkaccess.</li></ul></li><li><strong>Infrastructure Mode:</strong><ul><li><strong>handoff:</strong> mobile changes base station providingconnection into wired network.</li></ul></li><li><strong>Ad Hoc Mode:</strong><ul><li>no base stations.</li><li>nodes can only transmit to other nodes within link coverage.</li><li>nodes organize themselves into a network: route amongthemselves.</li></ul></li></ul><h2 id="wireless-network-taxonomy">Wireless Network Taxonomy</h2><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>Infrastructure</strong></th><th><strong>Single Hop</strong></th><th><strong>Multiple Hops</strong></th></tr></thead><tbody><tr><td><strong>With Infrastructure</strong></td><td>Host connects to base station (WiFi, WiMAX, cellular) which connectsto larger Internet.</td><td>Host relays through several wireless nodes to connect to largerInternet (mesh net).</td></tr><tr><td><strong>Without Infrastructure</strong></td><td>No base station, no connection to larger Internet (e.g., Bluetooth,ad hoc nets).</td><td>No base station, no connection to larger Internet. Nodes relay toreach other nodes (e.g., MANET, VANET).</td></tr></tbody></table></div><h1 id="wireless-link-characteristics">Wireless LinkCharacteristics</h1><blockquote><p>从下文可以分析出，这里的 link不能翻译成<strong>链路</strong>而应该翻译成<strong>连接</strong>。</p></blockquote><ul><li><strong>decreased signal strength</strong></li><li><strong>interference from other sources</strong></li><li><strong>multipath propagation</strong></li></ul><p>Multiple wireless senders and receivers create additional problems(beyond multiple access): - <strong>Hidden Terminal Problem:</strong> Aand C can not hear each other means A and C are unaware of theirinterference B.</p><blockquote><p>这里是在讲，A 和 C因为障碍物的问题而无法直接通信从而无法协调，但他们都能和 B进行通信，如果 A 和 C 同时向 B 通信会导致冲突。</p></blockquote><ul><li><strong>SNR (Signal-to-Noise Ratio):</strong><ul><li>larger SNR, easier to extract signal from noise.</li><li>increases power <span class="math inline">\(\to\)</span> increasesSNR <span class="math inline">\(\to\)</span> decreases <strong>BER (BitError Rate)</strong>.</li><li>Given SNR, choose physical layer that meets BER requirement, givinghighest throughput.</li></ul></li></ul><blockquote><p>SNR 是信噪比，顾名思义是一个比值，具体计算公式为 <spanclass="math display">\[\mathrm{SNR} = \frac{P_{\text{signal}}}{P_{\text{noise}}}\]</span> 实际中用单位 db 表示。SNR越大，说明信号越容易从噪声中分辨出来，通信质量越好。</p></blockquote><h2 id="code-division-multiple-access-cdma">Code Division MultipleAccess (CDMA)</h2><blockquote><p>码分多址，这个我们在 data link layer 提到过，类似的有 TDMA 和FDMA。需要注意的是 CDMA 是一个 physical layer protocol。所以下文用的是channel 而不是 link。</p></blockquote><p>A kind of <strong>channel partitioning protocol</strong>.</p><ul><li><strong>Usage</strong>: Used in <strong>wireless broadcastchannels</strong> (e.g., cellular, satellite).</li><li><strong>Code Assignment</strong>: Each user is assigned a<strong>unique “code”</strong> (code set partitioning).</li><li><strong>Frequency Sharing</strong>: All users share the samefrequency but use distinct <strong>“chipping”</strong> sequences toencode data.</li><li><strong>Signal Encoding</strong>:<ul><li>Encoded signal = (original data) (chipping sequence).</li></ul></li><li><strong>Signal Decoding</strong>:<ul><li>Decoding is done using the inner product of the encoded signal andthe chipping sequence.</li></ul></li><li><strong>Advantage</strong>: Allows multiple users to coexist andtransmit simultaneously with minimal interference (if codes areorthogonal). &gt; 这里提到的 unique code 和 chipping sequence是同一个事物。</li></ul><h3 id="cdma-encodedecode-process">CDMA Encode/Decode Process</h3><h4 id="sender"><strong>Sender:</strong></h4><ol type="1"><li><strong>Data Encoding</strong>:<ul><li>Each sender has a unique code (chipping sequence)<code>c_m</code>.</li><li>Encoded signal for each data bit:<br /><span class="math display">\[ Z_{i,m} = d_i \cdot c_m \]</span><ul><li><code>d_i</code>: Original data bit.</li><li><code>c_m</code>: Chipping sequence.</li></ul></li></ul></li><li><strong>Channel Output</strong>:<ul><li>Encoded signals are transmitted over the shared channel.</li><li>Channel output combines signals from all senders.</li></ul></li></ol><h4 id="receiver"><strong>Receiver:</strong></h4><ol type="1"><li><strong>Signal Decoding</strong>:<ul><li>Receiver uses the inner product of the received signal and its ownchipping sequence to decode data: <span class="math display">\[ D_i =\frac{\sum_{m=1}^{M} Z_{i,m} \cdot c_m}{M} \]</span><ul><li><code>D_i</code>: Decoded data bit.</li><li><code>Z_&#123;i,m&#125;</code>: Received signal.</li><li><code>c_m</code>: Receiver’s chipping sequence.</li></ul></li></ul></li><li><strong>Output</strong>:<ul><li>Decoded data bits are extracted from the combined channeloutput.</li></ul></li></ol><blockquote><p>每个发送端都被分配一个唯一的码字（chippingsequence），码字的长度应该足够长，按理来讲，如果有 <spanclass="math inline">\(N\)</span> 个用户，码字长度 <spanclass="math inline">\(M \geq N\)</span>。码字具体为：用 <spanclass="math inline">\(+1\)</span> 和 <spanclass="math inline">\(-1\)</span> 分别代表 <spanclass="math inline">\(1\)</span> 和 <spanclass="math inline">\(0\)</span>。发送者将发送数据与码字相乘，这里指的是位对码字相乘。发送后数据会和其他所有发送者的信息在channel 中叠加。解码公式有一个前提：要求 user 使用的码字之间正交。除以 M是为保证归一化。</p><p>还要补充的是，CDMA 的核心思想是：所有用户在 <strong>samefrequency</strong> 和 <strong>same time</strong>的情况下发送信息。此时应用 CDMA。如果 frequency不一致，也不会发生信号叠加，此时应该用 FDMA。</p></blockquote><h1 id="wifi-802.11-wireless-lans">WiFi: 802.11 Wireless LANs</h1><blockquote><p>前部分介绍了 wireless link 及其用到的 CDMA protocol，</p></blockquote><ul><li>all use <strong>CSMA/CA</strong> for multiple access. &gt; data linklayer 部分我们讲过了 CSMA/CD。</li><li>all have base-station and ad-hoc network versions.</li></ul><h2 id="the-802.11-lan-architecture">The 802.11 LAN Architecture</h2><ul><li>wireless host communicates with base station (base station = accesspoint (AP))</li><li>Basic Service Set (BSS) (aka “cell”一片区域) in infrastructure modecontains:<ul><li>wireless hosts</li><li>access point (AP): base station</li><li>ad hoc mode: hosts only</li></ul></li><li><strong>层次关系</strong>：一个 subnet 可以包含<strong>多个BSS</strong>，多个无线主机通过不同接入点接入同一子网</li><li><strong>切换过程</strong>：<ul><li>当移动设备在<strong>同一子网内</strong>的不同 BSS之间移动时，只需改变 BSS 关联（链路层切换），IP地址<strong>保持不变</strong></li><li>当移动设备跨子网移动时，除了需要切换 BSS，还需要获取新子网的 IP地址（通常通过 DHCP）</li></ul></li><li><strong>地址分配</strong>：BSS 关注 MAC 地址，而 Subnet 关注 IP地址</li><li><strong>管理机制</strong>：BSS 由 AP 管理，Subnet 由路由器管理</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>特性</strong></th><th><strong>BSS</strong></th><th><strong>Subnet</strong></th></tr></thead><tbody><tr><td><strong>所属网络层次</strong></td><td>物理层和数据链路层 (OSI 第 1、2 层)</td><td>网络层 (OSI 第 3 层)</td></tr><tr><td><strong>定义标准</strong></td><td>IEEE 802.11 标准</td><td>IP 协议标准</td></tr><tr><td><strong>标识符</strong></td><td>BSSID (MAC 地址)</td><td>IP 地址前缀和子网掩码</td></tr><tr><td><strong>地址范围</strong></td><td>单个无线接入点覆盖范围</td><td>可跨多个接入点，由路由器定义</td></tr><tr><td><strong>关注点</strong></td><td>无线媒体访问和信号传输</td><td>IP 数据包的寻址和路由</td></tr><tr><td><strong>设备组织方式</strong></td><td>围绕单个接入点的无线主机集合</td><td>共享同一网络前缀的主机集合</td></tr><tr><td><strong>移动特性</strong></td><td>设备在 BSS 间移动需要进行<strong>切换 (handoff)</strong></td><td>在同一子网内的移动不需要更改 IP 地址</td></tr></tbody></table></div><h2 id="channels-association">802.11: Channels, Association</h2><ul><li><strong>Frequency Spectrum</strong>: 2.4GHz-2.485GHz (802.11b)divided into 11 channels.</li><li><strong>AP Configuration</strong>: Admin selects frequency for AP;interference may occur if neighboring APs use the same channel.</li><li><strong>Host Association</strong>:<ul><li>Scans channels for beacon frames with AP’s SSID and MACaddress.</li><li>Selects an AP to associate with.</li><li>May perform authentication.</li><li>Typically runs <strong>DHCP</strong> to obtain an IP address in theAP’s subnet. &gt; 前文我们讲 CDMA 的时候提到了： CDMA的所有用户使用相同的 frequency。通常情况下，一个 AP在同一时刻只工作在一个信道（即一个频率范围），只能收发该信道上的无线信号。</li></ul></li></ul><h2 id="passiveactive-scanning">802.11: Passive/Active Scanning</h2><blockquote><p>Beacon Frame（信标帧） 是 IEEE 802.11无线局域网（WiFi）协议中由接入点（AP, AccessPoint）周期性广播的一种管理帧。</p></blockquote><ul><li><strong>Passive Scanning</strong>:<ul><li>APs send <strong>beacon frames</strong>.</li><li>Host (H1) sends Association Request frame to selected AP.</li><li>Selected AP sends Association Response frame to H1.</li></ul></li><li><strong>Active Scanning</strong>:<ul><li>Host (H1) broadcasts Probe Request frame.</li><li>APs respond with Probe Response frames.</li><li>Host (H1) sends Association Request frame to selected AP.</li><li>Selected AP sends Association Response frame to H1.</li></ul></li></ul><blockquote><p>这两种方式最后两步都是一样的。</p></blockquote><h2 id="ieee-802.11-multiple-access">IEEE 802.11: Multiple Access</h2><blockquote><p>data link layer</p></blockquote><h3 id="collision-avoidance-in-802.11">Collision Avoidance in802.11</h3><ul><li><strong>Problem</strong>: Collisions occur when <spanclass="math inline">\(2\)</span> more nodes transmitsimultaneously.</li><li><strong>Solution</strong>:<ul><li><strong>CSMA</strong>: Sense the channel before transmitting toavoid collisions with ongoing transmissions.</li><li><strong>No Collision Detection</strong>:<ul><li>Difficult to sense collisions while transmitting due to weakreceived signals (fading).</li><li><strong>Hidden terminal</strong> and <strong>fading issues</strong>prevent sensing all collisions.</li></ul></li><li><strong>Goal</strong>: Use <strong>CSMA/CA (CollisionAvoidance)</strong> to minimize collisions.</li></ul></li></ul><h2 id="ieee-802.11-mac-protocol-csmaca">IEEE 802.11 MAC Protocol:CSMA/CA</h2><blockquote><p>DIFS 是<strong>分布式帧间间隔</strong>（Distributed Inter-FrameSpace）的缩写。SIFS 是<strong>短帧间间隔</strong>（Short Inter-FrameSpace）的缩写。<strong>Link（链路）</strong>：在有线网络中，通常指两个节点之间的物理连接。<strong>Channel（信道）</strong>：在无线网络中，指的是一段特定频率范围内的无线传输资源，多个节点可以共享同一个信道。</p></blockquote><h3 id="sender-1"><strong>802.11 Sender</strong></h3><ol type="1"><li><strong>Channel Idle</strong>:<ul><li>If the channel is idle for DIFS, transmit the entire frame (nocollision detection).</li></ul></li><li><strong>Channel Busy</strong>:<ul><li>Start a random backoff timer.</li><li>Timer counts down while the channel is idle.</li><li>Transmit when the timer expires.</li><li>If no ACK is received, increase the random backoff interval andrepeat step <span class="math inline">\(2\)</span>.</li></ul></li></ol><h3 id="receiver-1"><strong>802.11 Receiver</strong></h3><ul><li>If the frame is received correctly:<ul><li>Return an ACK after SIFS (ACK is needed to address the hiddenterminal problem).</li></ul></li></ul><h3 id="avoiding-collisions-rtscts-mechanism">Avoiding Collisions:RTS/CTS Mechanism</h3><ul><li><strong>Idea</strong>: Allow sender to reserve the channel to avoidcollisions of long data frames.</li><li><strong>Process</strong>:<ol type="1"><li>Sender transmits a small <strong>Request-to-Send (RTS)</strong>packet to the base station (BS) using CSMA.</li><li>RTS packets may collide, but they are short.</li><li>BS responds with a <strong>Clear-to-Send (CTS)</strong> packet,broadcast to all nodes.</li><li>Sender transmits the data frame.</li><li>Other stations defer their transmissions upon hearing the CTS.</li></ol></li><li><strong>Advantage</strong>: Completely avoids collisions of longdata frames by using small reservation packets.</li></ul><ol type="1"><li><strong>发送预约请求（RTS）</strong><ul><li>发送方先发送一个很短的 RTS（Request toSend）帧给基站（或接入点，AP），请求占用信道。</li></ul></li><li><strong>接收预约确认（CTS）</strong><ul><li>基站收到 RTS 后，如果信道空闲，则广播一个 CTS（Clear toSend）帧，通知所有节点允许该发送方发送数据。</li></ul></li><li><strong>数据发送</strong><ul><li>发送方收到 CTS 后，立即发送长数据帧。</li></ul></li><li><strong>其他节点监听</strong><ul><li>网络中其他节点收到 CTS后，会在指定时间内暂停发送，避免与当前数据帧发生冲突。</li></ul></li></ol><h2 id="addressing">802.11 Addressing</h2><p>下表总结了 802.11 帧的各字段及其作用：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>字段名</th><th>长度（字节）</th><th>作用说明</th></tr></thead><tbody><tr><td>frame control</td><td>2</td><td>帧控制字段，指示帧类型、控制信息等</td></tr><tr><td>duration</td><td>2</td><td>持续时间字段，指示信道预留时间</td></tr><tr><td>address 1</td><td>6</td><td>接收方 MAC 地址（无线主机或 AP）</td></tr><tr><td>address 2</td><td>6</td><td>发送方 MAC 地址（无线主机或 AP）</td></tr><tr><td>address 3</td><td>6</td><td>路由器接口的 MAC 地址（AP 所连接的路由器接口）</td></tr><tr><td>seq control</td><td>2</td><td>序列控制字段，帧编号等</td></tr><tr><td>address 4</td><td>6</td><td>仅在 ad hoc 模式下使用的地址</td></tr><tr><td>payload</td><td>0 - 2312</td><td>数据负载部分</td></tr><tr><td>CRC</td><td>4</td><td>循环冗余校验，用于差错检测</td></tr></tbody></table></div><p><strong>说明：</strong> - address 1：接收方 MAC 地址 - address2：发送方 MAC 地址 - address 3：AP 所连接的路由器接口的 MAC 地址 -address 4：仅 ad hoc 模式下使用</p><h2 id="mobility-within-same-subnet">Mobility within Same Subnet</h2><p>Host 在统一子网下不同 BSS 移动，switch 如何得知 host 当前在哪个 BSS内？实际上 switch 能通过 self-learning：switch will see frame from H1and remember which switch port can be used to reach H1。</p><h2 id="power-management">Power Management</h2><ul><li><strong>定时唤醒机制</strong>：<br />休眠节点在进入省电模式（Power Save Mode）时，会本地保存下一个 beaconframe 的预计到达时间，并设置定时器（timer）。</li><li><strong>硬件支持</strong>：<br />无线网卡硬件通常具备低功耗计时功能，可以在主机休眠时保持计时，确保在beacon frame 到来前自动唤醒。</li><li><strong>唤醒流程</strong>：<br />节点休眠后，定时器到达设定时间，节点自动唤醒，监听并接收 AP 广播的beacon frame，判断是否有待接收的数据。</li><li><strong>节能的核心在于节点休眠</strong>：<br />节能的关键不是 AP是否省电，而是<strong>无线终端（如手机、笔记本）可以长时间休眠，仅在beacon frame到来时短暂唤醒</strong>，大大减少无线网卡的活跃时间和能耗。</li><li><strong>AP 通常为插电设备</strong>：<br />AP 持续广播 beacon frame 对其本身能耗影响不大，因为 AP通常是接入电源的设备，不依赖电池。</li><li><strong>终端省电效果显著</strong>：<br />终端设备在无数据通信时可以关闭大部分无线模块，仅保留低功耗计时和唤醒功能，只有在需要接收数据或发送数据时才唤醒主模块，极大延长了电池续航。</li></ul><h2 id="personal-area-network">802.15: Personal Area Network</h2><p>个人热点。使用 ad hoc mode，参考 bluetooth protocol。</p><h2 id="wimax">802.16: WiMAX</h2><h1 id="cellular-internet-access">Cellular Internet Access</h1><p>介绍几个概念： - <strong>Cell</strong>：一个区域，里面有一个 basestation，mobile users 通过这个基站连接到 network。 -<strong>MCS</strong>：Mobile Switching Center。连接 base station 和wired network。</p><h2 id="the-first-hop">The First Hop</h2><p>第一跳为 users 到 base station。显然是一个 multiple senders的场景，可以用 FDMA、TDMA 和 CDMA 分离数据。</p><h2 id="cellular-standards-brief-survey">Cellular standards: briefsurvey</h2><h3 id="g-systems"><strong>2G Systems</strong></h3><ul><li><strong>Voice Channels</strong>:<ul><li><strong>IS-136 TDMA</strong>: Combined FDMA/TDMA (NorthAmerica).</li><li><strong>GSM</strong>: Global System for Mobile Communications,combined FDMA/TDMA (most widely deployed).</li><li><strong>IS-95 CDMA</strong>: Code Division Multiple Access.</li></ul></li></ul><h3 id="g-systems-1"><strong>2.5G Systems</strong></h3><ul><li><strong>Voice and Data Channels</strong>:<ul><li><strong>GPRS</strong>: Evolved from GSM, data sent on multiplechannels.</li><li><strong>EDGE</strong>: Enhanced modulation, data rates up to384K.</li><li><strong>CDMA-2000 (Phase 1)</strong>: Data rates up to 144K, evolvedfrom IS-95.</li></ul></li></ul><h3 id="g-systems-2"><strong>3G Systems</strong></h3><ul><li><strong>Voice/Data</strong>:<ul><li><strong>UMTS</strong>: High-Speed Uplink/Downlink Packet Access(HSDPA/HSUPA), 3 Mbps.</li><li><strong>CDMA-2000</strong>: Data service (1xEVDO), up to 14Mbps.</li></ul></li></ul><h3 id="g-systems-3"><strong>4G Systems</strong></h3><ul><li><strong>Voice/Data</strong>:<ul><li><strong>LTE</strong>: Employs OFDM and MIMO techniques, 100 Mbps fordownlink, 50 Mbps for uplink.</li></ul></li></ul><h1 id="principles-addressing-and-routing-to-mobile-users">Principles:Addressing and Routing to Mobile Users</h1><p><strong>mobile user, passing through multiple access point whilemaintaining ongoing connections (like cell phone)</strong></p><h2 id="mobility-vocabulary">Mobility: Vocabulary</h2><h3 id="home-network"><strong>Home Network</strong></h3><ul><li>Permanent “home” of the mobile device (e.g., 128.119.40/24).</li><li><strong>Permanent Address</strong>: Address in the home network,always used to reach the mobile (e.g., 128.119.40.186).</li><li><strong>Home Agent</strong>: Entity in the home network thatperforms mobility functions for the mobile when it is remote.</li></ul><h3 id="visited-network"><strong>Visited Network</strong></h3><ul><li>Network where the mobile device currently resides (e.g.,79.129.13/24).</li><li><strong>Care-of-Address</strong>: Temporary address assigned to themobile in the visited network (e.g., 79.129.13.2).</li><li><strong>Foreign Agent</strong>: Entity in the visited network thatperforms mobility functions on behalf of the mobile.</li></ul><h3 id="correspondent"><strong>Correspondent</strong></h3><ul><li>The entity that wants to communicate with the mobile device.</li></ul><h3id="consider-friend-frequently-changing-addresses-how-do-you-find-her">Considerfriend frequently changing addresses, how do you find her?</h3><p><strong>let end-systems handle it:</strong> - indirect routing:communication from correspondent to mobile goes through home agent, thenforwarded to remote - direct routing: correspondent gets foreign addressof mobile, sends directly to mobile</p><figure><imgsrc="Wireless-and-Mobile-Networks/Indirect%20routing%20to%20a%20mobile%20node.png"style="display: block; margin: 0 auto; width: 90%"alt="Indirect routing" /><figcaption aria-hidden="true">Indirect routing</figcaption></figure><p>第一种 indirect routing，见上图所示，当你的朋友移动到其它<strong>foreign</strong> 网络，他会得到一个<strong>Care-of-Address</strong>，这个地址是临时的，用于在当前所在子网下通信，但他有一个<strong>Permanent Address</strong>，可以通过联系他的 <strong>Homeagent</strong>，从而联系到他所在子网的 <strong>Foreignagent</strong>，从而联系到他。</p><figure><imgsrc="Wireless-and-Mobile-Networks/Direct%20routing%20to%20a%20mobile%20user.png"style="display: block; margin: 0 auto; width: 90%"alt="Direct routing" /><figcaption aria-hidden="true">Direct routing</figcaption></figure><p>第二种是 direct routing，这种是先通过联系他的 Homeagent，得到他所在子网的 IP address，从联系到他。</p><p>需要补充两点： 1. <strong>correspondent 如何得到 friend 的 permanentaddress</strong>. - <strong>permanent address（永久地址）</strong> 是friend 在 home network 的固定 IP 地址，通常是 friend 在 home network注册时分配的。 - <strong>correspondent（通信对端）</strong> 想要联系friend 时，通常会通过 DNS 查询等方式获得 friend 的 permanent address（即home address）。 - 这个 permanent address是公开的、长期有效的，类似于家庭住址，所有通信发起者都可以通过标准方式获得。2. <strong>home agent 如何维护 friend 所在子网的 agent 和 IPaddress</strong>. - <strong>home agent（归属代理）</strong> 是部署在friend 的 home network 内的一个特殊节点，负责跟踪 friend 的当前位置。 -当 friend 移动到新的 visited network 并获得新的 care-of address 时，会向home agent 注册自己的新位置（即 care-of address 和 foreign agent的信息）。 - home agent 会维护一个映射表，记录每个移动节点的 permanentaddress 与其当前的 care-of address（以及 foreign agent的信息，如果有）。 - 当有数据包发往 friend 的 permanent address 时，homeagent 会将这些数据包<strong>隧道转发</strong>（tunnel）到 friend 当前的care-of address（即 friend 所在子网的 foreign agent 或直接到 friend本身）。</p><h1 id="mobile-ip-agent-discovery">Mobile IP: agent discovery</h1><p>Agent advertisement: foreign/home agents advertise service bybroadcasting ICMP messages (<code>typefield = 9</code>)</p><h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1><h2 id="r.1">R.1</h2><p><strong>Question and Answer:</strong></p><p>What does it mean for a wireless network to be operating in“infrastructure mode”? If the network is not in infrastructure mode,what mode of operation is it in, and what is the different between thatmode of operation and infrastructure mode?</p><p>在无线网络中，“基础设施模式”（infrastructuremode）指的是网络中存在一个基站（如接入点，AP），无线主机通过基站连接到有线网络或更大的互联网。在这种模式下，基站负责在无线主机和有线网络之间中继数据。如果网络不处于基础设施模式，则它处于”自组织模式”（adhocmode）。在自组织模式中，没有基站，节点只能与其链路覆盖范围内的其他节点通信，节点之间通过自组织的方式形成网络并相互路由。两者的主要区别在于是否依赖基站：基础设施模式依赖基站，而自组织模式则完全由节点自主协作。</p><h2 id="r.2">R.2</h2><p><strong>Question and Answer:</strong></p><p>What are the four type of wireless networks identified in ourtaxonomy in Section <span class="math inline">\(6.1\)</span>? Which ofthese types of wireless networks have you used?</p>Section <span class="math inline">\(6.1\)</span> 中提到的 <spanclass="math inline">\(4\)</span> 种无线网络结构如下：<div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>Infrastructure</strong></th><th><strong>Single Hop</strong></th><th><strong>Multiple Hops</strong></th></tr></thead><tbody><tr><td><strong>With Infrastructure</strong></td><td>Host connects to base station (WiFi, WiMAX, cellular) which connectsto larger Internet.</td><td>Host relays through several wireless nodes to connect to largerInternet (mesh net).</td></tr><tr><td><strong>Without Infrastructure</strong></td><td>No base station, no connection to larger Internet (e.g., Bluetooth,ad hoc nets).</td><td>No base station, no connection to larger Internet. Nodes relay toreach other nodes (e.g., MANET, VANET).</td></tr></tbody></table></div><p>其中像 WiFi 和 Bluetooth 经常使用。</p><h2 id="r.3">R.3</h2><p><strong>Question and Answer:</strong></p><p>What are the differences between the following types of wirelesschannel impairments: path loss, multipath propagation, interference fromother sources?</p>下面是对三种信道损伤的解释：<div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>损伤类型</strong></th><th><strong>详细解释</strong></th></tr></thead><tbody><tr><td><strong>路径损耗 (path loss)</strong></td><td>信号随<strong>传播距离增加</strong>而自然衰减的现象。遵循<strong>平方反比或更高次幂</strong>衰减规律，与距离和频率相关。主要包括<strong>自由空间损耗</strong>、<strong>大气吸收</strong>、<strong>障碍物衰减</strong>等，是无线通信中的<strong>基础衰减现象</strong>。</td></tr><tr><td><strong>多径传播 (multipath propagation)</strong></td><td>信号通过<strong>多个不同路径</strong>同时到达接收器的现象。由信号在建筑物、地面等物体表面的<strong>反射</strong>、<strong>散射</strong>、<strong>折射</strong>和<strong>绕射</strong>导致。产生<strong>相位差异</strong>使信号彼此<strong>增强或抵消</strong>，造成<strong>信号衰落</strong>、<strong>时延扩展</strong>和<strong>符号间干扰</strong>。</td></tr><tr><td><strong>外部干扰 (interference from other sources)</strong></td><td>来自<strong>其他发射源</strong>的电磁波对当前通信的干扰。包括<strong>同频干扰</strong>（相同频道上的其他发射器）、<strong>相邻频道干扰</strong>和<strong>电子设备噪声</strong>等。干扰与当前信号混合，<strong>降低信噪比</strong>和通信质量。</td></tr></tbody></table></div><h2 id="r.4">R.4</h2><p><strong>Question and Answer:</strong></p><p>As a mobile node gets farther and farther away from a base station,what are two actions that a base station could take to ensure that theloss probability of a transmitted frame does not increase?</p><ol type="1"><li><strong>Wireless Link Characteristics</strong> 部分提到：<ul><li><strong>SNR (Signal-to-NoiseRatio)</strong>：增大信号强度可以提高信噪比，从而降低误码率（BER）。</li><li><strong>decreased signalstrength</strong>：信号强度的降低会影响通信质量。</li></ul></li><li><strong>IEEE 802.11 MAC Protocol: CSMA/CA</strong> 部分提到：<ul><li><strong>CollisionAvoidance</strong>：通过避免冲突来提高传输成功率。</li></ul></li><li><strong>Cellular Internet Access</strong> 部分提到：<ul><li><strong>LTE</strong> 使用了 <strong>OFDM</strong> 和<strong>MIMO</strong>技术，这些技术可以提高信号覆盖范围和传输效率。</li></ul></li></ol><p>结合这些内容，可以得出以下两种可能的措施： -<strong>增大发射功率</strong>：提高信号强度以补偿路径损耗。 -<strong>使用多天线技术（如MIMO）</strong>：通过空间分集技术提高信号质量和覆盖范围。</p><h2 id="r.10">R.10</h2><p><strong>Question and Answer:</strong></p><p>Suppose the IEEE <span class="math inline">\(802.11\)</span> RTS andCTS frames were as long as the standard DATA and ACK frames. Would therebe any advantage to using the CTS and RTS frames? Why or why not?</p><ul><li><strong>Avoiding Collisions: RTS/CTS Mechanism</strong> 部分提到：<ul><li>RTS 和 CTS 的主要作用是 <strong>避免长数据帧的冲突</strong>。</li><li>RTS 和 CTS 包较小，即使发生冲突，影响也较小。</li><li>使用 RTS/CTS 机制可以通过小型的预留包来减少长数据帧的冲突。</li></ul></li><li>如果 RTS 和 CTS 包与标准的 DATA 和 ACK包一样长，那么它们的优势将丧失，因为：<ol type="1"><li><strong>冲突成本增加</strong>：长 RTS 和 CTS包的冲突会导致更大的资源浪费。</li><li><strong>效率降低</strong>：长 RTS 和 CTS包会增加额外的开销，降低整体网络效率。</li></ol></li></ul><h2 id="r.16">R.16</h2><p><strong>Question and Answer:</strong></p><p>If a node has a wireless connection to the Internet, does that nodehave to be mobile? Explain. Suppose that a user with a laptop walksaround her house with her laptop, and always accesses the Internetthrough the same access point. Is this user mobile from a networkstandpoint? Explain.</p><p>一个节点拥有无线连接，并不意味着它是<strong>移动的</strong>。无线连接只是物理层和链路层的接入方式，只要设备通过无线方式接入网络，无论它是否实际移动，都可以称为无线节点，但不一定是<strong>移动节点</strong>。用户在家中携带笔记本，始终通过同一个AP 上网，这说明用户始终在同一个 subnet 和 BSS内，所以不认为用户发生了网络层的移动。</p><h2 id="r.17">R.17</h2><p><strong>Question and Answer:</strong></p><p>What is the difference between a permanent address and a care-ofaddress? Who assigns a care-of address?</p><ul><li><strong>permanent address（永久地址）</strong><ul><li>也称为 homeaddress（归属地址），是移动节点在其<strong>归属网络</strong>（homenetwork）中的固定 IP 地址。</li><li>这个地址在移动节点无论身处何地都不会改变，始终用于标识该节点的身份。</li><li>例如：移动节点在家乡网络的 IP 地址 128.119.40.186。</li></ul></li><li><strong>care-of address（临时地址）</strong><ul><li>是移动节点在<strong>访问网络</strong>（visited network）中临时获得的IP 地址。</li><li>当移动节点离开归属网络，进入其他网络时，会在该访问网络中分配一个新的IP 地址，这个地址用于在当前网络中进行通信。</li><li>例如：移动节点在外地网络获得的 IP 地址 79.129.13.2。</li></ul></li><li>care-of address 通常由<strong>访问网络 visited network</strong>分配，具体来说：<ul><li>可以由访问网络中的<strong>外部代理 Foreign Agent</strong>分配；</li><li>也可以通过 DHCP 等自动分配协议由访问网络的路由器分配。</li></ul></li></ul><h2 id="r.19">R.19</h2><p><strong>Question and Answer:</strong></p><p>What are the purposes of the HLR and VLR in GSM networks? Whatelements of mobile IP are similar to the HLR and VLR?</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>GSM 网络</th><th>Mobile IP 协议</th><th>主要作用</th></tr></thead><tbody><tr><td>HLR</td><td>Home Agent</td><td>记录永久信息和当前位置</td></tr><tr><td>VLR</td><td>Foreign Agent</td><td>临时管理当前区域内的用户/节点信息</td></tr></tbody></table></div><h2 id="p.5">P.5</h2><p><strong>Question and Answer:</strong></p><p>Suppose there are two ISPs providing WiFi access in a particularcafé, with each ISP operating its own AP and having its own IP addressblock. a. Further suppose that by accident, each ISP has configured itsAP to operate over channel 11. Will the 802.11 protocol completely breakdown in this situation? Discuss what happens when two stations, eachassociated with a different ISP, attempt to transmit at the same time.b. Now suppose that one AP operates over channel 1 and the other overchannel 11. How do your answers change?</p><p><strong>a.</strong>：802.11 协议不会完全失效，但两个 AP 及其关联的hosts 会在 physical layer 竞争同一个信道的使用权。如果两个 hosts同时发送数据，此时会产生 collision，尽管 CSMA/CA协议会尽可能避免冲突，但由于信号干扰，冲突仍会发生，导致通信变得不稳定。</p><p><strong>b.</strong>：此时两个 AP用不同的信道，互不干扰，通信正常。</p><h2 id="p.13">P.13</h2><p><strong>Question and Answer:</strong></p><p>In mobile IP, what effect will mobility have on end-to-end delays ofdatagrams between the source and destination?</p><ol type="1"><li><strong>间接路由（Indirect Routing）增加路径长度</strong><ul><li>在移动 IP 的典型实现中，数据报首先被发送到移动节点的 homeagent（归属代理），然后由 home agent 转发（隧道）到移动节点当前的care-of address（临时地址）。</li><li>这种绕路导致数据报的实际传输路径比直接路由更长，<strong>增加了端到端延迟</strong>。</li><li>例如，源主机 → home agent → foreign agent → 移动节点。</li></ul></li><li><strong>切换期间的延迟抖动</strong><ul><li>当移动节点从一个网络切换到另一个网络时（如切换 AP或基站），需要重新获取 care-of address 并向 home agent 注册新位置。</li><li>在切换和注册期间，可能会出现短暂的不可达或数据包丢失，<strong>导致延迟波动或瞬时增加</strong>。</li></ul></li><li><strong>三角路由问题</strong><ul><li>在 indirect routing 下，通信对端（correspondent）始终将数据包发往permanent address，导致所有流量都要经过 homeagent，形成所谓的三角路由。</li><li>这进一步增加了端到端的传输时延，尤其当 home agent距离通信双方较远时影响更明显。</li></ul></li><li><strong>优化路由（Direct Routing）可减少延迟</strong><ul><li>如果采用 directrouting（如移动节点的当前位置被通知给通信对端），数据报可以直接从源主机发往移动节点当前的care-of address，<strong>端到端延迟会降低</strong>。</li><li>但 direct routing 需要额外的机制来保证安全和地址同步。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Wireless and Mobile Networks</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Transport Layer</title>
    <link href="/2025/06/08/The-Transport-Layer/"/>
    <url>/2025/06/08/The-Transport-Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="transport-layer-services">Transport-Layer Services</h1><p>Transport protocols run in <strong>end systems</strong>: - Sendingside: breaks app messages into <strong>segments</strong>, passes tonetwork layer. - Receiving side: reassembles segments into<strong>messages</strong>, passes to app layer.</p><h1 id="multiplexing-and-demultiplexing">Multiplexing andDemultiplexing</h1><p><strong>Multiplexing at sending host:</strong> gather data frommultiple sockets, enveloping data with <strong>header</strong>(laterused for demultiplexing). <strong>demultiplexing at receivinghost:</strong> deliver segments to correct socket.</p><h2 id="demultiplexing">Demultiplexing</h2><p>Hosts receives <strong>IP datagrams</strong>. Each IP datagram hassource IP address and destination IP address. Each IP datagram carries atransport-layer segment. Each segment has source port numbers anddestination port numbers.</p><figure><img src="The-Transport-Layer/a-transport-layer-segment.png"style="display: block; margin: 0 auto; width: 90%"alt="A transport layer segment" /><figcaption aria-hidden="true">A transport layer segment</figcaption></figure><blockquote><p>将 segment 传到目标 host，host 再将 segment 通过 socket 传给对应的application。</p></blockquote><h3 id="connectionless-demultiplexing">ConnectionlessDemultiplexing</h3><p>在 <strong>UDP</strong> 协议中使用。</p><p>Creates socket with <strong>port numbers</strong>. Each UDP socketidentified with <code>(dest IP address, dest port numbers)</code>.</p><blockquote><p>当终端收到 IP datagrams 中是 UDP segment 时。 The host will checkdestination port in the segment and then directs the segment tocorresponding socket。发生在 transport layer。</p></blockquote><h3 id="connection-oriented-demultiplexing">Connection-orientedDemultiplexing</h3><p><strong>Used in TCP protocol</strong>.</p><p>TCP socket identified by <strong>4</strong>-tuple:<code>(source IP address, source port numbers, dest IP address, dest port numbers)</code>.</p><h1 id="connectionless-transport-udp">Connectionless Transport: UDP</h1><h2 id="udp-segment-structure">UDP Segment Structure</h2><figure><img src="The-Transport-Layer/UDP-segment-structure.png"style="display: block; margin: 0 auto; width: 90%"alt="UDP segment structure" /><figcaption aria-hidden="true">UDP segment structure</figcaption></figure><h2 id="udp-checksum">UDP Checksum</h2><p><strong>Goal</strong>: detect “errors” (e.g., flipped bits) intransmitted segment. 指的是位比特发生了 <spanclass="math inline">\(01\)</span> 翻转。</p><p>“Calculation:” 1. <strong>Group Data</strong>: - Divide all fields ofthe UDP segment (including header and data) into 16-bit blocks. If thedata length is odd, pad with a zero byte.这里要注意，不同的比特排序方式会影响到最终结果，数据通常以<strong>大端序</strong>（高位字节在前）表示。</p><ol start="2" type="1"><li><strong>Compute Sum</strong>:<ul><li>Perform a 1’s complement sum of all 16-bitblocks。就是二进位加法。</li><li>If overflow occurs (exceeds 16 bits), wrap the overflow back intothe result.</li></ul></li><li><strong>Take Complement</strong>:<ul><li>Take the 1’s complement of the computed sum to get the finalchecksum。这里可以看作进行了一次<strong>同位全 <spanclass="math inline">\(1\)</span></strong> 加法。</li></ul></li><li><strong>Fill Checksum Field</strong>:<ul><li>Place the computed checksum into the checksum field of the UDPsegment.</li></ul></li></ol><h1 id="principles-of-reliable-data-transfer">Principles of ReliableData Transfer</h1><p><strong>应用程序即使运行在 UDP之上，也可以实现可靠数据传输</strong>。虽然 UDP本身是无连接、无保证的协议，不提供诸如数据包重传、顺序保证、丢包检测等机制，但<strong>应用层可以自行实现这些功能</strong>，从而达到可靠传输的目的。</p><figure><img src="The-Transport-Layer/Reliable-data-transfer.png"style="display: block; margin: 0 auto; width: 90%"alt="Reliable data transfer: Service model and service implementation" /><figcaption aria-hidden="true">Reliable data transfer: Service model andservice implementation</figcaption></figure><h2id="reliable-data-transfer-over-a-perfectly-reliable-channel-rdt-1.0">ReliableData Transfer over a Perfectly Reliable Channel: rdt 1.0</h2><figure><img src="The-Transport-Layer/rdt1.png"style="display: block; margin: 0 auto; width: 90%"alt="rdt1.0 - A protocol for a completely reliable channel" /><figcaption aria-hidden="true">rdt1.0 - A protocol for a completelyreliable channel</figcaption></figure><p><strong>Unrealistic:</strong> underlying channel perfectly reliable -no bit errors - no loss of packets</p><h2id="reliable-data-transfer-over-a-channel-with-bit-errors-rdt-2.0">ReliableData Transfer over a Channel with Bit Errors: rdt 2.0</h2><p>增添检查错误机制：checksum 和 ACK。</p><figure><img src="The-Transport-Layer/rdt2.png"style="display: block; margin: 0 auto; width: 90%"alt="rdt 2.0 - A protocol for a channel with bit errors" /><figcaption aria-hidden="true">rdt 2.0 - A protocol for a channel withbit errors</figcaption></figure><p><strong>New mechanism in rdt 2.0 (beyond rdt 1.0)</strong> - Errordetection; - <strong>Checksum</strong>. - Receiver feedback. -<strong>ACKs and NAKs</strong>.</p><blockquote><p>rdt 2.0 有一个致命问题：如果 ACK/NAK 出错导致信息改变。</p></blockquote><h2 id="rdt-2.1">rdt 2.1</h2><figure><img src="The-Transport-Layer/rdt2-1-sender.png"style="display: block; margin: 0 auto; width: 90%"alt="rdt 2.1 sender" /><figcaption aria-hidden="true">rdt 2.1 sender</figcaption></figure><figure><img src="The-Transport-Layer/rdt2-1-receiver.png"style="display: block; margin: 0 auto; width: 90%"alt="rdt 2.1 receiver" /><figcaption aria-hidden="true">rdt 2.1 receiver</figcaption></figure><blockquote><p>可以看到 rdt 2.1 新增了一个 sequence number。在 rdt 2.0中提到过其有着一个致命的问题，这个问题可能会导致两个问题：重传和丢失。从Figure P.6 和 Figure P.7 可以看到 rdt 2.1能解决重传的问题，但是不能解决丢失的问题。</p></blockquote><h2 id="rdt-2.2">rdt 2.2</h2><figure><img src="The-Transport-Layer/rdt2-2-sender.png"style="display: block; margin: 0 auto; width: 90%"alt="rdt2.2 sender" /><figcaption aria-hidden="true">rdt2.2 sender</figcaption></figure><figure><img src="The-Transport-Layer/rdt2-2-receiver.png"style="display: block; margin: 0 auto; width: 90%"alt="rdt2.2 receiver" /><figcaption aria-hidden="true">rdt2.2 receiver</figcaption></figure><blockquote><p>rdt 2.1 的机制是：如果是 NAK 或者 checksum 出错就重传。从 Figure P.8和 Figure P.9 可以看出，receiver收了什么序号的包就回什么序号，如果是自己要的包就 extract，然后 sender发下个序号的包，如果重传导致 duplicate，那么只需要 delete 然后给 sender发送 ACK。显然，receiver 回什么序号，sender 都会发下一个序号的包，也就是rdt 2.2 没有使用 NAK 就解决了重传的问题。</p></blockquote><p>补充：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>变量/语句</th><th>作用说明</th></tr></thead><tbody><tr><td><code>oncethru == 1</code></td><td>是否第一次进入该状态</td></tr><tr><td><code>udt_send(sndpkt)</code></td><td>发送 ACK 包</td></tr><tr><td>结合使用</td><td>首次进入状态时主动重发 ACK，防止因 ACK 丢失而死锁</td></tr></tbody></table></div><h2 id="rdt-3.0">rdt 3.0</h2><figure><img src="The-Transport-Layer/rdt3-0-receiver.png"style="display: block; margin: 0 auto; width: 90%"alt="rdt3.0 sender" /><figcaption aria-hidden="true">rdt3.0 sender</figcaption></figure><blockquote><p>增加了一个计时器，可以解决包丢失的问题，如果超时就重传，</p></blockquote><h2 id="pipelined-reliable-data-transfer-protocols">Pipelined ReliableData Transfer Protocols</h2><p><strong>rdt 3.0 stop-and-wait operation</strong>: rdt 3.0 can work,but its performance stinks.</p><blockquote><p>这里是说 rdt 3.0 的机制一轮就处理一个包而效率低下。</p></blockquote><p>For example, we suppose condition with 1 Gbps link, 15 ms propagationdelay, 8000 bits packet.</p><p><span class="math display">\[\text{d}_{trans} = \frac{L}{R} = \frac{8000 \text{bits}}{10^9\text{bps}} = 8 \text{microseconds}\]</span></p><p><span class="math display">\[\text{Utilization} = \frac{\frac{L}{R}}{\text{RTT} + \frac{L}{R}} =0.00027\]</span></p><p>So, we use <strong>Pipelined Reliable Data TransferProtocols</strong> to increase utilization!</p><p><strong>Pipelining:</strong> sender allows multiple,“in-flight”,yet-to-be-acknowledged pkts. - Range of sequence numbersmust be <strong>increased</strong>. - <strong>Buffering</strong> atsender and/or receiver.</p><h3 id="go-back-n-gbn-protocol">Go-Back-N (GBN) Protocol</h3><figure><imgsrc="The-Transport-Layer/Sender&#39;s-view-of-sequence-numbers-in-Go-Back-N.png"style="display: block; margin: 0 auto; width: 90%"alt="Sender’s view of sequence numbers in Go-Back-N" /><figcaption aria-hidden="true">Sender’s view of sequence numbers inGo-Back-N</figcaption></figure><p><strong>Timeout(n):</strong> retransmit pkt <code>n</code> and allhigher seq <code>#</code> pkts in window</p><figure><img src="The-Transport-Layer/GBN-sender.png.png"style="display: block; margin: 0 auto; width: 90%" alt="GBN sender" /><figcaption aria-hidden="true">GBN sender</figcaption></figure><figure><img src="The-Transport-Layer/GBN-receiver.png.png"style="display: block; margin: 0 auto; width: 90%" alt="GBN receiver" /><figcaption aria-hidden="true">GBN receiver</figcaption></figure><p>需要注意的是，上述图片中是<strong>覆盖确认</strong>：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>协议类型</th><th>ACK 处理方式</th><th>base 变化方式</th></tr></thead><tbody><tr><td>累计确认（GBN）</td><td>只确认按序最大已收到的包</td><td>base 只前进不回退</td></tr><tr><td>覆盖确认（图中）</td><td>收到哪个 ACK 就直接覆盖 base</td><td>base 可能跳跃前进</td></tr></tbody></table></div><h3 id="selective-repeat-sr">Selective Repeat (SR)</h3><p>Sender only <strong>resends</strong> pkts for which ACK notreceived.</p><figure><img src="The-Transport-Layer/RS-sender-receiver-view.png"style="display: block; margin: 0 auto; width: 90%"alt="Selective-repeat (SR) sender and receiver views of sequence-number space" /><figcaption aria-hidden="true">Selective-repeat (SR) sender and receiverviews of sequence-number space</figcaption></figure><p><span class="math display">\[\text{window size} \leq \frac{1}{2} \text{seq}\]</span></p><h4 id="sender">Sender</h4><ul><li><strong>Data from above</strong>:<ul><li>If next available sequence number is within the window, send thepacket.</li></ul></li><li><strong>Timeout(n)</strong>:<ul><li>Resend packet <code>n</code>, restart the timer.</li></ul></li><li><strong>ACK(n) in [sendbase, sendbase <spanclass="math inline">\(+\)</span> <spanclass="math inline">\(N\)</span>]</strong>:<ul><li>Mark packet <code>n</code> as received.</li><li>If <code>n</code> is the smallest unACKed packet,<strong>advance</strong> the window base to the next unACKed sequencenumber.</li></ul></li></ul><h4 id="receiver">Receiver</h4><ul><li><strong>Packet <code>n</code> in [rcvbase, rcvbase <spanclass="math inline">\(+\)</span> <span class="math inline">\(N\)</span><span class="math inline">\(-\)</span> <spanclass="math inline">\(1\)</span>]</strong>:<ul><li>Send ACK(n).</li><li><strong>Out-of-order</strong>: Buffer the packet.</li><li><strong>In-order</strong>: Deliver the packet (also deliverbuffered, in-order packets), advance the window to the nextnot-yet-received packet.</li></ul></li><li><strong>Packet <code>n</code> in [rcvbase <spanclass="math inline">\(-\)</span> <span class="math inline">\(N\)</span>,rcvbase <span class="math inline">\(-\)</span> <spanclass="math inline">\(1\)</span>]</strong>:<ul><li>Send ACK(n). 解决 duplicate。</li></ul></li><li><strong>Otherwise</strong>:<ul><li>Ignore the packet.</li></ul></li></ul><h1 id="connection-oriented-transport-tcp">Connection-orientedtransport: TCP</h1><h2 id="tcp-segment-structure">TCP Segment Structure</h2><figure><img src="The-Transport-Layer/TCP-segment-structure.png"style="display: block; margin: 0 auto; width: 90%"alt="TCP segment structure" /><figcaption aria-hidden="true">TCP segment structure</figcaption></figure><p><strong>How to set sequence number and acknowledgmentnumber?</strong></p><ul><li><strong>sequence number</strong>: represents the byte stream numberof the first byte in the segment’s data.</li><li><strong>ACKs</strong>: indicates the sequence number of the nextbyte expected from the sender. Using cumulative acknowledgment.</li></ul><h2 id="tcp-round-trip-time-and-timeout">TCP Round Trip Time andTimeout</h2><p><strong>How to estimate <spanclass="math inline">\(\mathbf{RTT}\)</span>?</strong></p><p><span class="math display">\[\text{EstimateRTT} = (1 - \alpha) \cdot \text{EstimateRTT} + \alpha\cdot \text{SampleRTT}, \quad \text{Typically } \alpha = 0.125\]</span></p><p><strong>How to set TCP timeout value?</strong></p><p>Longer than <span class="math inline">\(\text{RTT}\)</span>, but<span class="math inline">\(\text{RTT}\)</span> varies. <spanclass="math display">\[\text{DevRTT} = (1 - \beta) \cdot \text{DevRTT} + \beta \cdot|\text{SampleRTT} - \text{EstimateRTT}|, \quad \text{Typically } \beta =0.25\]</span></p><p><span class="math display">\[\text{TimeOutInterval} = \text{EstimateRTT} + 4 \cdot \text{DevRTT}\]</span></p><h2 id="tcp-reliable-data-transfer">TCP Reliable Data Transfer</h2><h3 id="fast-retransmit">Fast Retransmit</h3><p>If sender receives <span class="math inline">\(3\)</span> ACKs forsame data, it assumes that segment after ACKed data was lost.</p><h2 id="flow-control">Flow control</h2><p>Receiver side of TCP connection has a <strong>receivebuffer</strong>.</p><figure><img src="The-Transport-Layer/rwnd-buffer.png"style="display: block; margin: 0 auto; width: 90%"alt="The receive window (rwnd) and the receive buffer (RcvBuffer)" /><figcaption aria-hidden="true">The receive window (rwnd) and the receivebuffer (RcvBuffer)</figcaption></figure><h3 id="how-it-works">How it works?</h3><ul><li><strong>Receiver:</strong> advertises unused buffer space byincluding <span class="math inline">\(\text{rwnd}\)</span> value insegment header.</li><li><strong>Sender:</strong> limits unAcked bytes to <spanclass="math inline">\(\text{rwnd}\)</span>.</li></ul><p><span class="math display">\[\text{rwnd} = \text{RcvBuffer} - \left[\text{LastByteRcvd} -\text{LastByteRead} \right]\]</span></p><p><strong>字节编号</strong>的问题。在TCP中：</p><ul><li>如果初始序列号为0，发送50字节后：<ul><li>这些字节的序号为：0, 1, 2, …, 49</li><li><strong>最后一个字节</strong>的序号为49，即 LastByteRcvd = 49</li><li>根据公式 <span class="math inline">\(y = \text{LastByteRcvd} +1\)</span>，得到确认号 y = 50</li></ul></li></ul><p>其中 y 是 ACK。</p><h2 id="connection-management">Connection Management</h2><h3 id="three-way-handshake">Three Way Handshake</h3><p><strong>握手协议（Handshaking Protocol）</strong>是指在两个通信实体（如客户端和服务器）之间建立通信连接之前，双方通过一系列消息的交换，协商通信参数、确认彼此身份、同步状态等，从而为后续的数据传输做好准备的过程。</p><ol type="1"><li><strong>Step 1</strong>:<ul><li>Client sends TCP <code>SYN</code> segment to server, specifyinginitial seq. No data.</li></ul></li><li><strong>Step 2</strong>:<ul><li>Server host receives <code>SYN</code>, replies with<code>SYNACK</code> segment. Server allocates buffers and specifiesserver initial seq.</li></ul></li><li><strong>Step 3</strong>:<ul><li>Client receives <code>SYNACK</code>, replies with ACK segment, whichmay contain data</li></ul></li></ol><h3 id="closing-a-connection">Closing a Connection</h3><ol type="1"><li><strong>Step 1</strong>:<ul><li>Client sends TCP <code>FIN</code> segment to server, specifyinginitial seq. No data.</li></ul></li><li><strong>Step 2</strong>:<ul><li>Server receives <code>FIN</code>, replies with ACK. Closesconnection, sends <code>FIN</code>.</li></ul></li><li><strong>Step 3</strong>:<ul><li>Client receives <code>FIN</code>, replies with ACK.</li></ul></li><li><strong>Step 4</strong>:<ul><li>Server, receives ACK. Connection closed.</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">客户端A                                      服务器B<br>   | ----------- SYN, Seq=1000 ------------&gt; |<br>   |                                         |<br>   | &lt;------ SYN+ACK, Seq=2000, Ack=1001 --- |<br>   |                                         |<br>   | ----------- ACK, Seq=1001, Ack=2001 --&gt; |<br></code></pre></td></tr></table></figure><p>上面所说的 <code>SYN</code> 和 <code>FIN</code> 都在 TCP segment 结构header 中。</p><h1 id="principles-of-congestion-control">Principles of Congestioncontrol</h1><p>Too many sources sending too much data too fast for <strong>network(router)</strong> to handle.</p><h2 id="approaches-towards-congestion-control">Approaches towardsCongestion Control</h2><ul><li><strong>end-end congestion control</strong>: congestion inferredfrom end-system observed loss, delay.</li><li><strong>network-assisted congestion control</strong>: routersprovide feedback to end systems.</li></ul><h1 id="tcp-congestion-control">TCP Congestion Control</h1><p><strong>Goal:</strong> TCP sender should transmit as fast aspossible, but without congesting network</p><p><strong>probing for bandwidth:</strong> increase transmission rate onreceipt of ACK, until eventually loss occurs, then decrease transmissionrate. //一种贪心策略</p><p>Sender limits rate by limiting number of unACKed bytes “in pipeline”:<span class="math display">\[\text{LastByteSent} - \text{LastByteAcked} \leq \min \{\text{cwnd},\text{rwnd} \}\]</span></p><p><span class="math display">\[\text{rate} \approx \frac{\text{cwnd}}{\text{RTT}}\]</span></p><h2 id="slow-start-phase">Slow Start Phase</h2><p>When connection begins, <span class="math inline">\(\text{cwnd} = 1\, \text{MSS}\)</span>.</p><blockquote><p><span class="math display">\[ \text{MSS} = \text{MTU} -\text{IP头部大小} - \text{TCP头部大小} \]</span></p></blockquote><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>特性</th><th>MSS</th><th>MTU</th></tr></thead><tbody><tr><td>所属协议层</td><td>传输层 (TCP)</td><td>数据链路层</td></tr><tr><td>计量对象</td><td>TCP 数据部分</td><td>整个数据包（包括所有头部）</td></tr><tr><td>设置目的</td><td>避免 IP 分片</td><td>适应物理媒介的限制</td></tr><tr><td>典型值</td><td>1460 字节 (以太网)</td><td>1500 字节 (以太网)</td></tr><tr><td>协商方式</td><td>TCP 三次握手时协商</td><td>网络设备固定或自动发现</td></tr></tbody></table></div><p>Increase rate exponentially until first <strong>loss event</strong>or when <strong>threshold reached</strong>. - <strong>Double</strong>cwnd every RTT. 没有发生 loss 就以指数函数增长。 - Done by incrementingcwnd by <span class="math inline">\(1\)</span> for every ACK received.超过 <span class="math inline">\(\text{ssthresh}\)</span>后线性增长。</p><h2 id="congestion-avoidance">Congestion Avoidance</h2><p>When <span class="math inline">\(\text{cwnd} \geq\text{ssthresh}\)</span>, increase <spanclass="math inline">\(\text{cwnd}\)</span> by <spanclass="math inline">\(1\)</span> <spanclass="math inline">\(\text{MSS}\)</span> per <spanclass="math inline">\(\text{RTT}\)</span>.</p><h2 id="tcp-reno">TCP RENO</h2><p><strong>Fast recovery</strong>: When triple duplicate ACKs occurs,<span class="math inline">\(\text{ssthresh}\)</span> sets to <spanclass="math inline">\(\frac{\text{cwnd}}{2}\)</span>, <spanclass="math inline">\(\text{cwnd}\)</span> sets to <spanclass="math inline">\(\text{ssthresh}\)</span>. 传快了，适当减小。</p><p>But when <strong>timeout</strong> occurs, <spanclass="math inline">\(\text{ssthresh}\)</span> sets to <spanclass="math inline">\(\frac{\text{cwnd}}{2}\)</span>, <spanclass="math inline">\(\text{cwnd}\)</span> sets to <spanclass="math inline">\(1\)</span> <spanclass="math inline">\(\text{MSS}\)</span>. 丢包。</p><h2 id="tcp-throughput">TCP throughput</h2><p><strong>Question:</strong> What’s the average throughput of TCP as afunction of window size and RTT?</p><p><strong>Assumptions:</strong> - Ignoring slow start. - Let<code>W</code> be the window size when loss occurs.</p><p><strong>Throughput Analysis:</strong> 1. <strong>When window size is<code>W</code></strong>: - Throughput = <spanclass="math inline">\(\frac{W}{\text{RTT}}\)</span>.</p><ol start="2" type="1"><li><strong>Just after loss</strong>:<ul><li>Window size drops to <spanclass="math inline">\(\frac{W}{2}\)</span>.</li><li>Throughput = <span class="math inline">\(\frac{W}{2 \cdot\text{RTT}}\)</span>.</li></ul></li><li><strong>Average throughput</strong>:<ul><li>Average throughput = <span class="math inline">\(0.75 \cdot\frac{W}{\text{RTT}}\)</span>.</li></ul></li></ol><h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1><h2 id="r.4">R.4</h2><p><strong>Question:</strong></p><p>Describe why an application developer might choose to run anapplication over UDP rather than TCP.</p><p><strong>Answer:</strong></p><p>An application developer might choose to run an application over UDPrather than TCP for the following reasons:</p><ol type="1"><li><p><strong>Low Latency</strong>: UDP is a connectionless protocol,meaning it does not establish a connection before sending data. Thisreduces latency, making it suitable for real-time applications likevideo streaming, online gaming, and voice over IP (VoIP).</p></li><li><p><strong>No Overhead for Reliability</strong>: Unlike TCP, UDPdoes not provide reliability mechanisms such as retransmissions,acknowledgments, or congestion control. This reduces overhead and allowsapplications to handle reliability themselves if needed.</p></li><li><p><strong>Broadcast/Multicast Support</strong>: UDP supportsbroadcasting and multicasting, which is useful for applications likelive video streaming or network discovery.</p></li><li><p><strong>Simple Protocol</strong>: UDP is simpler and requiresfewer resources, making it ideal for lightweight applications or systemswith limited processing power.</p></li><li><p><strong>Custom Error Handling</strong>: Some applications preferto implement their own error handling and flow control mechanismstailored to their specific needs, which is easier with UDP.</p></li><li><p><strong>Unordered Data Delivery</strong>: For applications wherethe order of data packets is not critical (e.g., DNS queries), UDP is abetter choice as it does not enforce packet ordering.</p></li></ol><h2 id="p.4">P.4</h2><p><strong>Question:</strong> a. Suppose you have the following <spanclass="math inline">\(2\)</span> bytes: <spanclass="math inline">\(01011100\)</span> and <spanclass="math inline">\(01010110\)</span>. What is the <spanclass="math inline">\(1\)</span>s complement of the sum of these <spanclass="math inline">\(2\)</span> bytes? b. Suppose you have thefollowing <span class="math inline">\(2\)</span> bytes: <spanclass="math inline">\(11011010\)</span> and <spanclass="math inline">\(00110110\)</span>. What is the <spanclass="math inline">\(1\)</span>s complement of the sum of these <spanclass="math inline">\(2\)</span> bytes? c. For the bytes in part (a),give an example where one bit is flipped in each of the <spanclass="math inline">\(2\)</span> bytes and yet the <spanclass="math inline">\(1\)</span>s complement doesn’t change.</p><p><strong>Answer:</strong> - <strong>a.</strong> <spanclass="math inline">\(10110010\)</span>. - <strong>b.</strong> <spanclass="math inline">\(00010001\)</span>. - <strong>c.</strong> <spanclass="math inline">\(01011110\)</span> and <spanclass="math inline">\(01010100\)</span>.</p><h2 id="p.11">P.11</h2><p><strong>Question:</strong></p><p>The sender side of <span class="math inline">\(\text{rdt}3.0\)</span>simply ignores (that is, takes no action on) all received packets thatare either in error or have the wrong value in the acknum field of anacknowledgment packet. Suppose that in such circumstances, <spanclass="math inline">\(\text{rdt}3.0\)</span> were simply to retransmitthe current data packet. Would the protocol still work? (Hint: Considerwhat would happen if there were only bit errors; there are no packetlosses but premature timeouts can occur. Consider how many times the<span class="math inline">\(n^{th}\)</span> packet is sent, in the limitas <span class="math inline">\(n\)</span> approaches infinity.)</p><p><strong>Answer:</strong></p><p>在这种情况下，rdt <span class="math inline">\(3.0\)</span>仍然是有效的。首先，该协议接收方可以通过检查 <strong>sequencenumber</strong> 来判断当前的包是否重复，这个检查方式一直有效。原本的<span class="math inline">\(\text{rdt}3.0\)</span>协议在超时后会重传，但现在只要检查出 <strong>acknowledgmentpacket</strong>中出错就重传，这显然会增加网络负载，比如：在极端情况下，发送方可能会多次重传一个包，若ACK 错误率为 <spanclass="math inline">\(p\)</span>，则每个数据包平均需要发送 <spanclass="math inline">\(1/(1-p)\)</span> 次，直到接受到正确的<strong>ACKs</strong>。总结：<spanclass="math inline">\(\text{rdt}3.0\)</span>协议在这种情况下仍然是可靠的，但立即重传错误数据包会导致性能问题，因此这种修改并不是一个好的设计选择。</p><h2 id="p.14">P.14</h2><p><strong>Question:</strong></p><p>Consider the cross-country example shown in Figure <spanclass="math inline">\(3.17\)</span>. How big would the window size haveto be for the channel utilization to be greater than <spanclass="math inline">\(95\)</span> percent? Suppose that the size of apacket is <span class="math inline">\(1,500\)</span> bytes, includingboth header fields and data.</p><p><strong>Complement:</strong> <span class="math inline">\(1\)</span>Gbps link. RTT, is approximately <span class="math inline">\(30\)</span>milliseconds.</p><p><strong>Answer:</strong></p><p><span class="math display">\[\text{d}_{trans} = \frac{L}{R} = \frac{1500 \times 8}{1 \times 10^9} =1.2 \times 10^{-5} \, \text{s}\]</span></p><p><span class="math display">\[\text{Utilization} = \frac{\text{rwnd} \times \frac{L}{R}}{\text{RTT} +\text{rwnd} \times \frac{L}{R}} \geq 0.95\]</span></p><p>解得，<span class="math inline">\(\text{rwnd} \geq4750\)</span>。</p><h2 id="p.22">P.22</h2><p><strong>Questions and Answers:</strong></p><p>Answer true or false to the following questions and briefly justifyyour answer:</p><p><strong>a. With the SR protocol, it is possible for the sender toreceive an ACK for a packet that falls outside of its currentwindow.</strong></p><p><strong>True</strong>; 在 <strong>SR</strong>协议中，由于网络延迟等原因，发送方可能收到对应于已经滑出当前窗口的数据包的ACK。</p><p><strong>b. With GBN, it is possible for the sender to receive an ACKfor a packet that falls outside of its current window.</strong></p><p><strong>False</strong>; 在 <strong>GBN</strong>协议中，<strong>ACK</strong> 是累积的，表示所有序列号小于等于 ACK的包已经被正确接收。</p><p><strong>c. The alternating-bit protocol is the same as the SRprotocol with a sender and receiver window size of <spanclass="math inline">\(1\)</span>.</strong></p><p><strong>True</strong>; 交替位协议是 SR协议的一个特例，其中发送方和接收方的窗口大小均为 <spanclass="math inline">\(1\)</span>。它只允许发送一个未确认的包，并通过序列号（<spanclass="math inline">\(0\)</span> 或 <spanclass="math inline">\(1\)</span>）来区分包。</p><p><strong>d. The alternating-bit protocol is the same as the GBNprotocol with a sender and receiver window size of <spanclass="math inline">\(1\)</span>.</strong></p><p><strong>True</strong>; 交替位协议也可以看作是 GBN协议的一个特例，其中发送方和接收方的窗口大小均为 <spanclass="math inline">\(1\)</span>。在这种情况下，GBN的行为与交替位协议完全一致，因为它只允许发送一个未确认的包，并在超时或收到NAK 时重传该包。</p><h2 id="p.24">P.24</h2><p><strong>Questions and Answers:</strong></p><p>Consider transferring an enormous file of <spanclass="math inline">\(L\)</span> bytes from Host A to Host B. Assume anMSS of <span class="math inline">\(536\)</span> bytes.</p><p><strong>a. What is the maximum value of <spanclass="math inline">\(L\)</span> such that TCP sequence numbers are notexhausted? Recall that the TCP sequence number field has <spanclass="math inline">\(4\)</span> bytes.</strong></p><p>TCP segment structure 中 sequence number 有 <spanclass="math inline">\(32\)</span> bits，从 <spanclass="math inline">\(0\)</span> 开始。所以最大的 <spanclass="math inline">\(L = 2^{32} - 1\)</span>。</p><p><strong>b. For the <span class="math inline">\(L\)</span> you obtainin (a), find how long it takes to transmit the file. Assume that a totalof <span class="math inline">\(66\)</span> bytes of transport, network,and data-link header are added to each segment before the resultingpacket is sent out over a <span class="math inline">\(155\)</span> Mbpslink. Ignore flow control and congestion control so A can pump out thesegments back to back and continuously.</strong></p><ul><li>MSS = <span class="math inline">\(536\)</span> bytes<br /></li><li>每报文附加头部 = <span class="math inline">\(66\)</span> bytes<br /></li><li>总报文尺寸 (536 + 66 = 602) bytes<br /></li><li>报文数量<br /><span class="math display">\[N = \left\lceil \frac{L_{\max}}{\text{MSS}} \right\rceil  = \left\lceil \frac{2^{32}-1}{536} \right\rceil  = 8\,012\,999\]</span></li><li>总传输位数<br /><span class="math display">\[B = N \times 602\ \text{bytes} \times 8\\tfrac{\text{bits}}{\text{byte}}  = 8\,012\,999 \times 602 \times 8  \approx 3.85906\times 10^{10}\ \text{bits}\]</span></li><li>链路速率 (R = 155 )<br /></li><li>传输时间<br /><span class="math display">\[T = \frac{B}{R}  = \frac{3.85906\times 10^{10}}{155\times 10^6}  \approx 249\ \text{秒}  \approx 4.15\ \text{分钟}\]</span></li></ul><h2 id="p.25">P.25</h2><p>Host A and B are communicating over a TCP connection, and Host B hasalready received from A all bytes up through byte <spanclass="math inline">\(126\)</span>. Suppose Host A then sends twosegments to Host B back-to-back. The first and second segments contain<span class="math inline">\(70\)</span> and <spanclass="math inline">\(50\)</span> bytes of data, respectively. In thefirst segment, the sequence number is <spanclass="math inline">\(127\)</span>, the source port number is <spanclass="math inline">\(302\)</span>, and the destination port number is<span class="math inline">\(80\)</span>. Host B sends an acknowledgementwhenever it receives a segment from Host A.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. In the second segment sent from Host A to B, what are thesequence number, source port number, and destination portnumber?</strong> - The sequence number is <spanclass="math inline">\(197\)</span>, the source port number is <spanclass="math inline">\(302\)</span> and the dest port number is <spanclass="math inline">\(80\)</span>.</p><p><strong>b. If the first segment arrives before the second segment, inthe acknowledgement of the first arriving segment, what is theacknowledgment number, the source port number, and the destination portnumber?</strong> - The acknowledgement number is <spanclass="math inline">\(197\)</span>, the source port number is <spanclass="math inline">\(80\)</span> and the dest port number is <spanclass="math inline">\(302\)</span>.</p><p><strong>c. If the second segment arrives before the first segment, inthe acknowledgement of the first arriving segment, what is theacknowledgment number?</strong> - The acknowledgement number is <spanclass="math inline">\(127\)</span>.</p><p><strong>d. Suppose the two segments sent by A arrive in order at B.The first acknowledgement is lost and the second acknowledgement arrivesafter the first timeout interval. Draw a timing diagram, showing thesesegments and all other segments and acknowledgements sent. (Assume thereis no additional packet loss.) For each segment in your figure, providethe sequence number and the number of bytes of data; for eachacknowledgement that you add, provide the acknowledgementnumber.</strong></p><ul><li>假设：<br /></li><li>A→B 连续发送两段<br /></li><li>B 收到每段即发 ACK<br /></li><li>第一条 ACK(197) 丢失，第二条 ACK(247) 成功到达<br /></li><li>超时重传未触发（因为第二条 ACK 收到后 A 已完成确认）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>Time →<br>Host A                          Host B<br>  |                                |<br>  |-- [Seq=127, Len=70] ----------&gt;|   接收 127-196，B 发送 ACK(197) → 丢失<br>  |                                |<br>  |-- [Seq=197, Len=50] ----------&gt;|   接收 197-246，B 发送 ACK(247)<br>  |                                |<br>  |      [超时等待 ACK(197)]       |<br>  |                                |<br>  |-- [Seq=127, Len=70] ----------&gt;|   重复包，B 再次发送 ACK(247)<br>  |                                |<br>  |&lt;----------- ACK(247) ----------|   A 收到确认，确认两段都已接收<br></code></pre></td></tr></table></figure><h2 id="p.31">P.31</h2><p><strong>Question and Answer:</strong></p><p>What is the relationship between the variable SendBase in Section<span class="math inline">\(3.5.4\)</span> and the variable LastByteRcvdin Section <span class="math inline">\(3.5.5\)</span>?</p><p>在理想网络条件下（无丢包、延迟较小）：</p><p><span class="math display">\[\text{SendBase} - 1 =\text{LastByteRcvd}\]</span></p><p>这是因为： - 接收方接收到字节序号为 n 的数据后，LastByteRcvd = n -接收方发送 ACK(n+1) - 发送方收到 ACK(n+1) 后，更新 SendBase = n+1</p><p>由于网络延迟、丢包等因素： - LastByteRcvd 可能<strong>小于</strong>SendBase-1（发送方已收到更新的确认） - LastByteRcvd可能<strong>大于</strong> SendBase-1（某些已接收数据未被确认接收）</p><h2 id="p.32">P.32</h2><p><strong>Question and Answer:</strong></p><p>What is the relationship between the variable <spanclass="math inline">\(\text{LastByteRcvd}\)</span> in Section <spanclass="math inline">\(3.5.5\)</span> and the variable <spanclass="math inline">\(\text{y}\)</span> in Section <spanclass="math inline">\(3.5.4\)</span>?</p><p>由上题所述：</p><p><span class="math display">\[\text{acknowledgement number} = \text{LastByteRcvd} + 1\]</span></p><h2 id="p.34">P.34</h2><p>Compare GBN, SR, and TCP (no delayed ACK). Assume that the timeoutvalues for all three protocols are sufficiently long such that <spanclass="math inline">\(5\)</span> consecutive data segments and theircorresponding ACKs can be received (if not lost in the channel) by thereceiving host (Host B) and the sending host (Host A) respectively.Suppose Host A sends <span class="math inline">\(5\)</span> datasegments to Host B, and the <span class="math inline">\(2^{nd}\)</span>segment (sent from A) is lost. In the end, all <spanclass="math inline">\(5\)</span> data segments have been correctlyreceived by Host B.</p><p><strong>Question and Answer:</strong></p><p><strong>a. How many segments has Host A sent in total and how manyACKs has Host B sent in total? What are their sequence numbers? Answerthis question for all three protocols.</strong></p><p>题目没有指定 sequence number，这里默认从 <spanclass="math inline">\(0\)</span> 开始，所有 segment 大小为 <spanclass="math inline">\(1\)</span> byte。首先，receiver 收到多少个 segment就会回多少个 ACK。</p><p>首先明确各协议的ACK机制：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>协议</strong></th><th><strong>确认机制</strong></th><th><strong>ACK含义</strong></th></tr></thead><tbody><tr><td>GBN</td><td>累积确认</td><td>ACK(n)表示期望收到序号n的段</td></tr><tr><td>SR</td><td>选择确认</td><td>ACK(n)表示已收到序号n的段</td></tr><tr><td>TCP</td><td>累积确认+SACK</td><td>ACK(n)表示期望收到序号n的段</td></tr></tbody></table></div><p>分析 GBN 协议，第一个 segment 的 sequence number 为 <spanclass="math inline">\(0\)</span>，以此类推，接下来的 sequence number分别为 <span class="math inline">\(1\)</span> <spanclass="math inline">\(2\)</span> <span class="math inline">\(3\)</span><span class="math inline">\(4\)</span>，相应的 ACK 为 <spanclass="math inline">\(1\)</span> <span class="math inline">\(2\)</span><span class="math inline">\(3\)</span> <spanclass="math inline">\(4\)</span> <spanclass="math inline">\(5\)</span>。但由于第二个包丢失，实际上的 ACK 为<span class="math inline">\(1\)</span> 丢失 <spanclass="math inline">\(1\)</span> <span class="math inline">\(1\)</span><span class="math inline">\(1\)</span>， 再重发，<spanclass="math inline">\(2\)</span> <span class="math inline">\(3\)</span><span class="math inline">\(4\)</span> <spanclass="math inline">\(5\)</span>。再分析剩下两个协议，最终得到</p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr><th><strong>Protocol</strong></th><th><strong>Segments Sent</strong></th><th><strong>ACKs Received</strong></th><th><strong>Their Sequence</strong></th></tr></thead><tbody><tr><td>GBN</td><td>9</td><td>8</td><td>1 1 1 1 2 3 4 5</td></tr><tr><td>SR</td><td>6</td><td>5</td><td>0 2 3 4 1</td></tr><tr><td>TCP</td><td>6</td><td>5</td><td>1 1 1 1 5</td></tr></tbody></table></div><p><strong>b. If the timeout values for all three protocol are muchlonger than <span class="math inline">\(5\)</span> RTT, then whichprotocol successfully delivers all five data segments in shortest timeinterval?</strong></p><p>SR 和 TCP，因为这两种协议都只发送了 <spanclass="math inline">\(6\)</span> 次包。</p><h2 id="p.37">P.37</h2><p><strong>Questions and Answers:</strong></p><figure><imgsrc="The-Transport-Layer/TCP%20window%20size%20as%20a%20function%20of%20time.png"style="display: block; margin: 0 auto; width: 90%"alt="TCP window size as a function of time" /><figcaption aria-hidden="true">TCP window size as a function oftime</figcaption></figure><p>Assuming TCP <strong>Reno</strong> is the protocol experiencing thebehavior shown above, answer the following questions. In all cases, youshould provide a short discussion justifying your answer.</p><p><strong>a. Identify the intervals of time when TCP slow start isoperating.</strong></p><p>根据 TCP congestion control 机制，slow start phase 期间<strong>cwnd</strong> 是以指数函数增长，从图中可以得出大概是在 <spanclass="math inline">\(\text{Transmission round} \in [1, 6] \cup [23,26]\)</span> 期间。</p><p><strong>b. Identify the intervals of time when TCP congestionavoidance is operating</strong></p><p>TCP congestion avoidance 期间的特点是 <strong>cwnd</strong> 以 $ k =1 $ MSS 的速率线性增长，从图中可以得出大概是在 <spanclass="math inline">\(\text{Transmission round} \in [6, 16] \cup [17,22]\)</span> 期间。</p><p><strong>c. After the 16th transmission round, is segment lossdetected by a triple duplicate ACK or by a timeout?</strong></p><p>从图中可以分析出，<span class="math inline">\(\text{ssthresh} =\frac{\text{cwnd}}{2}\)</span>，<span class="math inline">\(\text{cwnd}= \text{ssthresh}\)</span>，然后线性增长，所以 detected by a tripleduplicate ACK。</p><p><strong>d. After the 22nd transmission round, is segment lossdetected by a triple duplicate ACK or by a timeout?</strong></p><p><strong>cwnd</strong> 归一，进入 slow start phase，所以 detected by atimeout。</p><p><strong>e. What is the initial value of <spanclass="math inline">\(\text{ssthresh}\)</span> at the first transmissionround?</strong></p><p>大概是 <span class="math inline">\(32\)</span> MSS，当 <spanclass="math inline">\({\text{cwnd} \geq \text{ssthresh}}\)</span> 会进入congestion avoidance phase，然后线性增长。</p><p><strong>f. What is the value of ssthresh at the <spanclass="math inline">\(18^{th}\)</span> transmission round?</strong></p><p>减半了，所以是，<span class="math inline">\(\text{ssthresh} =\frac{\text{cwnd}}{2} = 21\)</span> MSS</p><p><strong>g. What is the value of ssthresh at the <spanclass="math inline">\(24^{th}\)</span> transmission round?</strong></p><p>减半了，所以是，<span class="math inline">\(\text{ssthresh} =\frac{\text{cwnd}}{2} = 13\)</span> MSS</p><p><strong>h. During what transmission round is the <spanclass="math inline">\(70^{th}\)</span> segment sent?</strong></p><p>第一次 slow start phase 阶段后传了 63 个，所在第 <spanclass="math inline">\(6\)</span> 和 <spanclass="math inline">\(7\)</span> 轮之间。</p><p><strong>i. Assuming a packet loss is detected after the <spanclass="math inline">\(26^{th}\)</span> round by the receipt of a tripleduplicate ACK, what will be the values of the congestion window size andof ssthresh?</strong></p><p><span class="math inline">\(\text{ssthresh} =\frac{\text{cwnd}}{2}\)</span>，<span class="math inline">\(\text{cwnd}= \text{ssthresh}\)</span>，都是 <span class="math inline">\(4\)</span>segment.</p><p><strong>j. Suppose TCP Tahoe is used (instead of TCP Reno), andassume that triple duplicate ACKs are received at the <spanclass="math inline">\(16^{th}\)</span> round. What are the ssthresh andthe congestion window size at the <spanclass="math inline">\(19^{th}\)</span> round?</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table style="width:100%;"><thead><tr><th>特性</th><th>TCP Tahoe</th><th>TCP Reno</th></tr></thead><tbody><tr><td><strong>三次重复ACK时</strong></td><td>cwnd=1MSS, 进入慢启动</td><td>cwnd=ssthresh, 进入拥塞避免</td></tr><tr><td><strong>超时事件时</strong></td><td>cwnd=1MSS, 进入慢启动</td><td>cwnd=1MSS, 进入慢启动</td></tr><tr><td><strong>恢复速度</strong></td><td>较慢(需要重新慢启动)</td><td>较快(可能直接进入拥塞避免)</td></tr><tr><td><strong>快速恢复机制</strong></td><td>不支持</td><td>支持</td></tr></tbody></table></div><p>第 <span class="math inline">\(16^{th}\)</span> 出现了 tripleduplicate ACKs，所以，第 <span class="math inline">\(17^{th}\)</span><span class="math inline">\(\text{ssthresh} = \frac{\text{cwnd}}{2} =21\)</span>，<span class="math inline">\(\text{cwnd} =1\)</span>，然后进入 slow start 阶段，第 <spanclass="math inline">\(19^{th}\)</span> <spanclass="math inline">\(\text{cwnd} = 4\)</span></p><p><strong>k. Again suppose TCP Tahoe is used, and there is a timeoutevent at <span class="math inline">\(22^{nd}\)</span> round. How manypackets have been sent out from <spanclass="math inline">\(17^{th}\)</span> round till <spanclass="math inline">\(22^{nd}\)</span> round, inclusive?</strong></p><p>需要注意的是，在第 <span class="math inline">\(16^{th}\)</span>收到了三个 ACKs，同时，在第 <span class="math inline">\(22^{th}\)</span>到达 ssthresh 所以实际收到 <span class="math inline">\(1 + 2 + 4 + 8 +16 + 21 = 52\)</span> MSS。</p><h2 id="p.43">P.43</h2><p>Consider that only a single TCP (Reno) connection uses one <spanclass="math inline">\(10\)</span> Mbps link which does not buffer anydata. Suppose that this link is the only congested link between thesending and receiving hosts. Assume that the TCP sender has a huge fileto send to the receiver, and the receiver’s receive buffer is muchlarger than the congestion window. We also make the followingassumptions: each TCP segment size is <spanclass="math inline">\(1\,500\)</span> bytes; the two-way propagationdelay of this connection is <span class="math inline">\(100\)</span>msec; and this TCP connection <strong>is always in congestion avoidancephase, that is, ignore slow start</strong>.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is the maximum window size (in segments) that thisTCP connection can achieve?</strong></p><p>最大窗口大小由 <strong>带宽延迟积(BDP)</strong> 决定：</p><p>首先计算 RTT： - 传播延迟 = <span class="math inline">\(100\)</span>毫秒 - 传输延迟 = 段大小/带宽 = (<span class="math inline">\(1500 \times8\)</span>) 比特/(<span class="math inline">\(10 \times 10^6\)</span>)比特/秒 = <span class="math inline">\(1.2\)</span> 毫秒 -<strong>总RTT</strong> = <span class="math inline">\(101.2\)</span>毫秒</p><p>带宽延迟积： <span class="math display">\[\text{BDP} = 10\text{ Mbps} \times 0.1012\text{ s} = 1.012 \times 10^6\text{ bits}\]</span></p><p>也就是 PPT 上的公式： <span class="math display">\[\text{rate} \approx \frac{\text{cwnd}}{\text{RTT}}\]</span></p><p>最大窗口大小(段数)： <span class="math display">\[\text{最大窗口} = \frac{\text{BDP}}{\text{段大小}} = \frac{1.012 \times10^6}{1500 \times 8} \approx 84.33 = \boxed{84\text{ 段}}\]</span></p><p><strong>b. What is the average window size (in segments) and averagethroughput (in bps) of this TCP connection?</strong></p><p>根据TCP Reno特性，窗口大小在拥塞避免阶段会在 <spanclass="math inline">\(\frac{W}{2}\)</span> 和 <spanclass="math inline">\(W\)</span> 之间周期变化。</p><p>平均窗口大小： <span class="math display">\[\text{平均窗口} = 0.75 \times W = 0.75 \times 84 = \boxed{63\text{ 段}}\]</span></p><p>平均吞吐量： <span class="math display">\[\text{平均吞吐量} = 0.75 \times \frac{W \times \text{段大小} \times8}{\text{RTT}} = 0.75 \times \frac{84 \times 1500 \times 8}{0.1012}\approx \boxed{7.5\text{ Mbps}}\]</span></p><p><strong>c. How long would it take for this TCP connection to reachits maximum window again after recovering from a packetloss?</strong></p><p>在TCP Reno中，丢包后窗口大小减半，然后每个RTT增加 <spanclass="math inline">\(1\)</span> 个MSS：</p><ul><li>初始窗口（丢包后）= <span class="math inline">\(\frac{W}{2} =42\)</span> 段</li><li>每个RTT增加 <span class="math inline">\(1\)</span> 段</li><li>需要增加的段数 = <span class="math inline">\(\frac{W}{2} =42\)</span> 段</li><li>所需RTT数 = <span class="math inline">\(42\)</span></li></ul><p><span class="math display">\[\text{恢复时间} = 42 \times 0.1012 = \boxed{4.25\text{ 秒}}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Transport Layer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Application Layer</title>
    <link href="/2025/06/07/The-Application-Layer/"/>
    <url>/2025/06/07/The-Application-Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="principles-of-network-applications">Principles of networkapplications</h1><h2 id="application-architectures">Application architectures</h2><p><strong>Three Kinds:</strong> - Peer to Peer - Client-Server - hybridof P2P and Client-Server</p><h3 id="client-server">Client-Server</h3><p><strong>Client-Server architecture has followingcharacteristics:</strong> - Server is <strong>always-on</strong> host; -Server has a <strong>permanent IP address</strong>; - Clients do notcommunicate with each other directly.</p><blockquote><p>clients 之间通过 server 交流。</p></blockquote><h3 id="pure-p2p">Pure P2P</h3><p>In <strong>P2P architecture</strong>, there is no always-on server,what’s more, arbitrary end systems communicate directly.</p><h3 id="hybrid-of-client-server-and-p2p">Hybrid of Client-Server andP2P</h3><p>As the name suggests, this architecture is implemented withClient-Server and P2P.</p><p><strong>There are two important instance, Skype and QQ</strong> -<strong>Skype:</strong> a voice-over-IP P2P application. If a host Awants to voice another host B, he will get B’s IP address from a server.And then they communicate with each other directly. -<strong>QQ:</strong> a chat-over-IP P2P application.</p><blockquote><p>clients 会给 server 提交自己的 IP address。</p></blockquote><h4 id="client-server-部分">Client-Server 部分</h4><ul><li>用户登录、查找好友、获取在线状态等操作都需要通过<strong>集中服务器</strong>完成。</li><li>服务器维护所有用户的索引和状态信息，起到“中介”作用。</li></ul><h4 id="p2p-部分">P2P 部分</h4><ul><li>当用户之间需要发送即时消息或文件时，<strong>实际数据传输可以直接在用户之间进行</strong>，不经过服务器。</li><li>这样可以减轻服务器压力，提高传输效率。</li></ul><h2 id="processes-communicating">Processes Communicating</h2><p><strong>Process</strong> is a program controlled by <strong>appdeveloper</strong>, running within a host. Within a same host, twoprocesses communicate with each other by <strong>inter-processcommunication</strong>. Between two hosts, processes communicate witheach other by <strong>exchanging messages</strong>. Generally speaking,there are two kinds of processes, they are <strong>clientprocess</strong> and <strong>server process</strong>. Client processinitializes a communication, and server process waits to becontacted.</p><h2 id="sockets">Sockets</h2><p>A <strong>door</strong> between application layer and transportlayer.</p><h2 id="addressing-processes">Addressing Processes</h2><p>To receive message, process must have an <strong>identifier</strong>.Identifier includes both <strong>IP address</strong> and <strong>portnumbers</strong> associated with process on host.</p><h2 id="app-layer-protocol-defines">App-layer Protocol Defines</h2><p><strong>What does an app-layer protocol define?</strong> - Type ofmessage exchanged; - Message syntax: what fields in messages and howfields are delineated; - Message semantics: meaning of information infields; - Rules for when and how a process requests and sendsmessages.</p><blockquote><p>message 类型、语义、语法、传输时间和方式。</p></blockquote><p>Generally speaking, there are two sorts of app-layer protocols, they<strong>public-domain protocol</strong> and <strong>proprietaryprotocol</strong>.</p><blockquote><p>前者公开后者不公开。</p></blockquote><h2 id="what-transport-service-dose-an-application-need">What transportservice dose an application need?</h2><p>We can consider four standards to select transport service. - dataloss - timing - throughput - security</p><p>下面是常见的应用类型其需要的传输层服务：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>Application</strong></th><th><strong>Data Loss</strong></th><th><strong>Throughput</strong></th><th><strong>Time Sensitive</strong></th></tr></thead><tbody><tr><td>File transfer</td><td>No loss</td><td>Elastic</td><td>No</td></tr><tr><td>E-mail</td><td>No loss</td><td>Elastic</td><td>No</td></tr><tr><td>Web documents</td><td>No loss</td><td>Elastic</td><td>No</td></tr><tr><td>Real-time audio/video</td><td>Loss-tolerant</td><td>Audio: 5kbps-1Mbps<br>Video: 10kbps-5Mbps</td><td>Yes, 100’s msec</td></tr><tr><td>Stored audio/video</td><td>Loss-tolerant</td><td>Same as above</td><td>Yes, few secs</td></tr><tr><td>Interactive games</td><td>Loss-tolerant</td><td>Few kbps up</td><td>Yes, 100’s msec</td></tr><tr><td>Instant messaging</td><td>No loss</td><td>Elastic</td><td>Yes and no</td></tr></tbody></table></div><blockquote><p>远程医疗手术系统是 requires no data loss and is highly time-sensitive实际上，在当今互联网中，语音和视频流量经常通过 <strong>TCP</strong>发送，主要原因是<strong>防火墙和NAT（网络地址转换）设备的兼容性和穿透性更好</strong>。许多防火墙和 NAT设备默认只允许 TCP 流量通过，而对 UDP流量进行限制或直接丢弃。这样做是出于安全性和管理的考虑，因为 TCP连接有明确的建立和关闭过程，便于追踪和控制，而 UDP是无连接的，容易被滥用。因此，为了确保语音和视频应用能够在各种网络环境下顺利传输数据，开发者往往选择基于TCP 协议进行数据传输，即使 UDP 在实时性和低延迟方面更有优势。</p></blockquote><p>下面是常见的应用类型其需要的应用层、传输层协议：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>Application</strong></th><th><strong>Application Layer Protocol</strong></th><th><strong>Underlying Transport Protocol</strong></th></tr></thead><tbody><tr><td>E-mail</td><td>SMTP [RFC 2821]</td><td>TCP</td></tr><tr><td>Remote terminal access</td><td>Telnet [RFC 854]</td><td>TCP</td></tr><tr><td>Web</td><td>HTTP [RFC 2616]</td><td>TCP</td></tr><tr><td>File transfer</td><td>FTP [RFC 959]</td><td>TCP</td></tr><tr><td>Streaming multimedia</td><td>HTTP (e.g., YouTube), RTP [RFC 1889]</td><td>TCP or UDP</td></tr><tr><td>Internet telephony</td><td>SIP, RTP, proprietary (e.g., Skype)</td><td>Typically UDP</td></tr></tbody></table></div><h1 id="web-and-http">Web and HTTP</h1><p>Web pages consist of some <strong>objects</strong>, each object canbe HTML file, Java script and so on. Each object is addressed by a URL,for example, <code>www.someschool.edu/someDept/pic.gif</code>. Amongthis URL, <code>www.someschool.edu</code> is host name and<code>someDept/pic.gif</code> is path name.</p><p><strong>Base HTML-file</strong> is the core of a page. It mayincludes several referenced objects.</p><h2 id="http-hypertext-transfer-protocol">HTTP: Hypertext TransferProtocol</h2><p><strong>HTTP</strong> is Web’s application protocol with<strong>Client-Server model</strong>. Its transport layer protocol is<strong>TCP</strong>.</p><p>HTTP is <strong>stateless</strong>, this means server maintains noinformation of past clients requests. The reason why protocol thatmaintains state are complex is that if server or client crashes, theirviews of “state” may be inconsistent, must be reconciled.</p><blockquote><p>需要和后文的 cookie 区分开，cookie 并不和 stateless的性质相违背，原因是：Cookie只是让状态在客户端和服务器之间传递，而不是让服务器主动维护状态。</p></blockquote><h3 id="non-persistent-http">Non-Persistent HTTP</h3><h4 id="rtt-round-trip-time">RTT: Round Trip Time</h4><figure><img src="The-Application-Layer/Non-Persistent-HTTP.png"style="display: block; margin: 0 auto; width: 90%"alt="Non Persistent HTTP" /><figcaption aria-hidden="true">Non Persistent HTTP</figcaption></figure><p><strong>Definition of <spanclass="math inline">\(\text{RTT}\)</span>:</strong> time for a smallpacket to travel from client to server and back.</p><p>From the picture, we can calculate total time. <spanclass="math inline">\(\text{total time} = 2 \times \text{RTT} +\text{transmit time}_1\)</span></p><h3 id="persistent-http">Persistent HTTP</h3><p>Persistent HTTP leaves <strong>TCP connection open</strong> aftersending response. Client sends request as soon as it encounters areferenced object. As little as one RTT for all the referenced objects.<span class="math inline">\(\text{total time} \approx 3 \times\text{RTT} + \text{transmit time}_1 + \text{transmittime}_2\)</span></p><h2 id="http-message">HTTP Message</h2><p>Two types of HTTP message: <strong>request</strong> and<strong>response</strong>. <strong>Sent as ASCII text</strong></p><h3 id="request">Request</h3><figure><img src="The-Application-Layer/Request-Format.png"style="display: block; margin: 0 auto; width: 90%" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><ol type="1"><li><strong>Request Line</strong><ul><li><strong>Method:</strong> GET, POST, HEAD; PUT, DELETE;<ul><li><strong>POST:</strong> Server decides the path;</li><li><strong>PUT:</strong> Client decides the path;</li></ul></li><li><strong>URL:</strong> path;</li><li><strong>Version:</strong> HTTP version.</li></ul></li><li><strong>Header Lines</strong><ul><li><strong>Host:</strong></li><li><strong>User-Agent:</strong></li><li><strong>Connection:</strong> keep-alive or close;</li><li><strong>Accept-Language:</strong> .</li></ul></li><li><strong>Entity Body:</strong></li></ol><blockquote><p>如果是 keep-alive 则是 persistent connection；如果是 close 则是non-persistent connection。</p></blockquote><h3 id="response">Response</h3><figure><img src="The-Application-Layer/Response-Format.png"style="display: block; margin: 0 auto; width: 90%"alt="Response Format" /><figcaption aria-hidden="true">Response Format</figcaption></figure><p><strong>A few sample codes</strong> - <code>200: OK</code> -<code>301: Moved Permanently</code> - <code>400: Bad Request</code> -<code>404: Not Found</code> -<code>505: HTTP Version Not Supported</code></p><h2 id="user-server-state-cookies">User-Server State: Cookies</h2><p><strong>How to set cookies and use cookies?</strong> When a clientfirst initialize HTTP TCP connection, server will<strong><code>set cookies</code></strong> in response message’s<strong>Header</strong> filed. After that, each request message fromsame client will take will <strong><code>cookies</code></strong> inrequest message <strong>HEADER</strong> filed.</p><p><strong>What cookies can bring:</strong></p><ul><li>authorization</li><li>shopping carts</li><li>recommendations</li><li>user session state (Web e-mail)</li></ul><p>比如：</p><ol type="1"><li>用户访问电商网站 → 服务器分配并下发 <code>user_id</code> Cookie</li><li>用户下单 → 浏览器携带 <code>user_id</code> Cookie → 服务器根据<code>user_id</code> 更新购买记录</li><li>用户后续访问 → 服务器通过 Cookie 识别用户，展示其购买历史</li></ol><h2 id="web-caches">Web Caches</h2><p><strong>Goal</strong>: satisfy client request without involvingorigin server.</p><figure><img src="The-Application-Layer/Web-Caches.png"style="display: block; margin: 0 auto; width: 90%" alt="Web Caches" /><figcaption aria-hidden="true">Web Caches</figcaption></figure><blockquote><p>typically cache is installed by ISP.</p></blockquote><p><strong>Why Web caching?</strong> - <strong>reduce responsetime</strong> for client request - <strong>reduce traffic</strong> on aninstitution’s access link. - Internet dense with caches: enables “poor”content providers to effectively deliver content (but so does P2P filesharing)</p><h3 id="conditional-get">Conditional GET</h3><p><strong>Goal:</strong> don’t send object if cache has<strong>up-to-date</strong> cached version</p><p><strong>cache:</strong> specify date of cached copy in <strong>HTTPrequest</strong>: <code>If-modified-since: date</code><strong>server:</strong> <strong>response</strong> contains no object ifcached copy <code>is up-to-date: HTTP/1.0 304 Not Modified</code></p><h1 id="ftp-the-file-transfer-protocol">FTP: the File TransferProtocol</h1><p><strong>Goal:</strong> File transfers from/to remote host.</p><figure><img src="The-Application-Layer/FTP.png"style="display: block; margin: 0 auto; width: 90%" alt="FTP" /><figcaption aria-hidden="true">FTP</figcaption></figure><p>FTP client contacts FTP server at <strong>port 21</strong>,<strong>TCP</strong> is transport protocol. When server receives<strong>file transfer command</strong>, server opens <spanclass="math inline">\(2^{nd}\)</span> TCP connection for file to client.After transferring one file, server closes data connection. Server opensanother TCP data connection to transfer another file.</p><p>这是一种 <strong>out-of-band</strong> 的协议。</p><ul><li><strong>带外（Out-of-band）</strong>指的是控制信息和数据内容通过<strong>不同的通道</strong>进行传输，而不是混合在同一个通道中。</li></ul><h2 id="ftp-commands-responses">FTP Commands, Responses</h2><p>Sent as <strong>ASCII text</strong>, response: <strong>status codeand phrase</strong>.</p><p><strong>Sample commands:</strong> - <code>USER</code> username; -<code>PASS</code> password; - <code>LIST</code> return list of file incurrent directory; - <code>RETR</code> filename retrieves (gets) file; -<code>STOR</code> filename stores (puts) file onto remote host.</p><p><strong>Sample return codes:</strong> - <code>331</code> Username OK,password required; - <code>125</code> data connection already open;transfer starting; - <code>425</code> Can’t open data connection; -<code>452</code> Error writing file.</p><h1 id="electronic-mail">Electronic Mail</h1><figure><img src="The-Application-Layer/e-mail-system.png"style="display: block; margin: 0 auto; width: 90%"alt="e mail system" /><figcaption aria-hidden="true">e mail system</figcaption></figure><p><strong>Three Major Components:</strong> - user agents; - mailservers; - simple mail transfer protocol: SMTP.</p><p><strong>Mail Server</strong> - <strong>mailbox</strong> containsincoming messages for user; - <strong>message queue</strong> of outgoing(to be sent) mail messages - SMTP protocol <strong>between mailservers</strong> to send email messages</p><h2 id="smtp-simple-mail-transfer-protocol">SMTP: Simple Mail TransferProtocol</h2><figure><img src="The-Application-Layer/SMTP-example.png"style="display: block; margin: 0 auto; width: 90%" alt="SMTP example" /><figcaption aria-hidden="true">SMTP example</figcaption></figure><p><strong>Characteristics:</strong> - Uses <strong>TCP</strong> toreliably transfer email message from client to server, <strong>port25</strong>; - Three phases of transfer; - <strong>Handshaking</strong>(Greeting); - <strong>Transfer of Messages</strong>; -<strong>Closure</strong>. - Command/Response interaction; - Commands:ASCII text; - Response: status code and phrase.</p><p><strong>What’s more:</strong> - SMTP uses <strong>persistentconnections</strong>; - SMTP requires message (header &amp; body) to bein <strong>7-bit ASCII</strong>; - SMTP server uses<code>CRLF.CRLF</code> to determine end of message.</p><p><strong>Comparison with HTTP</strong> - HTTP: pull; SMTP: push -HTTP: each object encapsulated in its own response msg; SMTP:<strong>multiple objects sent in multipart msg</strong>.</p><h2 id="mail-message-format">Mail Message Format</h2><figure><img src="The-Application-Layer/Message-Format.png"style="display: block; margin: 0 auto; width: 90%"alt="Message Format" /><figcaption aria-hidden="true">Message Format</figcaption></figure><h2 id="mail-access-protocols">Mail Access Protocols</h2><figure><img src="The-Application-Layer/Mail-Access-Protocol.png"style="display: block; margin: 0 auto; width: 90%"alt="Mail Access Protocol" /><figcaption aria-hidden="true">Mail Access Protocol</figcaption></figure><ul><li>SMTP: <strong>delivery/storage</strong> to receiver’s server;</li><li>Mail Access Protocol: <strong>retrieval</strong> from server.</li></ul><h3 id="pop3-protocol">POP3 Protocol</h3><figure><img src="The-Application-Layer/POP3.png"style="display: block; margin: 0 auto; width: 90%" alt="POP3" /><figcaption aria-hidden="true">POP3</figcaption></figure><p><strong>More about POP3:</strong> Previous example uses “download anddelete” mode. Bob cannot re-read e-mail if he changesclient;<strong>“Download-and-keep”:</strong> copies of messages ondifferent clients; POP3 is stateless across sessions.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>模式</th><th>邮件服务器是否保留邮件</th><th>多终端访问体验</th><th>适用场景</th></tr></thead><tbody><tr><td>download-and-delete</td><td>否</td><td>仅首台设备可见</td><td>单一终端、节省空间</td></tr><tr><td>download-and-keep</td><td>是</td><td>多终端均可访问</td><td>多终端、备份安全</td></tr></tbody></table></div><h3 id="imap">IMAP</h3><ul><li>Keep all messages in one place: <strong>the server</strong>;</li><li>Allows user to <strong>organize</strong> messages in folders;</li><li>IMAP keeps user state across sessions: names of folders and mappingsbetween message IDs and folder name.</li></ul><h1 id="dns-domain-name-system">DNS: Domain Name System</h1><p>组织的 Web 服务器和邮件服务器能否拥有相同的主机别名？对应的 RR类型是什么？</p><p><strong>可以。</strong><br />一个组织的 Web 服务器和邮件服务器完全可以使用同一个主机别名（如<code>foo.com</code>）。这是因为 DNS允许为同一个域名设置不同类型的资源记录（Resource Record, RR），分别指向Web 服务和邮件服务。</p><ul><li>当用户在浏览器中访问 <code>http://foo.com</code> 时，DNS查询的是该域名的 <strong>A 记录</strong>（IPv4 地址）或 <strong>AAAA记录</strong>（IPv6 地址），用于定位 Web 服务器。</li><li>当发送邮件到 <code>user@foo.com</code> 时，邮件系统会查询该域名的<strong>MX 记录</strong>，用于定位邮件服务器。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>记录类型</th><th>作用说明</th></tr></thead><tbody><tr><td>A</td><td>域名到 IPv4 地址（Web 服务器）</td></tr><tr><td>MX</td><td>域名到邮件服务器主机名（邮件服务）</td></tr></tbody></table></div><p><strong>Hostname to IP address translation</strong></p><h2 id="distributed-hierarchical-database">Distributed, HierarchicalDatabase</h2><figure><img src="The-Application-Layer/DNS-Server.png"style="display: block; margin: 0 auto; width: 90%" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h3 id="top-level-domain-tld-servers">Top-Level Domain (TLD)Servers</h3><ul><li>Responsible for com, org, net, edu, etc, and all top-level countrydomains uk, fr, ca, jp;</li><li><strong>Network Solutions(a company)</strong> maintains servers forcom TLD;</li><li><strong>Educause(an institution)</strong> for edu TLD</li></ul><h3 id="authoritative-dns-servers">Authoritative DNS Servers</h3><p>Organization’s DNS servers, providing authoritative <strong>hostnameto IP mappings</strong> for organization’s servers (e.g., Web, mail).Can be maintained by organization or service provider.</p><h3 id="local-name-server">Local Name Server</h3><ul><li>Does not strictly belong to hierarchy;</li><li>Each <strong>ISP</strong> (residential ISP, company, university) hasone;</li><li>When host makes DNS query, query is sent to its local DNSserver.</li></ul><h2 id="dns-name-resolution">DNS Name Resolution</h2><h3 id="iterated-query">Iterated Query</h3><figure><img src="The-Application-Layer/Iterated-Query.png"style="display: block; margin: 0 auto; width: 70%" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h3 id="recursive-query">Recursive Query</h3><figure><img src="The-Application-Layer/Recursive-Query.png"style="display: block; margin: 0 auto; width: 70%" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h2 id="dns-caching-and-updating-records">DNS: Caching and UpdatingRecords</h2><ul><li>Once (any) name server learns mapping, it caches mapping;</li><li>Cache entries timeout (disappear) after some time;</li><li><strong>TLD servers</strong> typically cached in local name servers.Thus root name servers not often visited.</li></ul><h3 id="dns-records">DNS records</h3><p>DNS: distributed db storing <strong>resource records(RR)</strong>.</p><p>RR format: <code>(name, value, type, ttl)</code>.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>Type</strong></th><th><strong>Name</strong></th><th><strong>Value</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>A</strong></td><td>Hostname</td><td>IP address</td><td>Maps hostname to IP address</td></tr><tr><td><strong>NS</strong></td><td>Domain (e.g., <code>foo.com</code>)</td><td>Hostname of authoritative name server</td><td>Specifies authoritative name server for domain</td></tr><tr><td><strong>CNAME</strong></td><td>Alias name</td><td>Canonical name</td><td>Maps alias to canonical (real) name</td></tr><tr><td><strong>MX</strong></td><td>Domain name</td><td>Mail server name</td><td>Specifies mail server associated with domain</td></tr></tbody></table></div><h2 id="dns-protocol-messages">DNS Protocol, Messages</h2><p>DNS protocol : <strong>query</strong> and <strong>reply</strong>messages, both with <strong>same message format</strong>.</p><figure><img src="The-Application-Layer/DNS-message-format.png"style="display: block; margin: 0 auto; width: 90%" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p><strong>Identification:</strong> 16 bit <code>#</code> for query,reply to query uses same <code>#</code>.</p><p><strong>Flags:</strong> - query or reply; - recursion desired; -recursion available; - reply is authoritative.</p><h1 id="p2p-applications">P2P applications</h1><h2 id="pure-p2p-architecture">Pure P2P Architecture</h2><h3 id="file-distribution-server-client-vs-p2p">File Distribution:Server-Client vs P2P</h3><ul><li><span class="math inline">\(u_s\)</span>: server uploadbandwidth;</li><li><span class="math inline">\(u_i\)</span>: peer i uploadbandwidth;</li><li><span class="math inline">\(d_i\)</span>: peer i downloadbandwidth;</li><li><span class="math inline">\(F\)</span>: file size.</li></ul><p><strong>Question: How much time to distribute file from one server to<span class="math inline">\(N\)</span> peers?</strong></p><p><strong>Answer with Client-Server</strong> <spanclass="math display">\[t_{cs} = \max \left \{\frac{NF}{u_s}, \frac{F}{d_i} \right \} \tag{1}\]</span></p><p><strong>Answer with P2P</strong> <span class="math display">\[t_{p2p} = \max \left \{\frac{F}{u_s}, \frac{F}{d_i}, \frac{NF}{u_s +\sum_{i} u_i} \right \} \tag{2}\]</span></p><h3 id="bittorrent">BitTorrent</h3><p>基于 <strong>tit-for-tat</strong>（互惠）策略鼓励节点之间公平交换。每个节点会优先向那些<strong>当前向自己上传速度最快的节点</strong>上传数据块。</p><p>但是，即使 Alice 在 30 秒内持续向 Bob 上传数据块，Bob也<strong>不一定会在同一时间段内回馈 Alice</strong>，原因如下：</p><ol type="1"><li><strong>带宽和资源限制</strong>：Bob可能已经将上传带宽分配给了其他上传速度更快或更优先的 peer。</li><li><strong>块的可用性</strong>：Bob 可能没有 Alice需要的数据块，无法立即回馈。</li><li><strong>策略调整延迟</strong>：BitTorrent的“互惠”是基于一段时间内的统计结果，回馈行为可能会有延迟。</li><li><strong>乐善好施（optimisticunchoking）</strong>：每隔一段时间，客户端会随机选择一个 peer上传数据块，以发现潜在的更优互惠对象，这也可能导致回馈不及时。</li></ol><p>上述 4. 解决了新加入节点启动问题。</p><h3 id="skype">Skype</h3><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>用户查找与登录</td><td>通过 P2P 网络分布式存储和查找用户信息</td></tr><tr><td>媒体数据的传输</td><td>语音、视频、文件等数据优先点对点传输，必要时通过中继节点转发</td></tr></tbody></table></div><h1 id="socket-programming">Socket programming</h1><p><strong>Goal:</strong> learn how to <strong>build Client-Serverapplication</strong> that communicate using sockets.</p><h2 id="definition-of-socket">Definition of Socket</h2><p><strong>An application-created, OS-controlled interface (a “door”)into which application process can both send and receive messagesto/from another application process.</strong></p><h2 id="socket-programming-with-udp">Socket Programming with UDP</h2><figure><img src="The-Application-Layer/Socket-Programming-with-UDP.png"style="display: block; margin: 0 auto; width: 90%" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h3 id="udpclient.java">UDPClient.java</h3><figure><img src="The-Application-Layer/UDPClient-java.png"style="display: block; margin: 0 auto; width: 90%" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h2 id="socket-programming-with-tcp">Socket programming with TCP</h2><figure><img src="The-Application-Layer/Socket-Programming-with-TCP.png"style="display: block; margin: 0 auto; width: 90%" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><figure><img src="The-Application-Layer/Three-kinds-of-Socket.png"style="display: block; margin: 0 auto; width: 90%" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><figure><img src="The-Application-Layer/TCP-Socket.png"style="display: block; margin: 0 auto; width: 90%" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h3 id="tcpclient.java">TCPClient.java</h3><figure><img src="The-Application-Layer/TCPClient-java.png"style="display: block; margin: 0 auto; width: 90%" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1><h2 id="r.1">R.1</h2><p>List five nonproprietary Internet applications and theapplication-layer protocols that they use.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align: center;"><strong>Type</strong></th><th style="text-align: center;"><strong>Protocol(s)</strong></th></tr></thead><tbody><tr><td style="text-align: center;">Email</td><td style="text-align: center;">SMTP, IMAP, POP3</td></tr><tr><td style="text-align: center;">Web Browser</td><td style="text-align: center;">HTTP</td></tr><tr><td style="text-align: center;">File Transfer</td><td style="text-align: center;">FTP</td></tr><tr><td style="text-align: center;">Domain Name Resolution</td><td style="text-align: center;">DNS</td></tr><tr><td style="text-align: center;">Remote Terminal Access</td><td style="text-align: center;">SSH, Telnet</td></tr></tbody></table></div><h2 id="r.2">R.2</h2><p>What is the difference between network architecture and applicationarchitecture?（不太理解这里的 network architecture，默认和 applicationarchitecture 一样，都指的是在一个 OSI layer）</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>Aspect</strong></th><th><strong>Network Architecture</strong></th><th><strong>Application Architecture</strong></th></tr></thead><tbody><tr><td><strong>Definition</strong></td><td>Describes the organization of network layers and components for datatransmission.</td><td>Describes how application components interact to achieve specificfunctionalities.</td></tr><tr><td><strong>Focus</strong></td><td>Focuses on data transmission methods, routing, switching, andprotocol stacks.</td><td>Focuses on the logical structure and communication patterns ofapplications.</td></tr><tr><td><strong>Scope</strong></td><td>Concerned with the entire network, including physical, data link,and network layers.</td><td>Concerned with the application layer and its communication betweenprocesses.</td></tr><tr><td><strong>Examples</strong></td><td>Virtual circuit networks, datagram networks.</td><td>Client-server model, P2P model (e.g., Skype, HTTP).</td></tr></tbody></table></div><h2 id="r.6">R.6</h2><p>Suppose you wanted to do a transaction from a remote client to aserver as fast as possible. Would you use UDP or TCP? Why?</p><ul><li>对于<strong>简单、小型且允许失败的事务</strong>（如状态查询、监控数据上报），可以选择<strong>UDP</strong></li><li>对于<strong>大多数商业事务</strong>（如金融交易、数据库操作），应选择<strong>TCP</strong>，因为：<ul><li>事务的<strong>完整性和正确性</strong>通常比速度更重要</li><li>TCP的<strong>可靠性保障</strong>减少了应用层的复杂度</li><li>虽然TCP建立连接有开销，但对于事务的整体成功率和效率更有保障</li><li>在现代网络环境中，<strong>TCP连接建立的时延</strong>相对事务处理总时间通常可以接受</li></ul></li><li>但题目要求 <strong>as fast as possible</strong>，所以还是用<strong>UDP</strong>。</li></ul><h2 id="r.17">R.17</h2><p>Print out the header of an e-mail message you have recently received.How many <code>Received:</code> header lines are there? Analyze each ofthe header lines in the message.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Received: from codeforces.com (mx2.codeforces.com [77.234.215.195])<br>        by newxmmxszgpub6-1.qq.com (NewMX) with SMTP id BF70781A<br>        for &lt;1xx575xxxx@qq.com&gt;; Sat, 17 May 2025 00:47:55 +0800<br>Received: from localhost (gauss.codeforces.com [192.168.10.103])<br>        by codeforces.com (Postfix) with ESMTP id D7D9F322729C1<br>        for &lt;1xx575xxxx@qq.com&gt;; Fri, 16 May 2025 18:48:56 +0300 (MSK)<br>From: &quot;Codeforces@codeforces.com&quot; &lt;Codeforces@codeforces.com&gt;<br>To: &quot;1xx575xxxx@qq.com&quot; &lt;1xx575xxxx@qq.com&gt;<br>Subject: Codeforces Round 1025 (Div. 2)<br></code></pre></td></tr></table></figure><p>There are <span class="math inline">\(2\)</span><code>Received:</code> header lines.</p><p>The first part is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Received: from codeforces.com (mx2.codeforces.com [77.234.215.195])<br>        by newxmmxszgpub6-1.qq.com (NewMX) with SMTP id BF70781A<br>        for &lt;1xx575xxxx@qq.com&gt;; Sat, 17 May 2025 00:47:55 +0800<br></code></pre></td></tr></table></figure><ul><li><code>Received: from codeforces.com (mx2.codeforces.com [77.234.215.195])</code>:The email was sent from the Codeforces mail server with public IP.</li><li><code>by newxmmxszgpub6-1.qq.com (NewMX)</code>: Received by QQMail’s mail server.</li><li>Using <strong>SMTP</strong> protocol, <code>Date\Time</code>:<code>Sat, 17 May 2025 00:47:55 +0800</code>.</li><li>其中的 <code>mx2</code> 指的是 <strong>Mail eXchanger 2</strong>，即codeforces 的第二台邮件交换 server。</li></ul><p>The second part is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Received: from localhost (gauss.codeforces.com [192.168.10.103])<br>        by codeforces.com (Postfix) with ESMTP id D7D9F322729C1<br>        for &lt;1xx575xxxx@qq.com&gt;; Fri, 16 May 2025 18:48:56 +0300 (MSK)<br></code></pre></td></tr></table></figure><ul><li><code>Received: from localhost (gauss.codeforces.com [192.168.10.103])</code>:The email originated from the local server named<code>gauss.codeforces.com</code> (internal IP).</li><li><code>by codeforces.com (Postfix)</code>: Received by the mainCodeforces mail server using Postfix.</li><li>Using <strong>ESMTP</strong> protocol.</li></ul><ol type="1"><li><p><strong>邮件头传输顺序说明</strong>：邮件头按照邮件传输的<strong>相反顺序</strong>排列（最新的记录在最上面）。因此第二个<code>Received</code>行实际上是邮件传输的<strong>起始点</strong>，第一个是<strong>最后一跳</strong>。</p></li><li><p><strong>时区分析</strong>：注意到两个头部行的时间戳不同:</p><ul><li>第一个记录:<code>Sat, 17 May 2025 00:47:55 +0800</code>(中国时区)</li><li>第二个记录:<code>Fri, 16 May 2025 18:48:56 +0300</code>(莫斯科时区MSK)这说明邮件确实是从俄罗斯发往中国的，时间差符合时区差异。</li></ul></li><li><p><strong>ESMTP vsSMTP的区别</strong>：第二个头部使用ESMTP(扩展SMTP)而不是普通SMTP，这表明使用了更多高级功能(如身份验证、加密等)。</p></li></ol><h2 id="r.22">R.22</h2><p>What is an overlay network? Does it include routers? What are theedges in the overlay network? How is the query-flooding overlay networkcreated and maintained?</p><p>An <strong>overlay network</strong> is a virtual network built on topof an existing physical network. It consists of logical connections (or“edges”) between nodes, which are typically end systems or hosts. Theselogical connections are established using the underlying physicalnetwork infrastructure.</p><ul><li><p><strong>Does it include routers?</strong><br />No, an overlay network does not include physical routers. Instead, thenodes in the overlay network are typically end systems (e.g., computers,servers) that communicate directly with each other using logical links.The physical routers are part of the underlying network and are notexplicitly represented in the overlay.</p></li><li><p><strong>What are the edges in the overlay network?</strong><br />The edges in an overlay network are logical connections between nodes.These connections are established using the underlying physical networkbut are abstracted away from the physical topology. For example, in apeer-to-peer (P2P) network, the edges represent direct communicationpaths between peers.</p></li><li><p><strong>How is the query-flooding overlay network created andmaintained?</strong><br />A query-flooding overlay network is created by connecting nodes in alogical topology where each node knows a subset of other nodes (itsneighbors). When a query is initiated, it is broadcasted (or “flooded”)to all neighboring nodes, which in turn forward the query to theirneighbors, and so on.<br />Maintenance of the overlay involves:</p><ol type="1"><li><strong>Node discovery:</strong> New nodes join the network bydiscovering existing nodes and establishing connections.</li><li><strong>Topology updates:</strong> Nodes periodically update theirneighbor lists to reflect changes in the network (e.g., nodes joining orleaving).</li><li><strong>Failure handling:</strong> Mechanisms are implemented todetect and recover from node or connection failures to ensure theoverlay remains functional.</li></ol></li></ul><h2 id="r.28">R.28</h2><p>For the client-server application over TCP described in Section <spanclass="math inline">\(2.7\)</span>, why must the server program beexecuted before the client program? For the clientserver applicationover UDP described in Section <span class="math inline">\(2.8\)</span>,why may the client program be executed before the server program?</p><ul><li><strong>For the TCP client-server application (Section <spanclass="math inline">\(2.7\)</span>):</strong> The server program must beexecuted before the client because the server needs to create a socket,bind it to a port, and listen for incoming connections. If the clientstarts first, it will try to connect to the server’s port, but if theserver isn’t running and listening yet, the connection will fail.</li><li><strong>For the UDP client-server application (Section <spanclass="math inline">\(2.8\)</span>):</strong> The client program may beexecuted before the server because UDP is connectionless. The client cansend a datagram to the server’s address and port even if the serverisn’t running yet; the datagram may be lost, but the client doesn’t needto establish a connection first. When the server starts, it canimmediately receive any new datagrams sent to its port.</li></ul><h2 id="p.4">P.4</h2><p>Consider the following string of ASCII characters that were capturedby Wireshark when the browser sent an HTTP <code>GET</code> message(i.e., this is the actual content of an HTTP <code>GET</code> message).The characters <code>&lt;cr&gt;&lt;lf&gt;</code> are carriage return andline-feed characters (that is, the italized character string<code>&lt;cr&gt;</code> in the text below represents the singlecarriage-return character that was contained at that point in the HTTPheader). Answer the following questions, indicating where in the HTTPGET message below you find the answer.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">GET /cs453/index.html HTTP/1.1&lt;cr&gt;&lt;lf&gt;Host: gai<br>a.cs.umass.edu&lt;cr&gt;&lt;lf&gt;User-Agent: Mozilla/5.0 (<br>Windows;U; Windows NT 5.1; en-US; rv:1.7.2) Gec<br>ko/20040804 Netscape/7.2 (ax) &lt;cr&gt;&lt;lf&gt;Accept:ex<br>t/xml, application/xml, application/xhtml+xml, text<br>/html;q=0.9, text/plain;q=0.8,image/png,*/*;q=0.5<br>&lt;cr&gt;&lt;lf&gt;Accept-Language: en-us,en;q=0.5&lt;cr&gt;&lt;lf&gt;Accept-<br>Encoding: zip,deflate&lt;cr&gt;&lt;lf&gt;Accept-Charset: ISO<br>-8859-1,utf-8;q=0.7,*;q=0.7&lt;cr&gt;&lt;lf&gt;Keep-Alive: 300&lt;cr&gt;<br>&lt;lf&gt;Connection:keep-alive&lt;cr&gt;&lt;lf&gt;&lt;cr&gt;&lt;lf&gt;<br></code></pre></td></tr></table></figure><p><strong>Questions:</strong></p><ol type="a"><li>What is the URL of the document requested by the browser?</li><li>What version of HTTP is the browser running?</li><li>Does the browser request a non-persistent or a persistentconnection?</li><li>What is the IP address of the host on which the browser isrunning?</li><li>What type of browser initiates this message? Why is the browser typeneeded in an HTTP request message?</li></ol><p><strong>Answers:</strong></p><p><strong>a. What is the URL of the document requested by thebrowser?</strong> -<code>http://gaia.cs.umass.edu/cs453/index.html</code>.</p><p><strong>b. What version of HTTP is the browser running?</strong> -<code>HTTP/1.1</code></p><p><strong>c. Does the browser request a non-persistent or a persistentconnection?</strong> - <code>Connection:keep-alive</code>: a persistentconnection.</p><p><strong>d. What is the IP address of the host on which the browser isrunning?</strong> - The IP address of the host is not explicitlyprovided in the HTTP GET message. It would typically be determined byexamining the network layer (IP) headers in the packet capture, whichare not included in the provided data.</p><p><strong>e. What type of browser initiates this message? Why is thebrowser type needed in an HTTP request message?</strong><br />- The browser type is<code>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.2) Gecko/20040804 Netscape/7.2 (ax)</code>.<br />- The browser type is included in the <code>User-Agent</code> header. Itis needed in an HTTP request message to allow the server to tailor itsresponse based on the browser’s capabilities, such as supportedfeatures, rendering engine, or platform-specific optimizations.</p><h2 id="p.5">P.5</h2><p>The text below shows the reply sent from the server in response tothe HTTP <code>GET</code> message in the question above. Answer thefollowing questions, indicating where in the message below you find theanswer.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">HTTP/1.1 200 OK&lt;cr&gt;&lt;lf&gt;Date: Tue, 07 Mar 2008<br>12:39:45GMT&lt;cr&gt;&lt;lf&gt;Server: Apache/2.0.52 (Fedora)<br>&lt;cr&gt;&lt;lf&gt;Last-Modified: Sat, 10 Dec2005 18:27:46<br>GMT&lt;cr&gt;&lt;lf&gt;ETag: &quot;526c3-f22-a88a4c80&quot;&lt;cr&gt;&lt;lf&gt;Accept-<br>Ranges: bytes&lt;cr&gt;&lt;lf&gt;Content-Length: 3874&lt;cr&gt;&lt;lf&gt;<br>Keep-Alive: timeout=max=100&lt;cr&gt;&lt;lf&gt;Connection:<br>Keep-Alive&lt;cr&gt;&lt;lf&gt;Content-Type: text/html; charset=<br>ISO-8859-1&lt;cr&gt;&lt;lf&gt;&lt;cr&gt;&lt;lf&gt;&lt;!doctype html public &quot;-<br>//w3c//dtd html 4.0 transitional//en&quot;&gt;&lt;lf&gt;&lt;html&gt;&lt;lf&gt;<br>&lt;head&gt;&lt;lf&gt; &lt;meta http-equiv=&quot;Content-Type&quot;<br>content=&quot;text/html; charset=iso-8859-1&quot;&gt;&lt;lf&gt; &lt;meta<br>name=&quot;GENERATOR&quot; content=&quot;Mozilla/4.79 [en] (Windows NT<br>5.0; U) Netscape&quot;&gt;&lt;lf&gt; &lt;title&gt;CMPSCI 453 / 591 /<br>NTU-ST550A Spring 2005 homepage&lt;/title&gt;&lt;lf&gt;&lt;/head&gt;&lt;lf&gt;<br>&lt;much more document text following here (not shown)&gt;<br></code></pre></td></tr></table></figure><p><strong>Questions and Answers:</strong></p><p><strong>a. Was the server able to successfully find the document ornot? What time was the document reply provided?</strong> -<code>200 OK</code>: successfully find the document;<code>Tue, 07 Mar2008 12:39:45</code></p><p><strong>b. When was the document last modified?</strong> -<code>Last-Modified: Sat, 10 Dec2005 18:27:46</code></p><p><strong>c. How many bytes are there in the document beingreturned?</strong> -<code>Ranges: bytes&lt;cr&gt;&lt;lf&gt;Content-Length: 3874</code>:<span class="math inline">\(3874\)</span> bytes.</p><p><strong>d. What are the first 5 bytes of the document being returned?Did the server agree to a persistent connection?</strong></p><ul><li><strong>First 5 bytes of the document:</strong><code>&lt;!doc</code> (from the document content starting with<code>&lt;!doctype html public...</code>). 所选的 HTTP 报文内容声明了<code>Content-Type: text/html; charset=ISO-8859-1</code>，该编码是单字节编码（每个字符1 字节）</li><li><strong>Persistent connection:</strong> Yes, the server agreed to apersistent connection as indicated by the header<code>Connection: Keep-Alive</code>.</li></ul><h2 id="p.9">P.9</h2><p>Consider Figure <span class="math inline">\(2.12\)</span>, for whichthere is an institutional network connected to the Internet. Supposethat the average object size is <spanclass="math inline">\(850,000\)</span> bits and that the average requestrate from the institution’s browsers to the origin servers is <spanclass="math inline">\(16\)</span> requests per second. Also suppose thatthe amount of time it takes from when the router on the Internet side ofthe access link forwards an HTTP request until it receives the responseis <span class="math inline">\(3\)</span> seconds on average (see <spanclass="math inline">\(\text{Section}\)</span> <spanclass="math inline">\(2.2.5\)</span>). <strong>Model the total averageresponse time as the sum of the average access delay (that is, the delayfrom Internet router to institution router) and the average Internetdelay</strong>. For the average access delay, use <spanclass="math inline">\(\Delta / (1 - \Delta \beta)\)</span>, where <spanclass="math inline">\(\Delta\)</span> is the average time required tosend an object over the access link and <spanclass="math inline">\(\beta\)</span> is the arrival rate of objects tothe access link.</p><p><strong>Complement:</strong> <span class="math inline">\(15\)</span>Mbps access link and <span class="math inline">\(100\)</span> MbpsLAN.</p><figure><imgsrc="The-Application-Layer/Bottleneck%20between%20an%20institutional%20network%20and%20the%20Internet.png"style="display: block; margin: 0 auto; width: 90%"alt="Bottleneck between an institutional network and the Internet" /><figcaption aria-hidden="true">Bottleneck between an institutionalnetwork and the Internet</figcaption></figure><p><strong>Questions and Answers:</strong></p><p><strong>a. Find the total average response time.</strong></p><p>The total average response time is the sum of the <strong>averageaccess delay</strong> and the <strong>average Internetdelay</strong>.</p><ol type="1"><li><p><strong>Given data:</strong></p><ul><li>Average object size: <span class="math inline">\(L =850,000\)</span> bits</li><li>Access link rate: <span class="math inline">\(R = 15\)</span>Mbps</li><li>Request rate: <span class="math inline">\(\beta = 16\)</span>requests/second</li><li>Average Internet delay: <span class="math inline">\(3\)</span>seconds</li></ul></li><li><p><strong>Calculate <spanclass="math inline">\(\Delta\)</span>:</strong> <spanclass="math display">\[\Delta = \frac{L}{R} = \frac{850,000}{15 \times 10^6} = 0.0567 \,\text{seconds}\]</span></p></li><li><p><strong>Calculate average access delay:</strong> <spanclass="math display">\[\text{Access delay} = \frac{\Delta}{1 - \Delta \beta} = \frac{0.0567}{1- (0.0567 \times 16)} = \frac{0.0567}{1 - 0.9072} =\frac{0.0567}{0.0928} \approx 0.611 \, \text{seconds}\]</span></p></li><li><p><strong>Total average response time:</strong> <spanclass="math display">\[\text{Total response time} = \text{Access delay} + \text{Internet delay}= 0.611 + 3 = 3.611 \, \text{seconds}\]</span></p></li></ol><p><strong>b. Now suppose a cache is installed in the institutional LAN.Suppose the miss rate is <span class="math inline">\(0.4\)</span>. Findthe total response time.</strong></p><ol type="1"><li><strong>Given data:</strong><ul><li>Miss rate: <span class="math inline">\(0.4\)</span></li><li>Hit rate: <span class="math inline">\(1 - 0.4 = 0.6\)</span></li><li>Access delay (from part a): <spanclass="math inline">\(0.611\)</span> seconds</li><li>Internet delay: <span class="math inline">\(3\)</span> seconds</li></ul></li><li><strong>Calculate total response time with caching:</strong> <spanclass="math display">\[\text{Total response time} = (\text{Hit rate} \times \text{Accessdelay}) + (\text{Miss rate} \times (\text{Access delay} + \text{Internetdelay}))\]</span> Substituting values: <span class="math display">\[\text{Total response time} = 0.6 \times \frac{850000}{100 \times 10^6} +0.4 \times (0.611 + 3)\]</span> <span class="math display">\[\text{Total response time} = 0.0051 + 0.4 \times 3.611 = 1.4495 \,\text{s}\]</span></li></ol><h2 id="p.15">P.15</h2><p><strong>Question:</strong></p><p>Read RFC <span class="math inline">\(5321\)</span> for SMTP. Whatdoes MTA stand for? Consider the following received spam email (modifiedfrom a real spam email). Assuming only the originator of this spam emailis malacious and all other hosts are honest, identify the malacious hostthat has generated this spam email.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">From - Fri Nov 07 13:41:30 2008<br>Return-Path: &lt;tennis5@pp33head.com&gt;<br>Received: from barmail.cs.umass.edu<br>(barmail.cs.umass.edu [128.119.240.3]) by cs.umass.edu<br>(8.13.1/8.12.6) for &lt;hg@cs.umass.edu&gt;; Fri, 7 Nov 2008<br>13:27:10 -0500<br>Received: from asusus-4b96 (localhost [127.0.0.1]) by<br>barmail.cs.umass.edu (Spam Firewall) for<br>&lt;hg@cs.umass.edu&gt;; Fri, 7 Nov 2008 13:27:07 -0500<br>(EST)<br>Received: from asusus-4b96 ([58.88.21.177]) by<br>barmail.cs.umass.edu for &lt;hg@cs.umass.edu&gt;; Fri,<br>07 Nov 2008 13:27:07 -0500 (EST)<br>Received: from [58.88.21.177] by<br>inbnd55.exchangeddd.com; Sat, 8 Nov 2008 01:27:07 +0700<br>From: &quot;Jonny&quot; &lt;tennis5@pp33head.com&gt;<br>To: &lt;hg@cs.umass.edu&gt;<br>Subject: How to secure your savings<br></code></pre></td></tr></table></figure><p><strong>Answer:</strong></p><p><strong>最底部的 <code>Received:</code>记录代表邮件的最初来源</strong>，即发件人最初连接的主机。</p><ul><li><p><strong>What does MTA stand for?</strong><br />MTA stands for <strong>Mail Transfer Agent</strong>. It is a softwareapplication used to transfer email messages from one server to anotherusing protocols such as SMTP.</p></li><li><p><strong>Identify the malicious host:</strong><br />To identify the malicious host, we analyze the <code>Received</code>headers in reverse order (from bottom to top), as each<code>Received</code> header represents a hop in the email’sjourney.</p><ol type="1"><li><strong><code>Received: from [58.88.21.177] by inbnd55.exchangeddd.com</code></strong><ul><li>This indicates that the email originated from the IP address<code>58.88.21.177</code>.</li></ul></li><li><strong><code>Received: from asusus-4b96 ([58.88.21.177]) by barmail.cs.umass.edu</code></strong><ul><li>This confirms that the email was sent from the same IP address<code>58.88.21.177</code>.</li></ul></li><li><strong><code>Received: from asusus-4b96 (localhost [127.0.0.1]) by barmail.cs.umass.edu</code></strong><ul><li>This shows that the email passed through a local host(<code>127.0.0.1</code>) on the <code>barmail.cs.umass.edu</code>server.</li></ul></li><li><strong><code>Received: from barmail.cs.umass.edu (barmail.cs.umass.edu [128.119.240.3]) by cs.umass.edu</code></strong><ul><li>This indicates that the email was forwarded by<code>barmail.cs.umass.edu</code> to <code>cs.umass.edu</code>.</li></ul></li></ol><p>Based on the analysis, the <strong>malicious host</strong> is theoriginator of the email, which is the IP address<strong><code>58.88.21.177</code></strong>. This is the source of thespam email.</p></li></ul><h2 id="p.18">P.18</h2><p><strong>Questions and Answers:</strong></p><p><strong>a. What is a whois database?</strong></p><p>A <strong>whois database</strong> is a publicly accessible databasethat contains information about the registered owners of domain namesand IP address blocks. It is maintained by domain registrars andregional internet registries (RIRs). The database provides details suchas:</p><ul><li>The name and contact information of the domain owner ororganization.</li><li>The domain’s registration and expiration dates.</li><li>The domain’s associated name servers.</li><li>The registrar responsible for the domain.</li></ul><p>The <strong>whois database</strong> is commonly used foradministrative purposes, such as verifying domain ownership, resolvingtechnical issues, or investigating malicious activities.</p><p><strong>b. Use various whois databases on the Internet to obtain thenames of two DNS servers. Indicate which whois databases youused.</strong></p><p>DNS server 的名字，通常指的是域名形式的主机名。</p><p>通过在 <a href="https://lookup.icann.org/">ICANN Lookup</a> 查询<code>BiliBili.com</code> 得到其 Nameservers -<code>NS3.DNSV5.COM</code> - <code>NS4.DNSV5.COM</code></p><p>通过在 <a href="https://whois.domaintools.com/">DomainTools</a> 查询<code>Baidu.com</code> 得到其 Nameservers -<code>NS1.BAIDU.COM (has 805 domains)</code> -<code>NS2.BAIDU.COM (has 805 domains)</code> -<code>NS3.BAIDU.COM (has 805 domains)</code> -<code>NS4.BAIDU.COM (has 805 domains)</code> -<code>NS7.BAIDU.COM (has 805 domains)</code></p><p><strong>c. Use nslookup on your local host to send DNS queries tothree DNS servers: your local DNS server and the two DNS servers youfound in part (b). Try querying for Type A, NS, and MX reports.Summarize your findings.</strong></p><p>我在终端输入的语句及其显示结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">(base) PS C:\Users\17657\Desktop\Github\HEXO&gt; nslookup<br>默认服务器:  UnKnown<br>Address:  10.3.9.5<br><br>&gt; set type=A<br>&gt; www.baidu.com<br>服务器:  UnKnown<br>Address:  10.3.9.5<br><br>非权威应答:<br>名称:    www.a.shifen.com<br>Addresses:  220.181.111.232<br>          220.181.111.1<br>Aliases:  www.baidu.com<br><br>&gt; set type=NS<br>&gt; baidu.com<br>服务器:  UnKnown<br>Address:  10.3.9.5<br><br>非权威应答:<br>baidu.com       nameserver = ns2.baidu.com<br>baidu.com       nameserver = ns7.baidu.com<br>baidu.com       nameserver = ns3.baidu.com<br>baidu.com       nameserver = dns.baidu.com<br>baidu.com       nameserver = ns4.baidu.com<br><br>ns2.baidu.com   internet address = 220.181.33.31<br>ns7.baidu.com   internet address = 180.76.76.92<br>dns.baidu.com   internet address = 110.242.68.134<br>ns3.baidu.com   internet address = 36.155.132.78<br>ns3.baidu.com   internet address = 153.3.238.93<br>ns4.baidu.com   internet address = 14.215.178.80<br>ns4.baidu.com   internet address = 111.45.3.226<br>&gt; set type=MX<br>&gt; baidu.com<br>服务器:  UnKnown<br>Address:  10.3.9.5<br><br>非权威应答:<br>baidu.com       MX preference = 20, mail exchanger = mx.baidu.com<br>baidu.com       MX preference = 10, mail exchanger = mx.maillb.baidu.com<br>&gt; server ns1.baidu.com<br>默认服务器:  ns1.baidu.com<br>Address:  110.242.68.134<br><br>&gt; set type=A<br>&gt; www.baidu.com<br>服务器:  ns1.baidu.com<br>Address:  110.242.68.134<br><br>非权威应答:<br>名称:    www.a.shifen.com<br>Addresses:  220.181.111.1<br>          220.181.111.232<br>Aliases:  www.baidu.com<br><br>&gt; set type=NS<br>&gt; baidu.com<br>服务器:  ns1.baidu.com<br>Address:  110.242.68.134<br><br>非权威应答:<br>baidu.com       nameserver = dns.baidu.com<br>baidu.com       nameserver = ns3.baidu.com<br>baidu.com       nameserver = ns4.baidu.com<br>baidu.com       nameserver = ns2.baidu.com<br>baidu.com       nameserver = ns7.baidu.com<br><br>ns7.baidu.com   internet address = 180.76.76.92<br>ns4.baidu.com   internet address = 14.215.178.80<br>ns4.baidu.com   internet address = 111.45.3.226<br>ns2.baidu.com   internet address = 220.181.33.31<br>ns3.baidu.com   internet address = 36.155.132.78<br>ns3.baidu.com   internet address = 153.3.238.93<br>dns.baidu.com   internet address = 110.242.68.134<br>&gt; set type=MX<br>&gt; baidu.com<br>服务器:  ns1.baidu.com<br>Address:  110.242.68.134<br><br>非权威应答:<br>baidu.com       MX preference = 20, mail exchanger = mx.baidu.com<br>baidu.com       MX preference = 10, mail exchanger = mx.maillb.baidu.com<br>&gt; server ns3.dnsv5.com<br>默认服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>&gt; set type=A<br>&gt; baidu.com<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    baidu.com<br>Addresses:  182.61.201.211<br>          182.61.244.181<br><br>&gt; set type=NS<br>&gt; baidu.com<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>baidu.com       nameserver = ns4.baidu.com<br>baidu.com       nameserver = ns7.baidu.com<br>baidu.com       nameserver = ns2.baidu.com<br>baidu.com       nameserver = ns3.baidu.com<br>baidu.com       nameserver = dns.baidu.com<br><br>ns7.baidu.com   internet address = 180.76.76.92<br>ns4.baidu.com   internet address = 14.215.178.80<br>ns4.baidu.com   internet address = 111.45.3.226<br>ns2.baidu.com   internet address = 220.181.33.31<br>ns3.baidu.com   internet address = 36.155.132.78<br>ns3.baidu.com   internet address = 153.3.238.93<br>dns.baidu.com   internet address = 110.242.68.134<br>&gt; set type=MX<br>&gt; baidu.com<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>baidu.com       MX preference = 10, mail exchanger = mx.maillb.baidu.com<br>baidu.com       MX preference = 20, mail exchanger = mx.baidu.com<br></code></pre></td></tr></table></figure><p>总结： - <code>www.baidu.com</code> 和 <code>baidu.com</code>不是同一个东西。具体来说后者涵盖范围更广。 - 一个 Nameserver 能有多个Internet address。 - <code>type=A</code> 模式返回的是域名的 IPv4 地址。- <code>type=NS</code> 模式返回的是 Nameserver 的名字和其 internetaddress。 - <code>type=MS</code>模式返回的是该域名的邮件服务器主机名及优先级。</p><p><strong>d. Use nslookup to find a Web server that has multiple IPaddresses. Does the Web server of your institution (school or company)have multiple IP addresses?</strong></p><p>查询 <code>www.bilibili.com</code> 得到结果如下，其有两个 IPaddress。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>&gt; set type=A <br>&gt; www.bilibili.com<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    a.w.bilicdn1.com<br>Addresses:  121.194.11.73<br>          121.194.11.72<br>Aliases:  www.bilibili.com<br><br></code></pre></td></tr></table></figure><p>貌似我们学校的 web server 只有一个 IP Address</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>&gt; ucloud.bupt.edu.cn<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    vn.bupt.edu.cn<br>Address:  10.3.19.2<br>Aliases:  ucloud.bupt.edu.cn<br><br>&gt; auth.bupt.edu.cn<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    vn.bupt.edu.cn<br>Address:  10.3.19.2<br>Aliases:  auth.bupt.edu.cn<br><br>&gt; www.bupt.edu.cn<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    vn46.bupt.edu.cn<br>Address:  10.3.19.2<br>Aliases:  www.bupt.edu.cn<br></code></pre></td></tr></table></figure><p><strong>e. Use the ARIN whois database to determine the IP addressrange used by your university.</strong></p><p>操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>nslookup www.bupt.edu.cn<br>服务器:  UnKnown<br>Address:  10.3.9.5<br><br>非权威应答:<br>名称:    vn46.bupt.edu.cn<br>Addresses:  2001:da8:215:4038::161<br>          10.3.19.2<br>Aliases:  www.bupt.edu.cn<br><br></code></pre></td></tr></table></figure><p>这里的 IPv4 地址是子网地址吧？我在 rain上查询查到了一个美国机构，而且网页也提醒我了 <strong>These addresses arein use by many millions of independently operated networks, which mightbe as small as a single computer connected to a home gateway, and areautomatically configured in hundreds of millions of devices.</strong>所以我用的是 IPv6 的地址，这个地址能查到，显示：Net Range<code>2001:da8:: - 2001:da8:ffff:ffff:ffff:ffff:ffff:ffff</code>。</p><p><strong>f. Describe how an attacker can use whois databases and thenslookup tool to perform reconnaissance on an institution beforelaunching an attack.</strong></p><p>An attacker 可以用 whois 和 nslookup 干如下的事情：</p><ul><li><strong>whois 数据库</strong>：公开的域名/IP注册信息数据库，可查询域名所有者、联系方式、DNS 服务器、IP地址段等信息。</li><li><strong>nslookup 工具</strong>：DNS查询工具，可用来获取域名解析记录（如 A、NS、MX、CNAME等），进一步了解目标机构的网络结构和服务部署。</li></ul><p>从而可以：</p><ul><li>查询目标机构的域名，获取注册人、联系方式、注册商、DNS 服务器、IP地址段等信息。</li><li>通过 whois 查询 IP 地址，了解目标机构的公网 IP范围、网络归属、可能的子网划分。</li><li>利用这些信息，攻击者可以锁定攻击目标、寻找潜在的弱点（如联系邮箱、技术负责人等）。</li><li>查询目标机构域名的 A 记录，获取 Web 服务器等主机的 IP 地址。</li><li>查询 NS 记录，了解目标机构使用的权威 DNS 服务器，判断是否存在 DNS攻击面。</li><li>查询 MX记录，获取邮件服务器信息，可能用于钓鱼邮件、垃圾邮件攻击。</li><li>查询 CNAME、TXT等记录，发现隐藏的服务、第三方集成、邮件安全策略等。</li><li>通过对不同子域名的批量查询，发现更多内部服务和主机。</li></ul><p>进而：</p><ul><li>绘制目标机构的网络拓扑和服务分布图。</li><li>寻找潜在的攻击入口（如暴露的服务器、邮件系统、DNS 服务等）。</li><li>为后续的漏洞扫描、社工攻击、钓鱼邮件等攻击手段做准备。</li></ul><p><strong>g. Discuss why whois databases should be publiclyavailable.</strong></p><p>whois数据库作为互联网基础设施的重要组成部分，其公开可用性具有多方面的价值与意义：</p><ol type="1"><li><strong>互联网透明度与问责制</strong><ul><li>提供域名和IP地址资源的<strong>所有权透明度</strong>，确保资源分配可追溯</li><li>建立互联网资源使用的<strong>公开记录</strong>，减少匿名滥用可能性</li><li>符合互联网作为<strong>公共资源</strong>的基本属性，保障公众知情权</li></ul></li><li><strong>技术协调与故障排除</strong><ul><li>网络管理员能迅速找到<strong>技术联系人</strong>解决网络问题</li><li>跨组织网络协作时提供必要的<strong>联络信息</strong></li><li>在安全事件、网络中断等紧急情况下提供<strong>快速响应渠道</strong></li></ul></li><li><strong>法律与知识产权保护</strong><ul><li>协助<strong>商标持有者</strong>保护其在线知识产权</li><li>为<strong>域名争议解决</strong>提供必要的所有权信息</li><li>帮助执法机构<strong>打击网络犯罪</strong>和识别不法行为</li></ul></li><li><strong>历史与文化因素</strong><ul><li>符合互联网早期建立的<strong>开放共享精神</strong></li><li>继承了学术网络环境下的<strong>信任与协作文化</strong></li><li>反映了互联网治理中的<strong>多方参与模式</strong></li></ul></li><li><strong>安全与风险的平衡</strong><ul><li>虽然公开信息存在被滥用的风险，但<strong>安全通过隐蔽</strong>不是可持续策略</li><li>现代whois服务已引入<strong>数据隐私保护机制</strong>（如代理注册服务）</li><li>信息公开带来的<strong>集体安全收益</strong>通常超过个体风险</li></ul></li></ol><p>总之，whois数据库的公开可用反映了互联网基于<strong>透明、协作和问责</strong>的核心价值观，在保护隐私和维护网络健康运行之间寻求平衡。尽管存在被攻击者利用的风险，但其对互联网正常运行、问题排除和资源管理的价值仍然超过潜在风险。</p><h2 id="p.20">P.20</h2><p><strong>Question and Answer:</strong> Suppose you can access thecaches in the local DNS servers of your department. Can you propose away to roughly determine the Web servers (outside your department) thatare most popular among the users in your department? Explain.</p><p>To determine the most popular external Web servers among the users inmy department, I would propose the following method:</p><ol type="1"><li><strong>Access the local DNS server’s cache:</strong><ul><li>The local DNS server maintains a cache of recently resolved domainnames and their corresponding IP addresses.</li><li>By accessing this cache, I can retrieve a list of domain names thatusers in my department have recently accessed.</li></ul></li><li><strong>Filter out internal domain names:</strong><ul><li>Remove any domain names that belong to the local department ororganization.</li></ul></li><li><strong>Count the frequency of external domain names:</strong><ul><li>For each external domain name in the cache, count how many times itappears.</li><li>This will give an estimate of how frequently users in the departmentaccess each external Web server.</li></ul></li><li><strong>Identify the most popular Web servers:</strong><ul><li>Sort the external domain names by their access frequency.</li><li>The domain names with the highest counts represent the most popularexternal Web servers among the users in the department.</li></ul></li></ol><p><strong>Explanation:</strong> This method works because the local DNSserver’s cache reflects the browsing behavior of users in thedepartment. By analyzing the cache, we can infer which external Webservers are most frequently accessed. However, this method haslimitations, as it only provides a rough estimate and may not accountfor caching mechanisms in user devices or browsers.</p><h2 id="p.22">P.22</h2><p><strong>Question:</strong></p><p>Consider distributing a file of <span class="math inline">\(F =15\)</span> Gbits to <span class="math inline">\(N\)</span> peers. Theserver has an upload rate of <span class="math inline">\(u_s =30\)</span> Mbps, and each peer has a download rate of <spanclass="math inline">\(d_i = 2\)</span> Mbps and an upload rate of <spanclass="math inline">\(u\)</span>. For <span class="math inline">\(N =10\)</span>, <span class="math inline">\(100\)</span>, and <spanclass="math inline">\(1,000\)</span> and <span class="math inline">\(u =300\)</span> Kbps, <span class="math inline">\(700\)</span> Kbps, and<span class="math inline">\(2\)</span> Mbps, prepare a chart giving theminimum distribution time for each of the combinations of <spanclass="math inline">\(N\)</span> and <spanclass="math inline">\(u\)</span> for both client-server distribution andP2P distribution.</p><p><strong>Answer:</strong></p><p>To calculate the minimum distribution time for both client-serverdistribution and P2P distribution, we use the following formulas:</p><ol type="1"><li><p><strong>Client-Server Distribution:</strong> <spanclass="math display">\[t_{cs} = \max \left\{ \frac{N \cdot F}{u_s}, \frac{F}{d_i} \right\}\]</span></p></li><li><p><strong>P2P Distribution:</strong> <span class="math display">\[t_{p2p} = \max \left\{ \frac{F}{u_s}, \frac{F}{d_i}, \frac{N \cdotF}{u_s + \sum_{i} u_i} \right\}\]</span></p></li></ol><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><span class="math inline">\(N\)</span></th><th><span class="math inline">\(u \, \text{Kbps}\)</span></th><th><span class="math inline">\(t_{cs} \, \text{seconds}\)</span></th><th><span class="math inline">\(t_{p2p} \, \text{seconds}\)</span></th></tr></thead><tbody><tr><td><span class="math inline">\(10\)</span></td><td><span class="math inline">\(300\)</span></td><td><span class="math inline">\(\max\{5000, 7500\} = 7500\)</span></td><td><span class="math inline">\(\max\{500, 7500, 4545\} =7500\)</span></td></tr><tr><td><span class="math inline">\(10\)</span></td><td><span class="math inline">\(700\)</span></td><td><span class="math inline">\(\max\{5000, 7500\} = 7500\)</span></td><td><span class="math inline">\(\max\{500, 7500, 4054\} =7500\)</span></td></tr><tr><td><span class="math inline">\(10\)</span></td><td><span class="math inline">\(2,000\)</span></td><td><span class="math inline">\(\max\{5000, 7500\} = 7500\)</span></td><td><span class="math inline">\(\max\{500, 7500, 3000\} =7500\)</span></td></tr><tr><td><span class="math inline">\(100\)</span></td><td><span class="math inline">\(300\)</span></td><td><span class="math inline">\(\max\{50000, 7500\} =50000\)</span></td><td><span class="math inline">\(\max\{500, 7500, 25000\} =25000\)</span></td></tr><tr><td><span class="math inline">\(100\)</span></td><td><span class="math inline">\(700\)</span></td><td><span class="math inline">\(\max\{50000, 7500\} =50000\)</span></td><td><span class="math inline">\(\max\{500, 7500, 15000\} =15000\)</span></td></tr><tr><td><span class="math inline">\(100\)</span></td><td><span class="math inline">\(2,000\)</span></td><td><span class="math inline">\(\max\{50000, 7500\} =50000\)</span></td><td><span class="math inline">\(\max\{500, 7500, 6522\} =7500\)</span></td></tr><tr><td><span class="math inline">\(1,000\)</span></td><td><span class="math inline">\(300\)</span></td><td><span class="math inline">\(\max\{500000, 7500\} =500000\)</span></td><td><span class="math inline">\(\max\{500, 7500, 45455\} =45455\)</span></td></tr><tr><td><span class="math inline">\(1,000\)</span></td><td><span class="math inline">\(700\)</span></td><td><span class="math inline">\(\max\{500000, 7500\} =500000\)</span></td><td><span class="math inline">\(\max\{500, 7500, 20548\} =20548\)</span></td></tr><tr><td><span class="math inline">\(1,000\)</span></td><td><span class="math inline">\(2,000\)</span></td><td><span class="math inline">\(\max\{500000, 7500\} =500000\)</span></td><td><span class="math inline">\(\max\{500, 7500, 7389\} =7500\)</span></td></tr></tbody></table></div><ol type="1"><li><p>当节点数量<strong>较少</strong>（N=10）时，无论使用何种上传速率，<strong>两种分发方式所需时间相同</strong>，均受限于节点的下载速率。</p></li><li><p>当节点数量<strong>增加</strong>时，客户端-服务器模式的分发时间<strong>显著上升</strong>，而P2P模式在节点上传速率足够高时<strong>效率更高</strong>。</p></li><li><p>当节点上传速率达到<strong>2Mbps</strong>时，P2P模式的分发时间在各种节点数下都可以保持在<strong>较低水平</strong>，这显示了P2P架构在大规模分发时的优势。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Application Layer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>统计学习及监督学习概论</title>
    <link href="/2025/06/05/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/"/>
    <url>/2025/06/05/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>作为《统计学习方法》一书的开篇内容，本文旨在系统梳理统计学习领域中的基本概念与常见问题，为后续章节的深入学习奠定理论基础。</p><h2 id="模型评估与选择">模型评估与选择</h2><h3 id="训练误差与测试误差">训练误差与测试误差</h3><p>一般而言，统计学习方法具体采用的损失函数未必是评估时使用的损失函数。</p><p>假设学习到的模型是 <span class="math inline">\(Y =\hat{f}(X)\)</span>，<strong>训练误差</strong>是模型 <spanclass="math inline">\(Y = \hat{f}(X)\)</span>关于训练数据集的平局损失：</p><p><span class="math display">\[R_{\text{emp}} = \frac{1}{N} \sum_{i = 1}^{N} L(y_i, \hat{f}(x_i))\]</span></p><p>其中 <span class="math inline">\(N\)</span> 是训练样本容量。</p><p><strong>测试误差</strong>是模型 <span class="math inline">\(Y =\hat{f}(X)\)</span> 关于测试数据集的平均损失：</p><p><span class="math display">\[e_{\text{emp}} = \frac{1}{N&#39;} \sum_{i = 1}^{N&#39;} L(y_i,\hat{f}(x_i))\]</span></p><p>其中 <span class="math inline">\(N&#39;\)</span> 是测试样本容量。</p><p>上面所述中的函数 <span class="math inline">\(L\)</span>是损失函数。</p><p>常见的 <span class="math inline">\(L\)</span> 有指示函数 <spanclass="math inline">\(I\)</span>，当满足函数内容是取 <spanclass="math inline">\(1\)</span>。当损失函数是指示函数时，此时测试误差又叫做<strong>测试误差率</strong>：</p><p><span class="math display">\[e_{\text{test}} = \frac{1}{N&#39;} \sum_{i = 1}^{N&#39;} I(y_i \neq\hat{f}(x_i))\]</span></p><h3 id="过拟合">过拟合</h3><p>过拟合是统计学习和机器学习领域中常见且重要的问题之一。它指的是模型在训练数据上表现良好，能够取得较低的训练误差，但在未见过的测试数据或新样本上表现较差，导致<strong>泛化能力下降</strong>的现象。过拟合通常发生在模型复杂度过高、参数数量远大于训练样本数量，或训练过程中对训练数据<strong>记忆</strong>过多而忽略了数据的内在规律时。</p><p>造成过拟合的主要原因包括：模型容量过大、训练数据不足、特征冗余或噪声较多等。为缓解过拟合，常用的方法有：增加训练数据量、选择更简单的模型、采用正则化技术（如L1或L2正则化）、剪枝、交叉验证等。合理地控制模型复杂度和提升数据质量，是提升模型泛化能力、避免过拟合的关键。</p><h3 id="正则化与交叉验证">正则化与交叉验证</h3><h4 id="正则化">正则化</h4><p>正则化是<strong>结构风险最小化策略</strong>的实现，是在<strong>经验风险</strong>上加一个正则化项，一般具有下述形式：</p><p><span class="math display">\[\min_{f \in \mathcal{F}} \quad \frac{1}{N} \sum_{i = 1}^{N}L(y_i,\hat{f}(x_i)) + \lambda J(f)\]</span></p><h4 id="交叉验证">交叉验证</h4><p>如果样本数据不足，此时可以应用交叉验证。</p><h2 id="泛化能力">泛化能力</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Data Link Layer</title>
    <link href="/2025/06/04/The-Data-Link-Layer/"/>
    <url>/2025/06/04/The-Data-Link-Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="交换机网络通信原理解析">交换机网络通信原理解析</h1><h2 id="交换机接口mac地址的实际用途">交换机接口MAC地址的实际用途</h2><p>交换机每个接口虽有MAC地址，但<strong>并非用于普通数据转发</strong>，而主要用于：- <strong>管理访问</strong>（Telnet/SSH/Web界面登录） -<strong>协议通信</strong>（STP生成树协议、LLDP等） -<strong>故障诊断和监控</strong></p><h2 id="数据帧如何通过交换机转发">数据帧如何通过交换机转发</h2><p>关键误解在于认为数据帧的目标MAC需要是交换机的MAC。实际上：</p><ol type="1"><li><strong>正常帧转发过程</strong>：<ul><li>主机A发送数据到F时，帧中<strong>目标MAC是路由器的MAC</strong>（不是交换机）</li><li>交换机收到帧后<strong>不检查”这是否发给我”</strong></li><li>交换机仅通过<strong>MAC地址表查询</strong>决定从哪个端口转发出去</li></ul></li><li><strong>交换机的核心工作原理</strong>：<ul><li>交换机维护一个<strong>MAC地址表</strong>，记录”哪个MAC地址在哪个端口”</li><li>收到帧后，查表找到目标MAC对应端口</li><li>从对应端口转发，<strong>不修改帧内容</strong></li></ul></li><li><strong>同网段和跨网段通信区别</strong>：<ul><li><strong>同网段</strong>：源MAC→主机A，目标MAC→主机B</li><li><strong>跨网段</strong>：源MAC→主机A，目标MAC→<strong>路由器</strong>接口</li></ul></li></ol><h2 id="结论">结论</h2><p>交换机处理所有收到的有效帧，<strong>不会因为目标MAC不是自己而丢弃</strong>。这与路由器不同，路由器只处理目标MAC是自己接口MAC的帧。</p><p><strong>正是因为交换机不修改MAC地址并且不以自身MAC为转发判断依据</strong>，才使得以太网能够高效透明地工作。</p><h1 id="introduction-and-service">Introduction and Service</h1><h2 id="some-terminology">Some terminology</h2><p>我们规定：</p><ul><li><strong>Nodes</strong>: hosts and routers;</li><li><strong>Links</strong>: communication <strong>channels</strong> thatconnect adjacent nodes along communication path;<ul><li>wired links</li><li>wireless links</li><li>LANs</li></ul></li><li>layer-2 packet is a <strong>frame</strong>, encapsulatesdatagram.</li></ul><blockquote><p>这里就是在说 data link layer 的数据包叫做 frame。</p></blockquote><h2 id="link-layer-context">Link layer: context</h2><p>Datagram transferred by different link protocols over differentlinks, each link protocol provides different services.</p><blockquote><p>不同的 link 用不同的 protocol。</p></blockquote><h2 id="link-layer-services">Link Layer Services</h2><ul><li><strong>framing, link access</strong><ul><li>encapsulate datagram into frame, adding header, trailer.</li><li>channel access if shared medium.</li><li><strong>MAC</strong> addresses used in frame headers to identifysource, dest.</li></ul></li><li><strong>reliable delivery between adjacent nodes</strong><ul><li>seldom used on low bit-error link (fiber, some twisted pair).</li></ul></li><li><strong>flow control</strong><ul><li>pacing between adjacent sending and receiving nodes.</li></ul></li><li><strong>error detection</strong><ul><li>errors caused by signal <strong>attenuation, noise</strong>.</li><li>receiver detects presence of errors: signals sender forretransmission or drops frame.</li></ul></li><li><strong>error correction</strong><ul><li>receiver identifies and <strong>corrects</strong> bit error(s)without resorting to retransmission.</li></ul></li><li><strong>half-duplex and full-duplex</strong>（半双工和全双工）<ul><li>with half duplex, nodes at both ends of link can transmit, but notat same time.</li></ul></li></ul><h2 id="where-is-the-link-layer-implemented">Where is the link layerimplemented?</h2><ul><li>The <strong>link layer is implemented in every host</strong>.</li><li>It is realized through an <strong>adaptor</strong>, also known as a<strong>Network Interface Card (NIC)</strong>.<ul><li>Examples include: <strong>Ethernet cards</strong>, <strong>PCMCIAcards</strong>, and <strong>802.11 wireless cards</strong>.</li></ul></li><li>The adaptor is responsible for implementing both the <strong>linklayer</strong> and the <strong>physical layer</strong>.</li><li>It connects to the host via the <strong>system buses</strong>.</li><li>The adaptor is a <strong>combination of hardware, software, andfirmware</strong>.</li></ul><p>In essence, the NIC handles the lower layers of network communicationand serves as the interface between the host and the physicalnetwork.</p><figure><img src="The-Data-Link-Layer/Network%20adapter.png"style="display: block; margin: 0 auto; width: 70%"alt="Network adapter" /><figcaption aria-hidden="true">Network adapter</figcaption></figure><h2 id="adaptors-communicating">Adaptors Communicating</h2><figure><img src="The-Data-Link-Layer/AdaptorsCommunicating.png"style="display: block; margin: 0 auto; width: 70%"alt="Adaptors Communicating}" /><figcaption aria-hidden="true">Adaptors Communicating}</figcaption></figure><h3 id="sending-side">Sending Side</h3><ul><li><strong>Encapsulates the network-layer datagram into a link-layerframe</strong>.</li><li><strong>Adds</strong>:<ul><li><strong>Error checking bits</strong> (e.g., CRC).</li><li><strong>Reliable data transfer (rdt)</strong> mechanisms (ifneeded).</li><li><strong>Flow control</strong> to manage data rate between sender andreceiver.</li></ul></li></ul><h3 id="receiving-side">Receiving Side</h3><ul><li><strong>Checks</strong> the frame for:<ul><li><strong>Errors</strong> using error detection codes.</li><li><strong>Reliable data transfer</strong> mechanisms.</li><li><strong>Flow control</strong> compliance.</li></ul></li><li><strong>Extracts</strong> the datagram from the frame.</li></ul><h1 id="error-detection-and-correction">Error Detection andCorrection</h1><figure><img src="The-Data-Link-Layer/Error-detectionAnd-correctionScenario.png"style="display: block; margin: 0 auto; width: 70%"alt="Error detection And correction Scenario" /><figcaption aria-hidden="true">Error detection And correctionScenario</figcaption></figure><ul><li><strong>EDC (Error Detection and Correction bits)</strong>:<ul><li>Extra <strong>redundant bits</strong> added to data to detect andpossibly correct errors during transmission.</li></ul></li><li><strong>D (Data)</strong>:<ul><li>The actual data being protected by error checking.</li><li>May include <strong>header fields</strong> along with thepayload.</li></ul></li></ul><blockquote><p>也就是整个 IP datagram。</p></blockquote><ul><li><strong>Important Notes</strong>:<ul><li><strong>Error detection is not 100% reliable</strong>.<ul><li>Some errors may go undetected, though this is<strong>rare</strong>.</li></ul></li><li>A <strong>larger EDC field</strong> generally provides:<ul><li><strong>Better error detection</strong> capability.</li></ul></li></ul></li></ul><h2 id="parity-checks">Parity Checks</h2><ul><li><strong>Even Parity Scheme:</strong> the total number of <spanclass="math inline">\(1\)</span>s in the $ d + 1 $ bits is even.</li><li><strong>Odd Parity Scheme:</strong> the total number of <spanclass="math inline">\(1\)</span>s in the $ d + 1 $ bits is odd.</li></ul><blockquote><p>偶校验和奇校验。</p></blockquote><p>If an odd number of <span class="math inline">\(1\)</span>-valuedbits are found with an even parity schemes, the receiver knows that atleast one bit error has occurred.</p><h3 id="two-dimensional-parity">Two-dimensional Parity</h3><p>The receiver can thus not only <strong>detect</strong> the fact thata single bit error has occurred, but can use the column and row indicesof the column and row with parity errors to actually identify the bitthat was corrupted and <strong>correct</strong> that error!</p><figure><img src="The-Data-Link-Layer/Two-dimensional-even-parity.png"style="display: block; margin: 0 auto; width: 70%"alt="Two dimensional even parity" /><figcaption aria-hidden="true">Two dimensional even parity</figcaption></figure><h2 id="cyclic-redundancy-check-crc">Cyclic Redundancy Check (CRC)</h2><p>An error-detection technique used widely in today’s computer networksis based on <strong>cyclic redundancy check (CRC) codes</strong>. CRCcodes are also known as <strong>polynomial codes</strong>, since it ispossible to view the bit string to be sent as a polynomial whosecoefficients are the <span class="math inline">\(0\)</span> and <spanclass="math inline">\(1\)</span> values in the bit string, withoperations on the bit string interpreted as polynomial arithmetic.</p><ul><li><strong>数据表示</strong>：将要发送的 <spanclass="math inline">\(d\)</span> 位数据 <spanclass="math inline">\(D\)</span> 看作一个二进制多项式。</li><li><strong>生成多项式 <spanclass="math inline">\(G\)</span></strong>：发送方和接收方事先约定一个<span class="math inline">\(r + 1\)</span> 位的生成多项式 <spanclass="math inline">\(G\)</span>。</li><li><strong>附加冗余位 <spanclass="math inline">\(R\)</span></strong>：发送方为 <spanclass="math inline">\(D\)</span> 选择 <spanclass="math inline">\(r\)</span> 位冗余位 <spanclass="math inline">\(R\)</span>，并将其附加到 <spanclass="math inline">\(D\)</span> 后面，形成 <spanclass="math inline">\(d + r\)</span> 位的发送数据，使得整个 <spanclass="math inline">\(d + r\)</span> 位数据能被 <spanclass="math inline">\(G\)</span> 整除（模 2 运算下）。</li></ul><h3 id="how-the-sender-computes-r">How the Sender Computes <spanclass="math inline">\(R\)</span>?</h3><p>简单地来讲：</p><ul><li>发送方将 <span class="math inline">\(D\)</span> 左移 <spanclass="math inline">\(r\)</span> 位（即在 <spanclass="math inline">\(D\)</span> 后面补 <spanclass="math inline">\(r\)</span> 个 0），得到 <spanclass="math inline">\(D \cdot 2^r\)</span>。</li><li>用 <span class="math inline">\(D \cdot 2^r\)</span> 除以 <spanclass="math inline">\(G\)</span>，得到余数 <spanclass="math inline">\(R\)</span>。</li><li>将 <span class="math inline">\(R\)</span> 附加到 <spanclass="math inline">\(D\)</span> 后面，形成最终发送的数据。</li></ul><p><strong>公式表示：</strong> <span class="math display">\[R = \operatorname{remainder} \frac{D \cdot 2^r}{G}\]</span></p><figure><img src="The-Data-Link-Layer/CRCSample.png"style="display: block; margin: 0 auto; width: 70%" alt="CRC Sample" /><figcaption aria-hidden="true">CRC Sample</figcaption></figure><p>需要注意，<span class="math inline">\(1 - 0 = 1\)</span>，<spanclass="math inline">\(0 - 1 = 1\)</span>，<span class="math inline">\(1- 1 =0\)</span>，<span class="math inline">\(0 - 0 =0\)</span>，没有借位，最后的结果，比如：<spanclass="math inline">\(11\)</span>，但是 <span class="math inline">\(r =3\)</span>，则在左侧高位补充 <spanclass="math inline">\(0\)</span>，也就是 <span class="math inline">\(R =011\)</span>。</p><h1 id="multiple-access-links-and-protocols">Multiple Access Links andProtocols</h1><h2 id="two-types-of-links">Two Types of Links</h2><h3 id="point-to-point-links"><strong>Point-to-Point Links</strong></h3><ul><li><strong>定义</strong>：点对点链路是指仅有两个设备直接相连的通信链路。</li><li><strong>典型例子</strong>：<ul><li>拨号上网时使用的 PPP（Point-to-Point Protocol）协议。</li><li>以太网交换机与主机之间的连接。</li></ul></li><li><strong>特点</strong>：<ul><li>通信双方唯一，链路专用。</li><li>通常无需考虑信道竞争或冲突问题。</li><li>实现简单，性能稳定。</li></ul></li></ul><h3 id="broadcast-links"><strong>Broadcast Links</strong></h3><ul><li><strong>定义</strong>：广播链路是指多个设备共享同一个物理通信介质的链路，所有设备都能”听到”同一信道上的数据。</li><li><strong>典型例子</strong>：<ul><li>早期以太网（同轴电缆共享）。</li><li>HFC（Hybrid Fiber-Coaxial）上行链路。</li><li>802.11 WiFi（无线局域网）。</li></ul></li><li><strong>特点</strong>：<ul><li>多个节点共享信道，可能发生冲突。</li><li>需要多路访问协议（如CSMA/CD、ALOHA等）协调各节点的发送时机。</li><li>支持广播和组播通信。</li></ul></li></ul><h2 id="multiple-access-protocol">Multiple Access Protocol</h2><ul><li>A <strong>single shared broadcast channel</strong> is used bymultiple nodes.<ul><li>If two or more nodes transmit at the same time, their signalsinterfere, causing a <strong>collision</strong>.</li></ul></li><li>A <strong>multiple access protocol</strong> is needed to coordinatetransmissions.<ul><li>This protocol is a distributed algorithm that determines when eachnode can transmit.</li><li>All coordination and communication about channel sharing must occurover the same channel—there is <strong>no separate controlchannel</strong>.</li></ul></li></ul><blockquote><p>多个结点共用一条 channel 进行传输，这条 channel同一时间只能供一个结点传输。应用 multiple access protocol 来协调。</p></blockquote><ul><li><strong>链路（link）</strong>更强调<strong>连接关系</strong>，即两个节点之间的直接连接。如上文介绍的两种<strong>links</strong>。</li><li><strong>信道（channel）</strong>更强调<strong>传输资源</strong>，即数据传输所依赖的物理或逻辑媒介。</li><li>在点对点链路中，link 和 channel 通常是一一对应的。</li><li>在广播链路中，多个 link（设备间的连接）共享同一个channel（信道）。</li></ul><h3 id="ideal-multiple-access-protocol">Ideal Multiple AccessProtocol</h3><ul><li>The broadcast channel has a total rate of <strong><spanclass="math inline">\(R\)</span> bps</strong>.</li><li>If only one node transmits, it can use the full rate <strong><spanclass="math inline">\(R\)</span></strong>.</li><li>If <strong><span class="math inline">\(M\)</span></strong> nodestransmit simultaneously, each gets an average rate of <strong><spanclass="math inline">\(R/M\)</span></strong>.</li><li>The system is <strong>fully decentralized</strong>:<ul><li>No central coordinator.</li><li>No clock or slot synchronization required.</li></ul></li><li>The approach is simple and efficient for sharing the channel.</li></ul><h2 id="mac-protocols-a-taxonomy">MAC Protocols: a taxonomy</h2><h3 id="three-broad-classes-of-mac-protocols">Three Broad Classes of MACProtocols</h3><ol type="1"><li><strong>Channel Partitioning</strong><ul><li>The channel is divided into smaller pieces (such as time slots,frequency bands, or codes).</li><li>Each node is allocated a piece for exclusive use.</li></ul></li><li><strong>Random Access</strong><ul><li>The channel is not divided; all nodes can transmit at any time.</li><li>Collisions may occur, but protocols are designed to <strong>detectand recover</strong> from collisions.</li></ul></li><li><strong>Taking Turns</strong><ul><li>Nodes take turns using the channel.</li><li>Nodes with more data to send can take longer turns.</li></ul></li></ol><h2 id="channel-partitioning-protocols">Channel PartitioningProtocols</h2><p><strong>TDMA</strong>: Time Division Multiple Access<strong>FDMA</strong>: Frequency Division Multiple Access<strong>CDMA</strong>: Code Division Multiple Access</p><h3 id="tdma">TDMA</h3><ul><li><strong>Mechanism:</strong><ul><li>Divides time into frames, and each frame into <spanclass="math inline">\(N\)</span> time slots (for <spanclass="math inline">\(N\)</span> nodes).</li><li>Each node is assigned a specific time slot in each frame.</li><li>When a node has data to send, it transmits only during its assignedslot.</li></ul></li><li><strong>Example:</strong><ul><li>In a four-node TDMA system, each node gets one slot per frame, andthe slots repeat in a fixed order.</li></ul></li><li><strong>Advantages:</strong><ul><li>No collisions; perfectly fair (each node gets <spanclass="math inline">\(R/N\)</span> bps).</li></ul></li><li><strong>Drawbacks:</strong><ul><li>Each node is limited to <span class="math inline">\(R/N\)</span> bpseven if others are idle.</li><li>Nodes must wait for their turn, even if they are the only one withdata to send.</li></ul></li></ul><blockquote><p>只能用自己的。</p></blockquote><h3 id="fdma">FDMA</h3><ul><li><strong>Mechanism:</strong><ul><li>Divides the total channel bandwidth (<spanclass="math inline">\(R\)</span> bps) into <spanclass="math inline">\(N\)</span> frequency bands, each with bandwidth<span class="math inline">\(R/N\)</span>.</li><li>Each node is assigned a <strong>unique frequency band</strong> forexclusive use.</li></ul></li><li><strong>Example:</strong><ul><li>In a four-node FDM system, each node gets a <spanclass="math inline">\(4\)</span> KHz band out of a total <spanclass="math inline">\(16\)</span> KHz channel.</li></ul></li><li><strong>Advantages:</strong><ul><li>No collisions; fair bandwidth allocation.</li></ul></li><li><strong>Drawbacks:</strong><ul><li>Each node is limited to R/N bps, even if others are idle (same asTDMA).</li></ul></li></ul><figure><img src="The-Data-Link-Layer/TDA-and-FDA-example.png"style="display: block; margin: 0 auto; width: 70%"alt="TDA and FDA example" /><figcaption aria-hidden="true">TDA and FDA example</figcaption></figure><h3 id="cdma">CDMA</h3><ul><li><strong>Mechanism:</strong><ul><li>Each node is assigned a unique code.</li><li>Nodes encode their data using their code and transmit simultaneouslyover the same channel.</li><li>Receivers use the sender’s code to decode the intended message, evenin the presence of other transmissions.</li></ul></li><li><strong>Features:</strong><ul><li>Allows multiple nodes to transmit at the same time withoutcollisions, as long as codes are chosen carefully.</li><li>Widely used in wireless and cellular networks due to itsanti-jamming properties.</li></ul></li><li><strong>Note:</strong><ul><li>CDMA codes serve a similar role as time slots in TDMA and frequencybands in FDMA, enabling multiple access to the channel.</li></ul></li></ul><blockquote><p>每个节点分配一个唯一的编码，所有节点可同时发送，接收端用对应的码提取目标信号。详细过程参考第六章。</p></blockquote><h2 id="random-access-protocols">Random Access Protocols</h2><ul><li>When a node has a packet to send, it transmits at the full channeldata rate <span class="math inline">\(\mathbf{R}\)</span>.</li><li>There is <strong>no prior coordination</strong> among nodes beforetransmission.（也就是说这个结点传输前不会考虑其它因素）</li><li>If two or more nodes transmit at the same time, a<strong>collision</strong> occurs.</li><li>A <strong>random access MAC protocol</strong> defines:（干了两件事）<ul><li><strong>How to detect collisions</strong>.</li><li><strong>How to recover from collisions (e.g., by delaying andretransmitting)</strong>.（后传和重传）</li><li><strong>Examples:</strong><ul><li>Slotted ALOHA<br /></li><li>ALOHA<br /></li><li>CSMA, CSMA/CD, CSMA/CA</li></ul></li></ul></li></ul><h3 id="slotted-aloha">Slotted ALOHA</h3><p><strong>Assumptions:</strong> - All frames are the same size. - Timeis divided into equal-sized slots (each slot = time to transmit oneframe). - Nodes can only begin transmission at the start of a slot. -All nodes are synchronized. - If two or more nodes transmit in the sameslot, a collision occurs and is detected by all.</p><p><strong>Operation:</strong> - When a node has a new frame, ittransmits in the next available slot. - If there is no collision, thenode can send a new frame in the next slot. - If a collision occurs, thenode retransmits the frame in each subsequent slot with probability<span class="math inline">\(p\)</span> until successful.</p><p><strong>Pros of Slotted ALOHA:</strong> - A single active node cancontinuously transmit at the full channel rate. - Highly decentralized;only slot synchronization among nodes is needed. - Simple toimplement.</p><p><strong>Cons of Slotted ALOHA:</strong> - Collisions can occur,wasting slots. - Idle slots may occur, reducing efficiency. -<strong>Nodes may detect collisions before a full packet istransmitted</strong>. - <strong>Requires clock synchronization among allnodes</strong>.</p><blockquote><p>前提假设不太现实，要求所有的 frame大小相同，这样才能确保将时间分为等长的时隙有用。</p></blockquote><p><strong>同步(synchronize)</strong> 指的是：</p><ul><li>所有网络节点<strong>共享一个统一的时钟参考</strong></li><li>每个节点能够<strong>准确识别时隙的开始和结束时刻</strong></li><li>通常通过<strong>集中式时钟信号</strong>或<strong>同步协议</strong>实现</li></ul><p><strong>Slotted Aloha efficiency</strong></p><ul><li><strong>Efficiency</strong> is defined as the long-run fraction ofslots that contain a successful transmission (i.e., exactly one nodetransmits).</li><li>Suppose there are <span class="math inline">\(N\)</span> nodes, eachalways has frames to send, and each transmits in a slot with probability<span class="math inline">\(p\)</span>.</li><li>The probability that a given node has a successful transmission in aslot:<br /><span class="math display">\[p(1-p)^{N-1}\]</span></li><li>The probability that any node has a successful transmission in aslot:<br /><span class="math display">\[Np(1-p)^{N-1}\]</span></li><li><strong>Maximum efficiency</strong> is achieved by choosing <spanclass="math inline">\(p^*\)</span> that maximizes <spanclass="math inline">\(Np(1-p)^{N-1}\)</span>.</li><li>As <span class="math inline">\(N\)</span> becomes very large, themaximum efficiency approaches:<br /><span class="math display">\[\boxed{1/e \approx 0.37}\]</span></li><li><strong>Interpretation:</strong><br />At best, the channel is used for successful transmissions only 37% ofthe time.</li></ul><blockquote><p>当前时隙有结点传输的概率。</p></blockquote><h1 id="tdma与slotted-aloha对比分析">TDMA与Slotted ALOHA对比分析</h1><p><strong>TDMA和SlottedALOHA并不矛盾，它们是两种不同设计理念的多址接入协议</strong>，尽管都使用了时间分片的概念。</p><h2 id="关键区别">关键区别</h2><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>特性</th><th>TDMA</th><th>Slotted ALOHA</th></tr></thead><tbody><tr><td><strong>时隙分配</strong></td><td><strong>预先固定分配</strong>给特定节点</td><td><strong>动态竞争</strong>，任何节点可使用任何时隙</td></tr><tr><td><strong>传输决策</strong></td><td>只能在<strong>自己的专属时隙</strong>中传输</td><td>可以在<strong>任何时隙</strong>开始传输</td></tr><tr><td><strong>冲突可能性</strong></td><td><strong>无冲突</strong>（每个时隙专属一个节点）</td><td><strong>有冲突</strong>（多节点可能同时选择一个时隙）</td></tr><tr><td><strong>资源使用</strong></td><td>节点不传输时其时隙<strong>浪费</strong></td><td>任何节点都可以利用空闲时隙</td></tr><tr><td><strong>控制方式</strong></td><td><strong>集中式</strong>或预先协调</td><td><strong>分散式</strong>（各节点独立决策）</td></tr><tr><td><strong>最大效率</strong></td><td>理论上100%（无冲突）</td><td>理论上约37%（1/e）</td></tr></tbody></table></div><h2 id="本质区别">本质区别</h2><ul><li><strong>TDMA</strong>：<strong>预分配固定时隙</strong>的”预约”系统<ul><li>类似于餐厅固定座位：每人只能坐自己的座位</li><li>优点：无冲突，确定性高</li><li>缺点：资源可能浪费，缺乏灵活性</li></ul></li><li><strong>SlottedALOHA</strong>：<strong>随机竞争时隙</strong>的”抢座”系统<ul><li>类似于餐厅先到先得：谁想坐就尝试坐，有冲突就重试</li><li>优点：简单实现，适应突发流量</li><li>缺点：存在冲突，效率有限</li></ul></li></ul><p>这两种协议代表了多址接入的两种不同设计思路：<strong>静态分配</strong>与<strong>动态竞争</strong>，各有优缺点，适用于不同应用场景。</p><h3 id="pure-unslotted-aloha">Pure (unslotted) ALOHA</h3><figure><img src="The-Data-Link-Layer/pure-ALOHA-sample.png"style="display: block; margin: 0 auto; width: 70%"alt="pure ALOHA sample" /><figcaption aria-hidden="true">pure ALOHA sample</figcaption></figure><ul><li>Simpler than slotted ALOHA; <strong>no synchronization</strong>required.</li><li>When a frame arrives, the node <strong>transmitsimmediately</strong>.</li><li><strong>Higher collision probability</strong>:<ul><li>A frame sent at time <span class="math inline">\(t_0\)</span> willcollide with any other frame sent in the interval <spanclass="math inline">\([t_0-1, t_0+1]\)</span>.</li></ul></li></ul><p><strong>Pure (Unslotted) ALOHA Efficiency:</strong></p><ul><li>Probability of success for a given node:<ul><li><span class="math inline">\(P(\text{success}) = P(\text{nodetransmits}) \times P(\text{no other node transmits in } [t_0-1, t_0])\times P(\text{no other node transmits in } [t_0, t_0+1])\)</span></li><li><span class="math inline">\(= p \cdot (1-p)^{N-1} \cdot(1-p)^{N-1}\)</span></li><li><span class="math inline">\(= p \cdot (1-p)^{2(N-1)}\)</span></li></ul></li><li><strong>Maximum efficiency</strong> (choosing optimal <spanclass="math inline">\(p\)</span> and letting <spanclass="math inline">\(N \to \infty\)</span>):<ul><li><span class="math inline">\(\boxed{1/(2e) \approx0.18}\)</span></li></ul></li><li><strong>Interpretation:</strong><br />At best, the channel is used for successful transmissions only 18% ofthe time in pure ALOHA.</li></ul><blockquote><p><span class="math inline">\(t_0, \, t_0 - 1, \, t_0 + 1\)</span>三个时隙。</p></blockquote><h3 id="carrier-sense-multiple-access-csma">Carrier Sense MultipleAccess (CSMA)</h3><p>发送前先侦听，发送时检测碰撞，以太网核心技术</p><p><strong>Carrier Sensing</strong>: a node listens to the channelbefore transmitting. <strong>If a frame from another node is currentlybeing transmitted into the channel</strong>, a node then waits until itdetects no transmissions for a short amount of time and then beginstransmission.</p><p>In networks using CSMA (like <strong>traditional Ethernet orwireless</strong>), all nodes communicate over a single shared physicalchannel. Many network interfaces operating under CSMA protocols aredesigned for half-duplex communication, meaning they can either transmitOR receive at any given moment, but not both simultaneously. This is whya node can not transmit while receiving.</p><blockquote><p>半双工机制。</p></blockquote><h3 id="csma-with-collision-detection-csmacd">CSMA with collisiondetection (CSMA/CD)</h3><p><strong>Collision Detection</strong>: a transmitting node listens tothe channel while it is transmitting. If it detects that another node istransmitting an interfering frame, it stops transmitting and waits<strong>a random amount</strong> of time before repeating thesense-and-transmit-when-idle cycle.</p><blockquote><p>自己正在传的时候检测到有其他结点开始传了，停止自己的传输，随机等待一段时间后重试。</p></blockquote><h2 id="taking-turns-protocols">Taking-Turns Protocols</h2><h3 id="polling-protocol">Polling Protocol</h3><p><strong>PollingProtocol（轮询协议）</strong>是一种<strong>轮流访问</strong>型的多路访问协议，常用于多个节点共享同一信道的场景。其核心思想是：<br />- 网络中指定一个节点为<strong>主节点（master node）</strong>。 -主节点按照固定顺序依次<strong>轮询</strong>每个从节点，询问它们是否有数据要发送。- 只有被轮询到的节点才被允许发送数据。</p><p>这个协议有着如下缺陷： 1.<strong>轮询延迟</strong>：每个节点都要等主节点轮询到自己才能发送数据，可能会有等待延迟，尤其是节点数量多时。2.<strong>主节点单点故障</strong>：如果主节点出现故障，整个信道就无法正常工作，所有通信都会中断。</p><p><strong><em>Bluetooth protocol</em></strong></p><h3 id="token-passing-protocol">Token-Passing Protocol</h3><p>A small, special-purpose frame known as a <strong>token</strong> isexchanged among the nodes in some fixed order.</p><blockquote><p>When a node receives a token, it holds onto the token only if it hassome frames to transmit; otherwise, it immediately forwards the token tothe next node. If a node does have frames to transmit when it receivesthe token, it sends up to a maximum number of frames and then forwardsthe token to the next node.</p></blockquote><p>But it has its problems as well. For example, the failure of one nodecan crash the entire channel. Or if a node accidentally neglects torelease the token, then some recovery procedure must be invoked to getthe token back in circulation.</p><p>将一个特制的 <strong>frame</strong> 视作一个<strong>token</strong>，这个 token 会在结点中以一个固定的顺序传输，收到token 的结点可以选择发送自己的 frames或者立即传给下一个结点。缺陷：时延和崩坏。</p><p><strong><em>fiber distributed data interface (FDDI)protocol</em></strong></p><h1 id="link-layer-addressing-and-arp">Link-Layer Addressing andARP</h1><h2 id="addressing-in-computer-networks">Addressing in ComputerNetworks</h2><p>先回顾一下之前学过的 address。</p><h3 id="ip-address-32-bit">IP Address (32-bit)</h3><ul><li><strong>Layer</strong>: Network layer address</li><li><strong>Primary function</strong>: Used to route datagrams to theirdestination IP subnet</li><li><strong>Scope</strong>: Global addressing for internet-widerouting</li></ul><h3 id="mac-address-48-bit">MAC Address (48-bit)</h3><ul><li><strong>Layer</strong>: Data link layer (physical addressing)</li><li><strong>Primary function</strong>: Used to transfer frames betweendirectly connected interfaces on the same physical network</li><li><strong>Implementation</strong>: Permanently burned into NIC ROMhardware, though sometimes software-configurable</li><li><strong>Scope</strong>: Local addressing limited to a single networksegment</li></ul><p>The fundamental distinction is that IP addresses enable routingacross multiple networks, while MAC addresses handle the physicaldelivery between devices on the same network segment.</p><ul><li><strong>IP地址</strong>：用于在不同网络之间进行路由，确保数据能够跨越多个网络到达最终目标。</li><li><strong>MAC地址</strong>：用于在同一个网络段（如同一个局域网）内实现设备之间的物理交付。</li><li><strong>IP地址</strong>负<strong>找路</strong>，确定数据应该到哪个网络。</li><li><strong>MAC地址</strong>负责<strong>最后一公里</strong>，在本地网络中找到具体的设备。</li><li>路由器转发数据时，每经过一跳，都会用新的 MAC 地址封装数据帧，但 IP地址保持不变。</li></ul><p>假设主机 A 要给主机 B 发送数据：</p><ol type="1"><li><strong>跨网传输</strong>：数据包通过多个路由器，依靠 IP地址进行路由选择。</li><li><strong>到达目标网络</strong>：最后一跳，数据包到达 B所在的局域网。</li><li><strong>本地交付</strong>：A 通过 ARP 协议获取 B 的 MAC地址，将数据帧封装后，通过以太网物理传输到 B。</li></ol><h2 id="mac-addresses-and-arp">MAC Addresses and ARP</h2><figure><img src="The-Data-Link-Layer/MACAddress.png"style="display: block; margin: 0 auto; width: 70%" alt="MAC Address" /><figcaption aria-hidden="true">MAC Address</figcaption></figure><p>Broadcast address = <code>FF-FF-FF-FF-FF-FF</code></p><h3 id="mac-address-administration">MAC Address Administration</h3><ul><li><p><strong>分配权威（Allocation Authority）</strong><br />MAC 地址空间由 <strong>IEEE（电气和电子工程师协会）</strong>统一管理和分配，确保全球唯一性。</p></li><li><p><strong>分配流程（Assignment Process）</strong><br />各网络设备制造商需要向 IEEE 购买一批 MAC地址块。这样，每个厂商生产的设备都能分配到唯一的 MAC地址，避免地址冲突。</p></li><li><p><strong>结构（Structure）</strong><br />MAC 地址总长 48 位，<strong>前 24 位</strong>通常用来标识制造商（称为OUI，Organizationally Unique Identifier，组织唯一标识符），后 24位由厂商自行分配给各自的设备。</p></li></ul><h3 id="conceptual-comparison">Conceptual Comparison</h3><ul><li><strong>MAC Address</strong>: Similar to a Social Security Number<ul><li>Permanent identifier tied to hardware</li><li>Remains with the device regardless of location</li></ul></li><li><strong>IP Address</strong>: Similar to a postal address<ul><li>Indicates location in the network topology</li><li>Changes when moving between networks</li></ul></li></ul><h3 id="address-structure-implications">Address StructureImplications</h3><ul><li><strong>MAC Address (Flat)</strong>:<ul><li>Provides portability</li><li>LAN card maintains its address when moved between networks</li><li>No inherent network location information</li></ul></li><li><strong>IP Address (Hierarchical)</strong>:<ul><li>Not portable across networks</li><li>Contains network prefix that identifies subnet</li><li>Must change when moving to a different subnet</li><li>Enables efficient routing across internet</li></ul></li></ul><p>This fundamental difference in addressing philosophy reflects thedifferent purposes of each address type: MAC for unique hardwareidentification, IP for routable network location.</p><h2 id="address-resolution-protocol-arp">Address Resolution Protocol(ARP)</h2><p>The Address Resolution Protocol (ARP) is used to discover the MACaddress associated with a known IP address on the same localnetwork:</p><ol type="1"><li><strong>Check Local ARP Table First</strong><ul><li>Every IP-enabled device maintains an ARP table</li><li>The table contains mappings of IP addresses to MAC addresses</li><li>Each entry format:<code>&lt;IP address; MAC address; TTL&gt;</code></li><li>TTL (Time To Live): Typically 20 minutes before entry expires</li></ul></li><li><strong>If MAC Address Not in Table:</strong><ul><li>Device broadcasts an ARP request to all devices on LAN</li><li>Uses broadcast MAC address: FF-FF-FF-FF-FF-FF</li><li>The request asks: “Who has IP address B? Send your MAC address”</li></ul></li><li><strong>Resolution Process:</strong><ul><li>Only the device with IP address B responds</li><li>Device B sends its MAC address directly to requester</li><li>Requester adds the IP-to-MAC mapping to its ARP table</li><li>Communication can now proceed using the discovered MAC address</li></ul></li><li><strong>When Entry Expires:</strong><ul><li>After TTL expires, the mapping is removed from ARP table</li><li>A new ARP request must be sent if communication is needed again</li></ul></li></ol><p>ARP is essential because link-layer delivery requires MAC addresses,while applications and higher protocols use IP addresses.</p><h2 id="arp-protocol-same-lan-network">ARP Protocol: Same LAN(Network)</h2><p>When host A wants to send a datagram to host B on the same localnetwork but doesn’t have B’s MAC address:</p><h3 id="arp-request-process">ARP Request Process</h3><ul><li>Host A broadcasts an ARP query packet containing B’s IP address</li><li>Destination MAC address = <code>FF-FF-FF-FF-FF-FF</code> (broadcastaddress)</li><li>All machines on the LAN receive the ARP query</li><li>Only host B (with the matching IP address) processes andresponds</li></ul><h3 id="arp-response">ARP Response</h3><ul><li>Host B replies to A with its (B’s) MAC address</li><li>Frame is sent directly to A’s MAC address (unicast)</li><li>A adds the IP-to-MAC mapping to its ARP table</li></ul><h3 id="caching-mechanism">Caching Mechanism</h3><ul><li>A caches (saves) the IP-to-MAC address pair in its ARP table</li><li>Mapping remains until the information becomes old (times out)</li><li>This is “soft state”: information expires unless refreshed throughuse</li></ul><h3 id="key-characteristics">Key Characteristics</h3><ul><li><strong>Self-configuring</strong>: ARP is “plug-and-play”</li><li><strong>Distributed</strong>: Nodes create their ARP tables withoutintervention from network administrators</li><li><strong>Automatic</strong>: Mappings are created and maintaineddynamically as needed</li></ul><blockquote><p>自己也会创建置换表</p></blockquote><h2 id="addressing-routing-to-another-lan">Addressing: routing toanother LAN</h2><figure><img src="The-Data-Link-Layer/619.png"style="display: block; margin: 0 auto; width: 100%"alt="routing to another LAN" /><figcaption aria-hidden="true">routing to another LAN</figcaption></figure><h2 id="routing-between-different-lans-link-layer-process">RoutingBetween Different LANs: Link-Layer Process</h2><p>When data travels between hosts on different networks, the routerplays a critical intermediary role:</p><h3 id="initial-transmission-source-network">Initial Transmission(Source Network)</h3><ol type="1"><li>Host A creates an IP datagram with:<ul><li>Source IP address: Host A’s address</li><li>Destination IP address: Host B’s address (on different LAN)</li></ul></li><li>Host A determines B is on another network, so packet must go throughrouter R:<ul><li>A uses ARP to resolve router interface IP (111.111.111.110) to R’sMAC address</li><li>A creates an Ethernet frame with:<ul><li>Destination: R’s MAC address</li><li>Source: A’s MAC address</li><li>Payload: The A-to-B IP datagram</li></ul></li></ul></li><li>A’s network interface card transmits this frame onto the LAN</li></ol><blockquote><p>从此可以看出，LAN 内部是通过以太网传输数据的，用的是 MACaddress。</p></blockquote><h3 id="router-processing">Router Processing</h3><ol start="4" type="1"><li><p>Router R’s interface receives the frame (recognizes its MACaddress)</p></li><li><p>R extracts the IP datagram from the frame, examines the IPheader:</p><ul><li>Sees destination IP is for host B on another network</li><li>Consults routing table to determine next hop</li></ul></li><li><p>R prepares to forward to the destination network:</p><ul><li>Uses ARP to resolve B’s IP address to B’s MAC address</li><li>Creates a new Ethernet frame with:<ul><li>Destination: B’s MAC address</li><li>Source: R’s MAC address (interface on B’s network)</li><li>Payload: The original A-to-B IP datagram (unchanged)</li></ul></li></ul></li></ol><blockquote><p>R 在不同网络段代表不同的路由器接口。</p></blockquote><h3 id="final-delivery-destination-network">Final Delivery (DestinationNetwork)</h3><ol start="7" type="1"><li><p>Router’s interface on B’s network transmits the newframe</p></li><li><p>Host B receives the frame, extracts and processes the IPdatagram</p></li></ol><p>Note: The IP datagram remains unchanged throughout this process,while the frame addressing changes at each network segment.</p><h1 id="ethernet">Ethernet</h1><h2 id="the-dominant-wired-lan-technology">The Dominant Wired LANTechnology</h2><ul><li><strong>Cost-effective</strong>: Extremely affordable -approximately $20 for a Network Interface Card</li><li><strong>Pioneer technology</strong>: First widely used LANtechnology, establishing the foundation for modern networks</li><li><strong>Simplicity and economy</strong>: Significantly simpler andmore economical than token LANs and ATM alternatives</li><li><strong>Scalable performance</strong>: Successfully kept pace withspeed requirements over decades:<ul><li>Started at 10 Mbps</li><li>Evolved through 100 Mbps and 1 Gbps</li><li>Now supports up to 10 Gbps and beyond</li></ul></li></ul><p>Ethernet’s combination of low cost, simplicity, and adaptability toincreasing performance demands has secured its position as thepredominant wired networking technology in local area networksworldwide.</p><h2 id="ethernet-physical-topologies">Ethernet Physical Topologies</h2><h3 id="historical-evolution">Historical Evolution</h3><ul><li><strong>Bus topology</strong>: Popular through mid-1990s<ul><li>All nodes connected to a common shared cable</li><li><strong>Single collision domain</strong>: All nodes could interferewith each other’s transmissions</li><li>When one node transmitted, all others had to wait</li><li>Limited scalability due to increasing collision probability withmore nodes</li></ul></li></ul><blockquote><p>前面提到过</p></blockquote><h3 id="modern-configuration">Modern Configuration</h3><ul><li><strong>Star topology</strong>: Dominant configuration today<ul><li><strong>Central active switch</strong>: Intelligent device at centerof network</li><li>Point-to-point links between switch and end devices</li><li><strong>Separate collision domains</strong>: Each link operates asan independent Ethernet segment</li><li>Nodes connected to different switch ports cannot directly collidewith each other</li><li>Dramatically improved performance and reliability compared to bustopology</li></ul></li></ul><p>The shift from bus to star topology represents a fundamental advancein Ethernet technology, effectively eliminating the collision problemsthat limited earlier implementations.</p><h2 id="ethernet-frame-structure">Ethernet frame structure</h2><figure><img src="The-Data-Link-Layer/620.png"style="display: block; margin: 0 auto; width: 100%"alt="Ethernet frame structure" /><figcaption aria-hidden="true">Ethernet frame structure</figcaption></figure><ul><li><strong>Preamble</strong>:<ul><li>7 bytes with pattern 10101010 followed by one byte with pattern10101011</li><li>Used to synchronize receiver and sender clock rates</li><li>Allows receivers to “lock onto” the sender’s transmissiontiming</li></ul></li><li><strong>Addresses</strong>: 6 bytes each<ul><li>Destination MAC address (first)</li><li>Source MAC address (second)</li><li>Processing logic:<ul><li>If adapter receives frame with matching destination address orbroadcast address (FF-FF-FF-FF-FF-FF), it passes data to networklayer</li><li>Otherwise, adapter <strong>discards the frame</strong></li><li>Broadcast frames (e.g., ARP packets) are processed by allrecipients</li></ul></li></ul></li><li><strong>Type</strong>: 2 bytes<ul><li>Indicates the higher layer protocol encapsulated in the framepayload</li><li>Common values:<ul><li>0x0800: IPv4</li><li>0x0806: ARP</li><li>0x86DD: IPv6</li><li>Other protocols: Novell IPX, AppleTalk, etc.</li></ul></li></ul></li><li><strong>CRC</strong>: 4 bytes (32 bits)<ul><li>Cyclic Redundancy Check for error detection</li><li>Checked at receiver</li><li>If error is detected, frame is <strong>immediatelydropped</strong></li><li>No error correction or retransmission at Ethernet level</li></ul></li><li><strong>Preamble（前导码）</strong>是以太网帧结构中的一个字段。</li><li>由<strong>7 个字节的 10101010 模式</strong>，后跟<strong>1 个字节的10101011</strong> 组成。</li><li><strong>时钟同步</strong>：用于同步接收端和发送端的时钟速率。</li><li><strong>锁定信号</strong>：让接收方能够<strong>锁定</strong>到发送方的传输时序，确保后续数据能被准确采样和解析。</li></ul><h2 id="ethernet-key-characteristics">Ethernet: Key Characteristics</h2><h3 id="connectionless-protocol">Connectionless Protocol</h3><ul><li><strong>No handshaking</strong> between transmitting and receivingNetwork Interface Cards (NICs)</li><li>Each frame is sent independently without establishing a connectionfirst</li><li>Sender simply transmits frames when the medium is available</li><li>No session establishment or termination phases</li></ul><h3 id="unreliable-service">Unreliable Service</h3><ul><li><strong>No acknowledgments (ACKs)</strong> or negativeacknowledgments (NACKs) sent by receiving NICs</li><li>Sending NIC has no built-in way to know if frames were successfullydelivered</li><li>Corrupted frames are simply discarded by the receiver (detected viaCRC)</li><li>No automatic retransmission mechanism at the Ethernet level</li></ul><h3 id="implications-for-data-delivery">Implications for DataDelivery</h3><ul><li>Stream of datagrams passed to the network layer may contain<strong>gaps</strong> (missing datagrams)</li><li>If the application uses TCP (Transport layer):<ul><li>Gaps will be detected and filled through TCP’s reliable deliverymechanisms</li><li>End users won’t see missing data</li></ul></li><li>If using UDP or other unreliable protocols:<ul><li>Application will see the gaps and must handle them if needed</li><li>Responsibility for reliability shifts to the application layer</li></ul></li></ul><h3 id="medium-access-control">Medium Access Control</h3><ul><li>Ethernet’s MAC protocol: <strong>unslotted CSMA/CD</strong> (CarrierSense Multiple Access with Collision Detection)</li><li>Provides a way to share the communication medium among multipledevices</li><li>Modern switched Ethernet largely eliminates collisions, but theprotocol foundation remains</li></ul><h2 id="csmacd-algorithm-in-ethernet">CSMA/CD Algorithm in Ethernet</h2><p>Ethernet’s original medium access control protocol uses CSMA/CD(Carrier Sense Multiple Access with Collision Detection) to handleshared medium access:</p><h3 id="step-by-step-process">Step-by-Step Process</h3><ol type="1"><li><strong>Frame Creation</strong><ul><li>NIC receives datagram from network layer</li><li>Creates an Ethernet frame with appropriate headers</li></ul></li><li><strong>Channel Sensing</strong><ul><li>If NIC senses channel is <strong>idle</strong>: begins frametransmission immediately</li><li>If NIC senses channel is <strong>busy</strong>: waits until channelbecomes idle, then transmits</li></ul></li><li><strong>Successful Transmission</strong><ul><li>If NIC transmits the entire frame without detecting anothertransmission</li><li>Transmission is complete and successful</li></ul></li><li><strong>Collision Handling</strong><ul><li>If NIC detects another transmission while transmitting</li><li>Immediately aborts transmission</li><li><strong>Sends a brief jam signal to ensure all stations recognizethe collision</strong></li></ul></li><li><strong>Exponential Backoff</strong><ul><li>After aborting, NIC enters exponential backoff procedure:</li><li>After the mᵗʰ collision, NIC chooses K randomly from{0,1,2,…,2ᵐ-1}</li><li>NIC waits <strong>K·512 bit times</strong> before attemptingretransmission</li><li>Returns to Step 2 to attempt transmission again</li></ul></li></ol><p>The exponential backoff mechanism ensures that after repeatedcollisions, stations spread their retransmission attempts overincreasingly longer intervals, reducing the probability of repeatedcollisions.</p><h2 id="ethernets-csmacd-technical-details">Ethernet’s CSMA/CD:Technical Details</h2><h3 id="collision-handling-components">Collision HandlingComponents</h3><ul><li><strong>Jam Signal</strong>:<ul><li>48-bit signal transmitted after detecting a collision</li><li>Purpose: Ensures all transmitting stations are aware of thecollision</li><li>Small, fixed size makes collision detection efficient</li><li>Contains a deliberate pattern that cannot be mistaken for validdata</li></ul></li><li><strong>Bit Time</strong>:<ul><li>The time required to transmit one bit on the network</li><li><strong>For <span class="math inline">\(10\)</span> Mbps Ethernet:<span class="math inline">\(0.1\)</span> microseconds perbit</strong></li><li>Used as the basic time unit for backoff calculations</li><li>For <strong><span class="math inline">\(K = 1023\)</span> (maximumbackoff value)</strong>, wait time is approximately <spanclass="math inline">\(50\)</span> milliseconds</li></ul></li></ul><h3 id="exponential-backoff-algorithm">Exponential BackoffAlgorithm</h3><ul><li><strong>Goal</strong>: Adaptively adjust retransmission timing basedon estimated network load<ul><li>Under heavy load conditions, stations wait longer beforeretrying</li><li>Helps prevent collision cascades when multiple stations arecompeting for access</li></ul></li><li><strong>Progressive Backoff Process</strong>:<ul><li>After first collision: Choose K randomly from <spanclass="math inline">\(\{0,1\}\)</span><ul><li>Wait time = <span class="math inline">\(K × 512\)</span> bittransmission times</li></ul></li><li>After second collision: Choose K randomly from <spanclass="math inline">\(\{0,1,2,3\}\)</span></li><li>After third collision: Choose K randomly from <spanclass="math inline">\(\{0,1,2,3,4,5,6,7\}\)</span></li><li>Pattern continues: After nth collision, range is <spanclass="math inline">\(\{0,1,2,...,2^n-1\}\)</span></li><li>After tenth collision: Choose K randomly from <spanclass="math inline">\(\{0,1,2,...,1023\}\)</span></li><li><strong>Maximum range is capped at <spanclass="math inline">\(\{0,1,2,...,1023\}\)</span> even after morecollisions</strong></li></ul></li></ul><p>This adaptive algorithm ensures efficient channel utilization bydynamically adjusting to network congestion levels, minimizing repeatedcollisions while maintaining reasonable access times.</p><h2 id="csmacd-efficiency">CSMA/CD efficiency</h2><ul><li><span class="math inline">\(t_{prop}\)</span>: max prop delaybetween <span class="math inline">\(2\)</span> nodes in LAN;</li><li><span class="math inline">\(t_{trans}\)</span>: time to transmitmax-size frame.</li></ul><p><span class="math display">\[\text{efficiency} = \frac{1}{1 + \frac{5 t_{prop}}{t_{trans}}}\]</span></p><h2 id="ethernet-standards-link-physical-layers">Ethernet Standards:Link &amp; Physical Layers</h2><figure><img src="The-Data-Link-Layer/621.png"style="display: block; margin: 0 auto; width: 100%" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><ul><li><strong>Common Foundation</strong>:<ul><li>All Ethernet variants share the same <strong>MAC protocol</strong>principles</li><li><strong>Frame format</strong> remains consistent acrossimplementations</li><li>Upper layers interact with Ethernet through the same interfaceregardless of physical medium</li></ul></li><li><strong>Speed Evolution</strong>:<ul><li><strong>2 Mbps</strong>: Early experimental implementations</li><li><strong>10 Mbps</strong>: Original Ethernet standard (10BASE-T)</li><li><strong>100 Mbps</strong>: Fast Ethernet (100BASE-TX,100BASE-FX)</li><li><strong>1 Gbps</strong>: Gigabit Ethernet (1000BASE-T,1000BASE-SX/LX)</li><li><strong>10 Gbps</strong>: 10 Gigabit Ethernet (10GBASE-T,10GBASE-SR/LR)</li><li><strong>Higher speeds</strong>: 40 Gbps, 100 Gbps, 400 Gbpstechnologies now available</li></ul></li><li><strong>Physical Media Diversity</strong>:<ul><li><strong>Copper cable</strong>:<ul><li>Twisted pair (Cat5e, Cat6, Cat6a, Cat7)</li><li>Coaxial cable (older implementations)</li></ul></li><li><strong>Optical fiber</strong>:<ul><li>Multimode fiber (shorter distances)</li><li>Single-mode fiber (longer distances)</li><li>Various wavelengths and transmission techniques</li></ul></li></ul></li></ul><p>This standardized approach allows equipment from differentmanufacturers to interoperate while enabling continuous performanceimprovements through new physical layer technologies.</p><h1 id="link-layer-switches">Link-Layer Switches</h1><h2 id="hubs">Hubs</h2><p>physical-layer (dumb) repeaters: - bits coming in one link go out allother links at same rate - all nodes connected to hub can collide withone another - no frame buffering - no CSMA/CD at hub: host NICs detectcollisions</p><figure><img src="The-Data-Link-Layer/hub.png"style="display: block; margin: 0 auto; width: 70%" alt="hub" /><figcaption aria-hidden="true">hub</figcaption></figure><h2 id="switch">Switch</h2><ul><li><strong>Link-layer intelligence</strong>:<ul><li>Smarter than hubs, taking an active role in network trafficmanagement</li><li>Process frames at the data link layer (Layer 2) rather than merelyrepeating signals</li><li>Make forwarding decisions based on MAC addresses</li></ul></li><li><strong>Store-and-forward operation</strong>:<ul><li>Receive complete frames before forwarding</li><li>Buffer frames in memory, allowing for collision domainisolation</li><li>Check frames for errors (using CRC) before forwarding, improvingnetwork reliability</li></ul></li><li><strong>Selective forwarding</strong>:<ul><li>Examine incoming frame’s destination MAC address</li><li>Forward frame only to the specific port where destination device isconnected</li><li>Send to multiple ports only when necessary (broadcasts, unknowndestinations)</li><li>When forwarding frames onto a segment, uses CSMA/CD to access themedium</li></ul></li><li><strong>Transparent operation</strong>:<ul><li>Hosts are completely unaware of switches’ presence in thenetwork</li><li>End devices communicate as if directly connected</li><li>No modification of frame content during transit through switch</li></ul></li><li><strong>Plug-and-play functionality</strong>:<ul><li>Self-learning capability builds forwarding tables automatically</li><li>Observes source MAC addresses of incoming frames to learn devicelocations</li><li>Dynamically updates tables when devices move to different ports</li><li>No manual configuration required for basic operation</li></ul></li></ul><p>These capabilities allow switches to significantly improve networkperformance by creating separate collision domains for each port whilemaintaining the same Ethernet protocol standards.</p><h3 id="switch-advanced-link-layer-functionality">Switch: AdvancedLink-Layer Functionality</h3><ul><li><strong>Simultaneous transmissions</strong>:<ul><li>Allows multiple pairs of nodes to transmit concurrently</li><li>Different ports can carry independent data streams at the sametime</li><li>Dramatically increases total network throughput compared tohubs</li></ul></li><li><strong>Dedicated connections</strong>:<ul><li>Each host has a dedicated, direct connection to the switch</li><li>Full bandwidth of the link is available to each host-switchconnection</li><li>No competition for bandwidth between devices on different ports</li></ul></li><li><strong>Frame buffering</strong>:<ul><li>Switches contain memory to store frames temporarily</li><li>Can hold frames when output ports are busy</li><li>Prevents frame loss during periods of network congestion</li><li>Enables handling of traffic between different speed interfaces</li></ul></li><li><strong>Collision elimination</strong>:<ul><li>Ethernet protocol used on each link but without collisions</li><li>Full-duplex operation: simultaneous transmission and reception</li><li>Each link is its own separate collision domain</li><li>CSMA/CD no longer needed on point-to-point links to switch</li></ul></li><li><strong>Parallel communications</strong>:<ul><li>Host A can transmit to host A’ while host B simultaneously transmitsto host B’</li><li>No interference between unrelated data flows</li><li>Example: In a network with hosts A, A’, B, and B’ all connected to aswitch:<ul><li>A→A’ and B→B’ transmissions occur in parallel</li><li>Network throughput effectively multiplied by number of concurrenttransmissions</li></ul></li></ul></li><li><strong>Contrast with hubs</strong>:<ul><li>Hubs force a single shared collision domain among all connecteddevices</li><li>Only one device can transmit at any given time with a hub</li><li>Switches enable parallel, independent data flows that hubs cannotsupport</li></ul></li></ul><h2 id="switch-table">Switch Table</h2><p>Q: How does switch know that A’ reachable via interface 4, B’reachable via interface 5?</p><p>A: Each switch has a switch table, each entry contains</p><ul><li>MAC address of host</li><li>Interface to reach host</li><li>Time stamp</li></ul><p>This structure is similar to a routing table, but operates at Layer 2(MAC addresses) rather than Layer 3 (IP addresses).</p><p>Q: How are entries created, maintained in switch table? Somethinglike a routing protocol?</p><p>A: Switch tables are built through self-learning</p><ol type="1"><li><strong>Self-learning process</strong>:<ul><li>Initially the switch table is empty</li><li>When a frame arrives, the switch records the sender’s MAC addressand the interface on which it arrived</li><li>The switch learns the location of hosts based on the source MACaddress of incoming frames</li></ul></li><li><strong>Table maintenance</strong>:<ul><li>Each entry has a time-to-live (typically 20-30 minutes)</li><li>Entries are refreshed when new frames from the same sourcearrive</li><li>Entries timeout and are removed if not refreshed before TTLexpires</li></ul></li><li><strong>Handling unknown destinations</strong>:<ul><li>If destination MAC is unknown (not in table), the switch floods theframe to all interfaces except the one it arrived on</li><li>Once the destination host responds, its location is learned</li></ul></li><li><strong>Key differences from routing protocols</strong>:<ul><li>No explicit protocol messages exchanged between switches for MAClearning</li><li>Learning is passive, based solely on observing normal traffic</li><li>Completely automatic with no configuration required</li></ul></li></ol><h2 id="switch-self-learning">Switch: Self-Learning</h2><h3 id="learning-host-locations">Learning Host Locations</h3><ul><li><strong>Basic principle</strong>: Switches automatically learn whichhosts are located on which interfaces</li><li><strong>No configuration required</strong>: Learning happensdynamically as frames traverse the switch</li><li><strong>Process for each incoming frame</strong>:<ol type="1"><li>Switch examines the <strong>source MAC address</strong> in the frameheader</li><li>Switch records the <strong>interface</strong> on which the framearrived</li><li>Switch associates this MAC address with this interface in itstable</li><li>Timestamp is recorded for the entry for aging purposes</li></ol></li></ul><h3 id="switch-table-management">Switch Table Management</h3><ul><li><strong>Dynamic updates</strong>: If a host moves to a differentport, the switch updates its table when the host transmits</li><li><strong>Aging mechanism</strong>: Each entry includes a time-to-live(typically 20-30 minutes)<ul><li>Entries are refreshed when new frames from the same sourcearrive</li><li>If no frames are received from a MAC address before TTL expires,entry is removed</li></ul></li><li><strong>Adaptation to network changes</strong>: Tables automaticallyadjust when:<ul><li>New devices connect to the network</li><li>Existing devices are moved to different switch ports</li><li>Devices are removed from the network</li></ul></li></ul><h3 id="handling-unknown-destinations">Handling UnknownDestinations</h3><ul><li><strong>Initial state</strong>: Empty table when switch bootsup</li><li><strong>Flooding</strong>: When destination is unknown (not intable), switch forwards frame out all interfaces except the arrivalinterface</li><li><strong>Progressive learning</strong>: Table builds up as hosts sendframes, gradually reducing the need for flooding</li><li><strong>Self-correcting</strong>: If an entry becomes outdated,flooding will occur until the host location is relearned</li></ul><p>This passive learning approach enables plug-and-play networking withminimal administrative overhead.</p><h2 id="switch-frame-filteringforwarding">Switch: FrameFiltering/Forwarding</h2><h3 id="frame-processing-algorithm">Frame Processing Algorithm</h3><p>When a frame is received by a switch, it follows this decisionprocess:</p><ol type="1"><li><strong>Record source information</strong>:<ul><li>Record the link/interface associated with the sending host</li><li>Update or create switch table entry for source MAC address</li></ul></li><li><strong>Destination lookup</strong>:<ul><li>Index the switch table using the destination MAC address</li></ul></li><li><strong>Forwarding decision</strong>:<ul><li>If destination MAC entry is found in table:<ul><li>If destination is on same segment from which frame arrived:<ul><li>Drop the frame (no need to forward to the same segment)</li></ul></li><li>Else:<ul><li>Forward the frame on the interface indicated in the table entry</li></ul></li></ul></li><li>Else (destination not found in table):<ul><li>Flood the frame (forward on all interfaces except the one on whichit arrived)</li></ul></li></ul></li><li><strong>Flooding process</strong>:<ul><li>When flooding is required, the frame is sent out all switchports</li><li>Exception: Never send the frame back on the interface where it wasreceived</li><li>This ensures the destination will receive the frame if it exists onthe network</li><li>Subsequent replies will help the switch learn the destination’slocation</li></ul></li></ol><p>This algorithm combines the efficiency of direct forwarding with thereliability of flooding when necessary, while also preventingunnecessary network traffic through frame filtering.</p><h2 id="switches-vs.-routers-key-differences">Switches vs. Routers: KeyDifferences</h2><h3 id="similarities">Similarities</h3><ul><li>Both are <strong>store-and-forward devices</strong><ul><li>Receive complete packets/frames before processing andforwarding</li><li>Buffer data during processing</li></ul></li></ul><h3 id="fundamental-differences">Fundamental Differences</h3><table><thead><tr><th>Characteristic</th><th>Switches</th><th>Routers</th></tr></thead><tbody><tr><td><strong>OSI Layer</strong></td><td>Link layer (Layer 2)</td><td>Network layer (Layer 3)</td></tr><tr><td><strong>Addressing</strong></td><td>Use MAC addresses</td><td>Use IP addresses</td></tr><tr><td><strong>Header Examination</strong></td><td>Examine frame headers</td><td>Examine packet headers</td></tr><tr><td><strong>Decision Making</strong></td><td>Simple forwarding based on MAC address</td><td>Complex routing decisions based on network topology</td></tr></tbody></table><h3 id="table-management">Table Management</h3><ul><li><strong>Switches</strong>:<ul><li>Maintain switch tables mapping MAC addresses to interfaces</li><li>Implement self-learning algorithms (passive learning fromtraffic)</li><li>Use filtering to prevent unnecessary traffic propagation</li><li>Tables built automatically without configuration</li></ul></li><li><strong>Routers</strong>:<ul><li>Maintain routing tables mapping network addresses to next hops</li><li>Implement dynamic routing algorithms (RIP, OSPF, BGP, etc.)</li><li>Exchange routing protocol messages with other routers</li><li>Often require explicit configuration</li></ul></li></ul><h3 id="operational-scope">Operational Scope</h3><ul><li><strong>Switches</strong>: Operate within a single network(broadcast domain)</li><li><strong>Routers</strong>: Connect multiple networks and provideinter-network communication</li></ul><p>These fundamental differences reflect their different roles innetwork architecture: switches optimize local traffic flow withinnetworks, while routers enable traffic to traverse between differentnetworks.</p><figure><img src="The-Data-Link-Layer/624.png"style="display: block; margin: 0 auto; width: 70%" alt="Route" /><figcaption aria-hidden="true">Route</figcaption></figure><h2 id="virtual-local-area-networks-vlans">Virtual Local Area Networks(VLANs)</h2><h3 id="q-vlan-frame-format">802.1Q VLAN Frame Format</h3><ul><li>Compares standard 802.1 Ethernet frame with 802.1Q VLAN frame</li><li>802.1Q frame adds a 2-byte Tag Protocol Identifier (value:81-00)</li><li>Includes Tag Control Information with 12-bit VLAN ID field and 3-bitpriority field</li><li>CRC is recomputed to account for the added header fields</li><li>Allows frames to carry VLAN identification information</li></ul><h3 id="vlans-spanning-multiple-switches">VLANs Spanning MultipleSwitches</h3><ul><li>VLANs can extend across multiple physical switches</li><li>Trunk ports connect switches and carry frames between VLANs</li><li>Frames forwarded between switches must use 802.1Q protocol tomaintain VLAN information</li><li>Example shows Electrical Engineering VLAN (ports 1-8) and ComputerScience VLAN (ports 9-15) spanning two switches</li><li>Trunk ports ensure proper VLAN segregation across the extendednetwork</li></ul><h3 id="port-based-vlan">Port-based VLAN</h3><ul><li>Provides traffic isolation between different port groups</li><li>Supports dynamic membership where port</li><li>s can be reassigned to different VLANs</li><li>Communication between VLANs requires routing, similar to separatephysical networks</li><li>VLANs can be defined by port numbers or by MAC addresses ofendpoints</li><li>Vendors typically offer combined switch/router devices to facilitateinter-VLAN routing</li></ul><h3 id="vlan-concept-overview">VLAN Concept Overview</h3><ul><li>Defines VLANs as virtual networks created on a single physicalinfrastructure</li><li>A single physical switch operates as multiple virtual switches</li><li>Logically separates networks (e.g., Electrical Engineering fromComputer Science)</li><li>Provides network segmentation without requiring separate physicalswitches</li><li>Increases network flexibility, security, and managementcapabilities</li></ul><h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1><h2 id="r.8">R.8</h2><p><strong>Question</strong></p><p>How big is the <span class="math inline">\(\text{MAC}\)</span>address space? The <span class="math inline">\(\text{IPv4}\)</span>address space? The <span class="math inline">\(\text{IPv6}\)</span>address space?</p><p><strong>Answer</strong></p><p>The sizes of the three address spaces are:</p><h3 id="mac-address-space">MAC Address Space</h3><ul><li><strong>Size</strong>: <span class="math inline">\(2^{48}\)</span>possible addresses</li><li><strong>Format</strong>: <span class="math inline">\(48\)</span>-bitaddresses, typically represented as six groups of two hexadecimal digits(e.g., <code>00:1A:2B:3C:4D:5E</code>)</li></ul><h3 id="ipv4-address-space">IPv4 Address Space</h3><ul><li><strong>Size</strong>: <span class="math inline">\(2^{32}\)</span>possible addresses</li><li><strong>Format</strong>: <span class="math inline">\(32\)</span>-bitaddresses, typically represented as four decimal numbers separated bydots (e.g., <code>192.168.1.1</code>)</li></ul><h3 id="ipv6-address-space">IPv6 Address Space</h3><ul><li><strong>Size</strong>: <span class="math inline">\(2^{128}\)</span>possible addresses</li><li><strong>Format</strong>: <spanclass="math inline">\(128\)</span>-bit addresses, typically representedas eight groups of four hexadecimal digits separated by colons (e.g.,<code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>)</li></ul><p>The IPv6 address space is vastly larger than both MAC and IPv4address spaces, which was designed to address the IPv4 addressexhaustion problem.</p><h2 id="p.4">P.4</h2><p><strong>Consider the previous problem, but instead of containing thebinary of the numbers 0 through 9 suppose these 10 bytescontain.</strong></p><p><strong>Questions and Answers:</strong></p><ol type="a"><li>the binary representation of the numbers 1 through 10.</li><li>the ASCII representation of the letters A through J(uppercase).</li><li>the ASCII representation of the letters a through j (lowercase).Compute the Internet checksum for this data.</li></ol><p>下面按 16-bit 大端顺序（高字节在前）计算 Internet校验和（ones’complement sum）：</p><ol type="1"><li>每两个字节组成一个 16-bit 字，超出 0xFFFF时将高位环回加到低位。</li><li>对所有字求和后取反。</li></ol><ol type="a"><li>数值 1 ～ 10（二进制，字节值 0x01～0x0A）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x01 0x02 → 0x0102  <br>0x03 0x04 → 0x0304  <br>0x05 0x06 → 0x0506  <br>0x07 0x08 → 0x0708  <br>0x09 0x0A → 0x090A  <br>Sum = 0x0102+0x0304+0x0506+0x0708+0x090A = 0x191E  <br>Checksum = ~0x191E = 0xE6E1<br></code></pre></td></tr></table></figure><ol start="2" type="a"><li>大写字母 A ～ J（ASCII 0x41～0x4A）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x41 0x42 → 0x4142  <br>0x43 0x44 → 0x4344  <br>0x45 0x46 → 0x4546  <br>0x47 0x48 → 0x4748  <br>0x49 0x4A → 0x494A  <br>Sum = 0x4142+0x4344+0x4546+0x4748+0x494A = 0x5A5F  <br>Checksum = ~0x5A5F = 0xA5A0<br></code></pre></td></tr></table></figure><ol start="3" type="a"><li>小写字母 a ～ j（ASCII 0x61～0x6A）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x61 0x62 → 0x6162  <br>0x63 0x64 → 0x6364  <br>0x65 0x66 → 0x6566  <br>0x67 0x68 → 0x6768  <br>0x69 0x6A → 0x696A  <br>Sum = 0x6162+0x6364+0x6566+0x6768+0x696A = 0xFAFF  <br>Checksum = ~0xFAFF = 0x0500<br></code></pre></td></tr></table></figure><h2 id="p.11">P.11</h2><p>Suppose four active nodes—nodes A, B, C and D—are competing foraccess to a channel using slotted ALOHA. Assume each node has aninfinite number of packets to send. Each node attempts to transmit ineach slot with probability p. The first slot is numbered slot 1, thesecond slot is numbered slot 2, and so on.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is the probability that node A succeeds for the firsttime in slot 5?</strong></p><p>在单个 slot 中成功的概率：<spanclass="math display">\[P_{\text{succ}} = p (1 - p)^{3}\]</span></p><p>在前 4 个 slot 中都未成功的概率：<spanclass="math display">\[P_{\text{4s}} = \left(1 -P_{\text{succ}}\right)^{4}\]</span></p><p>也就是：<span class="math display">\[P(\text{first success in slot5}) = \bigl[1 - p(1-p)^3\bigr]^4 \times p(1-p)^3.\]</span></p><p><strong>b. What is the probability that some node (either A, B, C orD) succeeds in slot 4?</strong></p><p>总共有 <span class="math inline">\(N = 4\)</span> 个结点，某个结点在slot4 成功的概率为： <span class="math display">\[P_{\text{succ}} = 4 \cdot p \cdot (1 - p)^{3}\]</span></p><p><strong>c. What is the probability that the first success occurs inslot 3?</strong></p><p>第一次成功出现在 slot3 的概率 <span class="math display">\[P = (1-4p(1-p)^3)^2 \cdot 4p(1-p)^3\]</span></p><p><strong>d. What is the efficiency of this four-nodesystem?</strong></p><p>我们需要计算出使得 <span class="math inline">\(Np(1-p)^{N-1}\)</span>最大的 <span class="math inline">\(p\)</span>，记原式子为 <spanclass="math inline">\(L(p)\)</span>，最优解为 <spanclass="math inline">\(p^{\ast}\)</span>。对 <spanclass="math inline">\(p\)</span> 求偏导： <span class="math display">\[\frac{\partial L(p)}{\partial p} = 4(1 - p)^{3} - 12p(1 - p)^{2}\]</span></p><p>得到 <span class="math display">\[p^{\ast} = 0.25\]</span></p><p>所以，效率为： <span class="math display">\[\text{efficiency} = 4 \times 0.25 \times 0.75^3 = \frac{27}{64}\]</span></p><h2 id="p.17">P.17</h2><p><strong>Question and Answer:</strong></p><p>Recall that with the CSMA/CD protocol, the adapter waits <spanclass="math inline">\(K \cdot 512\)</span> bit times after a collision,where <span class="math inline">\(K\)</span> is drawn randomly. For<span class="math inline">\(K = 100\)</span>, how long does the adapterwait until returning to Step 2 for a <spanclass="math inline">\(10\)</span> Mbps Ethernet? For a <spanclass="math inline">\(100\)</span> Mbps Ethernet?</p><p>等待时间的计算公式为： <span class="math display">\[T = K \cdot 512 \cdot t_{\text{bit}}\]</span></p><p>其中，<span class="math inline">\(t_{\text{bit}}\)</span>是比特时间，其计算公式为： <span class="math display">\[t_{\text{bit}} = \frac{1}{\text{传输速率}}\]</span></p><p>分别带入 <span class="math inline">\(10\)</span> Mbps 和 <spanclass="math inline">\(100\)</span> Mbps，解得分别等待时间为<strong><span class="math inline">\(5.12\)</span> ms</strong> 和<strong><span class="math inline">\(0.512\)</span> ms</strong>。</p><h2 id="p.18">P.18</h2><p><strong>Question and Answer:</strong></p><p>Suppose nodes A and B are on the same <spanclass="math inline">\(10\)</span> Mbps Ethernet bus, and the propagationdelay between the two nodes is <span class="math inline">\(325\)</span>bit times. Suppose node A begins transmitting a frame and, before itfinishes, node B begins transmitting a frame. Can A finish transmittingbefore it detects that B has transmitted? Why or why not? If the answeris yes, then A incorrectly believes that its frame was successfullytransmitted without a collision. <em>Hint</em>: Suppose at time <spanclass="math inline">\(t = 0\)</span> bit times, A begins transmitting aframe. In the worst case, A transmits a minimum-sized frame of <spanclass="math inline">\(512 + 64\)</span> bit times. So A would finishtransmitting the frame at <span class="math inline">\(t = 512 +64\)</span> bit times. Thus, the answer is no, if B’s signal reaches Abefore bit time <span class="math inline">\(t = 512 + 64\)</span> bits.In the worst case, when does B’s signal reach A?</p><ol type="1"><li><strong>传播延迟计算</strong><ul><li>两节点之间的传播延迟为 <span class="math inline">\(325\)</span>比特时间。</li><li>因此，B 的信号从 B 传播到 A 所需的时间为 <spanclass="math inline">\(325\)</span> 比特时间。</li></ul></li><li><strong>最小帧传输时间</strong><ul><li>A 传输一个最小帧所需的时间为 <span class="math inline">\(512 + 64 =576\)</span> 比特时间。</li></ul></li><li><strong>碰撞检测条件</strong><ul><li>如果 B 的信号在 A 完成帧传输之前到达 A，则 A 可以检测到碰撞。</li><li>在最坏情况下，B 在传播延迟的最后一刻（即 <spanclass="math inline">\(t = 325\)</span> 比特时间）开始传输。</li><li>B 的信号需要 <span class="math inline">\(325\)</span> 比特时间到达A，因此 B 的信号到达 A 的时间为： <span class="math display">\[t_{\text{到达}} = 325 + 325 = 650 \, \text{比特时间}\]</span></li></ul></li><li><strong>结论</strong><ul><li>A 在 <span class="math inline">\(t = 576\)</span>比特时间完成帧传输，而 B 的信号在 <span class="math inline">\(t =650\)</span> 比特时间到达 A。</li><li>因此，A<strong>无法检测到碰撞</strong>，并会错误地认为其帧已成功传输。</li></ul></li></ol><h2 id="p.27">P.27</h2><p><strong>Question and Answer:</strong></p><p>Consider Figure <span class="math inline">\(5.38\)</span> in problemP<span class="math inline">\(14\)</span>. Provide MAC addresses and IPaddresses for the interfaces at Host A, both routers, and Host F.Suppose Host A sends a datagram to Host F. Give the source anddestination MAC addresses in the frame encapsulating this IP datagram asthe frame is transmitted <em>(i)</em> from A to the left router,<em>(ii)</em> from the left router to the right router, <em>(iii)</em>from the right router to F. Also give the source and destination IPaddresses in the IP datagram encapsulated within the frame at each ofthese points in time.</p><figure><imgsrc="The-Data-Link-Layer/Three%20subnets,%20interconnected%20by%20routers.png"style="display: block; margin: 0 auto; width: 50%" alt="Figure 5.38" /><figcaption aria-hidden="true">Figure 5.38</figcaption></figure><p>Assign IP addresses to all of the interfaces. For Subnet <spanclass="math inline">\(1\)</span> use addresses of the form<code>192.168.1.xxx</code>; for Subnet <spanclass="math inline">\(2\)</span> uses addresses of the form<code>192.168.2.xxx</code>; and for Subnet <spanclass="math inline">\(3\)</span> use addresses of the form<code>192.168.3.xxx</code>. Assign MAC addresses to all of theadapters.</p><p><span class="math inline">\(14\)</span> 和 <spanclass="math inline">\(27\)</span> 都没有明确说明 IP address 和 MACaddress。先分配接口，如下表所示。</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>设备/接口</th><th>子网</th><th>IP 地址</th><th>MAC 地址</th></tr></thead><tbody><tr><td>Host A</td><td>Subnet 1</td><td>192.168.1.1</td><td>AA-AA-AA-AA-AA-AA</td></tr><tr><td>Host B</td><td>Subnet 1</td><td>192.168.1.2</td><td>BB-BB-BB-BB-BB-BB</td></tr><tr><td>Router1-接口1</td><td>Subnet 1</td><td>192.168.1.254</td><td>A1-B1-C1-D1-E1-F1</td></tr><tr><td>Router1-接口2</td><td>Subnet 2</td><td>192.168.2.1</td><td>A1-B2-C2-D2-E2-F2</td></tr><tr><td>Router2-接口1</td><td>Subnet 2</td><td>192.168.2.254</td><td>A2-B1-C1-D1-E1-F1</td></tr><tr><td>Router2-接口2</td><td>Subnet 3</td><td>192.168.3.1</td><td>A2-B2-C2-D2-E2-F2</td></tr><tr><td>Host C</td><td>Subnet 2</td><td>192.168.2.2</td><td>CC-CC-CC-CC-CC-CC</td></tr><tr><td>Host D</td><td>Subnet 2</td><td>192.168.2.3</td><td>DD-DD-DD-DD-DD-DD</td></tr><tr><td>Host E</td><td>Subnet 3</td><td>192.168.3.2</td><td>EE-EE-EE-EE-EE-EE</td></tr><tr><td>Host F</td><td>Subnet 3</td><td>192.168.3.3</td><td>FF-FF-FF-FF-FF-FF</td></tr></tbody></table></div><p><strong><em>(i)</em> from A to the left router</strong> -<strong>Source MAC address</strong>: <code>AA-AA-AA-AA-AA-AA</code>. -<strong>Destination MAC address</strong>:<code>A1-B1-C1-D1-E1-F1</code>.</p><p><strong><em>(ii)</em> from the left router to the rightrouter</strong> - <strong>Source MAC address</strong>:<code>A1-B2-C2-D2-E2-F2</code>. - <strong>Destination MACaddress</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</p><p><strong><em>(iii)</em> from the right router to F</strong> -<strong>Source MAC address</strong>: <code>A2-B2-C2-D2-E2-F2</code>. -<strong>Destination MAC address</strong>:<code>FF-FF-FF-FF-FF-FF</code>.</p><h2 id="p.28">P.28</h2><p>Suppose now that the leftmost router in Figure <spanclass="math inline">\(5.38\)</span> is replaced by a switch. Hosts A, B,C, and D and the right router are all star-connected into this switch.Give the source and destination MAC addresses in the frame encapsulatingthis IP datagram as the frame is transmitted <em>(i)</em> from A to theswitch, <em>(ii)</em> from the switch to the right router,<em>(iii)</em> from the right router to F. Also give the source anddestination IP addresses in the IP datagram encapsulated within theframe at each of these points in time.</p><p>首先需要明确的是，switch 的每个接口都有一个 MAC address，但由于switch 并不会修改经过它的 frame，这里简单地用一个 MAC address概括。同时，理论上 subnet1 和 subnet2 应该合为一个subnet，但接下来的结果仍做区分（因为题目要仍在问 MAC address）。</p><p>接上题的接口配置，做简单修改：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>设备/接口</th><th>子网</th><th>IP 地址</th><th>MAC 地址</th></tr></thead><tbody><tr><td>Host A</td><td>Subnet 1</td><td>192.168.1.1</td><td>AA-AA-AA-AA-AA-AA</td></tr><tr><td>Host B</td><td>Subnet 1</td><td>192.168.1.2</td><td>BB-BB-BB-BB-BB-BB</td></tr><tr><td>Switch</td><td>Subnet 1 2</td><td>192.168.1.254</td><td>A1-B1-C1-D1-E1-F1</td></tr><tr><td>Router2-接口1</td><td>Subnet 2</td><td>192.168.2.254</td><td>A2-B1-C1-D1-E1-F1</td></tr><tr><td>Router2-接口2</td><td>Subnet 3</td><td>192.168.3.1</td><td>A2-B2-C2-D2-E2-F2</td></tr><tr><td>Host C</td><td>Subnet 2</td><td>192.168.2.2</td><td>CC-CC-CC-CC-CC-CC</td></tr><tr><td>Host D</td><td>Subnet 2</td><td>192.168.2.3</td><td>DD-DD-DD-DD-DD-DD</td></tr><tr><td>Host E</td><td>Subnet 3</td><td>192.168.3.2</td><td>EE-EE-EE-EE-EE-EE</td></tr><tr><td>Host F</td><td>Subnet 3</td><td>192.168.3.3</td><td>FF-FF-FF-FF-FF-FF</td></tr></tbody></table></div><p><strong><em>(i)</em> from A to the switch</strong> - <strong>SourceMAC address</strong>: <code>AA-AA-AA-AA-AA-AA</code>. -<strong>Destination MAC address</strong>:<code>A2-B1-C1-D1-E1-F1</code>.</p><p><strong><em>(ii)</em> from the switch to the right router</strong> -<strong>Source MAC address</strong>: <code>A1-B1-C1-D1-E1-F1</code>. -<strong>Destination MAC address</strong>:<code>A2-B1-C1-D1-E1-F1</code>.</p><p><strong><em>(iii)</em> from the right router to F</strong> -<strong>Source MAC address</strong>: <code>A2-B2-C2-D2-E2-F2</code>. -<strong>Destination MAC address</strong>:<code>FF-FF-FF-FF-FF-FF</code>.</p><h2 id="p.32">P.32</h2><figure><imgsrc="The-Data-Link-Layer/A%20link-layer%20switch%20inter-connecting%20six%20nodes.png"style="display: block; margin: 0 auto; width: 60%"alt="A link-layer switch inter-connecting six nodes" /><figcaption aria-hidden="true">A link-layer switch inter-connecting sixnodes</figcaption></figure><p>Let’s consider the operation of a learning switch in the context ofFigure <span class="math inline">\(5.24\)</span>. Suppose that<em>(i)</em> B sends a frame to E, <em>(ii)</em> E replies with a frameto B, <em>(iii)</em> A sends a frame to B, <em>(iv)</em> B replies witha frame to A. The switch table is initially empty. Show the state of theswitch table before and after each of these events. For each of theseevents, identify the link(s) on which the transmitted frame will beforwarded, and briefly justify your answers.</p><p>按字典序从小到大的顺序分配接口，用如下表格总结题目所述过程：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>步骤</th><th>事件</th><th>表项变化</th><th>转发链路</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>B→E</td><td>+B@2</td><td>1,3,4,5,6</td><td>泛洪</td></tr><tr><td>2</td><td>E→B</td><td>+E@5</td><td>2</td><td>定向转发</td></tr><tr><td>3</td><td>A→B</td><td>+A@1</td><td>2</td><td>定向转发</td></tr><tr><td>4</td><td>B→A</td><td>B@2 刷新</td><td>1</td><td>定向转发</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Data Link Layer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>朴素贝叶斯法</title>
    <link href="/2025/06/04/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/"/>
    <url>/2025/06/04/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="textnaive-bayes"><span class="math inline">\(\text{NaiveBayes}\)</span></h2><p><strong>朴素</strong>贝叶斯法基于一个强假设，即特征条件独立性。由条件独立性假设可将公式<span class="math inline">\((2)\)</span> 化简为公式 <spanclass="math inline">\((3)\)</span>。此外，朴素贝叶斯法是对输入进行<strong>分类</strong>，这其中的机理涉及到两个概念：<strong>先验概率</strong>和<strong>后验概率</strong>；先验概率是类别的先验分布<span class="math inline">\(P(Y)\)</span>，条件概率 <spanclass="math inline">\(P(X |Y)\)</span>是在类别条件下输入的分布，后验概率 <span class="math inline">\(P(Y|X)\)</span>是在输入条件下类的分布；最后我们选择后验概率最大的分类情况作为输入的类标签。</p><h2 id="朴素贝叶斯法的学习与分类">朴素贝叶斯法的学习与分类</h2><h3 id="基本方法">基本方法</h3><p>设输入空间 <span class="math inline">\(\mathcal{X} \in\mathbb{R}^n\)</span> 为 <span class="math inline">\(n\)</span>维向量的集合，输出空间类标记集合 <span class="math inline">\(\mathcal{Y}= \{c_1, c_2, \cdots, c_K \}\)</span>。训练数据集</p><p><span class="math display">\[T = \{(x_1, y_1), (x_2, y_2), \dots, (x_N, y_N)\}\]</span></p><p>由 <span class="math inline">\(P(X, Y)\)</span> 独立同分布产生。</p><p>朴素贝叶斯法通过训练数据集学习联合概率分布 <spanclass="math inline">\(P(X,Y)\)</span>。具体地，学习以下先验概率分布及条件概率分布。先验概率分布</p><p><span class="math display">\[P(Y = c_k), \quad k = 1, 2, \cdots K \tag{1}\]</span></p><p>条件概率分布</p><p><span class="math display">\[P(X = x |Y = c_k) = P(X^{(1)} = x^{(1)}, \cdots, X^{(n)} = x^{(n)} |Y =c_k), \quad k = 1, 2, \cdots, K \tag{2}\]</span></p><p>于是学习到联合概率分布 <span class="math inline">\(P(X,Y)\)</span>。</p><p>由条件独立性假设得</p><p><span class="math display">\[P(X = x |Y = c_k) = \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)\tag{3}\]</span></p><p>朴素贝叶斯法分类时，对给定的输入 <spanclass="math inline">\(x\)</span>，通过学习到的模型计算后验概率分布 <spanclass="math inline">\(P(Y = c_k |X = x)\)</span>，将后验概率最大的类作为<span class="math inline">\(x\)</span> 的类输出。后验概率计算如下：</p><p><span class="math display">\[P(Y = c_k |X = x) = \frac{P(X = x |Y = c_k) P(Y = c_k)}{\sum_{k} P(X = x|Y = c_k) P(Y = c_k)} \tag{4}\]</span></p><p>也就是：</p><p><span class="math display">\[P(Y = c_k |X = x) = \frac{P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} =x^{(j)} |Y = c_k)}{\sum_{k} P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} =x^{(j)} |Y = c_k)} \tag{5}\]</span></p><p>这是朴素贝叶斯法分类的基本公式。于是，朴素贝叶斯分类器可表示为</p><p><span class="math display">\[y = f(x) = \operatorname{arg} \max_{c_k} \frac{P(Y = c_k) \prod_{j =1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)}{\sum_{k} P(Y = c_k) \prod_{j =1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)} \tag{6}\]</span></p><p>注意到分母对所有 <span class="math inline">\(c_k\)</span>都是相同的，所以，</p><p><span class="math display">\[y = f(x) = \operatorname{arg} \max_{c_k} P(Y = c_k) \prod_{j = 1}^{n}P(X^{(j)} = x^{(j)} |Y = c_k) \tag{7}\]</span></p><h3 id="后验概率最大化的含义">后验概率最大化的含义</h3><p>朴素贝叶斯法将实例分到后验概率最大的类中。这等价于期望风险最小化。假设选择0-1 损失函数：</p><p><span class="math display">\[L(Y, f(X)) =  \begin{cases}1, &amp;Y \neq f(X)\\[10pt]0, &amp;Y = f(X)\end{cases}\]</span></p><p>式中 <span class="math inline">\(f(X)\)</span>是分类决策函数。这时，期望风险函数为</p><p><span class="math display">\[R_{\exp}(f) = \mathbf{E}[L(Y, f(X))]\]</span></p><p>期望是对联合分布 <span class="math inline">\(P(X,Y)\)</span>取的。由此取条件期望：</p><p><span class="math display">\[R_{\exp}(f) = \mathbf{E_{X}} \sum_{k = 1}^{K}[L(c_k, f(X))] P(c_k |X)\]</span></p><p>为了使期望风险最小化，只需对 <span class="math inline">\(X =x\)</span> 逐个极小化，由此得到：</p><p><span class="math display">\[f(x) = \operatorname{arg} \max_{y \in \mathcal{Y}} P(y = c_k |X = x)\]</span></p><h2 id="朴素贝叶斯法的参数估计">朴素贝叶斯法的参数估计</h2><h3 id="学习与分类算法">学习与分类算法</h3><p>输入：训练数据 <span class="math inline">\(T = \{(x_1, y_1), (x_2,y_2), \dots, (x_N, y_N)\}\)</span>，其中 <span class="math inline">\(x_i= (x_i^{(1)}, x_i^{(2)}, \dots, x_i^{(n)})\)</span>，<spanclass="math inline">\(x_i^{(j)}\)</span> 是第 <spanclass="math inline">\(i\)</span> 个样本的第 <spanclass="math inline">\(j\)</span> 个特征，<spanclass="math inline">\(x_i^{(j)} \in \{a_{j1}, a_{j2}, \cdots,a_{jS_j}\}\)</span> 是特征 <spanclass="math inline">\(x_i^{(j)}\)</span> 的可能取值，<spanclass="math inline">\(y_i \in \{c_1, c_2, \cdots, c_K\}\)</span>。输出：实例 <span class="math inline">\(x\)</span> 的分类。</p><p><strong>（1）计算先验概率及条件概率</strong> <spanclass="math display">\[\begin{align*}P(Y = c_k) &amp;= \frac{\sum_{i = 1}^{N} I(y_i = ck)}{N}, \quad k = 1,2, \cdots, K\\[10pt]P(X^{(j)} = a_{jl} |Y = c_k) &amp;= \frac{\sum_{i = 1}^{N} I(x_i^{(j)} =a_{jl}, y_i = c_k)}{\sum_{i = 1}^{N} I(y_i = c_k)}\\[10pt]j = 1, 2, \cdots, n; \quad l &amp;= 1, 2, \cdots, S_j; \quad k = 1, 2,\cdots, K\end{align*}\]</span> <strong>（2）对于给定实例 <span class="math inline">\(x =(x^{(1)}, x^{(2)}, \dots, x^{(n)})\)</span>，计算：</strong> <spanclass="math display">\[P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k), \quad k = 1,2, \cdots, K\]</span> <strong>（3）确定实例 <span class="math inline">\(x\)</span>的类</strong> <span class="math display">\[y = \operatorname{arg} \max_{c_k} P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)}= x^{(j)} |Y = c_k)\]</span></p><h3 id="贝叶斯估计">贝叶斯估计</h3><p>用极大似然估计可能会出现所要估计的概率值为 <spanclass="math inline">\(0\)</span> 的情况。这是采用贝叶斯估计。</p><p><span class="math display">\[\begin{align*}P_{\lambda}(X^{(j)} = a_{jl} |Y = c_k) &amp;= \frac{\sum_{i = 1}^{N}I(x_i^{(j)} = a_{jl}, y_i = c_k) + \lambda}{\sum_{i = 1}^{N} I(y_i =c_k) + S_j \lambda} \tag{8}\\[10pt]P_{\lambda}(Y = c_k) &amp;= \frac{\sum_{i = 1}^{N} I(y_i = c_k) +\lambda}{N + K \lambda} \tag{9}\end{align*}\]</span></p><p>常取 <span class="math inline">\(\lambda = 1\)</span></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>期望极大</title>
    <link href="/2025/06/03/%E6%9C%9F%E6%9C%9B%E6%9E%81%E5%A4%A7/"/>
    <url>/2025/06/03/%E6%9C%9F%E6%9C%9B%E6%9E%81%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="em-算法">EM 算法</h2><p><span class="math inline">\(\operatorname{EM}\)</span> 算法通过迭代求<span class="math inline">\(L(\theta) = \log P(Y | \theta)\)</span>的极大似然估计。每次迭代包含两步：<spanclass="math inline">\(\operatorname{E}\)</span> 步，求期望；<spanclass="math inline">\(\operatorname{M}\)</span> 步，求极大化。</p><h3 id="算法步骤">算法步骤</h3><p>输入：观测变量数据 <span class="math inline">\(Y\)</span>，隐变量数据<span class="math inline">\(Z\)</span>，联合分布 <spanclass="math inline">\(P(Y, Z | \theta)\)</span>，条件分布 <spanclass="math inline">\(P(Z | Y, \theta)\)</span>； 输出：模型参数<spanclass="math inline">\(\theta\)</span>。</p><p><strong>（1）选择参数初始值 <spanclass="math inline">\(\theta^{(0)}\)</span>，开始迭代；</strong></p><p><strong>（2）<span class="math inline">\(\operatorname{E}\)</span>步：计算 Q 函数值</strong></p><p><span class="math display">\[Q(\theta, \theta^{(i)}) = \sum_{Z} \log P(Y, Z | \theta) P(Z | Y,\theta^{(i)}) \tag{1}\]</span></p><p>这里，<span class="math inline">\(P(Z | Y, \theta^{(i)})\)</span>是在给定观测数据 <span class="math inline">\(Y\)</span> 和当前的参数估计<span class="math inline">\(\theta^{(i)}\)</span> 下隐变量数据 <spanclass="math inline">\(Z\)</span> 条件概率分布；</p><p><strong>（3）<span class="math inline">\(\operatorname{M}\)</span>步：求使 <span class="math inline">\(Q(\theta, \theta^{(i)})\)</span>极大化的 <span class="math inline">\(\theta\)</span>，确定第 <spanclass="math inline">\(i + 1\)</span> 次迭代的参数估计值 <spanclass="math inline">\(\theta^{(i + 1)}\)</span></strong></p><p><span class="math display">\[\theta^{(i + 1)} = \operatorname{arg} \max_{\theta} Q(\theta,\theta^{(i)}) \tag{2}\]</span></p><p><strong>（4）重复（2）（3）步直到收敛</strong></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>感知机</title>
    <link href="/2025/06/03/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <url>/2025/06/03/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="perceptron">Perceptron</h2><p>感知机用于<strong>二分类线性问题</strong>，这说明感知机只能用于二分类问题，同时样本数据线性可分。</p><p>接下来会介绍感知机的<strong>数学定义</strong>，也就是感知机的输入输出映射；然后介绍感知机的学习算法，学习什么？学习的是感知机数学定义中提及到的<strong>参数</strong>；如何学习？会介绍两种方法，第一种是基于原始<strong>损失函数</strong>的迭代算法，另一种是基于原始损失函数的<strong>对偶形式</strong>的迭代算法，这两种算法本质上等价。</p><span id="more"></span><h2 id="感知机的数学定义">感知机的数学定义</h2><p>假设输入空间 <span class="math inline">\(\mathcal{X} \subseteq\mathbb{R}^n\)</span>，输出空间是 <spanclass="math inline">\(\mathcal{Y} = \{+1,-1\}\)</span>。由输入空间到输出空间的如下函数：</p><p><span class="math display">\[f(x) = \operatorname{sign} (\mathbf{w} \cdot \mathbf{x} + b) \tag{1}\]</span></p><p>称为感知机。其中，<span class="math inline">\(w\)</span> 和 <spanclass="math inline">\(b\)</span> 为感知机模型参数，前者叫权值<strong>weight</strong>，后者叫偏置<strong>bias</strong>，点乘运算为<strong>向量内积</strong>。<spanclass="math inline">\(\operatorname{sign}\)</span>是符号函数，具体定义如下：</p><p><span class="math display">\[\operatorname{sign}(x) =\begin{cases}+1,&amp; x \geq 0\\[10pt]-1,&amp; x &lt; 0 \tag{2}\end{cases}\]</span></p><h2 id="感知机学习策略">感知机学习策略</h2><p>假设数据集<strong>线性可分</strong>，定义感知机学习的损失函数为：</p><p><span class="math display">\[L(\mathbf{w}, b) = -\sum_{\mathbf{x}_i \in M} y_i(\mathbf{w} \cdot\mathbf{x}_i + b) \tag{3}\]</span></p><p>其中，<span class="math inline">\(M\)</span>是<strong>误分类点的集合</strong>，我们的目标是极小化 <spanclass="math inline">\(L(\mathbf{w}, b)\)</span>。</p><h3 id="感知机学习算法的原始形式">感知机学习算法的原始形式</h3><p>随机初始化 <span class="math inline">\(\mathbf{w}\)</span> 和 <spanclass="math inline">\(b\)</span>，分别记为 <spanclass="math inline">\(\mathbf{w}_0\)</span> 和 <spanclass="math inline">\(b_0\)</span>，然后在训练数据集中选取数据 <spanclass="math inline">\((\mathbf{x}_i, y_i)\)</span>；如果 <spanclass="math inline">\(y_i(\mathbf{w} \cdot \mathbf{x}_i + b) \leq0\)</span>,</p><p><span class="math display">\[\begin{align*}&amp;\mathbf{w} \leftarrow \mathbf{w} + \eta y_i \mathbf{x}_i\\[10pt]&amp;b \leftarrow b + \eta y_i\end{align*}\]</span></p><p>重复上述选择更新过程直至没有误分类点。</p><blockquote><p>这个更新过程，根据《统计学习方法》的例题，需要这样更新。假设我有一训练数据集<span class="math inline">\(x_1, x_2, \cdots, x_N\)</span>，我初始化完<span class="math inline">\(\mathbf{w}\)</span> 和 <spanclass="math inline">\(b\)</span> 后，我从 <spanclass="math inline">\(x_1\)</span> 开始，每次更新后都要从 <spanclass="math inline">\(1 \to N\)</span> 的顺序进行验证。</p></blockquote><h3 id="感知机学习算法的对偶形式">感知机学习算法的对偶形式</h3><p>与原始形式不同，对原始形式使用拉格朗日对偶化，得到相应的对偶形式。首先初始化系数和偏置<span class="math inline">\(\mathbf{\alpha} \leftarrow \mathbf{0}, b\leftarrow 0\)</span>。再在训练集中选取数据 <spanclass="math inline">\((\mathbf{x}_i, y_i)\)</span>；如果 <spanclass="math inline">\(y_i \left(\sum_{j = 1}^{N} \alpha_j y_j(\mathbf{x}_j \cdot \mathbf{x}_i) + b \right) \leq0\)</span>，则更新</p><p><span class="math display">\[\begin{align*}&amp;\alpha_i \leftarrow \alpha_i + \eta\\[10pt]&amp;b \leftarrow b + \eta y_i\end{align*}\]</span></p><p><strong>tips</strong></p><p>可以预处理出所有输入实例间的内积，并将其存为一个矩阵，这个矩阵叫做Gram 矩阵，</p><p><span class="math display">\[\mathbf{G} = [\mathbf{x}_i \cdot \mathbf{x}_j]_{N \times N}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上下文无关文法</title>
    <link href="/2025/06/03/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/"/>
    <url>/2025/06/03/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="上下文无关文法的定义">上下文无关文法的定义</h1><p>定义文法 <span class="math inline">\(G = (V, T, P,S)\)</span>，其中产生式，除了空产生式外，有如下特点：</p><p><span class="math display">\[\forall \alpha \to \beta \in P, \quad \beta \in (V \cup T)^{\ast}, \quad\text{All have } |\beta| \geq |\alpha|, \text{and } \alpha \in V\]</span></p><h1 id="派生树">派生树</h1><p>设有 CFG $ G = (V, T, P, S)<span class="math inline">\(，\)</span>G$的派生树是满足如 下条件的有序树。 1. 树的每个顶点有一个标记 <spanclass="math inline">\(X\)</span>，且 <span class="math inline">\(X \in V\cup T \cup \{\epsilon\}\)</span>； 2. 树根的标记为 <spanclass="math inline">\(S\)</span>； 3. 如果非叶子顶点 <spanclass="math inline">\(v\)</span> 标记为 <spanclass="math inline">\(A\)</span>，<span class="math inline">\(v\)</span>的儿子从左到右依次为<span class="math inline">\(v_1, v_2, \dots,v_n\)</span>，并且它们分别标记为<span class="math inline">\(X_1, X_2,\dots, X_n\)</span>，则 <span class="math inline">\(A \to X_1 X_2 \cdotsX_n \in P\)</span>； 4. 如果 <span class="math inline">\(X\)</span>是一个<strong>非叶子顶点</strong>的标记，则 <spanclass="math inline">\(X \in V\)</span>； 5. 如果顶点 <spanclass="math inline">\(v\)</span> 标记为 <spanclass="math inline">\(\epsilon\)</span>，则 <spanclass="math inline">\(v\)</span> 是该树的叶子，并且 <spanclass="math inline">\(v\)</span>是其父顶点的<strong>惟一儿子</strong>。</p><p>派生树都是 CFG 的派生树。</p><h2 id="顶点的结果">顶点的结果</h2><p>派生树 <span class="math inline">\(T\)</span>的所有叶子结点从左到右的符号串为 <span class="math inline">\(X_1 X_2\cdots X_n\)</span>是 <span class="math inline">\(T\)</span>的结果。</p><h1 id="cfg-的化简">CFG 的化简</h1><h2 id="删除无用符号">删除无用符号</h2><p><strong>无用符号</strong></p><h1 id="cnf乔姆斯基范式文法">CNF：乔姆斯基范式文法</h1><p>CFG <span class="math inline">\(G = (V, T, P, S)\)</span>中的产生式形式为：<span class="math inline">\(A \to BC, \, A\toa\)</span>，其中 <span class="math inline">\(A,B,C \in V,\, a \inT\)</span>，需要注意的是此 CFG 已完成化简。</p><p>利用 CNF 范式派生长度为 <span class="math inline">\(n\)</span>的串，刚好需要 <span class="math inline">\(2n-1\)</span> 步。</p><h1 id="上下文无关文法的性质">上下文无关文法的性质</h1><h2 id="cfl-的泵引理">CFL 的泵引理</h2><p>对于任意的 CFL <span class="math inline">\(L\)</span>，存在仅仅依赖于<span class="math inline">\(L\)</span> 的正整数 <spanclass="math inline">\(N\)</span>，对于任意的 <spanclass="math inline">\(z \in L\)</span>，当 <spanclass="math inline">\(|z| \geq N\)</span> 时，存在 <spanclass="math inline">\(u, v, w, x, y\)</span>，使得 <spanclass="math inline">\(z = uvwxy\)</span>，同时满足：</p><ol type="1"><li><span class="math inline">\(|vwx| \leq N\)</span>；</li><li><span class="math inline">\(|vx| \geq 1\)</span>；</li><li>对于任意的非负整数 <span class="math inline">\(i\)</span>，<spanclass="math inline">\(u v^i w x^i y \in L\)</span>。</li></ol><h3 id="利用-cfl-泵引理证明一个语言不是-cfl">利用 CFL泵引理证明一个语言不是 CFL</h3><ol type="1"><li>首先假设该语言是 CFL，则其满足泵引理，任选 <spanclass="math inline">\(N\)</span>；</li><li>找到语言中的句子 <span class="math inline">\(z \in L\)</span> 且<span class="math inline">\(|z| \geq N\)</span>；</li><li>分析 <span class="math inline">\(v\)</span>、<spanclass="math inline">\(x\)</span> 的各种取值，当满足 <spanclass="math inline">\(z = uvwxy\)</span>，且 <spanclass="math inline">\(|vwx| \leq N\)</span>，<spanclass="math inline">\(|vx| \geq 1\)</span> 时，均能找到 <spanclass="math inline">\(i \geq 0\)</span>，使得 <spanclass="math inline">\(i\)</span>，<span class="math inline">\(u v^i wx^i y \notin L\)</span>。</li></ol><h2 id="ogden-引理">Ogden 引理</h2><p>对于任意的 CFL <span class="math inline">\(L\)</span>，存在仅仅依赖于<span class="math inline">\(L\)</span> 的正整数 <spanclass="math inline">\(N\)</span>，对于任意的 <spanclass="math inline">\(z \in L\)</span>，当 <spanclass="math inline">\(z\)</span> 中至少含有 <spanclass="math inline">\(N\)</span> 个特异点时，存在 <spanclass="math inline">\(u, v, w, x, y\)</span>，使得 <spanclass="math inline">\(z = uvwxy\)</span>，同时满足：</p><ol type="1"><li><span class="math inline">\(|vwx|\)</span> 中的特异点的数目 <spanclass="math inline">\(\leq N\)</span>；</li><li><span class="math inline">\(|vx|\)</span> 中的特异点的数目 <spanclass="math inline">\(\geq 1\)</span>；</li><li>对于任意的非负整数 <span class="math inline">\(i\)</span>，<spanclass="math inline">\(u v^i w x^i y \in L\)</span>。</li></ol><h2 id="cfl-在并乘积闭包运算下是封闭的但在交运算下不封闭">CFL在并、乘积、闭包运算下是封闭的，但在交运算下不封闭</h2><h1 id="cyk-algorithm">CYK Algorithm</h1><p>输入：CNF <span class="math inline">\(G = (V, T, P,S)\)</span>，<span class="math inline">\(x\)</span>； 输出：<spanclass="math inline">\(x \in L\)</span> 或者 <spanclass="math inline">\(x \notin L\)</span>；</p><p><span class="math inline">\(V_{i,k}\)</span>：可以派生出子串 <spanclass="math inline">\(x_{i,k}\)</span> 的变量集合，<spanclass="math inline">\(x_{i,k}\)</span> 表示从 <spanclass="math inline">\(i\)</span> 开始，长度为 <spanclass="math inline">\(k\)</span> 的子串。</p><ol type="1"><li><code>for i = 1 in |x|</code> <span class="math inline">\(V_{i,1} =\{A \mid A \to x_{i,1} \in P\}\)</span></li><li><code>for k = 2 in |x| &#123;for i = 1 to |x| - k + 1&#125;</code> $V_{i,k} =$<ol type="1"><li><code>for j = 1 to k - 1</code> <span class="math inline">\(V_{i,k}= V_{i,k} \cup \{A \mid A \to BC \text{ and } B \in V_{i,j} \text{ and }C \in V_{i + j,k - j}\}\)</span></li></ol></li></ol><h1 id="hw13">hw13</h1><p><strong>题目1：</strong> 使用CFL的泵引理证明 <spanclass="math inline">\(L = \{ ww \mid w \in \{a, b\}^{\ast} \}\)</span>不是上下文无关语言.</p><p><strong>解答1：</strong></p><p>我们使用 CFL 的泵引理来证明 <span class="math inline">\(L = \{ ww\mid w \in \{a, b\}^\ast \}\)</span> 不是上下文无关语言。</p><p>假设 <span class="math inline">\(L\)</span>是一个上下文无关语言，则它满足 CFL 的泵引理。</p><p>设 <span class="math inline">\(N\)</span> 为泵引理中的 <spanclass="math inline">\(N\)</span>，取句子 $ z = a^{N} b^{N} a^{N} b^{N} L$</p><p>接下来分析 <span class="math inline">\(vwx\)</span> 的各种取值： 1.因为 <span class="math inline">\(|vwx| \leq N\)</span>，不妨先假设 <spanclass="math inline">\(vwx \subseteq a^{N}\)</span> 或者 <spanclass="math inline">\(b^{N}\)</span>，显然对于 <spanclass="math inline">\(\forall i &gt; 0\)</span>，都会破坏 <spanclass="math inline">\(L\)</span> 的结构，即要求 <spanclass="math inline">\(ww \in L\)</span>。<br><br> 2. 然后再分析 <spanclass="math inline">\(vwx\)</span> 跨越了 <spanclass="math inline">\(a\)</span> 部分或者 <spanclass="math inline">\(b\)</span> 部分，由于 <spanclass="math inline">\(|vwx| \leq N\)</span>，可以证明 <spanclass="math inline">\(vwx\)</span> 最多横跨一个 <spanclass="math inline">\(a\)</span> 和一个 <spanclass="math inline">\(b\)</span>，也即是类似 <spanclass="math inline">\(a \cdots ab \cdots b\)</span> 和 <spanclass="math inline">\(b \cdots ba \cdots a\)</span> 的结构；<br><br> 1.假设 <span class="math inline">\(vwx\)</span> 横跨第一个 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span>。设 $ v = a^{m}, , x = b^{n}$，则 <spanclass="math inline">\(\forall i &gt; 0\)</span>，<spanclass="math inline">\(u a^{im} w b^{in} y \notinL\)</span>，这很好证明：此时 <span class="math inline">\(u a^{im} wb^{in} y\)</span> 可以写成 <span class="math inline">\(a^{N + im} b^{N +in} a^{N} b^{N}\)</span> 的形式，为了保证 <spanclass="math inline">\(ww\)</span> 的结构，只能如此分割 <spanclass="math inline">\(a^{N + im} b^{N + in}\)</span> 和 <spanclass="math inline">\(a^{N} b^{N}\)</span>，因为 <spanclass="math inline">\(|vx| \geq 1\)</span>，所以不存在 <spanclass="math inline">\(i\)</span> 使得分割后得两个句子相等；<br><br> 2.同理可以证明 <span class="math inline">\(vwx\)</span> 横跨第二个 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 时同样不满足泵引理；<br><br> 3. 对于<span class="math inline">\(vwx\)</span> 横跨第一个 <spanclass="math inline">\(b\)</span> 和 第二个 <spanclass="math inline">\(a\)</span> 的情况，此时 <spanclass="math inline">\(u a^{im} w b^{in} y\)</span> 可以写成 <spanclass="math inline">\(a^{N} b^{N + im} a^{N + in} b^{N}\)</span>的形式，同样为了保证 <span class="math inline">\(ww\)</span>的结构，只能如此分割 <span class="math inline">\(a^{N} b^{N +im}\)</span> 和 <span class="math inline">\(a^{N + in}b^{N}\)</span>，显然分割后的句子不相等，也就是不满足泵引理。<br><br></p><p>综上，<span class="math inline">\(L\)</span> 不是 CFL。</p><p><strong>题目2：</strong> 给定文法 <spanclass="math inline">\(G\)</span> 如下：</p><p>[ <span class="math display">\[\begin{align*}&amp;S \to AB \,|\, AA \,|\, BC \\&amp;A \to CD \,|\, a \\&amp;B \to BD \,|\, SB \,|\, b \\&amp;C \to c \\&amp;D \to DB \,|\, b\end{align*}\]</span> ]</p><p>根据算法 CYK 算法，请识别字符串”aabbc”是否属于 <spanclass="math inline">\(L(G)\)</span>?</p><p><strong>解答2：</strong> <span class="math inline">\(x =\text{&quot;aabbc&quot;}\)</span>，长度 <span class="math inline">\(|x|= 5\)</span>。</p><p>构造一个二维表 <span class="math inline">\(V_{i,k}\)</span>，其中<span class="math inline">\(V_{i,k}\)</span> 表示从位置 <spanclass="math inline">\(i\)</span> 开始，长度为 <spanclass="math inline">\(k\)</span> 的子串可以由哪些非终结符生成。</p><ol type="1"><li><strong>第一步：处理长度为 1 的子串</strong><br />根据文法的终结符规则，填充 <spanclass="math inline">\(V_{i,1}\)</span>：<ul><li><span class="math inline">\(x_1 = a \implies V_{1,1} =\{A\}\)</span></li><li><span class="math inline">\(x_2 = a \implies V_{2,1} =\{A\}\)</span></li><li><span class="math inline">\(x_3 = b \implies V_{3,1} = \{B,D\}\)</span></li><li><span class="math inline">\(x_4 = b \implies V_{4,1} = \{B,D\}\)</span></li><li><span class="math inline">\(x_5 = c \implies V_{5,1} =\{C\}\)</span></li></ul></li><li><strong>第二步：处理长度为 2 的子串</strong><br />根据文法的组合规则，填充 <span class="math inline">\(V_{i,2}\)</span>：<ul><li><span class="math inline">\(x_{1,2} = &quot;aa&quot; \impliesV_{1,2} = \{S\}\)</span> （因为 <span class="math inline">\(A \toAA\)</span>）</li><li><span class="math inline">\(x_{2,2} = &quot;ab&quot; \impliesV_{2,2} = \{B\}\)</span> （因为 <span class="math inline">\(S \toAB\)</span>）</li><li><span class="math inline">\(x_{3,2} = &quot;bb&quot; \impliesV_{3,2} = \{B, D\}\)</span> （因为 <span class="math inline">\(B \toBD\)</span> 和 <span class="math inline">\(D \to DB\)</span>）</li><li><span class="math inline">\(x_{4,2} = &quot;bc&quot; \impliesV_{4,2} = \{S\}\)</span> （因为 <span class="math inline">\(S \toBC\)</span>）</li></ul></li><li><strong>第三步：处理长度为 3 的子串</strong><br />根据文法的组合规则，填充 <span class="math inline">\(V_{i,3}\)</span>：<ul><li><span class="math inline">\(x_{1,3} = &quot;aab&quot; \impliesV_{1,3} = \{B\}\)</span> （因为 <span class="math inline">\(S \toAB\)</span>）</li><li><span class="math inline">\(x_{2,3} = &quot;abb&quot; \impliesV_{2,3} = \{S\}\)</span> （因为 <span class="math inline">\(S \toAB\)</span> 和 <span class="math inline">\(B \to SB\)</span>）</li><li><span class="math inline">\(x_{3,3} = &quot;bbc&quot; \impliesV_{3,3} = \{S\}\)</span> （因为 <span class="math inline">\(S \toBC\)</span>）</li></ul></li><li><strong>第四步：处理长度为 4 的子串</strong><br />根据文法的组合规则，填充 <span class="math inline">\(V_{i,4}\)</span>：<ul><li><span class="math inline">\(x_{1,4} = &quot;aabb&quot; \impliesV_{1,4} = \{S\}\)</span> （因为 <span class="math inline">\(S \toAB\)</span> 和 <span class="math inline">\(B \to SB\)</span>）</li><li><span class="math inline">\(x_{2,4} = &quot;abbc&quot; \impliesV_{2,4} = \{S\}\)</span> （因为 <span class="math inline">\(S \toBC\)</span>）</li></ul></li><li><strong>第五步：处理长度为 5 的子串</strong><br />根据文法的组合规则，填充 <span class="math inline">\(V_{1,5}\)</span>：<ul><li><span class="math inline">\(x_{1,5} = &quot;aabbc&quot; \impliesV_{1,5} = \{S\}\)</span> （因为 <span class="math inline">\(S \toAB\)</span> 和 <span class="math inline">\(B \to SB\)</span>）</li></ul></li></ol><p>最终，<span class="math inline">\(V_{1,5}\)</span> 包含 <spanclass="math inline">\(S\)</span>，因此字符串 “aabbc” 属于文法 <spanclass="math inline">\(G\)</span> 的语言 <spanclass="math inline">\(L(G)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>形式语言与自动机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大熵模型</title>
    <link href="/2025/06/02/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/06/02/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="logistic-regression">Logistic Regression</h2><h3 id="logistic-distribution">Logistic Distribution</h3><p>设<span class="math inline">\(X\)</span>是连续随机变量，<spanclass="math inline">\(X\)</span>服从 <strong>logisticdistribution</strong> 是指<spanclass="math inline">\(X\)</span>具有下列分布函数和密度函数：</p><p><span class="math display">\[\begin{align}F(x) &amp;= P(X \leq x) = \frac{1}{1 + e^{-(x-\mu)/\gamma}} \tag{1}\\f(x) &amp;= F&#39;(x) = \frac{e^{-(x-\mu)/\gamma}}{\gamma\left(1 +e^{-(x-\mu)/\gamma}\right)^2} \tag{2}\end{align}\]</span></p><h3 id="binomial-logistic-regression-model">Binomial Logistic RegressionModel</h3><p>这是一种二分类模型，这里规定模型输出 <span class="math inline">\(Y\in \{0, 1\}\)</span>， 也就是 <span class="math inline">\(y_i \in \{0,1\}\)</span></p><p><span class="math display">\[\begin{align}P(Y = 0 | \mathbf{x}) &amp;= \frac{1}{1 + \exp (\mathbf{w} \cdot\mathbf{x} + b)} \tag{3}\\P(Y = 1 | \mathbf{x}) &amp;= \frac{\exp (\mathbf{w} \cdot \mathbf{x} +b)}{1 + \exp (\mathbf{w} \cdot \mathbf{x} + b)} \tag{4}\end{align}\]</span></p><p>其中，<span class="math inline">\(\mathbf{x} \in\mathbb{R}^n\)</span> 是输入，<span class="math inline">\(\mathbf{w} \in\mathbb{R}^n\)</span> 和 $ b $ 分别是权值向量和偏置，<spanclass="math inline">\(\mathbf{w} \cdot \mathbf{x}\)</span>是向量内积运算。</p><h3 id="evaluation-of-model-parameters">Evaluation of ModelParameters</h3><p>采用极大似然估计法估计模型参数，从而得到 <strong><em>logisticsregression model</em></strong>。</p><p>我们设</p><p><span class="math display">\[P(Y = 1 | x) = \pi(x) \tag{5}\]</span></p><p>则得到似然函数为</p><p><span class="math display">\[\prod_{i=1}^{N}[\pi(x_i)]^{y_i}[1 - \pi(x_i)]^{1 - y_i} \tag{6}\]</span></p><p>经过计算，对数似然函数为</p><p><span class="math display">\[L(w) = \sum_{i=1}^{N} [y_i(\vec{w} \cdot \vec{x_i}) - \ln (1 + \exp(\vec{w} \cdot \vec{x_i}))] \tag{7}\]</span></p><p>对 <span class="math inline">\(L(w)\)</span> 求极大值，得到 <spanclass="math inline">\(w\)</span> 的估计值 <spanclass="math inline">\(\hat{w}\)</span></p><hr /><h2 id="maximum-entropy-model">Maximum Entropy Model</h2><h3 id="the-principle-of-maximum-entropy">The Principle of MaximumEntropy</h3><p>最大熵原理的核心在于，使得整个概率模型的熵最大。</p><h3 id="maxentropy-model">MaxEntropy Model</h3><p>模型输入 <span class="math inline">\(X \in \mathcal{X} \subseteq\mathbb{R}^n\)</span>，输出 <span class="math inline">\(Y \in\mathcal{Y}\)</span>，条件概率分布 <span class="math inline">\(P(Y |X)\)</span> 表示对于给定输入 <span class="math inline">\(X\)</span>以该条件概率输出 <span class="math inline">\(Y\)</span>。</p><p>给定训练数据集，可以确定联合分布 <span class="math inline">\(P(X,Y)\)</span> 的经验分布和边缘分布。</p><p><span class="math display">\[\begin{align}\tilde{P}(X = x, Y = y) &amp;= \frac{\nu(X = x, Y = y)}{N} \tag{8}\\\tilde{P}(X = x) &amp;= \frac{\nu(X = x)}{N} \tag{9}\end{align}\]</span></p><p>其中 <span class="math inline">\(\nu(X = x, Y = y)\)</span> 是样本<span class="math inline">\((x, y)\)</span> 出现的频数。</p><p>接下来介绍特征函数 <strong><em>feature function</em></strong> <spanclass="math inline">\(f(x,y)\)</span>，<spanclass="math inline">\(f()\)</span> 描述输入 <spanclass="math inline">\(x\)</span> 与输出 <spanclass="math inline">\(y\)</span> 之间的某一个事实。</p><p><span class="math display">\[f(x, y) =\begin{cases}1, &amp;\text{satisfying}\\0, &amp;\text{otherwise} \tag{10}\end{cases}\]</span></p><p>特征函数关于经验分布的期望值</p><p><span class="math display">\[E_{\tilde{P}}(f) = \sum_{x,y} \tilde{P}(x,y) f(x,y) \tag{11}\]</span></p><p>特征函数关于模型与经验分布的期望值</p><p><span class="math display">\[E_P(f) = \sum_{x,y} \tilde{P}(x) P(y|x) f(x,y) \tag{12}\]</span></p><p>如果模型能够获得训练数据中的信息，则可以认为上述两个期望值相等，即</p><p><span class="math display">\[E_{\tilde{P}}(f) = E_P(f) \tag{13}\]</span></p><p>综上，我们引出最大熵模型。</p><p>假设满足所有约束条件的模型集合为</p><p><span class="math display">\[\mathcal{C} \equiv \{P \in \mathcal{P} \mid E_{\tilde{P}}(f_i) =E_P(f_i), \quad i=1,2,\dots,n\} \tag{14}\]</span></p><p>定义在条件概率分布 <span class="math inline">\(P(Y|X)\)</span>上的条件熵为</p><p><span class="math display">\[H(P) = -\sum_{x,y} \tilde{P}(x) P(y|x) \ln P(y|x) \tag{15}\]</span></p><p>则模型集合 <span class="math inline">\(\mathcal{C}\)</span> 中条件熵<span class="math inline">\(H(P)\)</span> 最大的模型称为最大熵模型。</p><h3 id="training-a-maximum-entropy-model">Training a Maximum EntropyModel</h3><p>类似 <strong>SVM</strong> 的学习过程。给定训练数据集 <spanclass="math inline">\(T =\{(x_1,y_1),(x_2,y_2),\dots,(x_N,y_N)\}\)</span> 以及特征函数 <spanclass="math inline">\(f_i(x,y), \quad i = 1, 2, \dots,n\)</span>，最大熵模型的学习等价于约束最优化问题：</p><p><span class="math display">\[\begin{align*}\max_{P \in \mathcal{C}} \quad &amp; H(P) = -\sum_{x, y} \tilde{P}(x)P(y \mid x) \ln P(y \mid x)\\\text{subject to} \quad &amp; E_{\tilde{P}}[f_i] = E_P[f_i], \quad i =1, 2, \dots, n\\&amp; \sum_{y} P(y \mid x) = 1\end{align*}\]</span></p><p>将其换为等价的最小化问题</p><p><span class="math display">\[\begin{align*}\min_{P \in \mathcal{C}} \quad -&amp;H(P) = \sum_{x, y} \tilde{P}(x) P(y\mid x) \ln P(y \mid x) \tag{16}\\\text{subject to} \quad &amp; E_{\tilde{P}}[f_i] - E_P[f_i]= 0, \quad i= 1, 2, \dots, n \tag{17}\\&amp; \sum_{y} P(y \mid x) = 1 \tag{18}\end{align*}\]</span></p><p>将约束最优化问题转换为无约束最优化的对偶问题。引入拉格朗日乘子 <spanclass="math inline">\(w_0, w_1, \dots, w_n\)</span>，定义拉格朗日函数<span class="math inline">\(L(P, w)\)</span>：</p><p><span class="math display">\[\begin{align*}L(P, w) &amp;\equiv -H(P) + w_0 \left(1 - \sum_{y} P(y | x)\right) +\sum_{i = 1}^{n} w_i (E_{\tilde{P}}(f_i) - E_{P}(f_i)) \tag{19}\\&amp;= \sum_{x,y} \tilde{P}(x) P(y | x) \ln P(y | x) + w_0\left(1 -\sum_{y} P(y | x)\right) +\\&amp;\sum_{i = 1}^{n} w_i\left(\sum_{x, y} \tilde{P}(x, y) f_i(x, y) -\sum_{x, y} \tilde{P}(x) P(y | x) f_i(x, y) \right)\end{align*}\]</span></p><p>最优化的原始问题是</p><p><span class="math display">\[\min_{P \in \mathcal{C}} \max_{w} L(P, w) \tag{20}\]</span></p><p>对偶问题是</p><p><span class="math display">\[\max_{w} \min_{P \in \mathcal{C}} L(P, w) \tag{21}\]</span></p><p>先解决极小化问题， 记</p><p><span class="math display">\[\Psi(w) = \min_{P \in \mathcal{C}} L(P, w) = L(P_w, w) \tag{22}\]</span></p><p>求 <span class="math inline">\(L(P, w)\)</span> 对 <spanclass="math inline">\(P(y | x)\)</span> 的偏导数</p><p><span class="math display">\[\begin{align*}\frac{\partial L(P, w)}{\partial P(y | x)} &amp;= \sum_{x, y}\tilde{P}(x)(\ln P(y | x) + 1) - \sum_{y}w_0 - \sum_{x, y}\left(\tilde{P}(x) \sum_{i = 1}^{n} w_i f_i(x, y) \right)\\&amp;= \sum_{x, y} \tilde{P}(x) \left(\ln P(y | x) + 1 - w_0 - \sum_{i =1}^{n} w_i f_i(x, y) \right)\end{align*}\]</span></p><p>令偏导数等于 <span class="math inline">\(0\)</span>， 在 <spanclass="math inline">\(\tilde{P} &gt; 0\)</span> 的情况下，解得</p><p><span class="math display">\[P_w(y | x) = \frac{1}{Z_w(x)} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y)\right) \tag{23}\]</span></p><p>其中</p><p><span class="math display">\[Z_w(x) = \sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)\tag{24}\]</span></p><p>称 <span class="math inline">\(Z_w(x)\)</span> 为归一化因子。</p><p>最后求解对偶问题外部的极大化问题</p><p><span class="math display">\[\max_{w} \Psi(w) \tag{25}\]</span></p><h3 id="improved-iterative-scaling">Improved Iterative Scaling</h3><p>已知最大熵模型</p><p><span class="math display">\[P_w(y | x) = \frac{1}{Z_w(x)} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y)\right)\]</span></p><p>其中</p><p><span class="math display">\[Z_w(x) = \sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)\]</span></p><p>对数似然函数为</p><p><span class="math display">\[L(w) = \sum_{x, y} \tilde{P}(x, y) \sum_{i = 1}^{n} w_i f_i(x, y) -\sum_{x} \tilde{P}(x) \ln Z_w(x)\]</span></p><p>改进迭代算法的思路是，假设最大熵模型当前的参数向量是 <spanclass="math inline">\(w = (w_1, w_2, \dots,w_n)^{T}\)</span>，我们希望找到一个新的参数向量 <spanclass="math inline">\(w + \delta = (w_1 + \delta_1, \dots, w_n +\delta_n)^{T}\)</span>，使得模型的对数似然函数增值。</p><p><strong>算法步骤</strong></p><p><strong>输入</strong>：特征函数 <span class="math inline">\(f_1, f_2,\dots, f_n\)</span>；经验分布 <span class="math inline">\(\tilde{P}(X,Y)\)</span>；模型 <span class="math inline">\(P_w(y | x)\)</span></p><p><strong>输出</strong>：最优参数值 <spanclass="math inline">\(w_i^{\ast}\)</span>；最优模型 <spanclass="math inline">\(P_{w^{\ast}}\)</span></p><p><strong>步骤1</strong>：对所有 <span class="math inline">\(i \in \{1,2, \dots, n\}\)</span>，取初值 <span class="math inline">\(w_i =0\)</span>。</p><p><strong>步骤2</strong>：对每一 <span class="math inline">\(i \in \{1,2, \dots, n\}\)</span>，执行以下操作：</p><p>首先，令 <span class="math inline">\(\delta_i\)</span>为下列方程的解：</p><p><span class="math display">\[\sum_{x, y} \tilde{P}(x) P(y | x) f_i(x, y) \exp \left(\delta_if^{\Sigma}(x, y) \right) = E_{\tilde{P}}(f_i)\]</span></p><p>其中，<span class="math inline">\(f^{\Sigma}(x, y)\)</span>定义为：</p><p><span class="math display">\[f^{\Sigma}(x, y) = \sum_{i = 1}^{n} f_i(x, y)\]</span></p><p>然后，更新 <span class="math inline">\(w_i\)</span> 的值：</p><p><span class="math display">\[w_i \leftarrow w_i + \delta_i\]</span></p><p><strong>步骤3</strong>：如果不是所有 <spanclass="math inline">\(w_i\)</span> 都收敛，则重复步骤2。</p><h3 id="quasi-newton-method-bfgs">Quasi-Newton Method : BFGS</h3><p>对最大熵模型而言，</p><p><span class="math display">\[P_w(y | x) = \frac{\exp \left(\sum_{i = 1}^{n} w_i f_i(x, y)\right)}{\sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)}\]</span></p><p>目标函数：</p><p><span class="math display">\[\min_{w \in \mathbb{R}^n} f(w) = \sum_{x} \tilde{P}(x) \ln \sum_{y} \exp\left(\sum_{i = 1}^{n} w_i f_i(x, y) \right) - \sum_{x, y} \tilde{P}(x,y) \sum_{i = 1}^{n} w_i f_i(x, y)\]</span></p><p>相应 <span class="math inline">\(i\)</span> 的梯度有，</p><p><span class="math display">\[\frac{\partial f(w)}{\partial w_i} = \sum_{x, y} \tilde{P}(x) P_w(y | x)f_i(x, y) - E_{\tilde{p}}(f_i)\]</span></p><p>定义 <span class="math inline">\(g()\)</span></p><p><span class="math display">\[g(w) = \left(\frac{\partial f(x)}{\partial w_1}, \frac{\partialf(x)}{\partial w_2}, \dots,\frac{\partial f(x)}{\partial w_n} \right)^T\]</span></p><p><strong>算法步骤</strong></p><p><strong>输入</strong>：特征函数 <span class="math inline">\(f_1, f_2,\dots, f_n\)</span>；经验分布 <span class="math inline">\(\tilde{P}(X,Y)\)</span>；目标函数 <span class="math inline">\(f(w)\)</span>；梯度<span class="math inline">\(g(w) = \nabla f(w)\)</span>；精度要求 <spanclass="math inline">\(\epsilon\)</span>；<strong>输出</strong>：最优参数值 <spanclass="math inline">\(w_i^{\ast}\)</span>；最优模型 <spanclass="math inline">\(P_{w^{\ast}}\)</span></p><ol type="1"><li>选定初始点 <span class="math inline">\(w^{(0)}\)</span>，取 <spanclass="math inline">\(B_0\)</span> 为正定对称矩阵，置 <spanclass="math inline">\(k = 0\)</span>。</li><li>计算 <span class="math inline">\(g_k = g(w^{(k)})\)</span>。<br />若 <span class="math inline">\(\lVert g_k \rVert &lt;\epsilon\)</span>，则停止计算，得 <span class="math inline">\(w^{*} =w^{(k)}\)</span>；否则转第 3 步。</li><li>由 <span class="math inline">\(B_k p_k = -g_k\)</span> 求出 <spanclass="math inline">\(p_k\)</span>。</li><li>一维搜索，求 <span class="math inline">\(\lambda_k\)</span> 使得<span class="math display">\[f(w^{(k)} + \lambda_k p_k) = \min_{\lambda \geq 0} f(w^{(k)} + \lambdap_k)\]</span></li><li>置 <span class="math inline">\(w^{(k + 1)} = w^{(k)} + \lambda_kp_k\)</span>。</li><li>计算 <span class="math inline">\(g_{k + 1} = g(w^{(k +1)})\)</span>。<br />若 <span class="math inline">\(\lVert g_{k + 1} \rVert &lt;\epsilon\)</span>，则停止计算，得 <span class="math inline">\(w^{*} =w^{(k + 1)}\)</span>；否则，按下式求出 <span class="math inline">\(B_{k+ 1}\)</span>： <span class="math display">\[B_{k + 1} = B_k + \frac{y_k y_k^T}{y_k^T \delta_k} - \frac{B_k \delta_k\delta_k^T B_k}{\delta_k^T B_k \delta_k}\]</span> 其中， <span class="math display">\[y_k = g_{k + 1} - g_k, \quad \delta_k = w^{(k + 1)} - w^{(k)}\]</span></li><li>置 <span class="math inline">\(k = k + 1\)</span>，转第 3 步。</li></ol><p><strong>补充说明</strong></p><p>在 BFGS 算法中，<span class="math inline">\(B_k\)</span> 是对目标函数<strong><em>Hessian</em></strong> 矩阵的近似。初始时 <spanclass="math inline">\(B_0\)</span>通常取为单位矩阵或其他对称正定矩阵。每次迭代后，<spanclass="math inline">\(B_k\)</span> 按如下公式更新：</p><p><span class="math display">\[B_{k + 1} = B_k + \frac{y_k y_k^T}{y_k^T \delta_k} - \frac{B_k \delta_k\delta_k^T B_k}{\delta_k^T B_k \delta_k}\]</span></p><p>其中， - <span class="math inline">\(\delta_k = w^{(k + 1)} -w^{(k)}\)</span> 表示参数的变化， - <span class="math inline">\(y_k =g_{k + 1} - g_k\)</span> 表示梯度的变化。</p><p><span class="math inline">\(B_k\)</span>的更新保证了其对称正定性，并逐步逼近真实的 Hessian矩阵，从而提升搜索方向的准确性和收敛速度。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件随机场</title>
    <link href="/2025/06/01/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/"/>
    <url>/2025/06/01/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>本章仅讨论条件随机场在 <strong>标注问题（tagging problem）</strong>的应用，因此主要讲述 <strong>线性链（linear chain）</strong>条件随机场。</p><h2 id="概率无向图模型">概率无向图模型</h2><h3 id="成对马尔可夫性">成对马尔可夫性</h3><p>节点 <span class="math inline">\(u\)</span>、<spanclass="math inline">\(v\)</span> 和所有其他节点 <spanclass="math inline">\(O\)</span>，对应的随机变量分别为 <spanclass="math inline">\(Y_u\)</span>、<spanclass="math inline">\(Y_v\)</span>、<spanclass="math inline">\(Y_O\)</span>（<spanclass="math inline">\(Y\)</span> 表示随机变量）。它们具有以下概率关系：<span class="math display">\[P(Y_u, Y_v | Y_O) = P(Y_u | Y_O) P(Y_v | Y_O)\]</span></p><h3 id="局部马尔可夫性">局部马尔可夫性</h3><p>节点 <span class="math inline">\(v\)</span>，<spanclass="math inline">\(W\)</span> 是与 <spanclass="math inline">\(v\)</span> 相邻的所有节点，<spanclass="math inline">\(O\)</span> 是其余节点。它们具有以下概率关系：<span class="math display">\[P(Y_v, Y_O | Y_W) = P(Y_v | Y_W) P(Y_O | Y_W)\]</span></p><h3 id="全局马尔可夫性">全局马尔可夫性</h3><p>节点集合 <span class="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span>、<spanclass="math inline">\(C\)</span>，其中 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 被 <spanclass="math inline">\(C\)</span> 分离。它们具有以下概率关系： <spanclass="math display">\[P(Y_A, Y_B | Y_C) = P(Y_A | Y_C) P(Y_B | Y_C)\]</span></p><h3 id="definition-概率无向图模型">Definition: 概率无向图模型</h3><p>如果联合概率分布 <span class="math inline">\(P(Y)\)</span>满足上述三个马尔可夫性质，就称此联合概率分布为概率无向图模型。</p><h3 id="definition-团与最大团">Definition: 团与最大团</h3><p><strong>团（Clique）：</strong>图中的一个子集，其中任意两个节点都相邻连接。</p><p><strong>最大团（Maximum Clique）：</strong>不能再添加其他节点的团，即包含所有可能相邻节点的最大子集。</p><h3 id="概率无向图模型的因子分解">概率无向图模型的因子分解</h3><p><span class="math display">\[\begin{align}P(Y) &amp;= \frac{1}{Z} \prod_{C} \psi_{C}(Y_C), \quad C \text{ is amaximum clique}\\Z &amp;= \sum_{Y} \prod_{C} \psi_{C}(Y_C), \quad Z \text{ isnormalization factor}\\\psi_{C}(Y_C) &amp;= \exp\{-E(Y_C) \}\end{align}\]</span></p><p>其中，<span class="math inline">\(\psi\)</span>函数称为<strong>势函数</strong>，常用<strong>指数函数</strong>定义势函数。</p><p><span class="math display">\[\psi_{C}(Y_{C}) = e ^{- H_{C}(Y_{C})}\]</span></p><p><span class="math inline">\(H_{C}(Y_{C})\)</span> 是一个定义在变量<span class="math inline">\(Y_{C}\)</span> 上的实值函数，常见形式为</p><p><span class="math display">\[H_{C}(Y_{C}) = \sum_{u,v \in C, u \neq v} \alpha_{uv} x_u x_v + \sum_{v\in C} \beta_v x_v\]</span></p><p>其中，<span class="math inline">\(\alpha_{uv}\)</span> 和 <spanclass="math inline">\(\beta_{v}\)</span> 是参数。</p><hr /><h2 id="crf">CRF</h2><h3 id="definition-线性链条件随机场">Definition: 线性链条件随机场</h3><p>我们假设 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 是随机变量。如果随机变量 <spanclass="math inline">\(Y\)</span> 是一个马尔可夫随机场，即满足： <spanclass="math display">\[P(Y_v | X, Y_w, w \neq v) = P(Y_v | X, Y_w, w \sim v)\]</span> 其中 <span class="math inline">\(w \sim v\)</span> 表示节点<span class="math inline">\(v\)</span> 与节点 <spanclass="math inline">\(w\)</span> 相邻。</p><blockquote><p>通常情况下，我们认为 <span class="math inline">\(X\)</span> 与 <spanclass="math inline">\(Y\)</span> 具有相同的结构。</p></blockquote><img src="/2025/06/01/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/Linear-Chain.png" class="" title="具有相同结构的线性链"><div data-align="center"><em>图1：线性链示例</em></div><p>我们有如下概率关系。 <span class="math display">\[P(Y_i | X, Y_1, \dots, Y_{i-1}, Y_{i+1}, \dots, Y_n) = P(Y_i | X, Y_{i -1}, Y_{i + 1})\]</span></p><h3 id="条件随机场的参数化形式">条件随机场的参数化形式</h3><p><span class="math display">\[P(\mathbf{y} | \mathbf{x}) = \frac{1}{Z(\mathbf{x})} \exp\left(\sum_{i,k}\lambda_k t_k(y_{i -1}, y_i, \mathbf{x}, i) +\sum_{i,l}\mu_l s_l(y_i, \mathbf{x}, i))\right)\]</span></p><p>其中，</p><p><span class="math display">\[Z(\mathbf{x}) = \sum_{\mathbf{y}} \exp \left(\sum_{i,k}\lambda_kt_k(y_{i -1}, y_i, \mathbf{x}, i) + \sum_{i,l}\mu_l s_l(y_i, \mathbf{x},i)\right)\]</span></p><p>其中，<span class="math inline">\(t_k\)</span> 和 <spanclass="math inline">\(s_l\)</span> 是特征函数，<spanclass="math inline">\(\lambda_k\)</span> 和 <spanclass="math inline">\(\mu_l\)</span> 是对应的权重参数。</p><p><strong>Simplification</strong></p><p><span class="math display">\[f_k(y_{i-1}, y_i, \mathbf{x}, i) =\begin{cases}t_k(y_{i-1}, y_i, \mathbf{x}, i), \quad &amp;k = 1,2, \dots,K_1 \\\\s_l(y_i, \mathbf{x}, i), \quad &amp;k = K_1 + l; \text{ } l = 1,2,\dots,K_2\end{cases}\]</span></p><p><span class="math display">\[f_k(\mathbf{y}, \mathbf{x}) = \sum_{i=1}^{n} f_k(y_{i-1}, y_i,\mathbf{x}, i), \quad k = 1,2,\dots,K\]</span></p><p><span class="math display">\[w_k =\begin{cases}\lambda_k, &amp;k = 1,2,\dots,K_1 \\\\\mu_l, &amp;k = K_1 + l; \text{ } l = 1, 2, \dots, K_2\end{cases}\]</span> 即，</p><p><span class="math display">\[\begin{align*}P(\mathbf{y} \mid \mathbf{x}) &amp;= \frac{1}{Z(\mathbf{x})}\exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right) \\\\Z(\mathbf{x}) &amp;= \sum_{\mathbf{y}} \exp\left(\sum_{k=1}^{K} w_kf_k(\mathbf{y}, \mathbf{x})\right)\end{align*}\]</span> 注意，这里的 <spanclass="math inline">\(\sum_{\mathbf{y}}\)</span>是在对所有可能的标签序列求和，而不仅仅是一个确定的标签序列。</p><p>最后，</p><p><span class="math display">\[\begin{align}P_{\mathbf{w}}(\mathbf{y} \mid \mathbf{x}) = \frac{\exp(\vec{w} \cdot\vec{F}(\mathbf{y}, \mathbf{x}))}{Z_{\mathbf{w}}(\mathbf{x})}\end{align}\]</span></p><p><span class="math display">\[Z_{\mathbf{w}}(\mathbf{x}) = \sum_{\mathbf{y}} \exp(\vec{w} \cdot\vec{F}(\mathbf{y}, \mathbf{x}))\]</span></p><h3 id="矩阵形式">矩阵形式</h3><p>对于每个标签序列，我们引入特殊的起始点和结束点标签，<spanclass="math inline">\(y_0 = \text{start}\)</span> 和 <spanclass="math inline">\(y_{n+1} = \text{stop}\)</span>。对于观测序列 <spanclass="math inline">\(\mathbf{x}\)</span> 中的每个位置 <spanclass="math inline">\(i = 1,2,\dots,n+1\)</span>，我们可以定义一个矩阵<span class="math inline">\(M_i \in \mathbb{R}^{m \timesm}\)</span>：</p><p><span class="math display">\[\begin{align*}M_i(\mathbf{x}) &amp;= [M_i(y_{i-1}, y_i | \mathbf{x})]\\\\M_i(y_{i-1}, y_i |\mathbf{x}) &amp;= \exp \left(W_i(y_{i-1}, y_i |\mathbf{x})\right)\\\\W_i(y_{i-1}, y_i |\mathbf{x}) &amp;=\sum_{k=1}^{K}w_kf_k(y_{i-1},y_i,\mathbf{x},i)\end{align*}\]</span></p><p>因此： <span class="math display">\[P_w(\mathbf{y} |\mathbf{x}) = \frac{1}{Z_w(\mathbf{x})}\prod_{i=1}^{n+1} M_i(y_{i-1}, y_i |\mathbf{x})\]</span></p><p>特别地： <span class="math display">\[Z_w(\mathbf{x}) = [M_1(\mathbf{x})M_2(\mathbf{x}) \cdotsM_{n+1}(\mathbf{x})]_{\text{start},\text{stop}}\]</span></p><p>也就是矩阵 <span class="math inline">\((\text{start},\text{stop})\)</span> 位置上的元素。</p><p>矩阵形式不难理解，CRF 中的 <spanclass="math inline">\(M_i(\mathbf{x})\)</span> 矩阵就是在每个位置 <spanclass="math inline">\(i\)</span> 上，枚举所有可能的标签对 <spanclass="math inline">\((y_{i-1},y_i)\)</span>，并计算它们的转移得分。例如 <span class="math inline">\(m= 2\)</span>，<span class="math inline">\(Y = \{A, B\}\)</span>，则<span class="math inline">\(M_1\)</span> 为：</p><p><span class="math display">\[M_1(\mathbf{x}) =\begin{bmatrix}M_1(A, A \mid \mathbf{x}) &amp; M_1(A, B \mid \mathbf{x}) \\\\M_1(B, A \mid \mathbf{x}) &amp; M_1(B, B \mid \mathbf{x})\end{bmatrix}\]</span></p><hr /><h2 id="计算">计算</h2><p>接下来给出计算 <span class="math inline">\(P(Y_i = y_i|\mathbf{x})\)</span>、<span class="math inline">\(P(Y_{i - 1} = y_{i -1}, Y_i = y_i |\mathbf{x})\)</span> 以及相应数学期望的解决方法。</p><h3 id="前向-后向算法">前向-后向算法</h3><p>对于每个索引 <span class="math inline">\(i = 0, 1, \dots, n +1\)</span>，我们定义前向列向量 <spanclass="math inline">\(\alpha_i(x)\)</span>：</p><p><span class="math display">\[\alpha_0(y|\mathbf{x}) =\begin{cases}1, &amp;y = \text{start}\\\\0, &amp;\text{其他情况}\end{cases}\]</span></p><p>递推公式为：</p><p><span class="math display">\[\alpha_i^T(y_i|\mathbf{x}) = \alpha_{i-1}^T (y_{i-1}|\mathbf{x})[M_i(y_{i-1},y_i|\mathbf{x})],\quad i = 1,2,\dots,n+1 \tag{forward}\]</span></p><p>同样地，我们定义后向行向量：</p><p><span class="math display">\[\begin{align}\beta_{n+1}(y_{n+1}|\mathbf{x}) &amp;=\begin{cases}1, &amp;y_{n+1} = \text{stop}\\\\0, &amp;\text{其他情况}\end{cases}\\\\\beta_i(y_i|\mathbf{x})&amp; = [M_{i+1}(y_i,y_{i+1}|\mathbf{x})]\beta_{i+1}(y_{i+1}|\mathbf{x}) \tag{backward}\end{align}\]</span></p><h3 id="概率计算">概率计算</h3><p><span class="math display">\[P(Y_i = y_i | \mathbf{x}) = \frac{\alpha_i^T(y_i | \mathbf{x})\beta_i(y_i | \mathbf{x})}{Z(\mathbf{x})}\]</span></p><p><span class="math display">\[P(Y_{i-1} = y_{i-1}, Y_i = y_i |\mathbf{x}) =\frac{\alpha_{i-1}^T(y_{i-1} |\mathbf{x}) M_i(y_{i-1},y_i |\mathbf{x})\beta_i(y_i |\mathbf{x})}{Z(\mathbf{x})}\]</span></p><p>其中：</p><p><span class="math display">\[Z(\mathbf{x}) = \alpha_n^T(\mathbf{x})\mathbf{1} = \mathbf{1}^T\beta_1(\mathbf{x})\]</span></p><p><strong>可以仿照隐马尔科夫模型计算相似问题时引入 <spanclass="math inline">\(\alpha\)</span> 和 <spanclass="math inline">\(\beta\)</span> 矩阵</strong>，</p><h4 id="前向向量矩阵-alpha">前向向量矩阵 <spanclass="math inline">\(\alpha\)</span></h4><p><span class="math display">\[\alpha = \begin{bmatrix}\alpha_0(A) &amp; \alpha_0(B) &amp; \cdots &amp; \alpha_0(N) \\\\[10pt]\alpha_1(A) &amp; \alpha_1(B) &amp; \cdots &amp; \alpha_1(N) \\\\[10pt]\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\[10pt]\alpha_{n+1}(A) &amp; \alpha_{n+1}(B) &amp; \cdots &amp; \alpha_{n+1}(N)\end{bmatrix}^{T} \tag{CRF-1}\]</span></p><p>每一行表示在位置 <span class="math inline">\(i\)</span> 的前向向量<span class="math inline">\(\alpha_i\)</span>，每一列对应一个标签 <spanclass="math inline">\(y_i \in \mathcal{Y}\)</span>。</p><h4 id="后向向量矩阵-beta">后向向量矩阵 <spanclass="math inline">\(\beta\)</span></h4><p><span class="math display">\[\beta = \begin{bmatrix}\beta_0(A) &amp; \beta_0(B) &amp; \cdots &amp; \beta_0(N) \\\\[10pt]\beta_1(A) &amp; \beta_1(B) &amp; \cdots &amp; \beta_1(N) \\\\[10pt]\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\[10pt]\beta_{n+1}(A) &amp; \beta_{n+1}(B) &amp; \cdots &amp; \beta_{n+1}(N)\end{bmatrix} \tag{CRF-2}\]</span></p><p>每一行表示在位置 <span class="math inline">\(i\)</span> 的后向向量<span class="math inline">\(\beta_i\)</span>，每一列对应一个标签 <spanclass="math inline">\(y_i \in \mathcal{Y}\)</span>。</p><h3 id="期望值计算">期望值计算</h3><p>比较复杂，详情参考《统计学习方法》</p><hr /><h2 id="优化学习算法">优化学习算法</h2><p>优化学习算法涉及改进迭代尺度法、梯度下降法以及拟牛顿法。这些方法曾在最大熵的学习算法中提及，可以比对学习。</p><h3 id="改进的迭代尺度法">改进的迭代尺度法</h3><p>已知训练数据集，由此可知经验概率分布 <spanclass="math inline">\(\tilde{P}(X,Y)\)</span>。可以通过极大化训练数据的对数似然函数来求模型参数。</p><p>训练数据的对数似然函数为：</p><p><span class="math display">\[L(w) = L_{\tilde{P}}(P_{w}) = \sum_{\mathbf{x} ,\mathbf{y}}\tilde{P}(\mathbf{x} ,\mathbf{y}) \log P_{w}(\mathbf{y} |\mathbf{x})\]</span></p><p>若</p><p><span class="math display">\[\begin{align*}P(\mathbf{y} \mid \mathbf{x}) &amp;= \frac{1}{Z(\mathbf{x})}\exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right) \\\\Z(\mathbf{x}) &amp;= \sum_{\mathbf{y}} \exp\left(\sum_{k=1}^{K} w_kf_k(\mathbf{y}, \mathbf{x})\right)\end{align*}\]</span></p><p>则</p><p><span class="math display">\[L(w) = \sum_{j = 1}^{N} \sum_{k = 1}^{K} w_{k} f_{k}(y_j, x_j) - \sum_{j= 1}^{N} \log Z_w(x_j)\]</span></p><h3 id="拟牛顿法">拟牛顿法</h3><p>这里介绍的拟牛顿法是 <spanclass="math inline">\(\mathbf{BFGS}\)</span> 算法。</p><p><strong>输入</strong>：特征函数 <span class="math inline">\(f_1, f_2,\cdots, f_n\)</span>；经验分布 <span class="math inline">\(\tilde{P}(X,Y)\)</span>；精度要求 <span class="math inline">\(\epsilon\)</span>；<strong>输出</strong>：最优参数值 <spanclass="math inline">\(\hat{w}\)</span>；最优模型 <spanclass="math inline">\(P_{\hat{w}}(\mathbf{y} |\mathbf{x})\)</span>。</p><ol type="1"><li>选定初始点 <span class="math inline">\(w^{(0)}\)</span>，取 <spanclass="math inline">\(B_0\)</span> 为正定对称矩阵，置 <spanclass="math inline">\(k = 0\)</span>。</li><li>计算 <span class="math inline">\(g_k = g(w^{(k)})\)</span>。 若<span class="math inline">\(\lVert g_k \rVert &lt;\epsilon\)</span>，则停止计算，得 <span class="math inline">\(w^{*} =w^{(k)}\)</span>；否则转第 3 步。</li><li>由 <span class="math inline">\(B_k p_k = -g_k\)</span> 求出 <spanclass="math inline">\(p_k\)</span>。</li><li>一维搜索，求 <span class="math inline">\(\lambda_k\)</span> 使得<span class="math display">\[f(w^{(k)} + \lambda_k p_k) = \min_{\lambda \geq 0} f(w^{(k)} + \lambdap_k)\]</span></li><li>置 <span class="math inline">\(w^{(k + 1)} = w^{(k)} + \lambda_kp_k\)</span>。</li><li>计算 <span class="math inline">\(g_{k + 1} = g(w^{(k +1)})\)</span>。 若 <span class="math inline">\(\lVert g_{k + 1} \rVert&lt; \epsilon\)</span>，则停止计算，得 <span class="math inline">\(w^{*}= w^{(k + 1)}\)</span>；否则，按下式求出 <spanclass="math inline">\(B_{k + 1}\)</span>： <span class="math display">\[B_{k + 1} = B_k + \frac{y_k y_k^T}{y_k^T \delta_k} - \frac{B_k \delta_k\delta_k^T B_k}{\delta_k^T B_k \delta_k}\]</span> 其中， <span class="math display">\[y_k = g_{k + 1} - g_k, \quad \delta_k = w^{(k + 1)} - w^{(k)}\]</span></li><li>置 <span class="math inline">\(k = k + 1\)</span>，转第 3 步。</li></ol><h2 id="条件随机场的预测算法">条件随机场的预测算法</h2><p>采用隐马尔科夫模型相似的预测算法</p><h3 id="维特比算法">维特比算法</h3><p><strong>输入</strong>：</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Network Layer</title>
    <link href="/2025/05/30/The-Network-Layer/"/>
    <url>/2025/05/30/The-Network-Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>网络层有如下功能： - 将从 transport layer 传来的<strong>segment</strong> 打包成 <strong>datagram</strong>，再将<strong>datagram</strong> 中的 <strong>segment</strong> 分离开传给transport layer。 - 网络层协议应用在 <strong>host</strong> 和<strong>router</strong> 中。</p><p><strong>Router</strong> 和 <strong>Switch</strong> 都属于<strong>packet switch</strong>。</p><p>尽管路由器和链路层交换机都被称为<strong>packetswitches</strong>（分组交换机），但它们有以下根本区别：</p><ol type="1"><li><strong>工作层次不同</strong>：<ul><li>路由器（Router）：工作在<strong>网络层</strong>（第3层）</li><li>链路层交换机：工作在<strong>链路层</strong>（第2层）</li></ul></li><li><strong>转发决策依据</strong>：<ul><li>路由器：基于<strong>IP地址</strong>（网络层地址）做出转发决策</li><li>链路层交换机：基于<strong>MAC地址</strong>（物理地址）做出转发决策</li></ul></li><li><strong>功能范围</strong>：<ul><li>路由器：能够连接<strong>不同网络</strong>，执行<strong>路由决策</strong>和<strong>网络互联</strong></li><li>链路层交换机：主要在<strong>同一网络内</strong>转发帧</li></ul></li><li><strong>网络视角</strong>：<ul><li>路由器：能看到网络的<strong>拓扑结构</strong>，具有全局视野</li><li>链路层交换机：仅限于<strong>局部链路</strong>的连接情况</li></ul></li></ol><p>路由器拥有的IP地址数量<strong>通常等于其活跃网络接口的数量</strong>。这是因为：</p><ul><li>路由器的<strong>每个接口</strong>都需要一个IP地址来参与其所连接网络的通信</li><li>不同接口连接到不同的网络，因此需要不同的IP地址</li></ul><h2 id="forwarding-and-routing">Forwarding and Routing</h2><p>这两个功能十分好理解： - <strong>Forwarding：</strong> 一个 router中，决定如何移动 datagram 到正确的输出。 - <strong>Routing：</strong>决定 datagram 在整个网络中的传输路线。</p><h2 id="network-service-model">Network Service Model</h2><p>需要保证，对 <strong>individualdatagram</strong>：正确传输和传输时间；对 <strong>a flow ofdatagrams</strong>： 顺序接受，完整传输和传输最小带宽。</p><h1 id="virtual-circuit-and-datagram-networks">Virtual Circuit andDatagram Networks</h1><p>网络层有两种服务：<strong>connectionless service</strong> 和<strong>connection service</strong>；这两种服务分别应用在<strong>datagram network</strong> 和 <strong>virtual circuitnetwork</strong>。</p><h2 id="datagram-network">Datagram Network</h2><p>数据包网络使用的是<strong>动态路由</strong>，每一个数据包可以根据当前的网络状况独立地选择路径。</p><h3 id="forwarding-table">Forwarding Table</h3><p><strong>Forwarding table</strong> 应用在 <strong>router</strong>中，决定如何移动 datagram 到正确的输出。</p><p>具体形式如下表格所示，可以看到就是一个简单的地址到接口的映射</p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr><th style="text-align: center;"><strong>Destination AddressRange</strong></th><th style="text-align: center;"><strong>Link Interface</strong></th></tr></thead><tbody><tr><td style="text-align: center;"><spanclass="math inline">\(\sim\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(\sim\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr><tr><td style="text-align: center;">otherwise</td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td></tr></tbody></table></div><p><strong>需要注意的是</strong>：表格中的 <strong>Destination AddressRange</strong> 可以不是完整的 IP address，而是其的一个前缀；比如<strong>00111000</strong>，对应的地址范围是 <strong>00111000 0000000000000000 00000000</strong> 到 <strong>00111000 11111111 1111111111111111 11111111</strong>。这时 forwarding table 变成：</p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr><th style="text-align: center;"><strong>Header</strong></th><th style="text-align: center;"><strong>Link Interface</strong></th></tr></thead><tbody><tr><td style="text-align: center;"><spanclass="math inline">\(\sim\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(\sim\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr><tr><td style="text-align: center;">otherwise</td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td></tr></tbody></table></div><h1 id="whats-inside-a-router">What’s inside a Router</h1><p>有两个重要的路由功能： - 运行路由算法。 - 推送 datagram。</p><h2 id="input-port">Input Port</h2><div data-align="center"><pre><code class=" mermaid">flowchart LR    A[Line Termination &lt;br&gt; bit-level reception] --&gt; B[Data Link Processing]    B --&gt; C[Look up and Forwarding &lt;br&gt; Queueing]    C --&gt; D[Switch Fabric]</code></pre></div><p>这里涉及到的 <strong>look up and forwarding</strong> 的方式是<strong>decentralized switching</strong>，也就是 <strong>forwardingtable</strong> 已经存入到了 input port 的 <strong>memory</strong>中。</p><h2 id="switching-fabric">Switching Fabric</h2><p>有三种 <strong>switching fabrics</strong>。</p><h3 id="switching-via-memory">Switching via Memory</h3><p>这时可以把路由器看作是一个 <strong>computer</strong>。使用电脑的<strong>CPU</strong> 来 switching。</p><p>这个流程是，先把 datagram 拷贝到电脑 <strong>memory</strong> 中，在从memory 传到相应的 output port。</p><p>可以分析的是：<strong>memory bandwidth</strong> 是限制<strong>switching rate</strong> 的主要因素。同时需要注意的是，每个datagram 会经过两次 <strong>system bus</strong>。</p><h3 id="switching-via-bus">Switching via Bus</h3><p>其中只用到一个 bus。bus bandwidth 限制了 <strong>switchingspeed</strong>。</p><h3 id="switching-via-interconnection-network">Switching viaInterconnection Network</h3><p>网状结构。先 <strong>fragmenting datagram</strong> into fixed lengthcells，再 switch cells through the fabric。</p><h2 id="output-port">Output Port</h2><div data-align="center"><pre><code class=" mermaid">flowchart LR    A[Switch Fabric] --&gt; B[Queueing: Buffer Management]    B --&gt; C[Data Link Processing]    C --&gt; D[Line Termination]</code></pre></div><h3 id="output-port-queueing">Output Port Queueing</h3><p>Buffering when arrival rate via switch <strong>exceeds</strong>output line speed. Queueing (<strong>delay</strong>) and loss due tooutput port buffer overflows.</p><p>所以，需要多大的 buffer？假设 <strong>typical <spanclass="math inline">\(\text{RTT}\)</span></strong>（一般是 <spanclass="math inline">\(250\)</span> ms），link capacity <spanclass="math inline">\(C\)</span>，有 <spanclass="math inline">\(N\)</span> 个 datagram flow。则： <spanclass="math display">\[\text{buffering} = \frac{\text{RTT} \cdot C}{\sqrt{N}}\]</span></p><h3 id="input-port-queueing">Input Port Queueing</h3><p>同样，输入端也会堵塞。应用了名叫 <strong>Head-of-the-Line (HOL)blocking</strong> 的机制，这个机制很好理解：就是排在前面的 datagram传输了，其后面的 datagram 才能传输。</p><h1 id="internet-protocol">Internet Protocol</h1><p>这个协议干了三件事：<strong>addressingconventions</strong>（地址约定），<strong>datagramformat</strong>，<strong>packet handlingconventions</strong>（分组处理约定）。</p><h2 id="ip-datagram-format">IP Datagram Format</h2><h3 id="ipv4">IPv4</h3><figure><img src="The-Network-Layer/IPv4%20datagram%20format.png"style="display: block; margin: 0 auto; width: 60%"alt="IPv4 datagram format" /><figcaption aria-hidden="true">IPv4 datagram format</figcaption></figure><p><strong>总结表格：</strong></p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr><th>字段名</th><th>长度</th><th>作用/说明</th></tr></thead><tbody><tr><td>Version</td><td>4 位</td><td>IP 协议版本号</td></tr><tr><td>Header Length</td><td>4 位</td><td>首部长度（单位：<span class="math inline">\(4\)</span> 字节，最少<span class="math inline">\(5\)</span> ）</td></tr><tr><td>Type of Service</td><td>8 位</td><td>服务类型/QoS</td></tr><tr><td>Datagram Length</td><td>16 位</td><td>数据报总长度（单位：<span class="math inline">\(1\)</span>字节）</td></tr><tr><td>Identifier</td><td>16 位</td><td>分片标识符</td></tr><tr><td><strong>Flags</strong></td><td>3 位</td><td>分片控制标志</td></tr><tr><td><strong>Fragmentation Offset</strong></td><td>13 位</td><td>分片偏移量（单位：<span class="math inline">\(8\)</span> 字节）</td></tr><tr><td>Time-to-Live (TTL)</td><td>8 位</td><td>生存时间/最大跳数</td></tr><tr><td>Upper-layer Protocol</td><td>8 位</td><td>上层协议类型</td></tr><tr><td>Header Checksum</td><td>16 位</td><td>首部校验和</td></tr><tr><td>Source IP Address</td><td>32 位</td><td>源 IP 地址</td></tr><tr><td>Destination IP Address</td><td>32 位</td><td>目的 IP 地址</td></tr><tr><td>Options</td><td>可变</td><td>可选字段</td></tr><tr><td>Data</td><td>可变</td><td>负载数据</td></tr></tbody></table></div><p><strong>补充</strong>： - <strong>Flags</strong> 有 <spanclass="math inline">\(3\)</span> 位，第一位恒为 <spanclass="math inline">\(0\)</span>，第二位表示 <strong>Don’tfragment</strong>（不可分片），第三位表示 <strong>Morefragments</strong>（后续有分片）。为 <spanclass="math inline">\(1\)</span> 的时候相应功能开启。</p><h3 id="ip-fragmentation-and-reassembly">IP Fragmentation andReassembly</h3><p>从 IPv4 的 datagram format 中可以发现，必要时会对 datagram 切片。</p><p><strong>MTU</strong>：max transfer size。这是对 <strong>link</strong>而言，也就是说不同的 <strong>link</strong> 有不同的<strong>MTU</strong>。</p><p><strong>Fragmentation and Reassembly</strong>的过程很简单，就是需要时切分datagram，最后在最终目的主机的网络层进行：只有当所有分片都到达后，网络层才会将完整的数据报交给上层（如传输层）。</p><p>假设原 IP datagram 总长度为 <spanclass="math inline">\(L\)</span>，待转发链路的 MTU 为 <spanclass="math inline">\(M\)</span>，若 <span class="math inline">\(L &gt;M\)</span> 且 DF 为 <span class="math inline">\(0\)</span>，则需要分片。- 先复制 <strong>Identifier</strong>。 - 一个切片可封装的数据为：<spanclass="math display">\[d = \left \lfloor \frac{M - 20}{8} \right \rfloor\times 8\]</span> - 需要的总片数为：<span class="math display">\[n =\left \lceil \frac{L - 20}{d} \right \rceil\]</span></p><h2 id="ipv4-addressing">IPv4 Addressing</h2><h3 id="subnet">Subnet</h3><p><strong>IP address</strong>: subnet part (high order bits) <spanclass="math inline">\(+\)</span> host part (low order bits).</p><p>在一个 subnet中的所有设备都可以直接<strong>物理意义上</strong>地连接。</p><p><strong>Subnet mask</strong>：用类似 <code>/24</code>的形式表示。也就是说，前 <span class="math inline">\(24\)</span> 相同的IP address 在同一个 subnet 中。</p><h4 id="classes-inter-domain-routing-cidr">Classes Inter Domain Routing:CIDR</h4><p>规定了 address format 为 <code>a.b.c.d/x</code>。</p><h4 id="dynamic-host-configuration-protocol-dhcp">Dynamic HostConfiguration Protocol: DHCP</h4><p><strong>Goal</strong>: allow host to dynamically get his IP addressfrom a server when it joins network. - Can renew its lease on address inuse. - Allows reuse of address. - Support for mobile users who want tojoin network.</p><p><strong>DHCP</strong>（Dynamic Host ConfigurationProtocol，动态主机配置协议）是一个<strong>网络管理协议</strong>，用于在IP网络中<strong>自动分配IP地址和其他网络配置参数</strong>给网络设备。DHCP运行在<strong>应用层</strong>，使用<strong>UDP协议</strong>，客户端使用<strong>端口68</strong>，服务器使用<strong>端口67</strong>。</p><figure><img src="The-Network-Layer/DHCP%20client-server%20interaction.png"style="display: block; margin: 0 auto; width: 50%"alt="DHCP client-server interaction" /><figcaption aria-hidden="true">DHCP client-serverinteraction</figcaption></figure><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>步骤</th><th>消息类型</th><th>发送者</th><th>接收者</th><th>主要内容</th></tr></thead><tbody><tr><td>1</td><td>DISCOVER</td><td>客户端</td><td>广播</td><td>“我需要一个IP地址”</td></tr><tr><td>2</td><td>OFFER</td><td>服务器</td><td>客户端</td><td>“你可以使用这个IP”</td></tr><tr><td>3</td><td>REQUEST</td><td>客户端</td><td>广播</td><td>“我想使用这个IP”</td></tr><tr><td>4</td><td>ACK</td><td>服务器</td><td>客户端</td><td>“IP已分配，租期为X”</td></tr></tbody></table></div><p><strong>yiaddr</strong>（your IPaddress）是DHCP协议中表示<strong>服务器提供给客户端的IP地址</strong>的字段。</p><p><strong>补充</strong>：DHCP 还可以 return <strong>address offirst-hop router for client</strong>，<strong>name and IP address of DNSserver</strong>，<strong>network mask</strong>。</p><h3 id="network-address-translation-nat">Network Address Translation:NAT</h3><figure><img src="The-Network-Layer/Network%20address%20translation.png"style="display: block; margin: 0 auto; width: 90%"alt="Network address translation" /><figcaption aria-hidden="true">Network address translation</figcaption></figure><p>右边：局域网内通信，使用内部地址：<code>10.0.0/24</code>；左边：局域网外通信，共用唯一地址。注意，没有共用同一个端口号，因为端口号是用来区分的。比如：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align: center;">WAN 侧 (对外显示)</th><th style="text-align: center;">LAN 侧 (实际主机)</th></tr></thead><tbody><tr><td style="text-align: center;">203.0.113.5:50001</td><td style="text-align: center;">192.168.1.10:3345</td></tr><tr><td style="text-align: center;">203.0.113.5:50002</td><td style="text-align: center;">192.168.1.10:3346</td></tr><tr><td style="text-align: center;">203.0.113.5:50003</td><td style="text-align: center;">192.168.1.11:3345</td></tr></tbody></table></div><p>这样布置有一个比较好的优势：可以更换 ISP的同时不改变局域网内的地址。</p><p>注意到中间的 <strong>NAT router</strong>。它的功能如下： - 对<strong>outgoing datagrams</strong>，把原始 IP address 和 port更换为自己的 IP address 和 port。 - 再把上述转换记下来记为 <strong>NATtranslation table</strong>。 - 对 <strong>incomingdatagrams</strong>，更换。</p><p>现在回顾 NAT，不难察觉几个问题： - 如果 LAN 中的 host 想要通过 P2P进行 communication，此时该怎么办？ - 如果一个服务器是 NAT 的 LAN地址，怎么办？</p><h2 id="internet-control-message-protocol-icmp">Internet Control MessageProtocol: ICMP</h2><p>这个协议 used by hosts and routers to communicate network-levelinformation。具体包括： - Error reporting. - Echo request and reply.</p><p><strong>ICMP message</strong>的结构包括：<strong>type</strong>、<strong>code</strong>、<strong>checksum</strong>以及数据部分。</p><p>具体用来干什么？ - 通过发送 UDP segment，在 IP datagram header内设置适当的 TTL，来计算 <spanclass="math inline">\(\text{RTT}\)</span>。 - 还可以用来停止 source持续发送 UDP segment。</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>字段名</th><th>长度</th><th>作用/说明</th></tr></thead><tbody><tr><td><strong>Type</strong></td><td>8位</td><td>消息类型（如0=回显回复，3=目的不可达，8=回显请求）</td></tr><tr><td><strong>Code</strong></td><td>8位</td><td>消息子类型（进一步说明类型）</td></tr><tr><td><strong>Checksum</strong></td><td>16位</td><td>校验和（覆盖整个ICMP消息）</td></tr><tr><td><strong>Rest of Header</strong></td><td>32位</td><td>取决于Type和Code的其他信息</td></tr><tr><td><strong>Data</strong></td><td>可变</td><td>负载数据（例如原始数据包的片段）</td></tr></tbody></table></div><h2 id="ipv6">IPv6</h2><p>为了解决 IPv4 地址不足。具体 format 不讲，但要注意 header 大小为<span class="math inline">\(40\)</span> bytes，只有 address 大小变为<span class="math inline">\(128\)</span> bits。</p><h3 id="transition-from-ipv4-to-ipv6">Transition from IPv4 to IPv6</h3><figure><img src="The-Network-Layer/Tunneling.png"style="display: block; margin: 0 auto; width: 90%" alt="Tunneling" /><figcaption aria-hidden="true">Tunneling</figcaption></figure><p><strong>Tunneling</strong>: IPv6 carried as payload in IPv4 datagramamong Ipv4 routers.</p><h1 id="routing-algorithms">Routing Algorithms</h1><h2 id="software-defined-networking-sdn">Software-Defined Networking:SDN</h2><p>实际上，network layer 可以分为 <strong>data plane</strong> 和<strong>control plane</strong>，在 <strong>control plane</strong> 有一个logically centralized routing controller，由它 compute paths。</p><h2 id="link-state-algorithm">Link State Algorithm</h2><h3 id="dijkstras-link-state-algorithm">Dijkstra’s Link-StateAlgorithm</h3><p>伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">N = &#123;u&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : nodes) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isAdjacent</span>(u, a)) &#123;<br>      D[a] = <span class="hljs-built_in">Cost</span>(u, a);<br>      P[a] = u;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      D[a] = INF;<br>      P[a] = a;<br>      &#125;<br>&#125;<br><span class="hljs-keyword">while</span> (! all nodes in N) &#123;<br>    D[a] = <span class="hljs-built_in">min</span>(D)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> b : nodes) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isAdjacent</span>(b ,a)) &#123;<br>          D[b] = <span class="hljs-built_in">min</span>(D[b], <span class="hljs-built_in">Cost</span>(b, a) + D[a])<br>          <span class="hljs-keyword">if</span> (D[b] == <span class="hljs-built_in">Cost</span>(b, a) + D[a]) P[b] = a;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际做题的时候可以参考书上的风格：</p><p>记 <span class="math inline">\(N&#39;\)</span>为<strong>已找到最短路径</strong>的点集合，函数 <spanclass="math inline">\(D(x)\)</span> 为到点 <spanclass="math inline">\(x\)</span> 的最短路径，函数 <spanclass="math inline">\(P(x)\)</span> 为点 <spanclass="math inline">\(x\)</span>的父母结点。可以规范化求解过程如下，其中 <spanclass="math inline">\(0\)</span> 轮初始化。</p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr><th style="text-align: center;"><strong>Step</strong></th><th style="text-align: center;"><strong><spanclass="math inline">\(N&#39;\)</span></strong></th><th style="text-align: center;"><strong><spanclass="math inline">\(D()\,P()\)</span></strong></th><th style="text-align: center;"><strong><spanclass="math inline">\(D()\,P()\)</span></strong></th><th style="text-align: center;"><strong><spanclass="math inline">\(\cdots\)</span></strong></th><th style="text-align: center;"><strong><spanclass="math inline">\(D()\,P()\)</span></strong></th></tr></thead><tbody><tr><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(u\)</span></td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(uv\)</span></td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(uvw\)</span></td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(\cdots\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\cdots\)</span></td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(N\)</span></td><td style="text-align: center;"><span class="math inline">\(uvw \cdotsl\)</span></td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td></tr></tbody></table></div><p>这样可以求出从起点到图中其它点的所有最短路径。可以用来制作 forwardingtable。</p><p>可以用<strong>优先队列</strong>优化时间复杂度。</p><p>这里需要提到一个概念 <strong>Oscillationpossible</strong>，指的是网络路由状态可能出现反复波动、难以稳定的现象，是网络设计和协议实现中需要重点关注和避免的问题。这可能会导致在Link State Algorithm 中计算到无穷的结果。</p><h2 id="distance-vector-algorithm">Distance Vector Algorithm</h2><p><strong>Distributed Bellman-Ford equation</strong>: <spanclass="math display">\[D(x \to y) = \min_{v} \{\text{Cost}_{x \to v} +D(v \to y), \, D(x \to y)\}\]</span></p><p>其中，<span class="math inline">\(v\)</span> 是 <spanclass="math inline">\(x\)</span> 的邻居。</p><p>这是一个 <strong>iterative</strong>算法，需要多次计算，直到收敛。计算过程可以参考课本，如下表所述，结点<span class="math inline">\(z\)</span> 的 table。</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align: center;"><spanclass="math inline">\(z\)</span></th><th style="text-align: center;">cost to</th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th></tr></thead><tbody><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(x\)</span></td><td style="text-align: center;"><spanclass="math inline">\(y\)</span></td><td style="text-align: center;"><spanclass="math inline">\(z\)</span></td><td style="text-align: center;"><spanclass="math inline">\(u\)</span></td><td style="text-align: center;"><spanclass="math inline">\(v\)</span></td></tr><tr><td style="text-align: center;">from <spanclass="math inline">\(x\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td></tr><tr><td style="text-align: center;">from <spanclass="math inline">\(y\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td></tr><tr><td style="text-align: center;">from <spanclass="math inline">\(z\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(5\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(7\)</span></td><td style="text-align: center;"><spanclass="math inline">\(5\)</span></td></tr><tr><td style="text-align: center;">from <spanclass="math inline">\(u\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td></tr><tr><td style="text-align: center;">from <spanclass="math inline">\(v\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(6\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td></tr></tbody></table></div><h1 id="hierarchical-routing">Hierarchical Routing</h1><p><strong>Internet approach to scalable routing</strong>: aggregaterouters into regions known as <strong>autonomous system(AS)</strong></p><figure><img src="The-Network-Layer/AS%20structure.jpg"style="display: block; margin: 0 auto; width: 100%"alt="AS structure" /><figcaption aria-hidden="true">AS structure</figcaption></figure><h2 id="intra-as-routing-protocol">Intra-AS Routing Protocol</h2><ol type="1"><li>RIP: Routing Information Protocol (wasted).</li><li>OSPF: Open Shortest Path First (Link-State).</li><li>EIGRP: Enhanced Interior Gateway Routing Protocol.</li></ol><h3 id="ospf-open-shortest-path-first">OSPF: Open Shortest PathFirst</h3><p>classic link-state: 1. Each router floods <strong>OSPF</strong>link-state advertisements (over IP) to all routers. 2. Multiple linkcosts metrics possible: bandwidth, delay. 3. Each router has fulltopology, Dijkstra algorithm.</p><p>Security: all OSPF messages authenticated</p><figure><img src="The-Network-Layer/Hierarchical%20OSPF.png"style="display: block; margin: 0 auto; width: 80%"alt="Hierarchical OSPF" /><figcaption aria-hidden="true">Hierarchical OSPF</figcaption></figure><h2 id="inter-as-protocol">Inter-AS Protocol</h2><h3 id="bgp-border-gateway-protocol">BGP: Border Gateway Protocol</h3><p>BGP provides each AS a means to: - obtain destination networkreachability information form neighboring ASes eBGP. - determine routersto other networks based on reachability information and policy. -propagate reachability information to all AS-internal routers: iBGP. -advertise (to neighboring networks) destination reachabilityinformation.</p><figure><img src="The-Network-Layer/eBGP%20and%20iBGP%20sessions.png"style="display: block; margin: 0 auto; width: 90%"alt="eBGP and iBGP sessions" /><figcaption aria-hidden="true">eBGP and iBGP sessions</figcaption></figure><ul><li>BGP对等体（BGPpeers）通过<strong>半永久TCP连接</strong>（BGP会话）交换路由信息。</li><li>BGP会话不一定对应物理链路。</li><li>当AS2向AS1通告前缀时：<ul><li>AS2 <strong>承诺</strong>会为该前缀转发数据报。</li><li>AS2可以在通告中聚合前缀。</li></ul></li><li>通过eBGP会话，AS3将前缀可达性信息发送给AS1。</li><li>AS1内部的路由器（如1c）通过iBGP将新前缀信息分发给AS1内所有路由器。</li><li>AS1的1b路由器可以通过eBGP会话将新前缀信息再通告给AS2。</li><li>路由器学到新前缀后，会在转发表中为该前缀创建条目。</li><li>BGP通告的前缀包含<strong>BGP属性</strong>，前缀+属性即为<strong>路由</strong>。</li><li>两个重要属性：<ul><li><strong>AS-PATH</strong>：记录前缀通告经过的AS序列（如AS 67, AS17）。</li><li><strong>NEXT-HOP</strong>：指明到下一个AS的具体内部路由器（可能有多条链路）。</li></ul></li><li>当网关路由器收到路由通告时，会根据<strong>importpolicy</strong>（导入策略）决定是否接受该路由。</li></ul><p>假设有以下网络拓扑结构：</p><div style="display: block; margin: 0 auto; width: fit-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">        +------+<br>        | AS65 |<br>        +------+<br>       /        \<br>      /          \<br>+------+        +------+<br>| AS23 |--------| AS17 |<br>+------+        +------+<br>   |                |<br>+------+        +------+<br>| AS45 |        | AS78 |<br>+------+        +------+<br>                 /<br>             +------+<br>             | AS99 |---前缀：192.168.99.0/24<br>             +------+<br></code></pre></td></tr></table></figure></div><p>AS-PATH传播过程</p><p>假设AS99宣告前缀192.168.99.0/24，我们跟踪这个前缀在网络中的传播：</p><ol type="1"><li><strong>AS99向AS78通告前缀</strong>：<ul><li>AS99向AS78发送BGP更新：<code>192.168.99.0/24, AS-PATH=&#123;99&#125;</code></li><li>AS78收到前缀后，将其存入路由表</li></ul></li><li><strong>AS78向AS17通告前缀</strong>：<ul><li>AS78在转发前，将自己的AS号添加到AS-PATH</li><li>AS78发送BGP更新：<code>192.168.99.0/24, AS-PATH=&#123;78, 99&#125;</code></li></ul></li><li><strong>AS17向多个AS传播</strong>：<ul><li>AS17向AS23发送：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li><li>AS17向AS65发送：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li></ul></li><li><strong>AS23收到两种路径</strong>：<ul><li>从AS17：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li><li>从AS45（假设AS45也与AS99间接相连）：<code>192.168.99.0/24, AS-PATH=&#123;45, ..., 99&#125;</code></li><li>AS23基于AS-PATH长度和其他策略选择最佳路径</li></ul></li><li><strong>AS65收到更新后</strong>：<ul><li>获得路由：<code>192.168.99.0/24, AS-PATH=&#123;65, 17, 78, 99&#125;</code></li><li>若之后收到AS23的路由通告，也会比较两条路径</li></ul></li></ol><h1 id="subnetprefix和bgp-route的对比分析">Subnet、Prefix和BGPRoute的对比分析</h1><h2 id="subnet子网">Subnet（子网）</h2><p><strong>子网</strong>是指<strong>物理网络的逻辑划分</strong>，具有以下特征：- 由<strong>共享相同网络前缀</strong>的IP地址集合组成 -通过<strong>网络地址</strong>和<strong>子网掩码</strong>定义（如192.168.1.0/24）- 子网内设备可<strong>直接通信</strong>，无需路由器转发 -代表<strong>单一广播域</strong>内的网络段 -通常属于<strong>单一管理实体</strong></p><h2 id="prefix前缀">Prefix（前缀）</h2><p><strong>前缀</strong>是<strong>IP地址空间中的地址块</strong>，具有以下特征：- 用<strong>CIDR表示法</strong>表示（如10.0.0.0/8） -表示IP地址中固定的<strong>网络部分位数</strong> -是<strong>路由表聚合</strong>的基础单位 -可以表示<strong>不同大小</strong>的地址块 -是<strong>地址分配和路由通告</strong>的基本单位</p><h2 id="bgp-routebgp路由">BGP Route（BGP路由）</h2><p><strong>BGP路由</strong>是<strong>互联网核心路由系统</strong>中的路由条目：- 包含<strong>目的地前缀</strong>和<strong>完整路径属性</strong> -核心属性包括<strong>AS_PATH</strong>（自治系统路径）、<strong>NEXT_HOP</strong>等- 反映了<strong>网络政策</strong>和<strong>商业关系</strong> -用于<strong>自治系统间</strong>的路由决策 -通过BGP协议在全球互联网中<strong>传播和交换</strong></p><p>NEXT-HOP属性在BGP中用于<strong>指明到达目标网络的下一跳路由器IP地址</strong>，具体使用方式如下：</p><ol type="1"><li><strong>路由转发决策</strong><ul><li>当路由器接收到目标数据包时，通过查询BGP表中的NEXT-HOP属性确定<strong>实际转发目标</strong></li><li>路由器必须能够通过IGP协议(如OSPF)到达NEXT-HOP地址</li></ul></li><li><strong>BGP会话中的传递规则</strong><ul><li><strong>eBGP传递</strong>：设置为发送更新的BGP对等体的IP地址</li><li><strong>iBGP传递</strong>：保持NEXT-HOP值不变（除非明确配置修改）</li><li><strong>多出口AS</strong>：帮助选择最佳出口点</li></ul></li><li><strong>策略实现</strong><ul><li>通过修改NEXT-HOP实现<strong>流量工程</strong></li><li>支持热备份和负载均衡策略</li><li>可设置为特定接口地址或第三方路由器地址</li></ul></li></ol><p>AS-PATH属性记录了<strong>路由通告经过的AS序列</strong>，在BGP中具有多重重要功能：</p><ol type="1"><li><strong>路由选择依据</strong><ul><li>作为BGP决策过程中的<strong>关键指标</strong>之一</li><li><strong>AS-PATH越短</strong>的路径通常被优先选择</li><li>影响决策优先级：Local Preference &gt; AS-PATH长度 &gt; Origin &gt;MED等</li></ul></li><li><strong>环路检测机制</strong><ul><li>当路由器在AS-PATH中发现<strong>自己的AS号</strong>时，自动拒绝该路由</li><li>避免路由环路产生，确保BGP路由收敛性</li><li>例如：AS17收到路径”AS23, AS45, AS17, AS78”会直接丢弃</li></ul></li><li><strong>路径操纵技术</strong><ul><li>通过<strong>AS-PATH预置</strong>(prepending)增加路径长度</li><li>例如：“AS78, AS78, AS78, AS99”使路径看起来更长</li><li>降低特定路径被选择的可能性，实现出站流量控制</li></ul></li><li><strong>路由过滤依据</strong><ul><li>基于AS-PATH中的特定AS创建<strong>过滤策略</strong></li><li>可拒绝包含竞争对手或不信任AS的路由</li><li>实现复杂的路由策略控制和商业关系维护</li></ul></li></ol><h2 id="三者关系对比">三者关系对比</h2><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>特性</th><th>Subnet</th><th>Prefix</th><th>BGP Route</th></tr></thead><tbody><tr><td><strong>范围</strong></td><td>局部网段</td><td>地址块</td><td>全球路由</td></tr><tr><td><strong>用途</strong></td><td>网络分段</td><td>地址分配与聚合</td><td>域间路由决策</td></tr><tr><td><strong>包含信息</strong></td><td>网络地址+掩码</td><td>地址块+长度</td><td>前缀+路径属性</td></tr><tr><td><strong>管理层次</strong></td><td>单一管理域内</td><td>可跨域使用</td><td>多AS协作</td></tr><tr><td><strong>通告机制</strong></td><td>不直接通告</td><td>内部路由协议</td><td>BGP协议</td></tr><tr><td><strong>聚合能力</strong></td><td>固定大小</td><td>可变大小</td><td>可聚合或特定</td></tr></tbody></table></div><h2 id="层次关系">层次关系</h2><p>这三个概念形成了一个层次结构： -<strong>Subnet</strong>：最基础，表示<strong>实际网络分段</strong> -<strong>Prefix</strong>：中间层，表示<strong>可路由的地址块</strong> -<strong>BGPRoute</strong>：最高层，表示<strong>如何到达特定前缀的完整路径信息</strong></p><p>一个BGP路由可以指向一个前缀，而一个前缀可以包含多个子网。</p><h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1><h2 id="p.6">P.6</h2><p><strong>Questions:</strong></p><p>In the text we have used the term connection-oriented service todescribe a transport-layer service and connection service for anetwork-layer service. Why the subtle shades in terminology?</p><p><strong>Answer:</strong></p><p>The subtle difference in terminology reflects the distinct roles andresponsibilities of the transport and network layers:</p><ul><li><p><strong>Connection-oriented service (TransportLayer):</strong><br />At the transport layer, a connection-oriented service (such as TCP)establishes, maintains, and terminates a logical end-to-end connection.This connection is defined <strong>between two processes</strong> on theend hosts (e.g., two TCP sockets). This service ensures reliable,ordered, and error-checked delivery of data across the entire networkpath, directly between the communicating applications.</p></li><li><p><strong>Connection service (Network Layer):</strong><br />At the network layer, a connection service (such as a virtual circuit)refers to the establishment of a logical path through the network,typically between routers or switches. This connection is defined<strong>between two hosts</strong> (and their intervening routers in thecase of virtual-circuit networks). This path helps guide packets fromsource to destination but does not necessarily guarantee reliability orordering. The focus here is on the route and forwarding of packetswithin the network infrastructure.</p></li></ul><p><strong>In summary:</strong><br />The term “connection-oriented service” at the transport layer emphasizesend-to-end reliability and communication, while “connection service” atthe network layer highlights the setup of a path through the network,without necessarily providing full end-to-end guarantees. The nuancedterminology helps clarify the different scopes and guarantees providedby each layer.</p><h2 id="p.9">P.9</h2><p><strong>Consider a datagram network using 32-bit host addresses.Suppose a router has four links, numbered 0 through 3, and packets areto be forwarded to the link interfaces as follows:</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align: center;">Destination Address Range</th><th style="text-align: center;">Link Interface</th></tr></thead><tbody><tr><td style="text-align: center;"></td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;">3</td></tr></tbody></table></div><p><strong>Questions and Answers:</strong></p><p><strong>a. Provide a forwarding table that has four entries, useslongest prefix matching, and forwards packets to the correct linkinterfaces.</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>Header</th><th style="text-align: center;">Link Interface(output)</th></tr></thead><tbody><tr><td>11100000 00</td><td style="text-align: center;">0</td></tr><tr><td>11100000 01000000</td><td style="text-align: center;">1</td></tr><tr><td>1110000</td><td style="text-align: center;">2</td></tr><tr><td>otherwise</td><td style="text-align: center;">3</td></tr></tbody></table></div><p><strong>Explanation:</strong><br />- Each entry uses the longest prefix that matches the given addressrange. - The router checks the destination address against each prefix,starting from the longest, and forwards the packet to the correspondinginterface.</p><p><strong>b. Describe how your forwarding table determines theappropriate link interface for datagrams with destinationaddresses</strong>:</p><div data-align="center">11001000 10010001 01010001 01010101</div><div data-align="center">11100001 01000000 11000011 00111100</div><div data-align="center">11100001 10000000 00010001 01110111</div><ol type="1"><li><strong>11001000 10010001 01010001 01010101</strong><ul><li>This address does <strong>not</strong> match any of the specifiedprefixes (does not start with 111…), so it is forwarded to<strong>interface 3</strong>.</li></ul></li><li><strong>11100001 01000000 11000011 00111100</strong><ul><li>This address matches the third entry:<ul><li>Prefix: <code>1110000</code></li><li>So, it is forwarded to <strong>interface 2</strong>.</li></ul></li></ul></li><li><strong>11100001 10000000 00010001 01110111</strong><ul><li>This address matches the third entry:<ul><li>Prefix: <code>1110000</code></li><li>So, it is forwarded to <strong>interface 2</strong>.</li></ul></li></ul></li></ol><h2 id="p.10">P.10</h2><p><strong>Consider a datagram network using 8-bit host addresses.Suppose a router uses longest-prefix matching and has the followingforwarding table:</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align: center;">Prefix Match</th><th style="text-align: center;">Interface</th></tr></thead><tbody><tr><td style="text-align: center;">00</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">010</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">011</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">10</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">11</td><td style="text-align: center;">3</td></tr></tbody></table></div><p><strong>Question and Answer:</strong></p><p>For each of the four interfaces, give the associated range ofdestination host addresses and the number of addresses in the range.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align: center;">Interface</th><th style="text-align: center;">Destination Address Range</th><th style="text-align: right;">Number of Addresses</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">00000000 - 00111111</td><td style="text-align: right;">64</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">01000000 - 01011111</td><td style="text-align: right;">32</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">01100000 - 01111111<br>10000000 -10111111</td><td style="text-align: right;">96</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">11000000 - 11111111</td><td style="text-align: right;">64</td></tr></tbody></table></div><h2 id="p.17">P.17</h2><p><strong>Question and Answer:</strong></p><p>Consider sending a 2400-byte datagram into a link that has an MTU of700 bytes. Suppose the original datagram is stamped with theidentification number 422. How many fragments are generated? What arethe values in the various fields in the IP datagram(s) generated relatedto fragmentation?</p><p>According to IPv4 datagram format, each fragment includes a 20-bytesheader.</p><p>先计算数据大小 <span class="math inline">\(d = \lfloor \frac{700 -20}{8} \rfloor \times 8 = 680\)</span> bytes。</p><p>所以需要分成 <span class="math inline">\(n = \lceil \frac{2400 -20}{d} \rceil = 4\)</span></p><p>主要变化在 <code>Offset</code> 和 <code>Flag</code>，所以：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align: center;">Fragment</th><th style="text-align: center;">Datagram length</th><th style="text-align: center;">Offset</th><th style="text-align: center;">Flag</th></tr></thead><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">700</td><td style="text-align: center;">0</td><td style="text-align: center;">001</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">700</td><td style="text-align: center;">85</td><td style="text-align: center;">001</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">700</td><td style="text-align: center;">170</td><td style="text-align: center;">001</td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;">360</td><td style="text-align: center;">255</td><td style="text-align: center;">000</td></tr></tbody></table></div><h2 id="p.18">P.18</h2><p><strong>Question and Answer:</strong></p><p>Suppose datagrams are limited to 1,500 bytes (including header)between source Host A and destination Host B. Assuming a 20-byte IPheader, how many datagrams would be required to send an MP3 consistingof 5 million bytes? Explain how you computed your answer.</p><p>MTU 为 <span class="math inline">\(1500\)</span> bytes，一个 datagram的 data 大小为 <span class="math inline">\(d = \lfloor \frac{1500-20}{8} \rfloor \times 8 = 1480\)</span> bytes。</p><p>最终，datagram 的数目为 <span class="math inline">\(n = \lceil\frac{5 \times 10^6}{d} \rceil = 3379\)</span> 个。</p><h2 id="p.19">P.19</h2><p><strong>Consider the network setup in Figure 4.22. Suppose that theISP instead assigns the router the address 24.34.112.235 and that thenetwork address of the home network is 192.168.1/24</strong>.</p><figure><img src="The-Network-Layer/Network%20address%20translation.png"style="display: block; margin: 0 auto; width: 80%"alt="Network address translation" /><figcaption aria-hidden="true">Network address translation</figcaption></figure><p><strong>Questions and Answers:</strong></p><p><strong>a. Assign addresses to all interfaces in the homenetwork.</strong></p><p>也即是说，中间的 router WAN 的 IP address 是<code>24.34.112.235</code>，LAN 的是<code>192.168.1/24</code>，不妨和原图一样，设为<code>192.168.1.4</code>。则右边的三个 host 的 LAN IP address分别为：</p><ul><li>Host 1 address is 192.168.1.1</li><li>Host 2 address is 192.168.1.2</li><li>Host 3 address is 192.168.1.3</li></ul><p><strong>b. Suppose each host has two ongoing TCP connections, all toport 80 at host 128.119.40.86. Provide the six corresponding entries inthe NAT translation table.</strong></p><p>总共有 <span class="math inline">\(6\)</span> 个 TCPconnection，随便分几个端口号：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align: center;">WAN side</th><th style="text-align: center;">LAN side</th></tr></thead><tbody><tr><td style="text-align: center;">24.34.112.235, 50001</td><td style="text-align: center;">192.168.1.1, 3345</td></tr><tr><td style="text-align: center;">24.34.112.235, 50002</td><td style="text-align: center;">192.168.1.1, 3346</td></tr><tr><td style="text-align: center;">24.34.112.235, 50003</td><td style="text-align: center;">192.168.1.2, 3345</td></tr><tr><td style="text-align: center;">24.34.112.235, 50004</td><td style="text-align: center;">192.168.1.2, 3346</td></tr><tr><td style="text-align: center;">24.34.112.235, 50005</td><td style="text-align: center;">192.168.1.3, 3345</td></tr><tr><td style="text-align: center;">24.34.112.235, 50006</td><td style="text-align: center;">192.168.1.3, 3346</td></tr></tbody></table></div><h2 id="p.24">P.24</h2><figure><img src="The-Network-Layer/P24.jpg"style="display: block; margin: 0 auto; width: 80%" alt="Graph P.24" /><figcaption aria-hidden="true">Graph P.24</figcaption></figure><p><strong>Question:</strong></p><p>Consider the following network. With the indicated link costs, useDijkstra’s shortest-path algorithm to compute the shortest path from xto all network nodes. Show how the algorithm works by computing a tablesimilar to Table 4.3.</p><p><strong>Answer:</strong></p><p><span class="math inline">\(N&#39; = \{x\}\)</span></p><table><thead><tr><th style="text-align: center;">step</th><th style="text-align: center;"><spanclass="math inline">\(D(x)\)</span> <spanclass="math inline">\(P(x)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(D(y)\)</span> <spanclass="math inline">\(P(y)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(D(z)\)</span> <spanclass="math inline">\(P(z)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(D(v)\)</span> <spanclass="math inline">\(P(v)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(D(u)\)</span> <spanclass="math inline">\(P(u)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(D(w)\)</span> <spanclass="math inline">\(P(w)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(D(t)\)</span> <spanclass="math inline">\(P(t)\)</span></th><th style="text-align: center;"><spanclass="math inline">\(N&#39;\)</span></th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(0\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><strong><spanclass="math inline">\(3\)</span></strong> <spanclass="math inline">\(x\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(x\)</span></td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(0\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><strong><spanclass="math inline">\(6\)</span></strong> <spanclass="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span><span class="math inline">\(v\)</span></td><td style="text-align: center;"><spanclass="math inline">\(xv\)</span></td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(0\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><strong><spanclass="math inline">\(6\)</span></strong> <spanclass="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span><span class="math inline">\(v\)</span></td><td style="text-align: center;"><spanclass="math inline">\(xvy\)</span></td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(0\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(v\)</span></td><td style="text-align: center;"><strong><spanclass="math inline">\(6\)</span></strong> <spanclass="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span><span class="math inline">\(v\)</span></td><td style="text-align: center;"><spanclass="math inline">\(xvyu\)</span></td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(0\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><strong><spanclass="math inline">\(7\)</span></strong> <spanclass="math inline">\(v\)</span></td><td style="text-align: center;"><spanclass="math inline">\(xvyuw\)</span></td></tr><tr><td style="text-align: center;">5</td><td style="text-align: center;"><span class="math inline">\(0\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><strong><spanclass="math inline">\(8\)</span></strong> <spanclass="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span><span class="math inline">\(v\)</span></td><td style="text-align: center;"><spanclass="math inline">\(xvyuwt\)</span></td></tr><tr><td style="text-align: center;">6</td><td style="text-align: center;"><span class="math inline">\(0\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span><span class="math inline">\(v\)</span></td><td style="text-align: center;"><spanclass="math inline">\(xvyuwtz\)</span></td></tr></tbody></table><p>So the shortest path from <span class="math inline">\(x\)</span> toall nodes is follow.</p><table><thead><tr><th style="text-align: center;">Destination</th><th style="text-align: center;">Shortest Distance</th><th style="text-align: center;">Path</th></tr></thead><tbody><tr><td style="text-align: center;"><spanclass="math inline">\(x\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(x\)</span></td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(v\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><span class="math inline">\(x \tov\)</span></td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(y\)</span></td><td style="text-align: center;"><spanclass="math inline">\(6\)</span></td><td style="text-align: center;"><span class="math inline">\(x \toy\)</span></td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(w\)</span></td><td style="text-align: center;"><spanclass="math inline">\(6\)</span></td><td style="text-align: center;"><span class="math inline">\(x \tow\)</span></td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(u\)</span></td><td style="text-align: center;"><spanclass="math inline">\(6\)</span></td><td style="text-align: center;"><span class="math inline">\(x \to v \tou\)</span></td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(t\)</span></td><td style="text-align: center;"><spanclass="math inline">\(7\)</span></td><td style="text-align: center;"><span class="math inline">\(x \to v \tot\)</span></td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(z\)</span></td><td style="text-align: center;"><spanclass="math inline">\(8\)</span></td><td style="text-align: center;"><span class="math inline">\(x \toz\)</span></td></tr></tbody></table><h2 id="p.26">P.26</h2><figure><img src="The-Network-Layer/P26.png"style="display: block; margin: 0 auto; width: 80%" alt="Graph P.26" /><figcaption aria-hidden="true">Graph P.26</figcaption></figure><p><strong>Question:</strong></p><p>Consider the network shown below, and assume that each node initiallyknows the costs to each of its neighbors. Consider the distance-vectoralgorithm and show the distance table entries at node z.</p><p><strong>Answer:</strong></p><p><strong>Node z table:</strong></p><p><strong><em>First round</em></strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">cost to</th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th></tr></thead><tbody><tr><td style="text-align: center;"></td><td style="text-align: center;">x</td><td style="text-align: center;">y</td><td style="text-align: center;">z</td><td style="text-align: center;">u</td><td style="text-align: center;">v</td></tr><tr><td style="text-align: center;">from x</td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td></tr><tr><td style="text-align: center;">from y</td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td></tr><tr><td style="text-align: center;">from z</td><td style="text-align: center;">2</td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;">6</td></tr><tr><td style="text-align: center;">from u</td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td></tr><tr><td style="text-align: center;">from v</td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td></tr></tbody></table></div><p><strong><em>Second round</em></strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">cost to</th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th></tr></thead><tbody><tr><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(x\)</span></td><td style="text-align: center;"><spanclass="math inline">\(y\)</span></td><td style="text-align: center;"><spanclass="math inline">\(z\)</span></td><td style="text-align: center;"><spanclass="math inline">\(u\)</span></td><td style="text-align: center;"><spanclass="math inline">\(v\)</span></td></tr><tr><td style="text-align: center;">from <spanclass="math inline">\(x\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td></tr><tr><td style="text-align: center;">from <spanclass="math inline">\(y\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td></tr><tr><td style="text-align: center;">from <spanclass="math inline">\(z\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(5\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(7\)</span></td><td style="text-align: center;"><spanclass="math inline">\(5\)</span></td></tr><tr><td style="text-align: center;">from <spanclass="math inline">\(u\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td></tr><tr><td style="text-align: center;">from <spanclass="math inline">\(v\)</span></td><td style="text-align: center;"><spanclass="math inline">\(3\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: center;"><spanclass="math inline">\(6\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\infty\)</span></td></tr></tbody></table></div><p>Because the question only asks to show the distance table entries atnode z, we do not need to compute the full routing tables for all nodes.The Second round result about node z is also the finial result. 到这一步from z to other 的 cost 表就收敛了，题目也只问了 node z。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Network Layer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>提升方法</title>
    <link href="/2025/05/30/%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/"/>
    <url>/2025/05/30/%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="adaboost-算法">AdaBoost 算法</h2><p><strong><em>Data Information</em></strong>：<strong>二分类</strong>训练数据集 <span class="math inline">\(T\)</span><span class="math display">\[\begin{align}T&amp; = \{(x_1, y_1), (x_2, y_2), \ldots, (x_N, y_N)\}\\x_i \in \mathcal{X}&amp; = \mathbb{R}^n, \quad y_i \in \mathcal{Y} =\{+1, -1\}, \quad i = 1, 2, \ldots, N\end{align}\]</span></p><p><strong><em>Algorithm Process</em></strong> 1.初始化训练数据的权值分布： <span class="math display">\[   D_1 = (w_{11}, w_{12}, \dots, w_{1N}), \quad w_{1i} = \frac{1}{N},\quad i = 1, 2, \dots, N   \]</span></p><ol start="2" type="1"><li>用权值分布 <span class="math inline">\(D_i\)</span><ol type="a"><li><p>计算不正确率： <span class="math display">\[e_m = \sum_{i=1}^{N} P(G_m(x_i) \neq y_i) = \sum_{i=1}^{N} w_{mi}I(G_m(x_i) \neq y_i)\]</span></p></li><li><p>计算 <span class="math inline">\(\alpha_m\)</span>: <spanclass="math display">\[\alpha_m = \frac{1}{2} \ln \frac{1 - e_m}{e_m}\]</span></p></li><li><p>更新权值分布: <span class="math display">\[D_{m+1} = (w_{m+1,1}, \dots, w_{m+1, N})\]</span> <span class="math display">\[w_{m+1,i} = \frac{w_{mi}}{Z_m} \exp(-\alpha_m y_i G_m(x_i))\]</span> <span class="math inline">\(Z_m\)</span> 是归一化因子。 <spanclass="math display">\[Z_m = \sum_{i=1}^{N} w_{mi} \exp(-\alpha_m y_i G_m(x_i))\]</span></p></li></ol></li><li>构造基本分类器的线性组合 <span class="math display">\[f(x) = \sum_{m=1}^{M} \alpha_m G_m(x)\]</span></li><li>得到最终分类器 <span class="math display">\[G(x) = \operatorname{sign}\left( \sum_{m=1}^{M} \alpha_m G_m(x) \right)\]</span></li></ol><h2 id="回归问题的提升树算法">回归问题的提升树算法</h2><p><strong><em>Algorithm Process</em></strong> 输入：训练数据集 <spanclass="math inline">\(T = \{(x_1, y_1),(x_2, y_2), \cdots, (x_N,y_N)\}\)</span>； 输出：提升树 <spanclass="math inline">\(f_M(x)\)</span>。 （1）初始化 <spanclass="math inline">\(f_0(x) = 0\)</span>。 （2）对 <spanclass="math inline">\(m = 1, 2, \cdots, M\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>支持向量机</title>
    <link href="/2025/05/30/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2025/05/30/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="线性可分支持向量机">线性可分支持向量机</h2><p><strong>训练数据</strong> <span class="math display">\[T = \{(x_1, y_1), (x_2, y_2), \ldots, (x_N, y_N)\}\]</span></p><p><span class="math display">\[x_i \in \mathcal{X} = \mathbb{R}^n, \quad y_i \in \mathcal{Y} = \{+1,-1\}, \quad i = 1, 2, \ldots, N\]</span></p><p><strong>分离超平面</strong></p><p><span class="math display">\[w^* \cdot x + b^* = 0\]</span></p><p><strong>分类决策函数</strong></p><p><span class="math display">\[f(x) = \operatorname{sign}(w^* \cdot x + b^*)\]</span></p><p><strong>函数间隔</strong></p><p><span class="math display">\[\begin{align*}\hat{\gamma}_i &amp;= y_i (w \cdot x_i + b)\\\\\hat{\gamma} &amp;= \min_{i = 1, 2, \ldots, N} \hat{\gamma}_i\end{align*}\]</span></p><p>规范化函数间隔得到<strong>几何间隔</strong></p><p><span class="math display">\[\begin{align*}\gamma_i &amp;= y_i \times \left(\frac{w \cdot x_i + b}{\lVert w\rVert}\right)\\\\\gamma &amp;= \min_{i=1, \ldots, N} \gamma_i\end{align*}\]</span></p><p><span class="math inline">\(\lVert w \rVert\)</span> is <spanclass="math inline">\(L_2\)</span> 范数，也就是：</p><p><span class="math display">\[\lVert w \rVert _{2} = \sqrt{w_1^2 + w_2^2 + \cdots + w_n^2}\]</span></p><p>可以得到几何间隔和函数间隔之间的关系：</p><p><span class="math display">\[\gamma_i = \frac{\hat{\gamma}_i}{\lVert w \rVert}\]</span></p><h3 id="间隔最大化">间隔最大化</h3><p>原始问题如下：</p><p><span class="math display">\[\begin{align*}&amp;\max_{w, b} \quad \gamma\\\\&amp;s.t. \quad y_i\left(\frac{w}{\lVert w \rVert} \cdot x_i +\frac{b}{\lVert w \rVert}\right) \geq \gamma, \quad i = 1, 2, \ldots ,N\end{align*}\]</span></p><p>我们可以将原始问题转换为一个<strong>凸二次规划问题</strong>。</p><p><span class="math display">\[\begin{align*}&amp;\min_{w, b} \quad \frac{1}{2} \lVert w \rVert ^2\\\\&amp;s.t. \quad y_i(w \cdot x_i + b) - 1 \geq 0, \quad i = 1, 2, \ldots,N\end{align*}\]</span></p><p><strong>支持向量</strong>满足如下关系：</p><p><span class="math display">\[y_i(w \cdot x_i + b) - 1 = 0\]</span></p><p><strong>间隔</strong>的定义如下：</p><p><span class="math display">\[d = \frac{2}{\lVert w \rVert}\]</span></p><h4 id="学习的对偶算法">学习的对偶算法</h4><p>如何解上述的<strong>凸二次规划</strong>问题？应用拉格朗日对偶性得到原始问题的对偶问题：</p><p><span class="math display">\[L(w, b, \alpha) = \frac{1}{2} \lVert w \rVert ^2 - \sum_{i = 1}^{N}\alpha_i y_i (w \cdot x_i + b) + \sum_{i = 1}^{N} \alpha_i\]</span></p><p>在求极大极小问题，先求极小问题 <span class="math inline">\(\min_{w,b} L(w, b, \alpha)\)</span></p><p>分别对 <span class="math inline">\(w\)</span>，<spanclass="math inline">\(b\)</span> 求偏导，并令偏导为 <spanclass="math inline">\(0\)</span> 得：</p><p><span class="math display">\[\begin{align*}\nabla_{w} L(w, b, \alpha) &amp;= w - \sum_{i = 1}^{N} \alpha_i y_i x_i= 0\\\\\nabla_b L(w, b, \alpha) &amp;= -\sum_{i = 1}^{N} \alpha_i y_i = 0\end{align*}\]</span></p><p>也就是</p><p><span class="math display">\[\begin{align*}&amp;w = \sum_{i = 1}^{N} \alpha_i y_i x_i\\\\&amp;\sum_{i = 1}^{N} \alpha_i y_i = 0\end{align*}\]</span></p><p>回代，得到</p><p><span class="math display">\[\min_{w, b} L(w, b, \alpha) = -\frac{1}{2} \sum_{i = 1}^{N} \sum_{j =1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) + \sum_{i =1}^{N} \alpha_i\]</span></p><p>再求极大问题</p><p><span class="math display">\[\max_{\alpha} \quad -\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N}\alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) + \sum_{i = 1}^{N}\alpha_i\]</span></p><p>去掉负号，也就是</p><p><span class="math display">\[\begin{align*}\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N}\alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N}\alpha_i\\\\\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0\\&amp;\alpha_i \geq 0, \quad i = 1, 2, \cdots, N\end{align*}\]</span></p><h3 id="学习算法">学习算法</h3><ul><li><p><strong>输入</strong>：<spanclass="math inline">\(T\)</span></p></li><li><p><strong>输出</strong>：分离超平面和分类决策函数</p><ul><li>构造并求解约束最优化问题。</li></ul><p><span class="math display">\[\begin{align*}\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N}\alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N}\alpha_i\\\\\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0\\&amp;\alpha_i \geq 0, \quad i = 1, 2, \cdots, N\\\\&amp;\alpha^* = (\alpha_1^{\ast}, \alpha_2^{\ast}, \ldots,\alpha_N^{\ast})\end{align*}\]</span></p><ul><li>计算</li></ul><p><span class="math display">\[\begin{align*}w^{\ast} &amp;= \sum_{i=1}^{N} \alpha_i^{\ast} y_i x_i\\\\\forall y_j &gt; 0, \quad b^\ast &amp;= y_j -\sum_{i=1}^{N}\alpha_i^\ast y_i(x_i \cdot x_j)\end{align*}\]</span></p></li></ul><hr /><h2 id="线性支持向量机">线性支持向量机</h2><p>引进一个松弛变量 <span class="math inline">\(\xi_i \geq0\)</span>，</p><p><span class="math display">\[y_i (w \cdot x_i + b) \geq 1 - \xi_i\]</span></p><p>相应的原始最优化问题变为：</p><p><span class="math display">\[\begin{align*}\min_{w, b, \xi} \quad &amp;\frac{1}{2} \lVert w \rVert^2 + C \sum_{i =1}^{N} \xi_i\\\\s.t. \quad &amp;y_i(w \cdot x_i + b) \geq 1 - \xi_i\\\\&amp;i = 1, 2, \ldots, N, \quad \xi_i \geq 0\end{align*}\]</span></p><p>这里 <span class="math inline">\(C \geq 0\)</span>称为惩罚变量，值越大，对误分类的惩罚越大。</p><p>求解原始问题的拉格朗日对偶问题得到</p><p><span class="math display">\[\begin{align*}\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N}\alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N}\alpha_i\\\\\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0\\&amp;C \geq \alpha_i \geq 0, \quad i = 1, 2, \cdots, N\end{align*}\]</span></p><h3 id="学习算法-1">学习算法</h3><ul><li><p><strong>输入</strong>：<spanclass="math inline">\(T\)</span></p></li><li><p><strong>输出</strong>：分离超平面和分类决策函数</p><ul><li>选择惩罚参数，构造并求解： <span class="math display">\[\begin{align*}\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N}\alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N}\alpha_i\\\\\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0\\&amp;C \geq \alpha_i \geq 0, \quad i = 1, 2, \cdots, N\end{align*}\]</span></li></ul><p>得到最优解 <span class="math inline">\(\alpha^* = (\alpha_1^{\ast},\alpha_2^{\ast}, \ldots, \alpha_N^{\ast})\)</span>。</p><ul><li>计算</li></ul><p><span class="math display">\[\begin{align*}w^{\ast} &amp;= \sum_{i=1}^{N} \alpha_i^{\ast} y_i x_i\\\\\forall C &gt; \alpha_j^{\ast} &gt; 0, \quad b^\ast &amp;= y_j -\sum_{i=1}^{N}\alpha_i^\ast y_i(x_i \cdot x_j)\end{align*}\]</span></p></li></ul><hr /><h2 id="荷叶损失函数">荷叶损失函数</h2><p>这是对线性支持向量机学习的一种解释，就是最小化以下目标函数：</p><p><span class="math display">\[\min_{w, b} \quad \sum_{i = 1}^{N} [1 - y_i(w \cdot x_i + b)]_+ +\lambda \lVert w \rVert^2\]</span></p><hr /><h2 id="非线性支持向量机">非线性支持向量机</h2><p><strong>正定核函数</strong></p><p><span class="math inline">\(K :\mathcal{X} \times \mathcal{X} \to\mathbb{R}\)</span> 是对称函数，<span class="math inline">\(K(x,z)\)</span> 是正定核函数 <spanclass="math inline">\(\Leftrightarrow\)</span> 对于任意 <spanclass="math inline">\(x_i \in \mathcal{X}, \quad i = 1, 2, 3, \dots,m\)</span>，<span class="math inline">\(K(x, z)\)</span>对应的格拉姆矩阵是半正定的。</p><p><strong><span class="math inline">\(Gram\)</span> 矩阵</strong></p><p><span class="math display">\[K = [K(x_i, x_j)]_{m \times m}\]</span></p><p>如何判别这个矩阵是半正定的，可以采用<strong>特征值判别法</strong>，如果一个矩阵的所有特征值都<span class="math inline">\(\geq 0\)</span>，则这个矩阵是半正定的。</p><h3 id="学习算法-2">学习算法</h3><ul><li><p><strong>输入</strong>：<spanclass="math inline">\(T\)</span></p></li><li><p><strong>输出</strong>：分离超平面和分类决策函数</p><ul><li>选择惩罚参数，构造并求解： <span class="math display">\[\begin{align*}\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N}\alpha_i \alpha_j y_i y_j K\left(x_i \cdot x_j\right) - \sum_{i = 1}^{N}\alpha_i\\\\\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0\\&amp;C \geq \alpha_i \geq 0, \quad i = 1, 2, \cdots, N\end{align*}\]</span></li></ul><p>得到最优解 <span class="math inline">\(\alpha^* = (\alpha_1^{\ast},\alpha_2^{\ast}, \ldots, \alpha_N^{\ast})\)</span>。</p><ul><li>计算</li></ul><p><span class="math display">\[\begin{align*}w^{\ast} &amp;= \sum_{i=1}^{N} \alpha_i^{\ast} y_i x_i\\\\\forall C &gt; \alpha_j^{\ast} &gt; 0, \quad b^\ast &amp;= y_j -\sum_{i=1}^{N}\alpha_i^\ast y_i K(x_i \cdot x_j)\end{align*}\]</span></p></li></ul><h2 id="序列最小最优化算法">序列最小最优化算法</h2><p><strong>两个变量二次规划的求解方式</strong></p><p><span class="math display">\[\begin{align}&amp;\min_{\alpha} \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}\alpha_i\alpha_j y_i y_j K(x_i \cdot x_j) - \sum_{i=1}^{N} \alpha_i \\\\&amp;s.t. \quad \sum_{i = 1}^{N} \alpha_i y_i = 0, \quad C \geq \alpha_i\geq 0, \quad i = 1, 2, \ldots, N\end{align}\]</span></p><p>我们选择 <spanclass="math inline">\(\alpha_1，\alpha_2\)</span>，规定其他 <spanclass="math inline">\(\alpha_i (i = 3, 4, \dots, N)\)</span>。</p><h3 id="学习算法-3">学习算法</h3><p>下面只给出<strong>应试过程</strong></p><p>我们的<strong>目标</strong>是，求解下述最小化问题：</p><p><span class="math display">\[\begin{align}&amp;\min_{\alpha_1, \alpha_2} W(\alpha_1, \alpha_2) = \frac{1}{2}K_{11}\alpha_1^2 +  \frac{1}{2} K_{22}\alpha_2^2+y_1y_2K_{12}\alpha_1\alpha_2 - (\alpha_1 + \alpha_2) +y_1\alpha_1\sum_{i=3}^{N}y_i\alpha_iK_{i1} +y_2\alpha_2\sum_{i=3}^{N}y_i\alpha_iK_{i2} \tag{1}\\\\&amp;s.t. \quad \alpha_1y_1 + \alpha_2y_2 = \sum_{i=3}^{N}y_i\alpha_i =\zeta, \quad 0 \leq \alpha_i \leq C, \quad i = 1, 2 \tag{2}\end{align}\]</span></p><p><span class="math inline">\(K_{ij} = K(x_i, x_j),i,j = 1,2, \dots,N\)</span>，<span class="math inline">\(\zeta\)</span>是一个常数。同时需要注意的是，公式 <spanclass="math inline">\((1)\)</span> 缺少了常数项</p><p><span class="math display">\[\text{const} = \sum_{i=3}^N \alpha_i - \frac{1}{2} \sum_{i=3}^N\sum_{j=3}^N \alpha_i \alpha_j y_i y_j K(x_i, x_j)\]</span></p><p>但这个常数项<strong>不会</strong>影响优化 <spanclass="math inline">\(\alpha_1\)</span> 和 <spanclass="math inline">\(\alpha_2\)</span> 的结果，故可以省略。</p><p>我们考虑 <span class="math inline">\(\alpha_2\)</span>的最优化问题。</p><p>如果 $ y_1 y_2 $</p><p><span class="math display">\[L = \max(0, \alpha_2^{old} - alpha_1^{old}), \quad H = \min(C, C +\alpha_2^{old} - alpha_1^{old}) \tag{3}\]</span></p><p>否则</p><p><span class="math display">\[L = \max(0, \alpha_2^{old} + alpha_1^{old} - C), \quad H = \min(C,\alpha_2^{old} + alpha_1^{old}) \tag{4}\]</span></p><p>为了叙述简单，记</p><p><span class="math display">\[g(x) = \sum_{i=1}^{N}\alpha_i y_i K(x_i, x) + b\]</span></p><p>令</p><p><span class="math display">\[E_i = g(x_i) - y_i = \sum_{j=1}^{N}\alpha_j y_j K(x_j, x_i) + b - y_i,\quad i = 1, 2\]</span></p><p>接下来我们更新 <span class="math inline">\(\alpha_2\)</span></p><p><span class="math display">\[\alpha_2^{new,unc} = \alpha_2^{old} + \frac{y_2(E_1 - E_2)}{\eta}, \quad\eta = K_{11} + K_{22} - 2K_{12}\]</span></p><p><span class="math display">\[\alpha_2^{new} =\begin{cases}H, &amp;\alpha_2^{new,unc} &gt; H\\\\\alpha_2^{new,unc}, &amp;L \leq \alpha_2^{new,unc} \leq H\\\\L, &amp;\alpha_2^{new,unc} &lt; L\end{cases}\]</span></p><p>N然后再更新 <span class="math inline">\(\alpha_1\)</span></p><p><span class="math display">\[\alpha_1^{new} = \alpha_1^{old} + y_1 y_2(\alpha_2^{old} -\alpha_2^{new})\]</span></p><p><strong>如何选择 <span class="math inline">\(\alpha_1\)</span> 和<span class="math inline">\(\alpha_2\)</span></strong></p><ol type="1"><li>在所有节点中选择具有最大 <span class="math inline">\(E_i\)</span>值的节点作为 <span class="math inline">\(\alpha_1\)</span>。</li><li>选择使得 <span class="math inline">\(|E_1 - E_2|\)</span>最大的节点作为 <span class="math inline">\(\alpha_2\)</span>。</li></ol><p><strong>求解阈值 b 和 E 的计算方法</strong></p><p><span class="math display">\[b_1^{new} = -E_1 - y_1 K_{11} (\alpha_1^{new} - \alpha_1^{old}) - y_2K_{21} (\alpha_2^{new} - \alpha_2^{old}) + b^{old}\]</span></p><p><span class="math display">\[b_2^{new} = -E_2 - y_1 K_{12} (\alpha_1^{new} - \alpha_1^{old}) - y_2K_{22} (\alpha_2^{new} - \alpha_2^{old}) + b^{old}\]</span></p><p><span class="math display">\[b^{new} = \frac{b_1^{new} + b_2^{new}}{2}\]</span></p><p><strong>此外</strong></p><p>更新 <span class="math inline">\(E\)</span>：</p><p><span class="math display">\[E_i^{new} = \sum_{\mathcal{S}}y_j \alpha_j K(x_i, x_j) + b^{new} - y_i\]</span></p><p>其中 <span class="math inline">\(\mathcal{S}\)</span>包含所有支持向量 <span class="math inline">\(x_i\)</span>。样本 <spanclass="math inline">\(x_i\)</span> 是支持向量 <spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\(0 &lt; \alpha_i^* &lt; C\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下推自动机</title>
    <link href="/2025/05/28/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2025/05/28/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="背景知识">背景知识</h1><h2 id="pda形式化描述">PDA形式化描述</h2><p><span class="math display">\[\text{PDA} \quad M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F) \tag{1}\]</span> - <span class="math inline">\(Q\)</span>：状态集合 - <spanclass="math inline">\(\Sigma\)</span>：字母表 - <spanclass="math inline">\(\Gamma\)</span>：栈符号表 - <spanclass="math inline">\(\delta\)</span>：状态转移函数 - <spanclass="math inline">\(q_0\)</span>：开始状态 - <spanclass="math inline">\(Z_0\)</span>：栈底符号 - <spanclass="math inline">\(F\)</span>：终态集合</p><p>其中状态转移函数为</p><p><span class="math display">\[\delta : Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow2^{Q \times \Gamma^*} \tag{2}\]</span></p><h2 id="即时描述">即时描述</h2><p><span class="math display">\[(q, w, \gamma) \in Q \times \Sigma^* \times \Gamma^* \tag{3}\]</span></p><ul><li>当前状态是 <span class="math inline">\(q\)</span></li><li>未处理的输入字符串是 <span class="math inline">\(w\)</span></li><li>栈中符号串是 <span class="math inline">\(\gamma\)</span></li></ul><h2 id="接受语言">接受语言</h2><p>有两种方式描述：</p><p><span class="math display">\[L(M) = \{w \mid (q_0, w, Z_0)  \vdash ^* (p, \epsilon, \beta) \text{ and} p \in F \} \tag{4}\]</span></p><p><span class="math display">\[L(M) = \{w \mid (q_0, w, Z_0) \vdash ^* (p, \epsilon, \epsilon) \}\tag{5}\]</span></p><h1 id="构造pda">构造PDA</h1><pre><code class=" mermaid">graph LR    A[&quot;Get Grammar&quot;] --&gt; B[&quot;CFG&quot;]    B[&quot;CFG&quot;] --&gt; C[&quot;GNF&quot;]    C[&quot;GNF&quot;] --&quot;finial states&quot;--&gt; D[&quot;PDA&quot;]    C[&quot;GNF&quot;] --&quot;empty stack&quot;--&gt; D[&quot;PDA&quot;]</code></pre><h1 id="pda转换">PDA转换</h1><h2 id="终态换为空栈">终态换为空栈</h2><p>已知终态接受的 PDA <spanclass="math inline">\(M_1\)</span>，公式化构造空战接受的 PDA <spanclass="math inline">\(M_2\)</span>，具体过程如下： <spanclass="math display">\[\text{PDA } M_1 = (Q, \Sigma, \Gamma, \delta_1, q_0, F) \tag{6}\]</span></p><p><span class="math display">\[\text{PDA } M_2 = (Q \cup \{q_{02}, q_e \}, \Sigma, \Gamma \cup \{Z_{02}\}, \delta_2, q_{02}, Z_{02}, F) \tag{7}\]</span></p><p>We construct PDA <span class="math inline">\(M_2\)</span> tosimulates PDA <span class="math inline">\(M_1&#39;s\)</span> function.And first step, we need to get in PDA <spanclass="math inline">\(M_1\)</span>.</p><p><span class="math display">\[\delta_2(q_{02}, \epsilon, Z_{02}) = \{(q_{01}, Z_{01}Z_{02})\} \tag{8}\]</span></p><p>PDA <span class="math inline">\(M_2\)</span> simulates each none<span class="math inline">\(\epsilon\)</span> step of PDA <spanclass="math inline">\(M_1\)</span>.</p><p><span class="math display">\[\forall (q, a, Z) \in Q \times \Sigma \times \Gamma, \delta_2(q, a, Z) =\delta_1(q, a, Z) \tag{9}\]</span></p><p>PDA <span class="math inline">\(M_2\)</span> completely simulates PDA<span class="math inline">\(M_1\)</span> transition function in nonefinial states.</p><p><span class="math display">\[\forall (q, Z) \in (Q - F) \times \Gamma, \delta_2(q, \epsilon, Z) =\delta_1(q, \epsilon, Z) \tag{10}\]</span></p><p>In <span class="math inline">\(M_1&#39;s\)</span> finial states, notonly should <span class="math inline">\(M_2\)</span> simulates <spanclass="math inline">\(M_1&#39;s\)</span> <spanclass="math inline">\(\epsilon\)</span> moves, but also simulatesaccepting moves.</p><p><span class="math display">\[\forall (q, Z) \in F \times \Gamma, \delta_2(q, \epsilon, Z) =\delta_1(q, \epsilon, Z) \cup \\{(q_e, \epsilon)\\} \tag{11}\]</span></p><p><span class="math inline">\(M_1&#39;s\)</span> stacks having beenempty and in finial states, <span class="math inline">\(M_2\)</span>begins to cleat stack.</p><p><span class="math display">\[\forall q \in F, \delta_2(q, \epsilon, Z_{02}) = \{(q_e, \epsilon) \}\tag{12}\]</span></p><p><span class="math display">\[\forall q \in \Gamma \cup \{Z_{02} \}, \delta_2(q_e, \epsilon, Z) =\{(q_e, \epsilon) \}\]</span></p><h3 id="empty-stack-to-finial-state">Empty Stack to Finial State</h3><p>已知空栈接受的 PDA <spanclass="math inline">\(M_1\)</span>，要构造一个与之等价终态接受的 PDA<span class="math inline">\(M_2\)</span>，核心思路在于<strong>只要 <spanclass="math inline">\(M_2\)</span> 发现 <spanclass="math inline">\(M_1\)</span>在运行过程中将栈弹空，就可以进入终止状态</strong>。</p><p><strong>公式化构造</strong></p><p>设 PDA <span class="math inline">\(M_1\)</span> 为</p><p><span class="math display">\[\text{PDA } M_1 =\left(Q, \Sigma, \Gamma, \delta_1, q_{01}, Z_{01},\Phi\right)\]</span></p><p>公式化构造 PDA <span class="math inline">\(M_2\)</span></p><p><span class="math display">\[\text{PDA } M_2 = \left(Q \cup \{q_0, q_f\}, \Sigma, \Gamma \cup\{Z_{02} \}, \delta_2, q_{02}, Z_{02}, \{q_f\} \right)\]</span></p><p>其中状态转移函数 <span class="math inline">\(\delta_2\)</span> 为</p><p><span class="math display">\[\begin{align*}&amp;\delta_2(q_{02}, \epsilon, Z_{02}) = \{(q_{01}, Z_{01} Z_{02})\}\\&amp;\forall(q, a, Z) \in Q \times (\Sigma \cup \{\epsilon\}) \times\Gamma, \quad \delta_2(q, a ,Z) = \delta_1(q, a, Z)\\&amp;\delta_2(q, \epsilon, Z_{02}) = \{(q_f, \epsilon)\}\end{align*}\]</span></p><h3 id="cfg-to-empty-stack">CFG to Empty Stack</h3><p>先考虑 <span class="math inline">\(L\)</span> 为不含 <spanclass="math inline">\(\epsilon\)</span> 的 CFL。<spanclass="math inline">\(G\)</span> 是该语言对应的 GNF 文法，考虑用 PDA模拟 GNF 的最左派生。</p><p><strong>公式化构造</strong></p><p>设 GNF <span class="math inline">\(G = (V, T, P, S)\)</span>。</p><p>取 PDA <span class="math inline">\(M = (\{q\}, T, V, \delta, q, S,\Phi)\)</span></p><p><span class="math inline">\(\forall A \in V, \quad a \in T, \quad\gamma \in V^{\ast}\)</span> 我们有 <spanclass="math inline">\(\delta(q, a, A) = \{(q, \gamma) \mid A \to a\gamma\in P\}\)</span></p><p><strong>补充 <spanclass="math inline">\(\{\epsilon\}\)</span></strong></p><p>在 <span class="math inline">\(M\)</span> 的基础上，构造 <spanclass="math inline">\(M_1\)</span>，具体是</p><p><span class="math display">\[M_1 = (\{q, q_0\}, T, V \cup \{Z\}, \delta_1, q_0, Z, \Phi)\]</span></p><p>对于状态转移函数 <spanclass="math inline">\(\delta_1\)</span>，定义如下：</p><p><span class="math display">\[\begin{align*}\delta_1(q_0, \epsilon, Z) &amp;= \{(q_0, \epsilon), (q, S)\}\\\delta_1(q, a, A) &amp;= \delta(q, a, A)\end{align*}\]</span></p><h3 id="empty-stack-to-cfg">Empty Stack to CFG</h3><p><strong>公式化构造</strong></p><p>设 PDA <span class="math inline">\(M = (Q, \Sigma, \Gamma, \delta,q_0, Z_0, \Phi)\)</span>，取 CFG <span class="math inline">\(G = (V,\Sigma, P, S)\)</span>，其中： <span class="math display">\[\begin{align*}V &amp;= \{S\} \cup Q \times \Gamma \times Q，\text{特别地我们用$[q_i,A, q_j]$来表示变量}\\P &amp;= \{S \to [q_0, Z_0, q] \mid q \in Q\}\\&amp; \cup \{[q, A, q_{n + 1}] \to a[q_1, A_1, q_2][q_2, A_2, q_3] \dots[q_n, A_n, q_{n + 1} \mid (q_1, A_1A_2 \dots A_n) \in \delta(q, a, A)\text{且} a \in \Sigma \cup \{\epsilon\}, n \geq 1\}\\&amp; \cup \{[q, A, q_1] \to a \mid (q_1, \epsilon) \in \delta(q, a,A)\}\end{align*}\]</span></p><h2 id="课后习题解答">课后习题解答</h2><h3 id="构造空栈接受的-pda">8.(2) 构造空栈接受的 PDA</h3><img src="/2025/05/28/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/8(2).png" class="" title="8(2)"><div data-align="center">图8.(2)</div><h3 id="补充题">补充题</h3><p><strong>Question:</strong> PDA <spanclass="math inline">\(\to\)</span> CFG绘制此PDA状态转移图，按照定理7-4所述的文法构造方法进行转换。并对所得到的文法进行化简。</p><p><span class="math display">\[\begin{align*}\delta(q_0, a, Z) &amp;= \{(q_0, AZ)\} \tag{1}\\\delta(q_0, a, A) &amp;= \{(q_0, A)\} \tag{2}\\\delta(q_0, b, A) &amp;= \{(q_1, \epsilon)\} \tag{3}\\\delta(q_1, \epsilon, Z) &amp;= \{(q_2, \epsilon)\} \tag{4}\end{align*}\]</span></p><p><strong>Answer:</strong></p><p>根据 <span class="math inline">\((4)\)</span>式，可以判断这是一个空栈接受的 PDA。</p><p>设 PDA <span class="math inline">\(M = (Q, \Sigma, \Gamma, \delta,q_0, Z, \Phi)\)</span></p><p>公式化构造 CFG。</p><p><strong>首先</strong></p>]]></content>
    
    
    <categories>
      
      <category>形式语言与自动机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>决策树</title>
    <link href="/2025/05/28/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2025/05/28/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="textdecision-tree"><span class="math inline">\(\text{DecisionTree}\)</span></h2><p>本文章中，总数据集是 <span class="math inline">\(D\)</span>，属性集是<span class="math inline">\(a\)</span>，其中 <spanclass="math inline">\(a = \{a^1, a^2, \ldots, a^V \}\)</span>，表示属性<span class="math inline">\(a\)</span> 有 <spanclass="math inline">\(V\)</span> 种取值；<span class="math inline">\(D^v= \{D(\text{attribute}(a) = a^v)\}\)</span> 则表示总数据集 <spanclass="math inline">\(D\)</span> 中满足属性 <spanclass="math inline">\(a = a^v\)</span> 的数目。</p><p>决策树是一种分类算法，本文将介绍三种决策树算法，包括三种决策树算法涉及到的多个概念，比如信息熵、信息增益、信息增益比等等。</p><h2 id="信息熵">信息熵</h2><p><span class="math display">\[p_k = \frac{\sum(sort = k)}{|D|} \quad (k = 1,2,\ldots,|\mathscr{Y}|)\]</span></p><p>用符号 <strong><spanclass="math inline">\(\operatorname{Ent}\)</span></strong>表示信息熵</p><p><span class="math display">\[\text{Ent}(D) = -\sum_{k=1}^{|\mathscr{Y}|}p_k\log_2p_k\]</span></p><h2 id="信息增益">信息增益</h2><p>用符号 <strong><spanclass="math inline">\(\text{Gain}\)</span></strong> 表示信息增益</p><p><span class="math display">\[\text{Gain}(D, a) = \text{Ent}(D) - \sum_{v = 1}^{V}\frac{|D^v|}{|D|}\text{Ent}(D^v)\]</span></p><h2 id="信息增益比">信息增益比</h2><p>用符号 <strong><spanclass="math inline">\(\text{Gain_ratio}\)</span></strong>表示信息增益比</p><p><span class="math display">\[\text{Gain_ratio}(D,a) = \frac{\text{Gain}(D,a)}{\text{IV}(a)}\]</span></p><p>其中，</p><p><span class="math display">\[\text{IV}(a) = -\sum_{v = 1}^{V}\frac{|D^v|}{|D|} \log_2\frac{|D^v|}{|D|}\]</span></p><h2 id="基尼指数">基尼指数</h2><p>用符号 <strong><spanclass="math inline">\(\text{Gini_index}\)</span></strong>表示基尼指数</p><p><span class="math display">\[\begin{align*}\text{Gini}(D^v) &amp;= \sum_{k = 1}^{|\mathscr{Y}|}\sum_{k&#39; \neqk}p_k p_{k&#39;}\\\\\text{Gini}(D^v) &amp;= 1 - \sum_{k = 1}^{|\mathscr{Y}|}p_k^{2}\\\\\text{Gini_index}(D,a) &amp;= \sum_{v = 1}^{V} \frac{|D^v|}{|D|}\text{Gini}(D^v)\end{align*}\]</span></p><h2 id="剪枝">剪枝</h2><h3 id="损失函数">损失函数</h3><p>假设决策树 <span class="math inline">\(T\)</span> 有 <spanclass="math inline">\(|T|\)</span> 个叶节点，每个叶节点 <spanclass="math inline">\(t\)</span> 有 <spanclass="math inline">\(N_t\)</span> 个样本，其中类别 <spanclass="math inline">\(k = 1, 2, \ldots, K\)</span> 的样本数为 <spanclass="math inline">\(N_{tk}\)</span>。</p><p><strong>损失函数</strong></p><p><span class="math display">\[C_\alpha(T) = \sum_{t=1}^{|T|}N_t \operatorname{Ent}(D_t) + \alpha |T|\]</span></p><p>其中 <span class="math inline">\(\operatorname{Ent}(D_t)\)</span>是叶节点 <span class="math inline">\(t\)</span> 上样本集合 <spanclass="math inline">\(D_t\)</span> 的信息熵，</p><p><span class="math display">\[\operatorname{Ent}(D_t) = -\sum_{k=1}^{|\mathscr{Y}|} p_{tk} \log_2p_{tk}\]</span></p><p>其中 <span class="math inline">\(p_{tk} =\frac{N_{tk}}{N_t}\)</span>，<span class="math inline">\(N_{tk}\)</span>为叶节点 <span class="math inline">\(t\)</span> 上第 <spanclass="math inline">\(k\)</span> 类样本数，<spanclass="math inline">\(N_t\)</span> 为叶节点 <spanclass="math inline">\(t\)</span> 的样本总数。</p><p>所以可以将损失函数写成：</p><p><span class="math display">\[\begin{align*}C(T) &amp;= -\sum_{t=1}^{|T|} N_t \sum_{k=1}^{|\mathscr{Y}|} p_{tk}\log_2 p_{tk}\\\\C_\alpha(T) &amp;= C(T) + \alpha |T|\end{align*}\]</span></p><p>我们的<strong>目的</strong>就是最小化损失函数</p><p><span class="math display">\[\min_{T} \quad C_\alpha(T) = \sum_{t=1}^{|T|}N_t \operatorname{Ent}(D_t)+ \alpha |T|\]</span></p><h4 id="算法步骤">算法步骤</h4><p>我们可以定义一个DP[]数组，并使用动态规划的思想来找到最优剪枝</p><ul><li>输入数据 <span class="math inline">\(X = \{(\vec{x}_1, y_1),(\vec{x}_2, y_2), \ldots, (\vec{x}_N, y_N) \}\)</span></li><li>输出 <span class="math inline">\(T_\alpha\)</span></li></ul><ol type="1"><li>对于树T中的每个节点t，计算 <spanclass="math inline">\(H_t(T)\)</span></li><li>从树的叶节点开始递归地向上回溯，比较 <spanclass="math inline">\(C_\alpha(T_A)\)</span> 和 <spanclass="math inline">\(C_\alpha(T_B)\)</span></li><li>返回步骤2</li></ol><h2 id="cart">CART</h2><h3 id="回归树">回归树</h3><p>回归树对应于输入空间的分割和分割单元内的输出值。</p><p>输入空间 <span class="math inline">\(M = R_1, R_2, \ldots,R_M\)</span>，每个空间 <span class="math inline">\(R_m\)</span>有一个输出值 <spanclass="math inline">\(c_m\)</span>，我们可以定义回归树模型如下：</p><p><strong>回归树模型</strong> <span class="math display">\[f(x) = \sum_{m=1}^{M} c_m I (x \in R_m)\]</span></p><p><strong>均方误差</strong> <span class="math display">\[\sum_{x_i \in R_m} (y_i - f(x_i))^2\]</span></p><p><span class="math display">\[\hat{c}_m = \text{ave}(y_i \mid x_i \in R_m)\]</span></p><h4 id="分割算法">分割算法</h4><ul><li>输入：训练数据 <span class="math inline">\(D\)</span></li><li>输出：回归树 <span class="math inline">\(f(x)\)</span></li></ul><ol type="1"><li>选择 <span class="math inline">\(x_j\)</span>，其输出为 <spanclass="math inline">\(s\)</span>。空间 <spanclass="math inline">\(R_1(j, s) = \{x \mid x^{(j)} \leqs\}\)</span>，空间 <span class="math inline">\(R_2(j, s) = \{x \midx^{(j)} &gt; s\}\)</span></li><li><span class="math display">\[\min_{j,s}\left[\min_{c_1} \sum_{x_i\in R_1(j,s)} (y_i - c_1)^2 + \min_{c_2} \sum_{x_i \in R_2(j,s)} (y_i -c_2)^2 \right]\]</span></li><li><span class="math display">\[\frac{1}{N_m} \sum_{x_i \in R_m(j,s)}y_i, \quad x_i \in R_m, \quad m = 1, 2\]</span></li><li>重复步骤2和3，直至满足停止条件。</li></ol><h3 id="分类树">分类树</h3><p>根据<strong>基尼指数</strong>进行分类即可</p><p><span class="math display">\[\begin{align*}\text{Gini}(D^v) &amp;= \sum_{k = 1}^{|\mathscr{Y}|}\sum_{k&#39; \neqk}p_k p_{k&#39;}\\\\\text{Gini}(D^v) &amp;= 1 - \sum_{k = 1}^{|\mathscr{Y}|}p_k^{2}\\\\\text{Gini_index}(D,a) &amp;= \sum_{v = 1}^{V} \frac{|D^v|}{|D|}\text{Gini}(D^v)\end{align*}\]</span></p><h3 id="textcart-剪枝"><span class="math inline">\(\text{CART}\)</span>剪枝</h3><p><span class="math inline">\(\text{CART}\)</span>剪枝算法由两步组成：手下从省城算法产生的决策树 <spanclass="math inline">\(T_0\)</span> 底端开始不断简直，直到 <spanclass="math inline">\(T_0\)</span> 的根节点，形成一个子树序列 <spanclass="math inline">\(\{T_0, T_1, \cdotsT_n\}\)</span>；然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</p><h4 id="textcart-剪枝算法"><spanclass="math inline">\(\text{CART}\)</span> 剪枝算法</h4><p><strong>输入</strong>：<spanclass="math inline">\(\text{CART}\)</span> 算法生成的决策树 <spanclass="math inline">\(T_0\)</span>； <strong>输出</strong>：最优决策树<span class="math inline">\(T_{\alpha}\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>隐马尔科夫模型</title>
    <link href="/2025/05/27/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/05/27/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="隐马尔科夫模型的定义">隐马尔科夫模型的定义</h2><p>隐马尔科夫模型有如下两个假设：任意状态只依赖于前一时刻状态和任意时刻的观测只依赖于该时刻的马尔科夫链的状态。设 <span class="math inline">\(Q\)</span> 是所有可能的状态的集合，<spanclass="math inline">\(V\)</span>是所有可能的观测的集合：</p><p><span class="math display">\[Q =\{q_1, q_2, \dots, q_N\}, \quad V = \{v_1, v_2, \dots, v_M\}\]</span></p><p>其中，<span class="math inline">\(N\)</span> 是可能的状态数，<spanclass="math inline">\(M\)</span> 是可能的观测数。 <spanclass="math inline">\(I\)</span> 是长度为 <spanclass="math inline">\(T\)</span> 的状态序列，<spanclass="math inline">\(O\)</span> 是对应的观测序列：</p><p><span class="math display">\[I = (i_1, i_2, \dots, i_T), \quad O =(o_1, o_2, \dots, o_T)\]</span></p><p><span class="math inline">\(A\)</span> 是状态转移概率矩阵：</p><p><span class="math display">\[A = [a_{ij}]_{N \times N} \tag{1}\]</span></p><p>其中，</p><p><span class="math display">\[a_{ij} = P(i_{t + 1} = q_j | i_t = q_i), \quad i = 1, 2, \dots, N; \quadj = 1, 2, \dots, N \tag{2}\]</span></p><p><span class="math inline">\(B\)</span> 是观测概率矩阵：</p><p><span class="math display">\[B = [b_j(k)]_{N \times N} \tag{3}\]</span></p><p>其中，</p><p><span class="math display">\[b_j(k) = P(o_t = v_k | i_t = q_j), \quad k = 1, 2, \dots, M; \quad j =1, 2, \dots, N \tag{4}\]</span></p><p><span class="math inline">\(\pi\)</span> 是初始状态概率向量：</p><p><span class="math display">\[\pi = (\pi_i) \tag{5}\]</span></p><p>其中，</p><p><span class="math display">\[\pi_i = P(i_1 = q_i), \quad i = 1, 2, \dots, N \tag{6}\]</span></p><p>综上，可以将隐马尔科夫模型用三元符号表示，即</p><p><span class="math display">\[\lambda = (A, B, \pi) \tag{7}\]</span></p><h2 id="隐马尔科夫模型的3个基本问题">隐马尔科夫模型的3个基本问题</h2><h3 id="概率计算问题">概率计算问题</h3><p>给定模型 <span class="math inline">\(\lambda = (A, B, \pi)\)</span>和观测序列 <span class="math inline">\(O = (o_1, o_2, \dots,o_T)\)</span>，计算在模型 <span class="math inline">\(\lambda\)</span>下观测序列 <span class="math inline">\(O\)</span> 出现的概率 <spanclass="math inline">\(P(O | \lambda)\)</span>。</p><h4 id="前向算法">前向算法</h4><p>输入：隐马尔科夫模型 <spanclass="math inline">\(\lambda\)</span>，观测序列 <spanclass="math inline">\(O\)</span>； 输出：观测序列概率 <spanclass="math inline">\(P(O | \lambda)\)</span>。</p><p>（1）初值</p><p><span class="math display">\[\alpha_1(i) = \pi_i b_i(o_1), \quad i = 1, 2, \dots, N \tag{8}\]</span></p><p>（2）递推，对 <span class="math inline">\(t = 1, 2, \dots, T -1\)</span>，</p><p><span class="math display">\[\alpha_{t + 1}(i) = \left[\sum_{j = 1}^{N} \alpha_t(j)a_{ji}\right]b_i(o_{t + 1}), \quad i = 1, 2, \dots, N \tag{9}\]</span></p><p>（3）终止</p><p><span class="math display">\[P(O | \lambda) = \sum_{i = 1}^{N} \alpha_T(i) \tag{10}\]</span></p><p>这个算法中的 <span class="math inline">\(\alpha\)</span>可以用一个矩阵表示，其中下标表示行号，括号内表示列号</p><p><span class="math display">\[\alpha = \begin{bmatrix}\alpha_1(1) &amp; \alpha_1(2) &amp; \alpha_1(3) &amp; \cdots &amp;\alpha_1(N) \\\\[10pt]\alpha_2(1) &amp; \alpha_2(2) &amp; \alpha_2(3) &amp; \cdots &amp;\alpha_2(N) \\\\[10pt]\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\[10pt]\alpha_T(1) &amp; \alpha_T(2) &amp; \alpha_T(3) &amp; \cdots &amp;\alpha_T(N)\end{bmatrix} \tag{11}\]</span> 每次迭代就是在一次计算行内容。</p><h4 id="后向算法">后向算法</h4><p>输入：隐马尔科夫模型 <spanclass="math inline">\(\lambda\)</span>，观测序列 <spanclass="math inline">\(O\)</span>； 输出：观测序列概率 <spanclass="math inline">\(P(O | \lambda)\)</span>。</p><p>（1） <span class="math display">\[\beta_T(i) = 1, \quad i = 1, 2, \dots, N \tag{12}\]</span></p><p>（2）对 <span class="math inline">\(t = T - 1, T - 2, \dots,1\)</span></p><p><span class="math display">\[\beta_t(i) = \sum_{j = 1}^{N} a_{ij} b_j(o_{t + 1})\beta_{t + 1}(j)\tag{13}\]</span> （3）</p><p><span class="math display">\[P(O | \lambda) = \sum_{i = 1}^{N} \pi_i b_i(o_1) \beta_1(i) \tag{14}\]</span></p><p><span class="math inline">\(\beta\)</span> 矩阵</p><p><span class="math display">\[\beta = \begin{bmatrix}\beta_1(1) &amp; \beta_1(2) &amp; \beta_1(3) &amp; \cdots &amp;\beta_1(N) \\\\[10pt]\beta_2(1) &amp; \beta_2(2) &amp; \beta_2(3) &amp; \cdots &amp;\beta_2(N) \\\\[10pt]\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\[10pt]\beta_T(1) &amp; \beta_T(2) &amp; \beta_T(3) &amp; \cdots &amp;\beta_T(N)\end{bmatrix} \tag{15}\]</span></p><h3 id="一些概率与期望值的计算">一些概率与期望值的计算</h3><h4 id="单个状态的计算公式">单个状态的计算公式</h4><p>给定模型 <span class="math inline">\(\lambda\)</span> 和观测 <spanclass="math inline">\(O\)</span>，在时刻 <spanclass="math inline">\(t\)</span> 处于状态 <spanclass="math inline">\(q_i\)</span> 的概率。记</p><p><span class="math display">\[\gamma_t(i) = P(i_t = q_i |O, \lambda) \tag{16}\]</span></p><p>可以通过前向后向概率计算：</p><p><span class="math display">\[\gamma_t(i) = \frac{\alpha_t(i) \beta_t(i)}{P(O |\lambda)} =\frac{\alpha_t(i) \beta_t(i)}{\sum_{j = 1}^{N} \alpha_t(j) \alpha_t(j)}\tag{17}\]</span></p><h4 id="两个状态的计算公式">两个状态的计算公式</h4><p>给定模型 <span class="math inline">\(\lambda\)</span> 和观测 <spanclass="math inline">\(O\)</span>，在时刻 <spanclass="math inline">\(t\)</span> 处于状态 <spanclass="math inline">\(q_i\)</span>，在时刻 <span class="math inline">\(t+ 1\)</span> 处于 <span class="math inline">\(q_j\)</span>的概率。记</p><p><span class="math display">\[\xi_t(i, j) = \frac{\alpha_t(i)a_{ij}b_j(o_{t + 1})\beta_{t +1}(j)}{\sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_t(i) a_{ij} b_j(o_{t +1}) \beta_{t + 1}(j)} \tag{18}\]</span></p><h4 id="在观测-o-下状态-i-出现的期望值">在观测 <spanclass="math inline">\(O\)</span> 下状态 <spanclass="math inline">\(i\)</span> 出现的期望值</h4><p><span class="math display">\[\sum_{t = 1}^{T} \gamma_t(i) \tag{19}\]</span></p><h4 id="在观测-o-下由状态-i-转移的期望值">在观测 <spanclass="math inline">\(O\)</span> 下由状态 <spanclass="math inline">\(i\)</span> 转移的期望值</h4><p><span class="math display">\[\sum_{t = 1}^{T - 1} \gamma_t(i) \tag{20}\]</span></p><h4 id="在观测-o-下由状态-i-转移到状态-j-的期望值">在观测 <spanclass="math inline">\(O\)</span> 下由状态 <spanclass="math inline">\(i\)</span> 转移到状态 <spanclass="math inline">\(j\)</span> 的期望值</h4><p><span class="math display">\[\sum_{t = 1}^{T - 1} \xi_t(i, j) \tag{21}\]</span></p><h2 id="学习算法">学习算法</h2><p>前文的内容是都和概率计算有关，那如何根据训练集训练一个隐马尔科夫模型模型呢？</p><h3 id="监督学习方法">监督学习方法</h3><p>如果已给训练数据集包含 <span class="math inline">\(S\)</span>个长度相同的观测序列和对应的状态序列，我们可以用极大似然估计法来估计参数。分别的有：</p><p><span class="math display">\[\begin{align*}\hat{a_{ij}} &amp;= \frac{A_{ij}}{\sum_{j = 1}^{N} A_{ij}}, \quad i = 1,2, \dots, N; \quad j = 1, 2, \dots, N \tag{22}\\[10pt]\hat{b_{j}}(k) &amp;= \frac{B_{jk}}{\sum_{k = 1}^{M} B_{jk}}, \quad j =1, 2, \dots, N; \quad k = 1, 2, \dots, M \tag{23}\\[10pt]\hat{\pi_{i}} &amp;= \frac{\sum \text{初始状态为$q_i$} }{S} \tag{24}\end{align*}\]</span></p><p>其中 <span class="math inline">\(A_{ij}\)</span>表示在训练数据中，从状态 <span class="math inline">\(q_i\)</span>转移到状态 <span class="math inline">\(q_j\)</span>的<strong>次数总和</strong>。<span class="math inline">\(B_{jk}\)</span>表示在状态 <span class="math inline">\(q_j\)</span> 下，观测到符号 <spanclass="math inline">\(v_k\)</span> 的<strong>次数总和</strong>。</p><h3 id="baum-welch-算法">Baum-Welch 算法</h3><p>假定训练数据只包含 <span class="math inline">\(S\)</span> 个长度为<span class="math inline">\(T\)</span> 的观测序列 <spanclass="math inline">\(\{O_1, O_2, \dots,O_S\}\)</span>，我们将观测序列数据看作观测数据 <spanclass="math inline">\(O\)</span>，状态序列数据看做不可观测的隐数据 <spanclass="math inline">\(I\)</span>，那么存在如下概率模型</p><p><span class="math display">\[P(O | \lambda) = \sum_{I} P(O |I, \lambda) P(I |\lambda) \tag{25}\]</span></p><p>实际上，这个模型的参数学习可由 EM 算法实现。</p><p>（1）确定完全数据的对数似然函数。完全数据是<spanclass="math inline">\((O, I) = (o_1, o_2, \dots, o_T, i_1, i_2, \dots,i_T)\)</span>。</p><p><span class="math display">\[\log P(O, T |\lambda) \tag{26}\]</span></p><p>（2）E步</p><p><span class="math display">\[Q(\lambda, \bar{\lambda}) = \sum_{I} \log P(O, I |\lambda) P(O, I|\bar{\lambda}) \tag{27}\]</span></p><p>其中 <span class="math inline">\(\bar{\lambda}\)</span>是当前模型参数的估计值，<span class="math inline">\(\lambda\)</span>是要极大化的模型参数。</p><p><span class="math display">\[P(O, I |\lambda) = \pi_{i_1}b_{i_1}(o_1)a_{i_1i_2}b_{i_2}(o_2) \cdotsa_{i_{T-1}i_{T}}b_{i_{T}}(o_T) \tag{28}\]</span></p><p>于是，函数 <span class="math inline">\(Q\)</span> 可以写成：</p><p><span class="math display">\[\begin{align*}Q(\lambda, \bar{\lambda}) = &amp;\sum_{I} \log \pi_{i_1} P(O, I|\bar{\lambda}) + \sum_{I} \left(\sum_{t = 1}^{T - 1} \log a_{i_t i_{t +1}} \right) P(O, I |\bar{\lambda}) +\\[10pt]&amp;\sum_{I} \left(\sum_{t = 1}^{T} \log b_{i_t}(o_t) \right) P(O, I|\bar{\lambda})\end{align*}\]</span></p><h4 id="算法步骤">算法步骤</h4><p>（1）初始化。对 <span class="math inline">\(n =0\)</span>，随机初始化 <spanclass="math inline">\(\lambda^{(0)}\)</span>。 （2）递推。对 <spanclass="math inline">\(n = 1, 2, \dots\)</span>，</p><p><span class="math display">\[\begin{align*}\alpha_{ij}^{(n + 1)} &amp;= \frac{\sum_{t = 1}^{T - 1} \xi_t(i,j)}{\sum_{t = 1}^{T - 1} \gamma_t(i)}\\[10pt]b_{j}(k)^{(n + 1)} &amp;= \frac{\sum_{t = 1, o_t = v_k}^{T}\gamma_t(j)}{\sum_{t= 1}^{T} \gamma_t(j)}\\[10pt]\pi_{i}^{(n + 1)} &amp;= \gamma_1(i)\end{align*}\]</span></p><h2 id="预测算法">预测算法</h2><h3 id="近似算法">近似算法</h3><p>由公式： <span class="math display">\[\gamma_t(i) = \frac{\alpha_t(i) \beta_t(i)}{P(O |\lambda)} =\frac{\alpha_t(i) \beta_t(i)}{\sum_{j = 1}^{N} \alpha_t(j) \alpha_t(j)}\]</span> 知，在每一时刻 <span class="math inline">\(t\)</span>最有可能的状态 <span class="math inline">\(i_t^{\ast}\)</span> 是 <spanclass="math display">\[i_t^{\ast} = \operatorname{arg} \max_{1 \leq i \leq N} [\gamma_t(i)],\quad t = 1, 2, \dots, T \tag{29}\]</span></p><h3 id="维特比算法">维特比算法</h3><p>维特比算法是用动态规划解隐马尔科夫模型的预测问题。</p><h4 id="算法步骤-1">算法步骤</h4><p>输入：模型 <span class="math inline">\(\lambda = (A, B, \pi)\)</span>和观测序列 <span class="math inline">\(O = (o_1, o_2, \dots,o_T)\)</span>； 输出：最优路径 <span class="math inline">\(I^{\ast} =(i_1^{\ast}, i_2^{\ast}, \dots, i_T^{\ast})\)</span>。</p><p>（1）初始化</p><p><span class="math display">\[\begin{align*}\delta_1(i) = \pi_i b_i(o_1), \quad i = 1, 2, \dots, N\\[10pt]\Psi_1(i) = 0, \quad i = 1, 2, \dots, N\end{align*}\]</span></p><p>（2）递推。对 <span class="math inline">\(t = 2, 3, \cdots,T\)</span></p><p><span class="math display">\[\begin{align*}\delta_t(i) &amp;= \max_{1 \leq j \leq N} [\delta_{t - 1}(j) a_{ji}]b_i(o_t), \quad i = 1, 2, \cdots, N\\[10pt]\Psi_t(i) &amp;= \operatorname{arg} \max_{1 \leq j \leq N}[\delta_{t -1} a_{ji}], \quad i = 1, 2, \cdots, N\end{align*}\]</span></p><p>（3）终止</p><p><span class="math display">\[\begin{align*}P^{\ast} &amp;= \max_{1 \leq i \leq N} \delta_{T}(i)\\[10pt]i_{T}^{\ast} &amp;= \operatorname{arg} \max_{1 \leq i \leq N}[\delta_{T}(i)]\end{align*}\]</span></p><p>（4）最优路径回溯。对 <span class="math inline">\(t = T - 1, T - 2,\cdots, 1\)</span></p><p><span class="math display">\[i_t^{\ast} = \Psi_{t + 1}(i_{t + 1}^{\ast})\]</span></p><p>求得最优路径 <span class="math inline">\(I^{\ast} = (i_1^{\ast},i_2^{\ast}, \dots, i_T^{\ast})\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
