<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>��ѧ��ʽ����</title>
    <link href="/2025/09/10/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/"/>
    <url>/2025/09/10/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>����һ��������ѧ��ʽ��Ⱦ�����¡�</p><h2 id="���ڹ�ʽ����">���ڹ�ʽ����</h2><p>����һ�����ڹ�ʽ��$x = \frac{-b \pm \sqrt{b^2-4ac}}{2a}$��Ӧ��ֻ��ʾһ�Ρ�</p><p>��һ�����ڹ�ʽ��$E = mc^2$��</p><h2 id="�鼶��ʽ����">�鼶��ʽ����</h2><p>����һ���鼶��ʽ��</p><p>$$<br>\begin{aligned}<br>\nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp;= \frac{4\pi}{c}\vec{\mathbf{j}} \<br>\nabla \cdot \vec{\mathbf{E}} &amp;= 4 \pi \rho \<br>\nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp;= \vec{\mathbf{0}} \<br>\nabla \cdot \vec{\mathbf{B}} &amp;= 0<br>\end{aligned}<br>$$</p><h2 id="�������">�������</h2><p>$$<br>\begin{pmatrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9<br>\end{pmatrix}<br>$$</p><p>�����Щ��ʽֻ��ʾһ������ȷ��Ⱦ��˵���޸��ɹ���</p>]]></content>
    
    
    <categories>
      
      <category>����</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MathJax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wireshark Homework</title>
    <link href="/2025/06/17/Wireshark-Homework/"/>
    <url>/2025/06/17/Wireshark-Homework/</url>
    
    <content type="html"><![CDATA[<h2 id="提取的请求信息">提取的请求信息</h2><p><img src="Wireshark-Homework/my%20ipconfig.png" alt="my ipconfig"></p><p><img src="Wireshark-Homework/a%20request%20and%20its%20response.png" alt="a request and its response"></p><p><img src="Wireshark-Homework/get%20request.png" alt="get request"></p><p><img src="Wireshark-Homework/request%20right.png" alt="request right"></p><p><img src="Wireshark-Homework/response.png" alt="response"></p><p><img src="Wireshark-Homework/response%20more%20details.png" alt="response more details"></p><p><img src="Wireshark-Homework/response%20right.png" alt="response right"></p><h3 id="源和目标IP地址">源和目标IP地址</h3><ul><li><strong>源IP地址</strong>: 10.21.205.40（本机IP，如ipconfig截图所示）</li><li><strong>目标IP地址</strong>: 104.110.191.133（服务器IP）</li></ul><h3 id="端口号">端口号</h3><ul><li><strong>源端口</strong>: 54283（随机分配的客户端端口）</li><li><strong>目标端口</strong>: 80（标准HTTP端口）</li></ul><h3 id="Host字段">Host字段</h3><ul><li><strong>Host</strong>: <code>www.msftconnecttest.com</code></li></ul><h3 id="User-Agent字段">User-Agent字段</h3><ul><li><strong>User-Agent</strong>: Microsoft NCSI</li></ul><h2 id="提取的响应信息">提取的响应信息</h2><h3 id="状态码">状态码</h3><ul><li><strong>状态码</strong>: 200 OK</li></ul><h3 id="Content-Type字段">Content-Type字段</h3><ul><li><strong>Content-Type</strong>: text/plain</li></ul><h3 id="Server字段">Server字段</h3><ul><li>在提供的截图中没有明确显示Server字段，该字段可能不存在于此HTTP响应中，或位于未捕获到的响应头部分</li></ul><h2 id="问题思考">问题思考</h2><h3 id="HTTP请求的目标端口通常是多少？">HTTP请求的目标端口通常是多少？</h3><p>HTTP请求的<strong>标准目标端口是80</strong>，如截图中所示。HTTPS则使用443端口。</p><h3 id="报文中的字段形式是怎样的？">报文中的字段形式是怎样的？</h3><p>HTTP报文使用<strong>纯文本格式</strong>，以&quot;字段名: 字段值&quot;的形式组织，每行一个字段，如截图中所示：</p><ul><li><code>Host: www.msftconnecttest.com</code></li><li><code>User-Agent: Microsoft NCSI</code></li><li><code>Content-Type: text/plain</code></li></ul><p>Wireshark同时提供了三种查看方式：</p><ol><li><strong>解析后的纯文本视图</strong>（HTTP协议字段被解析为易读形式）</li><li><strong>十六进制原始数据视图</strong>（数据包的二进制表现形式）</li><li><strong>结构化协议树</strong>（按协议层级组织的视图）</li></ol><p>在Wireshark中可以看到，虽然在网络上传输时是二进制字节流，但HTTP协议本身是<strong>基于文本</strong>的协议。</p><h2 id="DNS">DNS</h2><p><img src="Wireshark-Homework/%E5%9B%9B%E6%9D%A1%E4%BF%A1%E6%81%AF.png" alt="四条信息"></p><p><img src="Wireshark-Homework/config.png" alt="config"></p><p><img src="Wireshark-Homework/A%20request.png" alt="A request"></p><p><img src="Wireshark-Homework/AAAA%20request.png" alt="AAAA request"></p><p><img src="Wireshark-Homework/A%20response.png" alt="A response"></p><p><img src="Wireshark-Homework/AAAA%20response.png" alt="AAAA response"></p><h2 id="清除DNS缓存">清除DNS缓存</h2><p>从终端截图可以看到，已使用命令<code>ipconfig /flushdns</code>成功清除了DNS缓存：</p><ul><li>终端显示：<strong>&quot;已成功刷新 DNS 解析缓存&quot;</strong></li><li>使用<code>nslookup</code>确认DNS服务器为<strong>10.3.9.5</strong></li></ul><h2 id="DNS查询与响应报文分析">DNS查询与响应报文分析</h2><h3 id="查询报文分析">查询报文分析</h3><p>根据截图，可以看到多个DNS查询：</p><ol><li><strong>查询域名</strong>：<a href="http://www.163.com">www.163.com</a></li><li><strong>查询类型</strong>：<ul><li>A记录查询（IPv4地址）- Type: A (1)</li><li>AAAA记录查询（IPv6地址）- Type: AAAA (28)</li></ul></li><li><strong>查询特征</strong>：<ul><li>Transaction ID: 0x8d99（A记录查询）和0xaa7c（AAAA记录查询）</li><li>源端口：55570、59624（随机客户端端口）</li><li>目标端口：<strong>53</strong>（标准DNS端口）</li><li>使用<strong>UDP协议</strong>传输</li></ul></li></ol><h3 id="响应报文分析">响应报文分析</h3><ol><li><strong>查询域名</strong>：<code>www.163.com</code></li><li><strong>响应IP地址</strong>：多个IP地址返回，包括：<ul><li><strong>IPv4地址</strong>（A记录）：<ul><li>220.181.171.126</li><li>220.181.10.69</li><li>220.181.10.67</li><li>220.181.10.70</li><li>220.181.10.66</li><li>等多个IP地址</li></ul></li><li><strong>CNAME记录</strong>：<ul><li><code>www.163.com.163jiasu.com</code></li><li><code>www.163.com.w.kunluncan.com</code></li></ul></li></ul></li></ol><h2 id="DNS协议特性分析">DNS协议特性分析</h2><h3 id="DNS使用的端口号">DNS使用的端口号</h3><p>从截图中可以明确看到：</p><ul><li><strong>服务器端口</strong>：53（固定标准端口）</li><li><strong>客户端端口</strong>：随机高位端口（如55570、59624）</li></ul><h3 id="DNS使用的传输协议">DNS使用的传输协议</h3><p>截图中可以看到：</p><ul><li><strong>主要使用UDP协议</strong>，因为：<ul><li>数据包标识为&quot;User Datagram Protocol&quot;</li><li>相比TCP更快速，适合简短的DNS查询</li><li>标准DNS查询通常小于512字节，适合UDP传输</li></ul></li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>DNS特性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>查询域名</td><td><code>www.163.com</code></td><td>中国网易公司网站</td></tr><tr><td>查询类型</td><td>A 和 AAAA</td><td>分别查询IPv4和IPv6地址</td></tr><tr><td>客户端端口</td><td>55570、59624等</td><td>随机高位端口</td></tr><tr><td>服务器端口</td><td>53</td><td>DNS标准端口</td></tr><tr><td>传输协议</td><td>UDP</td><td>无连接、快速、适合短查询</td></tr><tr><td>查询事务ID</td><td>0x8d99、0xaa7c</td><td>确保请求和响应匹配的唯一标识符</td></tr></tbody></table></div><p><strong>补充说明</strong>：虽然本次抓包显示使用UDP，但DNS协议在某些情况下也会使用TCP：</p><ul><li>当响应大小超过512字节时</li><li>进行区域传送(AXFR)等操作时</li><li>需要可靠连接时</li></ul>]]></content>
    
    
    <categories>
      
      <category>Wireshark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Introduction</title>
    <link href="/2025/06/10/Introduction/"/>
    <url>/2025/06/10/Introduction/</url>
    
    <content type="html"><![CDATA[<h1>Network Edge</h1><p>applications and hosts</p><h1>Client Program and Server Program</h1><p>一般而言，客户端程序是 <strong>发送请求</strong> 的，而服务器端程序是 <strong>接受请求</strong> 的。</p><h1>Access Technologies</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>接入技术</th><th>分类</th><th>简要说明</th></tr></thead><tbody><tr><td>数字用户线（DSL）</td><td>居家接入</td><td>通过电话线为家庭用户提供宽带互联网接入</td></tr><tr><td>电缆调制解调器</td><td>居家接入</td><td>通过有线电视网络为家庭用户提供互联网接入</td></tr><tr><td>光纤到户（FTTH）</td><td>居家接入/公司接入</td><td>通过光纤直接连接家庭或公司，提供高速接入</td></tr><tr><td>以太网</td><td>公司接入</td><td>企业内部常用的局域网接入方式</td></tr><tr><td>Wi-Fi</td><td>居家接入/公司接入</td><td>无线局域网，常用于家庭和公司内部无线接入</td></tr><tr><td>蜂窝移动网络（3G/4G/5G）</td><td>移动接入</td><td>通过移动运营商网络为移动设备提供互联网接入</td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>接入技术</th><th>典型速率范围</th><th>速率共享性</th><th>说明</th></tr></thead><tbody><tr><td>拨号调制解调器</td><td>最高 56 Kbps</td><td>专用</td><td>每户独占电话线</td></tr><tr><td>HFC</td><td>10 Mbps ~ 1 Gbps（下行）</td><td>共享</td><td>同轴电缆段内用户共享带宽</td></tr><tr><td>DSL</td><td>256 Kbps ~ 100 Mbps（下行）</td><td>专用</td><td>每户独占电话线，汇聚点可能有瓶颈</td></tr><tr><td>FTTH</td><td>100 Mbps ~ 10 Gbps</td><td>通常专用</td><td>部分PON架构下分光器后带宽被共享</td></tr></tbody></table></div><h1>HFC: hybrid fiber coax</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>问题</th><th>答案</th></tr></thead><tbody><tr><td>HFC 传输速率是专用还是共享？</td><td>共享</td></tr><tr><td>下行 HFC 信道是否可能发生冲突？</td><td>不会</td></tr><tr><td>原因</td><td>只有头端设备发送，无多发冲突</td></tr></tbody></table></div><h1>Ethernet LANs</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>以太网类型</th><th>典型速率</th><th>每用户能否持续满速发送？</th></tr></thead><tbody><tr><td>10BASE-T</td><td>10 Mbps</td><td>否</td></tr><tr><td>100BASE-TX</td><td>100 Mbps</td><td>否</td></tr><tr><td>1000BASE-T</td><td>1 Gbps</td><td>否</td></tr><tr><td>10GBASE-T</td><td>10 Gbps</td><td>否</td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>物理介质类型</th><th>典型应用场景</th><th>传输距离</th><th>传输速率</th></tr></thead><tbody><tr><td>双绞线</td><td>局域网、办公、家庭</td><td>最远可达100米</td><td>10 Mbps ~ 40 Gbps</td></tr><tr><td>光纤</td><td>数据中心、骨干网</td><td>数百米至数十公里</td><td>100 Mbps ~ 400 Gbps</td></tr><tr><td>同轴电缆</td><td>早期局域网</td><td>数百米</td><td>10 Mbps</td></tr></tbody></table></div><h1>Wireless Internet Access Technologies</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>技术类型</th><th>典型速率范围</th><th>覆盖范围</th><th>主要应用场景</th><th>延迟</th><th>主要优缺点</th></tr></thead><tbody><tr><td>Wi-Fi</td><td>数十 Mbps ~ 数 Gbps</td><td>局部（几十米）</td><td>家庭、办公、热点</td><td>低</td><td>速率高、成本低、覆盖范围有限</td></tr><tr><td>蜂窝网络（4G/5G）</td><td>数十 Mbps ~ 数 Gbps</td><td>广域（城市/乡村）</td><td>移动设备、车载、物联网</td><td>低（5G更优）</td><td>覆盖广、速率高、需付流量费用</td></tr><tr><td>卫星互联网</td><td>数十 Mbps ~ 数百 Mbps</td><td>全球（含偏远区）</td><td>偏远地区、应急通信</td><td>中~高</td><td>覆盖广、不依赖地面设施、延迟较高</td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>设备类型</th><th style="text-align:center">物理层</th><th style="text-align:center">链路层</th><th style="text-align:center">网络层</th><th style="text-align:center">传输层</th><th style="text-align:center">应用层</th></tr></thead><tbody><tr><td>路由器</td><td style="text-align:center">$$\surd$$</td><td style="text-align:center">$$\surd$$</td><td style="text-align:center">$$\surd$$</td><td style="text-align:center">$$\times$$</td><td style="text-align:center"></td></tr><tr><td>链路层交换机</td><td style="text-align:center">$$\surd$$</td><td style="text-align:center">$$\surd$$</td><td style="text-align:center">$$\times$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>主机</td><td style="text-align:center">$$\surd$$</td><td style="text-align:center">$$\surd$$</td><td style="text-align:center">$$\surd$$</td><td style="text-align:center">$$\surd$$</td><td style="text-align:center">$$\surd$$</td></tr></tbody></table></div><h1>Packet Switching and Circuit Switching</h1><ul><li><strong>带宽保证</strong>：电路交换网络（如传统电话网）在通信双方建立连接时，会为其分配一条固定的物理路径和带宽，整个通信期间该带宽专属使用，不会被其他用户占用。</li><li><strong>通信延迟低且稳定</strong>：由于路径和带宽在会话期间独占，数据传输延迟固定且可预测，适合对实时性要求高的应用（如语音通话）。</li><li><strong>无拥塞丢包</strong>：通信过程中不会因网络拥塞导致丢包或重传，通信质量有保障。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>网络类型</th><th>主要优势</th></tr></thead><tbody><tr><td>电路交换网络</td><td>带宽独占、延迟稳定、无拥塞丢包</td></tr><tr><td>分组交换网络</td><td>资源利用率高、灵活、适合突发性数据传输</td></tr></tbody></table></div><h2 id="Statistical-Multiplexing">Statistical Multiplexing</h2><p>分组交换（Packet Switching）中，网络资源（如链路带宽）是<strong>按需动态分配</strong>给各个数据流的。每个用户的数据被分成分组（包），这些分组在网络中独立传输，多个用户的分组在同一链路上<strong>交错传输</strong>。<br>由于不是每个用户都持续发送数据，链路带宽可以被“活跃”的用户动态共享，这种方式称为<strong>统计复用（Statistical Multiplexing）</strong>。</p><ul><li><strong>核心思想</strong>：利用用户流量的突发性和不均匀性，通过动态分配资源，提高链路利用率。</li><li><strong>资源分配</strong>：没有为每个用户预留固定带宽，资源按需分配。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>复用方式</th><th>资源分配方式</th><th>利用率</th><th>适用场景</th><th>主要特点</th></tr></thead><tbody><tr><td>统计复用</td><td>动态分配，按需使用</td><td>高</td><td>分组交换网络</td><td>用户多时可能拥塞，利用率高</td></tr><tr><td>TDM（时分复用）</td><td>固定分配，每用户固定时隙</td><td>低（有空闲浪费）</td><td>电路交换网络</td><td>时隙空闲时无法被他人利用</td></tr></tbody></table></div><h2 id="Store-and-Forward-Packet-Switching">Store-and-Forward Packet Switching</h2><p><strong>存储转发</strong>：交换机必须在收到整个分组后，才能开始向下一个链路转发。</p><h1>ISP</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>ISP 类型</th><th>互联方式</th><th>是否需购买上网带宽</th><th>网络覆盖范围</th></tr></thead><tbody><tr><td>Tier-1 ISP</td><td>与其他 Tier-1 ISP 结算互免互联</td><td>否</td><td>全球骨干</td></tr><tr><td>Tier-2 ISP</td><td>部分互联+向上级 ISP 购买带宽</td><td>是</td><td>区域/国家级</td></tr></tbody></table></div><h1>Delay</h1><ul><li>Processing Delay：每个路由器或主机在接收到分组时进行首部检查、差错检测等处理所需的时间。</li><li>Queuing Delay：分组在路由器的输出队列中等待转发的时间，取决于当前队列的长度和网络拥塞状况。</li><li>Transmission Delay： 分组所有比特从路由器或主机的输出端口“上线”所需的时间，计算公式为<br>$$<br>\text{传输时延} = \frac{L}{R}<br>$$<br>其中，$L$ 为分组长度（比特），$R$ 为链路带宽（比特/秒）。</li><li>Propagation Delay：   分组在物理链路上传播所需的时间，计算公式为：<br>$$<br>\text{传播时延} = \frac{d}{s}<br>$$<br>其中，$d$ 为链路长度，$s$ 为信号在介质中的传播速率。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>时延类型</th><th>公式</th><th>是否依赖分组长度 L</th><th>是否依赖传输速率 R</th></tr></thead><tbody><tr><td>传播时延</td><td>$$\frac{d}{s}$$</td><td>否</td><td>否</td></tr><tr><td>传输时延</td><td>$$\frac{L}{R}$$</td><td>是</td><td>是</td></tr><tr><td>总时延</td><td>$$\frac{L}{R} + \frac{d}{s}$$</td><td>部分依赖</td><td>部分依赖</td></tr></tbody></table></div><h1>Throughput</h1><p>吞吐量：传输速率，单位 $\text{bits} / \text{time}$。</p><p>每一个用于传输比特流的 <strong>pipe</strong> 的吞吐量可能不一致，这时如何计算端到端的吞吐量？<br>$$<br>\min , {R_C, R_S, \dots}<br>$$</p><p>这种情况下，端到端的吞吐量取决于整个传输路径中最慢的通道</p><h1>Layer Structure</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>任务名称</th><th>可能涉及的层级</th><th>是否可多层实现</th></tr></thead><tbody><tr><td>分段与重组</td><td>传输层、网络层</td><td>是</td></tr><tr><td>差错检测与纠正</td><td>数据链路层、传输层</td><td>是</td></tr><tr><td>流量控制</td><td>数据链路层、传输层</td><td>是</td></tr><tr><td>寻址与路由选择</td><td>网络层</td><td>否（主要网络层）</td></tr><tr><td>封装与解封装</td><td>各层均有</td><td>是</td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>层级</th><th>数据单元名称</th><th>主要内容说明</th></tr></thead><tbody><tr><td>应用层</td><td>应用层消息</td><td>应用协议数据（如HTTP请求、邮件内容等）</td></tr><tr><td>传输层</td><td>报文段（Segment）</td><td>传输层首部 + 应用层消息</td></tr><tr><td>网络层</td><td>数据报（Datagram）</td><td>网络层首部 + 传输层报文段</td></tr><tr><td>链路层</td><td>帧（Frame）</td><td>链路层首部 + 网络层数据报 + 链路层尾部</td></tr></tbody></table></div><h1>Security</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>类型</th><th style="text-align:center">是否自我复制</th><th style="text-align:center">是否依附宿主</th><th style="text-align:center">是否主动传播</th><th>主要危害方式</th></tr></thead><tbody><tr><td>病毒</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td>破坏文件、传播感染</td></tr><tr><td>蠕虫</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td>网络传播、资源消耗</td></tr><tr><td>特洛伊木马</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td>窃密、远控、伪装攻击</td></tr></tbody></table></div><ul><li><strong>僵尸网络（Botnet）</strong>：由大量被恶意控制的设备组成的分布式网络。</li><li><strong>DDoS攻击（分布式拒绝服务攻击）</strong>：利用僵尸网络同时发起大规模攻击，瘫痪目标服务。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td>恶意软件传播</td><td>通过多种方式感染大量设备</td></tr><tr><td>设备感染与控制</td><td>感染设备与C&amp;C服务器建立联系，成为“僵尸”</td></tr><tr><td>集中管理</td><td>攻击者统一管理所有僵尸设备</td></tr><tr><td>发起DDoS攻击</td><td>僵尸设备同时向目标发起流量，导致目标服务瘫痪</td></tr></tbody></table></div><h1>End-of-chapter exercises</h1><h2 id="R-15">R.15</h2><p>Suppose users share a $2$ Mbps link. Also suppose each user transmits continuously at $1$ Mbps when transmitting, but each user transmits only $20$ percent of the time. (See the discussion of statistical multiplexing in Section $1.3$.)</p><p><strong>Questions and Answers:</strong></p><p><strong>a. When circuit switching is used, how many users can be supported?</strong></p><p>在电路交换中，每个用户需要预留 $1$ Mbps 的带宽，而链路总带宽为 $2$ Mbps。因此，最多可以支持：</p><p>$$<br>\text{用户数} = \frac{\text{总带宽}}{\text{每用户带宽}} = \frac{2 , \text{Mbps}}{1 , \text{Mbps}} = 2 , \text{用户}<br>$$</p><p><strong>b. For the remainder of this problem, suppose packet switching is used. Why will there be essentially no queuing delay before the link if two or fewer users transmit at the same time? Why will there be a queuing delay if three users transmit at the same time?</strong></p><ul><li>如果两名或更少的用户同时传输，每个用户的传输速率为 $1$ Mbps，总传输速率为 $2$ Mbps 或更少，等于链路的总带宽。因此，数据可以立即通过链路传输，不会产生排队延迟。</li><li>如果三名用户同时传输，总传输速率为 $3 , \text{Mbps}$，超过了链路的总带宽 $2 , \text{Mbps}$。此时，链路无法立即传输所有数据，导致数据在队列中等待，从而产生排队延迟。</li></ul><p><strong>c. Find the probability that a given user is transmitting.</strong></p><p>每个用户有 $20%$ 的时间在传输数据，因此某个用户正在传输的概率为：</p><p>$$<br>P(\text{用户传输}) = 0.2<br>$$</p><p><strong>d. Suppose now there are three users. Find the probability that at any given time, all three users are transmitting simultaneously. Find the fraction of time during which the queue grows.</strong></p><ul><li>每个用户独立传输的概率为 $0.2$，因此三名用户同时传输的概率为：</li></ul><p>$$<br>P(\text{三名用户同时传输}) = P(\text{用户1传输}) \cdot P(\text{用户2传输}) \cdot P(\text{用户3传输}) = 0.2 \cdot 0.2 \cdot 0.2 = 0.008<br>$$</p><ul><li>队列增长的时间比例等于三名用户同时传输的概率，因为只有在这种情况下，传输速率超过链路带宽：</li></ul><p>$$<br>\text{队列增长的时间比例} = 0.008<br>$$</p><h2 id="R-19">R.19</h2><p>Suppose Host A wants to send a large file to Host B. The path from Host A to Host B has three links, of rates $R_1$ = $500$ Kbps, $R_2$ = $2$ Mbps, and $R_3$ = $1$ Mbps.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. Assuming no other traffic in the network, what is the throughput for the file transfer.</strong></p><ul><li>用公式 $\min {R_i}$ 计算得到实际吞吐量是 $500$ Kbps。</li></ul><p><strong>b. Suppose the file is 4 million bytes. Dividing the file size by the throughput, roughly how long will it take to transfer the file to Host B?</strong></p><ul><li>$$\text{传输时间} = \frac{4 \times 10^{6} \times 8}{500 \times 1000} = 64 , \text{s}$$</li></ul><p><strong>c. Repeat (a) and (b), but now with R2 reduced to 100 Kbps.</strong></p><ul><li>用公式 $\min {R_i}$ 计算得到实际吞吐量是 $100$ Kbps。</li><li>$$\text{传输时间} = \frac{4 \times 10^{6} \times 8}{100 \times 1000} = 320 , \text{s}$$</li></ul><h2 id="R-23">R.23</h2><p><strong>Questions and Answers:</strong></p><p><strong>What are the five layers in the Internet protocol stack? What are the principal responsibilities of each of these layers?</strong></p><p>There are application layer, transport layer, network layer, data link layer and physical layer. Their principal responsibilities are as follow:</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>层级</strong></th><th><strong>名称</strong></th><th><strong>主要职责</strong></th><th><strong>典型协议举例</strong></th></tr></thead><tbody><tr><td><strong>第5层</strong></td><td>应用层 (Application)</td><td>提供<strong>网络服务的接口</strong>，支持应用程序间的通信</td><td>HTTP, FTP, SMTP, DNS</td></tr><tr><td><strong>第4层</strong></td><td>传输层 (Transport)</td><td>提供<strong>端到端的传输服务</strong>，负责分段、重组、流量控制和差错恢复</td><td>TCP, UDP</td></tr><tr><td><strong>第3层</strong></td><td>网络层 (Network)</td><td>负责<strong>数据包的路由和转发</strong>，实现<strong>端到端的寻址和路径选择</strong></td><td>IP, ICMP, OSPF, BGP</td></tr><tr><td><strong>第2层</strong></td><td>数据链路层 (Data Link)</td><td>提供<strong>相邻节点间可靠传输</strong>，处理帧的封装、寻址、差错检测和媒体访问控制</td><td>Ethernet, PPP, HDLC, Wi-Fi</td></tr><tr><td><strong>第1层</strong></td><td>物理层 (Physical)</td><td>负责<strong>比特流的传输</strong>，定义物理介质、信号编码和传输速率等物理特性</td><td>RS-232, USB, SONET, 以太网物理标准</td></tr></tbody></table></div><h2 id="P-8">P.8</h2><p>Consider the discussion in Section $1.3$ of statistical multiplexing in which an example is provided with a $1$ Mbps link. Users are generating data at a rate of $100$ Kbps when busy, but are busy generating data only with probability $p = 0.1$. Suppose that the $1$ Mbps link is replaced by a $1$ Gbps link.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is $N$, the maximum number of users that can be supported simultaneously under circuit switching?</strong></p><p>$$<br>N = \frac{1 , \text{Gbps}}{100 , \text{Kbps}} = 10000<br>$$</p><p><strong>b. Now consider packet switching and a user population of $M$ users. Give a formula (in terms of $p$, $M$, $N$) for the probability that more than $N$ users are sending data.</strong></p><p>假设用户的发送行为是独立的，则发送数据的用户数目服从二项分布，只考虑 $M \geq N$：<br>$$<br>P_{ &gt; N} = 1 - \sum_{k = 0}^{N} \binom{M}{k} p^k (1 - p)^{M - k}<br>$$</p><h2 id="P-22">P.22</h2><p>Consider Figure $1.19(a)$. Assume that we know the bottleneck link along the path from the server to the client is the first link with rate $R_s$ $\text{bits/sec}$. Suppose we send a pair of packets back to back from the server to the client, and there is no other traffic on this path. Assume each packet of size $L$ $\text{bits}$, and both links have the same propagation delay $d_{prop}$.</p><p><img src="Introduction/Throughput%20for%20a%20file%20transfer%20from%20server%20to%20client.png" alt="Figure $1.19(a)$">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p>back-to-back 指的是一组数据包在没有间隔的情况下连续发送</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is the packet inter-arrival time at the destination? That is, how much time elapses from when the last bit of the first packet arrives until the last bit of the second packet arrives?</strong></p><p>从图中我们可以看到有两条 <strong>link</strong>，速率分别是 $R_s$ 和 $R_c$，前者导致瓶颈，也就是 $R_c$ &gt; $R_s$。所以，<strong>inter-arrival time</strong>：<br>$$<br>t = \frac{L}{R_s}<br>$$</p><p><strong>b. Now assume that the second link is the bottleneck link (i.e., $R_c$ &lt; $R_s$). Is it possible that the second packet queues at the input queue of the second link? Explain. Now suppose that the server sends the second packet $T$ seconds after sending the first packet. How large must $T$ be to ensure no queuing before the second link? Explain.</strong></p><p>有可能第二个包在第二条 link 输入处排队，因为 $R_c$ &lt; $R_s$ 导致，第一包仍在传输。只要保证当第二个包到达第二条 link 输入时，第一个包已经传完了，也就是：<br>$$<br>T = \frac{L}{R_c}<br>$$</p><h2 id="P-28">P.28</h2><p>Suppose there is a $10$ $\text{Mbps}$ microwave link between a geostationary satellite and its base station on Earth. Every minute the satellite takes a digital photo and sends it to the base station. Assume a propagation speed of $2.4 \cdot 10^8$ $\text{meters/sec}$.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is the propagation delay of the link?</strong></p><p>地球静止卫星轨道高度约为 $d \approx 3.5786 \times 10^7 , \text{m}$，再由公式 $d_{prop} = \frac{d}{s}$ 得到 $d_{prop} \approx 150 , \text{ms}$</p><p><strong>b. What is the bandwidth-delay product, $R \cdot d_{prop}$?</strong></p><p>这个乘式中的 $R$ 是 link 的传输速率，表示的是因延迟而没有传输的数据大小。结果是 $10 \times 10^6 \times 0.15 = 1.5 \times 10^6 , \text{bits}$。</p><p><strong>c. Let $x$ denote the size of the photo. What is the minimum value of $x$ for the microwave link to be continuously transmitting?</strong></p><p>设照片大小为 $x$（单位：$\text{bits}$），要使链路持续发送，需满足传输时间 $\frac{x}{R}$ 不小于拍照间隔 $60,\text{s}$，即<br>$$<br>\frac{x}{R} \geq 60 , \Longrightarrow ; x \geq R \times 60 = 10\times10^6\ \text{bps} \times 60\ \text{s} = 600\times10^6\ \text{bits} = 75\ \text{MB}.<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Introduction</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Wireless and Mobile Networks</title>
    <link href="/2025/06/09/Wireless-and-Mobile-Networks/"/>
    <url>/2025/06/09/Wireless-and-Mobile-Networks/</url>
    
    <content type="html"><![CDATA[<h1>Introduction</h1><h2 id="Elements-of-a-Wireless-Networks">Elements of a Wireless Networks</h2><ul><li><strong>Wireless Hosts:</strong> laptop, PDA, IP phone.</li><li><strong>Base Station:</strong><ul><li>connected to a <strong>wired network</strong>.</li><li><strong>relays</strong><ul><li>responsible for sending packets between wired network and wireless hosts in its area.</li></ul></li></ul></li><li><strong>Wireless Link:</strong><ul><li>typically used to connect mobiles to bas stations.</li><li><strong>multiple access protocol</strong> coordinates link access.</li></ul></li><li><strong>Infrastructure Mode:</strong><ul><li><strong>handoff:</strong> mobile changes base station providing connection into wired network.</li></ul></li><li><strong>Ad Hoc Mode:</strong><ul><li>no base stations.</li><li>nodes can only transmit to other nodes within link coverage.</li><li>nodes organize themselves into a network: route among themselves.</li></ul></li></ul><h2 id="Wireless-Network-Taxonomy">Wireless Network Taxonomy</h2><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>Infrastructure</strong></th><th><strong>Single Hop</strong></th><th><strong>Multiple Hops</strong></th></tr></thead><tbody><tr><td><strong>With Infrastructure</strong></td><td>Host connects to base station (WiFi, WiMAX, cellular) which connects to larger Internet.</td><td>Host relays through several wireless nodes to connect to larger Internet (mesh net).</td></tr><tr><td><strong>Without Infrastructure</strong></td><td>No base station, no connection to larger Internet (e.g., Bluetooth, ad hoc nets).</td><td>No base station, no connection to larger Internet. Nodes relay to reach other nodes (e.g., MANET, VANET).</td></tr></tbody></table></div><h1>Wireless Link Characteristics</h1><blockquote><p>从下文可以分析出，这里的 link 不能翻译成<strong>链路</strong>而应该翻译成<strong>连接</strong>。</p></blockquote><ul><li><strong>decreased signal strength</strong></li><li><strong>interference from other sources</strong></li><li><strong>multipath propagation</strong></li></ul><p>Multiple wireless senders and receivers create additional problems (beyond multiple access):</p><ul><li><strong>Hidden Terminal Problem:</strong> A and C can not hear each other means A and C are unaware of their interference B.</li></ul><blockquote><p>这里是在讲，A 和 C 因为障碍物的问题而无法直接通信从而无法协调，但他们都能和 B 进行通信，如果 A 和 C 同时向 B 通信会导致冲突。</p></blockquote><ul><li><strong>SNR (Signal-to-Noise Ratio):</strong><ul><li>larger SNR, easier to extract signal from noise.</li><li>increases power $\to$ increases SNR $\to$ decreases <strong>BER (Bit Error Rate)</strong>.</li><li>Given SNR, choose physical layer that meets BER requirement, giving highest throughput.</li></ul></li></ul><blockquote><p>SNR 是信噪比，顾名思义是一个比值，具体计算公式为<br>$$<br>\mathrm{SNR} = \frac{P_{\text{signal}}}{P_{\text{noise}}}<br>$$<br>实际中用单位 db 表示。SNR 越大，说明信号越容易从噪声中分辨出来，通信质量越好。</p></blockquote><h2 id="Code-Division-Multiple-Access-CDMA">Code Division Multiple Access (CDMA)</h2><blockquote><p>码分多址，这个我们在 data link layer 提到过，类似的有 TDMA 和 FDMA。需要注意的是 CDMA 是一个 physical layer protocol。所以下文用的是 channel 而不是 link。</p></blockquote><p>A kind of <strong>channel partitioning protocol</strong>.</p><ul><li><strong>Usage</strong>: Used in <strong>wireless broadcast channels</strong> (e.g., cellular, satellite).</li><li><strong>Code Assignment</strong>: Each user is assigned a <strong>unique &quot;code&quot;</strong> (code set partitioning).</li><li><strong>Frequency Sharing</strong>: All users share the same frequency but use distinct <strong>&quot;chipping&quot;</strong> sequences to encode data.</li><li><strong>Signal Encoding</strong>:<ul><li>Encoded signal = (original data)  (chipping sequence).</li></ul></li><li><strong>Signal Decoding</strong>:<ul><li>Decoding is done using the inner product of the encoded signal and the chipping sequence.</li></ul></li><li><strong>Advantage</strong>: Allows multiple users to coexist and transmit simultaneously with minimal interference (if codes are orthogonal).</li></ul><blockquote><p>这里提到的 unique code 和 chipping sequence 是同一个事物。</p></blockquote><h3 id="CDMA-Encode-Decode-Process">CDMA Encode/Decode Process</h3><h4 id="Sender"><strong>Sender:</strong></h4><ol><li><p><strong>Data Encoding</strong>:</p><ul><li>Each sender has a unique code (chipping sequence) <code>c_m</code>.</li><li>Encoded signal for each data bit:<br>$$ Z_{i,m} = d_i \cdot c_m $$<ul><li><code>d_i</code>: Original data bit.</li><li><code>c_m</code>: Chipping sequence.</li></ul></li></ul></li><li><p><strong>Channel Output</strong>:</p><ul><li>Encoded signals are transmitted over the shared channel.</li><li>Channel output combines signals from all senders.</li></ul></li></ol><h4 id="Receiver"><strong>Receiver:</strong></h4><ol><li><p><strong>Signal Decoding</strong>:</p><ul><li>Receiver uses the inner product of the received signal and its own chipping sequence to decode data:<br>$$ D_i = \frac{\sum_{m=1}^{M} Z_{i,m} \cdot c_m}{M} $$<ul><li><code>D_i</code>: Decoded data bit.</li><li><code>Z_&#123;i,m&#125;</code>: Received signal.</li><li><code>c_m</code>: Receiver’s chipping sequence.</li></ul></li></ul></li><li><p><strong>Output</strong>:</p><ul><li>Decoded data bits are extracted from the combined channel output.</li></ul></li></ol><blockquote><p>每个发送端都被分配一个唯一的码字（chipping sequence），码字的长度应该足够长，按理来讲，如果有 $N$ 个用户，码字长度 $M \geq N$。码字具体为：用 $+1$ 和 $-1$ 分别代表 $1$ 和 $0$。发送者将发送数据与码字相乘，这里指的是位对码字相乘。发送后数据会和其他所有发送者的信息在 channel 中叠加。解码公式有一个前提：要求 user 使用的码字之间正交。除以 M 是为保证归一化。</p><p>还要补充的是，CDMA 的核心思想是：所有用户在 <strong>same frequency</strong> 和 <strong>same time</strong> 的情况下发送信息。此时应用 CDMA。如果 frequency 不一致，也不会发生信号叠加，此时应该用 FDMA。</p></blockquote><h1>WiFi: 802.11 Wireless LANs</h1><blockquote><p>前部分介绍了 wireless link 及其用到的 CDMA protocol，</p></blockquote><ul><li>all use <strong>CSMA/CA</strong> for multiple access.</li></ul><blockquote><p>data link layer 部分我们讲过了 CSMA/CD。</p></blockquote><ul><li>all have base-station and ad-hoc network versions.</li></ul><h2 id="The-802-11-LAN-Architecture">The 802.11 LAN Architecture</h2><ul><li><p>wireless host communicates with base station (base station = access point (AP))</p></li><li><p>Basic Service Set (BSS) (aka &quot;cell&quot;一片区域) in infrastructure mode contains:</p><ul><li>wireless hosts</li><li>access point (AP): base station</li><li>ad hoc mode: hosts only</li></ul></li><li><p><strong>层次关系</strong>：一个 subnet 可以包含<strong>多个 BSS</strong>，多个无线主机通过不同接入点接入同一子网</p></li><li><p><strong>切换过程</strong>：</p><ul><li>当移动设备在<strong>同一子网内</strong>的不同 BSS 之间移动时，只需改变 BSS 关联（链路层切换），IP 地址<strong>保持不变</strong></li><li>当移动设备跨子网移动时，除了需要切换 BSS，还需要获取新子网的 IP 地址（通常通过 DHCP）</li></ul></li><li><p><strong>地址分配</strong>：BSS 关注 MAC 地址，而 Subnet 关注 IP 地址</p></li><li><p><strong>管理机制</strong>：BSS 由 AP 管理，Subnet 由路由器管理</p></li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>特性</strong></th><th><strong>BSS</strong></th><th><strong>Subnet</strong></th></tr></thead><tbody><tr><td><strong>所属网络层次</strong></td><td>物理层和数据链路层 (OSI 第 1、2 层)</td><td>网络层 (OSI 第 3 层)</td></tr><tr><td><strong>定义标准</strong></td><td>IEEE 802.11 标准</td><td>IP 协议标准</td></tr><tr><td><strong>标识符</strong></td><td>BSSID (MAC 地址)</td><td>IP 地址前缀和子网掩码</td></tr><tr><td><strong>地址范围</strong></td><td>单个无线接入点覆盖范围</td><td>可跨多个接入点，由路由器定义</td></tr><tr><td><strong>关注点</strong></td><td>无线媒体访问和信号传输</td><td>IP 数据包的寻址和路由</td></tr><tr><td><strong>设备组织方式</strong></td><td>围绕单个接入点的无线主机集合</td><td>共享同一网络前缀的主机集合</td></tr><tr><td><strong>移动特性</strong></td><td>设备在 BSS 间移动需要进行<strong>切换 (handoff)</strong></td><td>在同一子网内的移动不需要更改 IP 地址</td></tr></tbody></table></div><h2 id="802-11-Channels-Association">802.11: Channels, Association</h2><ul><li><strong>Frequency Spectrum</strong>: 2.4GHz-2.485GHz (802.11b) divided into 11 channels.</li><li><strong>AP Configuration</strong>: Admin selects frequency for AP; interference may occur if neighboring APs use the same channel.</li><li><strong>Host Association</strong>:<ul><li>Scans channels for beacon frames with AP’s SSID and MAC address.</li><li>Selects an AP to associate with.</li><li>May perform authentication.</li><li>Typically runs <strong>DHCP</strong> to obtain an IP address in the AP’s subnet.</li></ul></li></ul><blockquote><p>前文我们讲 CDMA 的时候提到了： CDMA 的所有用户使用相同的 frequency。通常情况下，一个 AP 在同一时刻只工作在一个信道（即一个频率范围），只能收发该信道上的无线信号。</p></blockquote><h2 id="802-11-Passive-Active-Scanning">802.11: Passive/Active Scanning</h2><blockquote><p>Beacon Frame（信标帧） 是 IEEE 802.11 无线局域网（WiFi）协议中由接入点（AP, Access Point）周期性广播的一种管理帧。</p></blockquote><ul><li><p><strong>Passive Scanning</strong>:</p><ul><li>APs send <strong>beacon frames</strong>.</li><li>Host (H1) sends Association Request frame to selected AP.</li><li>Selected AP sends Association Response frame to H1.</li></ul></li><li><p><strong>Active Scanning</strong>:</p><ul><li>Host (H1) broadcasts Probe Request frame.</li><li>APs respond with Probe Response frames.</li><li>Host (H1) sends Association Request frame to selected AP.</li><li>Selected AP sends Association Response frame to H1.</li></ul></li></ul><blockquote><p>这两种方式最后两步都是一样的。</p></blockquote><h2 id="IEEE-802-11-Multiple-Access">IEEE 802.11: Multiple Access</h2><blockquote><p>data link layer</p></blockquote><h3 id="Collision-Avoidance-in-802-11">Collision Avoidance in 802.11</h3><ul><li><strong>Problem</strong>: Collisions occur when $2$ more nodes transmit simultaneously.</li><li><strong>Solution</strong>:<ul><li><strong>CSMA</strong>: Sense the channel before transmitting to avoid collisions with ongoing transmissions.</li><li><strong>No Collision Detection</strong>:<ul><li>Difficult to sense collisions while transmitting due to weak received signals (fading).</li><li><strong>Hidden terminal</strong> and <strong>fading issues</strong> prevent sensing all collisions.</li></ul></li><li><strong>Goal</strong>: Use <strong>CSMA/CA (Collision Avoidance)</strong> to minimize collisions.</li></ul></li></ul><h2 id="IEEE-802-11-MAC-Protocol-CSMA-CA">IEEE 802.11 MAC Protocol: CSMA/CA</h2><blockquote><p>DIFS 是<strong>分布式帧间间隔</strong>（Distributed Inter-Frame Space）的缩写。SIFS 是<strong>短帧间间隔</strong>（Short Inter-Frame Space）的缩写。<strong>Link（链路）</strong>：在有线网络中，通常指两个节点之间的物理连接。<strong>Channel（信道）</strong>：在无线网络中，指的是一段特定频率范围内的无线传输资源，多个节点可以共享同一个信道。</p></blockquote><h3 id="802-11-Sender"><strong>802.11 Sender</strong></h3><ol><li><strong>Channel Idle</strong>:<ul><li>If the channel is idle for DIFS, transmit the entire frame (no collision detection).</li></ul></li><li><strong>Channel Busy</strong>:<ul><li>Start a random backoff timer.</li><li>Timer counts down while the channel is idle.</li><li>Transmit when the timer expires.</li><li>If no ACK is received, increase the random backoff interval and repeat step $2$.</li></ul></li></ol><h3 id="802-11-Receiver"><strong>802.11 Receiver</strong></h3><ul><li>If the frame is received correctly:<ul><li>Return an ACK after SIFS (ACK is needed to address the hidden terminal problem).</li></ul></li></ul><h3 id="Avoiding-Collisions-RTS-CTS-Mechanism">Avoiding Collisions: RTS/CTS Mechanism</h3><ul><li><strong>Idea</strong>: Allow sender to reserve the channel to avoid collisions of long data frames.</li><li><strong>Process</strong>:<ol><li>Sender transmits a small <strong>Request-to-Send (RTS)</strong> packet to the base station (BS) using CSMA.</li><li>RTS packets may collide, but they are short.</li><li>BS responds with a <strong>Clear-to-Send (CTS)</strong> packet, broadcast to all nodes.</li><li>Sender transmits the data frame.</li><li>Other stations defer their transmissions upon hearing the CTS.</li></ol></li><li><strong>Advantage</strong>: Completely avoids collisions of long data frames by using small reservation packets.</li></ul><ol><li><strong>发送预约请求（RTS）</strong><ul><li>发送方先发送一个很短的 RTS（Request to Send）帧给基站（或接入点，AP），请求占用信道。</li></ul></li><li><strong>接收预约确认（CTS）</strong><ul><li>基站收到 RTS 后，如果信道空闲，则广播一个 CTS（Clear to Send）帧，通知所有节点允许该发送方发送数据。</li></ul></li><li><strong>数据发送</strong><ul><li>发送方收到 CTS 后，立即发送长数据帧。</li></ul></li><li><strong>其他节点监听</strong><ul><li>网络中其他节点收到 CTS 后，会在指定时间内暂停发送，避免与当前数据帧发生冲突。</li></ul></li></ol><h2 id="802-11-Addressing">802.11 Addressing</h2><p>下表总结了 802.11 帧的各字段及其作用：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>字段名</th><th>长度（字节）</th><th>作用说明</th></tr></thead><tbody><tr><td>frame control</td><td>2</td><td>帧控制字段，指示帧类型、控制信息等</td></tr><tr><td>duration</td><td>2</td><td>持续时间字段，指示信道预留时间</td></tr><tr><td>address 1</td><td>6</td><td>接收方 MAC 地址（无线主机或 AP）</td></tr><tr><td>address 2</td><td>6</td><td>发送方 MAC 地址（无线主机或 AP）</td></tr><tr><td>address 3</td><td>6</td><td>路由器接口的 MAC 地址（AP 所连接的路由器接口）</td></tr><tr><td>seq control</td><td>2</td><td>序列控制字段，帧编号等</td></tr><tr><td>address 4</td><td>6</td><td>仅在 ad hoc 模式下使用的地址</td></tr><tr><td>payload</td><td>0 - 2312</td><td>数据负载部分</td></tr><tr><td>CRC</td><td>4</td><td>循环冗余校验，用于差错检测</td></tr></tbody></table></div><p><strong>说明：</strong></p><ul><li>address 1：接收方 MAC 地址</li><li>address 2：发送方 MAC 地址</li><li>address 3：AP 所连接的路由器接口的 MAC 地址</li><li>address 4：仅 ad hoc 模式下使用</li></ul><h2 id="Mobility-within-Same-Subnet">Mobility within Same Subnet</h2><p>Host 在统一子网下不同 BSS 移动，switch 如何得知 host 当前在哪个 BSS 内？实际上 switch 能通过 self-learning：switch will see frame from H1 and remember which switch port can be used to reach H1。</p><h2 id="Power-Management">Power Management</h2><ul><li><strong>定时唤醒机制</strong>：<br>休眠节点在进入省电模式（Power Save Mode）时，会本地保存下一个 beacon frame 的预计到达时间，并设置定时器（timer）。</li><li><strong>硬件支持</strong>：<br>无线网卡硬件通常具备低功耗计时功能，可以在主机休眠时保持计时，确保在 beacon frame 到来前自动唤醒。</li><li><strong>唤醒流程</strong>：<br>节点休眠后，定时器到达设定时间，节点自动唤醒，监听并接收 AP 广播的 beacon frame，判断是否有待接收的数据。</li><li><strong>节能的核心在于节点休眠</strong>：<br>节能的关键不是 AP 是否省电，而是<strong>无线终端（如手机、笔记本）可以长时间休眠，仅在 beacon frame 到来时短暂唤醒</strong>，大大减少无线网卡的活跃时间和能耗。</li><li><strong>AP 通常为插电设备</strong>：<br>AP 持续广播 beacon frame 对其本身能耗影响不大，因为 AP 通常是接入电源的设备，不依赖电池。</li><li><strong>终端省电效果显著</strong>：<br>终端设备在无数据通信时可以关闭大部分无线模块，仅保留低功耗计时和唤醒功能，只有在需要接收数据或发送数据时才唤醒主模块，极大延长了电池续航。</li></ul><h2 id="802-15-Personal-Area-Network">802.15: Personal Area Network</h2><p>个人热点。使用 ad hoc mode，参考 bluetooth protocol。</p><h2 id="802-16-WiMAX">802.16: WiMAX</h2><h1>Cellular Internet Access</h1><p>介绍几个概念：</p><ul><li><strong>Cell</strong>：一个区域，里面有一个 base station，mobile users 通过这个基站连接到 network。</li><li><strong>MCS</strong>：Mobile Switching Center。连接 base station 和 wired network。</li></ul><h2 id="The-First-Hop">The First Hop</h2><p>第一跳为 users 到 base station。显然是一个 multiple senders 的场景，可以用 FDMA、TDMA 和 CDMA 分离数据。</p><h2 id="Cellular-standards-brief-survey">Cellular standards: brief survey</h2><h3 id="2G-Systems"><strong>2G Systems</strong></h3><ul><li><strong>Voice Channels</strong>:<ul><li><strong>IS-136 TDMA</strong>: Combined FDMA/TDMA (North America).</li><li><strong>GSM</strong>: Global System for Mobile Communications, combined FDMA/TDMA (most widely deployed).</li><li><strong>IS-95 CDMA</strong>: Code Division Multiple Access.</li></ul></li></ul><h3 id="2-5G-Systems"><strong>2.5G Systems</strong></h3><ul><li><strong>Voice and Data Channels</strong>:<ul><li><strong>GPRS</strong>: Evolved from GSM, data sent on multiple channels.</li><li><strong>EDGE</strong>: Enhanced modulation, data rates up to 384K.</li><li><strong>CDMA-2000 (Phase 1)</strong>: Data rates up to 144K, evolved from IS-95.</li></ul></li></ul><h3 id="3G-Systems"><strong>3G Systems</strong></h3><ul><li><strong>Voice/Data</strong>:<ul><li><strong>UMTS</strong>: High-Speed Uplink/Downlink Packet Access (HSDPA/HSUPA), 3 Mbps.</li><li><strong>CDMA-2000</strong>: Data service (1xEVDO), up to 14 Mbps.</li></ul></li></ul><h3 id="4G-Systems"><strong>4G Systems</strong></h3><ul><li><strong>Voice/Data</strong>:<ul><li><strong>LTE</strong>: Employs OFDM and MIMO techniques, 100 Mbps for downlink, 50 Mbps for uplink.</li></ul></li></ul><h1>Principles: Addressing and Routing to Mobile Users</h1><p><strong>mobile user, passing through multiple access point while maintaining ongoing connections (like cell phone)</strong></p><h2 id="Mobility-Vocabulary">Mobility: Vocabulary</h2><h3 id="Home-Network"><strong>Home Network</strong></h3><ul><li>Permanent &quot;home&quot; of the mobile device (e.g., 128.119.40/24).</li><li><strong>Permanent Address</strong>: Address in the home network, always used to reach the mobile (e.g., 128.119.40.186).</li><li><strong>Home Agent</strong>: Entity in the home network that performs mobility functions for the mobile when it is remote.</li></ul><h3 id="Visited-Network"><strong>Visited Network</strong></h3><ul><li>Network where the mobile device currently resides (e.g., 79.129.13/24).</li><li><strong>Care-of-Address</strong>: Temporary address assigned to the mobile in the visited network (e.g., 79.129.13.2).</li><li><strong>Foreign Agent</strong>: Entity in the visited network that performs mobility functions on behalf of the mobile.</li></ul><h3 id="Correspondent"><strong>Correspondent</strong></h3><ul><li>The entity that wants to communicate with the mobile device.</li></ul><h3 id="Consider-friend-frequently-changing-addresses-how-do-you-find-her">Consider friend frequently changing addresses, how do you find her?</h3><p><strong>let end-systems handle it:</strong></p><ul><li>indirect routing: communication from correspondent to mobile goes through home agent, then forwarded to remote</li><li>direct routing: correspondent gets foreign address of mobile, sends directly to mobile</li></ul><p><img src="Wireless-and-Mobile-Networks/Indirect%20routing%20to%20a%20mobile%20node.png" alt="Indirect routing">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p>第一种 indirect routing，见上图所示，当你的朋友移动到其它 <strong>foreign</strong> 网络，他会得到一个 <strong>Care-of-Address</strong>，这个地址是临时的，用于在当前所在子网下通信，但他有一个 <strong>Permanent Address</strong>，可以通过联系他的 <strong>Home agent</strong>，从而联系到他所在子网的 <strong>Foreign agent</strong>，从而联系到他。</p><p><img src="Wireless-and-Mobile-Networks/Direct%20routing%20to%20a%20mobile%20user.png" alt="Direct routing">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p>第二种是 direct routing，这种是先通过联系他的 Home agent，得到他所在子网的 IP address，从联系到他。</p><p>需要补充两点：</p><ol><li><strong>correspondent 如何得到 friend 的 permanent address</strong>.</li></ol><ul><li><strong>permanent address（永久地址）</strong> 是 friend 在 home network 的固定 IP 地址，通常是 friend 在 home network 注册时分配的。</li><li><strong>correspondent（通信对端）</strong> 想要联系 friend 时，通常会通过 DNS 查询等方式获得 friend 的 permanent address（即 home address）。</li><li>这个 permanent address 是公开的、长期有效的，类似于家庭住址，所有通信发起者都可以通过标准方式获得。</li></ul><ol start="2"><li><strong>home agent 如何维护 friend 所在子网的 agent 和 IP address</strong>.</li></ol><ul><li><strong>home agent（归属代理）</strong> 是部署在 friend 的 home network 内的一个特殊节点，负责跟踪 friend 的当前位置。</li><li>当 friend 移动到新的 visited network 并获得新的 care-of address 时，会向 home agent 注册自己的新位置（即 care-of address 和 foreign agent 的信息）。</li><li>home agent 会维护一个映射表，记录每个移动节点的 permanent address 与其当前的 care-of address（以及 foreign agent 的信息，如果有）。</li><li>当有数据包发往 friend 的 permanent address 时，home agent 会将这些数据包<strong>隧道转发</strong>（tunnel）到 friend 当前的 care-of address（即 friend 所在子网的 foreign agent 或直接到 friend 本身）。</li></ul><h1>Mobile IP: agent discovery</h1><p>Agent advertisement: foreign/home agents advertise service by broadcasting ICMP messages (<code>typefield = 9</code>)</p><h1>End-of-chapter exercises</h1><h2 id="R-1">R.1</h2><p><strong>Question and Answer:</strong></p><p>What does it mean for a wireless network to be operating in &quot;infrastructure mode&quot;? If the network is not in infrastructure mode, what mode of operation is it in, and what is the different between that mode of operation and infrastructure mode?</p><p>在无线网络中，&quot;基础设施模式&quot;（infrastructure mode）指的是网络中存在一个基站（如接入点，AP），无线主机通过基站连接到有线网络或更大的互联网。在这种模式下，基站负责在无线主机和有线网络之间中继数据。如果网络不处于基础设施模式，则它处于&quot;自组织模式&quot;（ad hoc mode）。在自组织模式中，没有基站，节点只能与其链路覆盖范围内的其他节点通信，节点之间通过自组织的方式形成网络并相互路由。两者的主要区别在于是否依赖基站：基础设施模式依赖基站，而自组织模式则完全由节点自主协作。</p><h2 id="R-2">R.2</h2><p><strong>Question and Answer:</strong></p><p>What are the four type of wireless networks identified in our taxonomy in Section $6.1$? Which of these types of wireless networks have you used?</p><p>Section $6.1$ 中提到的 $4$ 种无线网络结构如下：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>Infrastructure</strong></th><th><strong>Single Hop</strong></th><th><strong>Multiple Hops</strong></th></tr></thead><tbody><tr><td><strong>With Infrastructure</strong></td><td>Host connects to base station (WiFi, WiMAX, cellular) which connects to larger Internet.</td><td>Host relays through several wireless nodes to connect to larger Internet (mesh net).</td></tr><tr><td><strong>Without Infrastructure</strong></td><td>No base station, no connection to larger Internet (e.g., Bluetooth, ad hoc nets).</td><td>No base station, no connection to larger Internet. Nodes relay to reach other nodes (e.g., MANET, VANET).</td></tr></tbody></table></div>其中像 WiFi 和 Bluetooth 经常使用。<h2 id="R-3">R.3</h2><p><strong>Question and Answer:</strong></p><p>What are the differences between the following types of wireless channel impairments: path loss, multipath propagation, interference from other sources?</p><p>下面是对三种信道损伤的解释：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>损伤类型</strong></th><th><strong>详细解释</strong></th></tr></thead><tbody><tr><td><strong>路径损耗 (path loss)</strong></td><td>信号随<strong>传播距离增加</strong>而自然衰减的现象。遵循<strong>平方反比或更高次幂</strong>衰减规律，与距离和频率相关。主要包括<strong>自由空间损耗</strong>、<strong>大气吸收</strong>、<strong>障碍物衰减</strong>等，是无线通信中的<strong>基础衰减现象</strong>。</td></tr><tr><td><strong>多径传播 (multipath propagation)</strong></td><td>信号通过<strong>多个不同路径</strong>同时到达接收器的现象。由信号在建筑物、地面等物体表面的<strong>反射</strong>、<strong>散射</strong>、<strong>折射</strong>和<strong>绕射</strong>导致。产生<strong>相位差异</strong>使信号彼此<strong>增强或抵消</strong>，造成<strong>信号衰落</strong>、<strong>时延扩展</strong>和<strong>符号间干扰</strong>。</td></tr><tr><td><strong>外部干扰 (interference from other sources)</strong></td><td>来自<strong>其他发射源</strong>的电磁波对当前通信的干扰。包括<strong>同频干扰</strong>（相同频道上的其他发射器）、<strong>相邻频道干扰</strong>和<strong>电子设备噪声</strong>等。干扰与当前信号混合，<strong>降低信噪比</strong>和通信质量。</td></tr></tbody></table></div><h2 id="R-4">R.4</h2><p><strong>Question and Answer:</strong></p><p>As a mobile node gets farther and farther away from a base station, what are two actions that a base station could take to ensure that the loss probability of a transmitted frame does not increase?</p><ol><li><p><strong>Wireless Link Characteristics</strong> 部分提到：</p><ul><li><strong>SNR (Signal-to-Noise Ratio)</strong>：增大信号强度可以提高信噪比，从而降低误码率（BER）。</li><li><strong>decreased signal strength</strong>：信号强度的降低会影响通信质量。</li></ul></li><li><p><strong>IEEE 802.11 MAC Protocol: CSMA/CA</strong> 部分提到：</p><ul><li><strong>Collision Avoidance</strong>：通过避免冲突来提高传输成功率。</li></ul></li><li><p><strong>Cellular Internet Access</strong> 部分提到：</p><ul><li><strong>LTE</strong> 使用了 <strong>OFDM</strong> 和 <strong>MIMO</strong> 技术，这些技术可以提高信号覆盖范围和传输效率。</li></ul></li></ol><p>结合这些内容，可以得出以下两种可能的措施：</p><ul><li><strong>增大发射功率</strong>：提高信号强度以补偿路径损耗。</li><li><strong>使用多天线技术（如 MIMO）</strong>：通过空间分集技术提高信号质量和覆盖范围。</li></ul><h2 id="R-10">R.10</h2><p><strong>Question and Answer:</strong></p><p>Suppose the IEEE $802.11$ RTS and CTS frames were as long as the standard DATA and ACK frames. Would there be any advantage to using the CTS and RTS frames? Why or why not?</p><ul><li><strong>Avoiding Collisions: RTS/CTS Mechanism</strong> 部分提到：<ul><li>RTS 和 CTS 的主要作用是 <strong>避免长数据帧的冲突</strong>。</li><li>RTS 和 CTS 包较小，即使发生冲突，影响也较小。</li><li>使用 RTS/CTS 机制可以通过小型的预留包来减少长数据帧的冲突。</li></ul></li><li>如果 RTS 和 CTS 包与标准的 DATA 和 ACK 包一样长，那么它们的优势将丧失，因为：<ol><li><strong>冲突成本增加</strong>：长 RTS 和 CTS 包的冲突会导致更大的资源浪费。</li><li><strong>效率降低</strong>：长 RTS 和 CTS 包会增加额外的开销，降低整体网络效率。</li></ol></li></ul><h2 id="R-16">R.16</h2><p><strong>Question and Answer:</strong></p><p>If a node has a wireless connection to the Internet, does that node have to be mobile? Explain. Suppose that a user with a laptop walks around her house with her laptop, and always accesses the Internet through the same access point. Is this user mobile from a network standpoint? Explain.</p><p>一个节点拥有无线连接，并不意味着它是<strong>移动的</strong>。无线连接只是物理层和链路层的接入方式，只要设备通过无线方式接入网络，无论它是否实际移动，都可以称为无线节点，但不一定是<strong>移动节点</strong>。用户在家中携带笔记本，始终通过同一个 AP 上网，这说明用户始终在同一个 subnet 和 BSS 内，所以不认为用户发生了网络层的移动。</p><h2 id="R-17">R.17</h2><p><strong>Question and Answer:</strong></p><p>What is the difference between a permanent address and a care-of address? Who assigns a care-of address?</p><ul><li><p><strong>permanent address（永久地址）</strong></p><ul><li>也称为 home address（归属地址），是移动节点在其<strong>归属网络</strong>（home network）中的固定 IP 地址。</li><li>这个地址在移动节点无论身处何地都不会改变，始终用于标识该节点的身份。</li><li>例如：移动节点在家乡网络的 IP 地址 128.119.40.186。</li></ul></li><li><p><strong>care-of address（临时地址）</strong></p><ul><li>是移动节点在<strong>访问网络</strong>（visited network）中临时获得的 IP 地址。</li><li>当移动节点离开归属网络，进入其他网络时，会在该访问网络中分配一个新的 IP 地址，这个地址用于在当前网络中进行通信。</li><li>例如：移动节点在外地网络获得的 IP 地址 79.129.13.2。</li></ul></li><li><p>care-of address 通常由<strong>访问网络 visited network</strong> 分配，具体来说：</p><ul><li>可以由访问网络中的<strong>外部代理 Foreign Agent</strong> 分配；</li><li>也可以通过 DHCP 等自动分配协议由访问网络的路由器分配。</li></ul></li></ul><h2 id="R-19">R.19</h2><p><strong>Question and Answer:</strong></p><p>What are the purposes of the HLR and VLR in GSM networks? What elements of mobile IP are similar to the HLR and VLR?</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>GSM 网络</th><th>Mobile IP 协议</th><th>主要作用</th></tr></thead><tbody><tr><td>HLR</td><td>Home Agent</td><td>记录永久信息和当前位置</td></tr><tr><td>VLR</td><td>Foreign Agent</td><td>临时管理当前区域内的用户/节点信息</td></tr></tbody></table></div><h2 id="P-5">P.5</h2><p><strong>Question and Answer:</strong></p><p>Suppose there are two ISPs providing WiFi access in a particular café, with each ISP operating its own AP and having its own IP address block. a. Further suppose that by accident, each ISP has configured its AP to operate over channel 11. Will the 802.11 protocol completely break down in this situation? Discuss what happens when two stations, each associated with a different ISP, attempt to transmit at the same time. b. Now suppose that one AP operates over channel 1 and the other over channel 11. How do your answers change?</p><p><strong>a.</strong>：802.11 协议不会完全失效，但两个 AP 及其关联的 hosts 会在 physical layer 竞争同一个信道的使用权。如果两个 hosts 同时发送数据，此时会产生 collision，尽管 CSMA/CA 协议会尽可能避免冲突，但由于信号干扰，冲突仍会发生，导致通信变得不稳定。</p><p><strong>b.</strong>：此时两个 AP 用不同的信道，互不干扰，通信正常。</p><h2 id="P-13">P.13</h2><p><strong>Question and Answer:</strong></p><p>In mobile IP, what effect will mobility have on end-to-end delays of datagrams between the source and destination?</p><ol><li><p><strong>间接路由（Indirect Routing）增加路径长度</strong></p><ul><li>在移动 IP 的典型实现中，数据报首先被发送到移动节点的 home agent（归属代理），然后由 home agent 转发（隧道）到移动节点当前的 care-of address（临时地址）。</li><li>这种绕路导致数据报的实际传输路径比直接路由更长，<strong>增加了端到端延迟</strong>。</li><li>例如，源主机 → home agent → foreign agent → 移动节点。</li></ul></li><li><p><strong>切换期间的延迟抖动</strong></p><ul><li>当移动节点从一个网络切换到另一个网络时（如切换 AP 或基站），需要重新获取 care-of address 并向 home agent 注册新位置。</li><li>在切换和注册期间，可能会出现短暂的不可达或数据包丢失，<strong>导致延迟波动或瞬时增加</strong>。</li></ul></li><li><p><strong>三角路由问题</strong></p><ul><li>在 indirect routing 下，通信对端（correspondent）始终将数据包发往 permanent address，导致所有流量都要经过 home agent，形成所谓的三角路由。</li><li>这进一步增加了端到端的传输时延，尤其当 home agent 距离通信双方较远时影响更明显。</li></ul></li><li><p><strong>优化路由（Direct Routing）可减少延迟</strong></p><ul><li>如果采用 direct routing（如移动节点的当前位置被通知给通信对端），数据报可以直接从源主机发往移动节点当前的 care-of address，<strong>端到端延迟会降低</strong>。</li><li>但 direct routing 需要额外的机制来保证安全和地址同步。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Wireless and Mobile Networks</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Transport Layer</title>
    <link href="/2025/06/08/The-Transport-Layer/"/>
    <url>/2025/06/08/The-Transport-Layer/</url>
    
    <content type="html"><![CDATA[<h1>Transport-Layer Services</h1><p>Transport protocols run in <strong>end systems</strong>:</p><ul><li>Sending side: breaks app messages into <strong>segments</strong>, passes to  network layer.</li><li>Receiving side: reassembles segments into <strong>messages</strong>, passes to app layer.</li></ul><h1>Multiplexing and Demultiplexing</h1><p><strong>Multiplexing at sending host:</strong> gather data from multiple sockets, enveloping data with <strong>header</strong>(later used for demultiplexing).<br><strong>demultiplexing at receiving host:</strong> deliver segments to correct socket.</p><h2 id="Demultiplexing">Demultiplexing</h2><p>Hosts receives <strong>IP datagrams</strong>. Each IP datagram has source IP address and destination IP address. Each IP datagram carries a transport-layer segment. Each segment has source port numbers and destination port numbers.</p><p><img src="The-Transport-Layer/a-transport-layer-segment.png" alt="A transport layer segment">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><blockquote><p>将 segment 传到目标 host，host 再将 segment 通过 socket 传给对应的 application。</p></blockquote><h3 id="Connectionless-Demultiplexing">Connectionless Demultiplexing</h3><p>在 <strong>UDP</strong> 协议中使用。</p><p>Creates socket with <strong>port numbers</strong>. Each UDP socket identified with <code>(dest IP address, dest port numbers)</code>.</p><blockquote><p>当终端收到 IP datagrams 中是 UDP segment 时。 The host will check destination port in the segment and then directs the segment to corresponding socket。发生在 transport layer。</p></blockquote><h3 id="Connection-oriented-Demultiplexing">Connection-oriented Demultiplexing</h3><p><strong>Used in TCP protocol</strong>.</p><p>TCP socket identified by <strong>4</strong>-tuple: <code>(source IP address, source port numbers, dest IP address, dest port numbers)</code>.</p><h1>Connectionless Transport: UDP</h1><h2 id="UDP-Segment-Structure">UDP Segment Structure</h2><p><img src="The-Transport-Layer/UDP-segment-structure.png" alt="UDP segment structure">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><h2 id="UDP-Checksum">UDP Checksum</h2><p><strong>Goal</strong>: detect &quot;errors&quot; (e.g., flipped bits) in transmitted segment. 指的是位比特发生了 $01$ 翻转。</p><p>&quot;Calculation:&quot;</p><ol><li><p><strong>Group Data</strong>:</p><ul><li>Divide all fields of the UDP segment (including header and data) into 16-bit blocks. If the data length is odd, pad with a zero byte. 这里要注意，不同的比特排序方式会影响到最终结果，数据通常以<strong>大端序</strong>（高位字节在前）表示。</li></ul></li><li><p><strong>Compute Sum</strong>:</p><ul><li>Perform a 1’s complement sum of all 16-bit blocks。就是二进位加法。</li><li>If overflow occurs (exceeds 16 bits), wrap the overflow back into the result.</li></ul></li><li><p><strong>Take Complement</strong>:</p><ul><li>Take the 1’s complement of the computed sum to get the final checksum。这里可以看作进行了一次<strong>同位全 $1$</strong> 加法。</li></ul></li><li><p><strong>Fill Checksum Field</strong>:</p><ul><li>Place the computed checksum into the checksum field of the UDP segment.</li></ul></li></ol><h1>Principles of Reliable Data Transfer</h1><p><strong>应用程序即使运行在 UDP 之上，也可以实现可靠数据传输</strong>。虽然 UDP 本身是无连接、无保证的协议，不提供诸如数据包重传、顺序保证、丢包检测等机制，但<strong>应用层可以自行实现这些功能</strong>，从而达到可靠传输的目的。</p><p><img src="The-Transport-Layer/Reliable-data-transfer.png" alt="Reliable data transfer: Service model and service implementation">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><h2 id="Reliable-Data-Transfer-over-a-Perfectly-Reliable-Channel-rdt-1-0">Reliable Data Transfer over a Perfectly Reliable Channel: rdt 1.0</h2><p><img src="The-Transport-Layer/rdt1.png" alt="rdt1.0 - A protocol for a completely reliable channel">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><strong>Unrealistic:</strong> underlying channel perfectly reliable</p><ul><li>no bit errors</li><li>no loss of packets</li></ul><h2 id="Reliable-Data-Transfer-over-a-Channel-with-Bit-Errors-rdt-2-0">Reliable Data Transfer over a Channel with Bit Errors: rdt 2.0</h2><p>增添检查错误机制：checksum 和 ACK。</p><p><img src="The-Transport-Layer/rdt2.png" alt="rdt 2.0 - A protocol for a channel with bit errors">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><strong>New mechanism in rdt 2.0 (beyond rdt 1.0)</strong></p><ul><li>Error detection;<ul><li><strong>Checksum</strong>.</li></ul></li><li>Receiver feedback.<ul><li><strong>ACKs and NAKs</strong>.</li></ul></li></ul><blockquote><p>rdt 2.0 有一个致命问题：如果 ACK/NAK 出错导致信息改变。</p></blockquote><h2 id="rdt-2-1">rdt 2.1</h2><p><img src="The-Transport-Layer/rdt2-1-sender.png" alt="rdt 2.1 sender">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><img src="The-Transport-Layer/rdt2-1-receiver.png" alt="rdt 2.1 receiver">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><blockquote><p>可以看到 rdt 2.1 新增了一个 sequence number。在 rdt 2.0 中提到过其有着一个致命的问题，这个问题可能会导致两个问题：重传和丢失。从 Figure P.6 和 Figure P.7 可以看到 rdt 2.1 能解决重传的问题，但是不能解决丢失的问题。</p></blockquote><h2 id="rdt-2-2">rdt 2.2</h2><p><img src="The-Transport-Layer/rdt2-2-sender.png" alt="rdt2.2 sender">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><img src="The-Transport-Layer/rdt2-2-receiver.png" alt="rdt2.2 receiver">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><blockquote><p>rdt 2.1 的机制是：如果是 NAK 或者 checksum 出错就重传。从 Figure P.8 和 Figure P.9 可以看出，receiver 收了什么序号的包就回什么序号，如果是自己要的包就 extract，然后 sender 发下个序号的包，如果重传导致 duplicate，那么只需要 delete 然后给 sender 发送 ACK。显然，receiver 回什么序号，sender 都会发下一个序号的包，也就是 rdt 2.2 没有使用 NAK 就解决了重传的问题。</p></blockquote><p>补充：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>变量/语句</th><th>作用说明</th></tr></thead><tbody><tr><td><code>oncethru == 1</code></td><td>是否第一次进入该状态</td></tr><tr><td><code>udt_send(sndpkt)</code></td><td>发送 ACK 包</td></tr><tr><td>结合使用</td><td>首次进入状态时主动重发 ACK，防止因 ACK 丢失而死锁</td></tr></tbody></table></div><h2 id="rdt-3-0">rdt 3.0</h2><p><img src="The-Transport-Layer/rdt3-0-receiver.png" alt="rdt3.0 sender">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><blockquote><p>增加了一个计时器，可以解决包丢失的问题，如果超时就重传，</p></blockquote><h2 id="Pipelined-Reliable-Data-Transfer-Protocols">Pipelined Reliable Data Transfer Protocols</h2><p><strong>rdt 3.0 stop-and-wait operation</strong>: rdt 3.0 can work, but its performance stinks.</p><blockquote><p>这里是说 rdt 3.0 的机制一轮就处理一个包而效率低下。</p></blockquote><p>For example, we suppose condition with 1 Gbps link, 15 ms propagation delay, 8000 bits packet.</p><p>$$<br>\text{d}_{trans} = \frac{L}{R} = \frac{8000 \text{bits}}{10^9 \text{bps}} = 8 \text{microseconds}<br>$$</p><p>$$<br>\text{Utilization} = \frac{\frac{L}{R}}{\text{RTT} + \frac{L}{R}} = 0.00027<br>$$</p><p>So, we use <strong>Pipelined Reliable Data Transfer Protocols</strong> to increase utilization!</p><p><strong>Pipelining:</strong> sender allows multiple, &quot;in-flight&quot;,yet-to-be-acknowledged pkts.</p><ul><li>Range of sequence numbers must be <strong>increased</strong>.</li><li><strong>Buffering</strong> at sender and/or receiver.</li></ul><h3 id="Go-Back-N-GBN-Protocol">Go-Back-N (GBN) Protocol</h3><p><img src="The-Transport-Layer/Sender's-view-of-sequence-numbers-in-Go-Back-N.png" alt="Sender's view of sequence numbers in Go-Back-N">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><strong>Timeout(n):</strong> retransmit pkt <code>n</code> and all higher seq <code>#</code> pkts in window</p><p><img src="The-Transport-Layer/GBN-sender.png.png" alt="GBN sender">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><img src="The-Transport-Layer/GBN-receiver.png.png" alt="GBN receiver">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p>需要注意的是，上述图片中是<strong>覆盖确认</strong>：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>协议类型</th><th>ACK 处理方式</th><th>base 变化方式</th></tr></thead><tbody><tr><td>累计确认（GBN）</td><td>只确认按序最大已收到的包</td><td>base 只前进不回退</td></tr><tr><td>覆盖确认（图中）</td><td>收到哪个 ACK 就直接覆盖 base</td><td>base 可能跳跃前进</td></tr></tbody></table></div><h3 id="Selective-Repeat-SR">Selective Repeat (SR)</h3><p>Sender only <strong>resends</strong> pkts for which ACK not received.</p><p><img src="The-Transport-Layer/RS-sender-receiver-view.png" alt="Selective-repeat (SR) sender and receiver views of sequence-number space">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p>$$<br>\text{window size} \leq \frac{1}{2} \text{seq}<br>$$</p><h4 id="Sender">Sender</h4><ul><li><strong>Data from above</strong>:<ul><li>If next available sequence number is within the window, send the packet.</li></ul></li><li><strong>Timeout(n)</strong>:<ul><li>Resend packet <code>n</code>, restart the timer.</li></ul></li><li><strong>ACK(n) in [sendbase, sendbase $+$ $N$]</strong>:<ul><li>Mark packet <code>n</code> as received.</li><li>If <code>n</code> is the smallest unACKed packet, <strong>advance</strong> the window base to the next unACKed sequence number.</li></ul></li></ul><h4 id="Receiver">Receiver</h4><ul><li><strong>Packet <code>n</code> in [rcvbase, rcvbase $+$ $N$ $-$ $1$]</strong>:<ul><li>Send ACK(n).</li><li><strong>Out-of-order</strong>: Buffer the packet.</li><li><strong>In-order</strong>: Deliver the packet (also deliver buffered, in-order packets), advance the window to the next not-yet-received packet.</li></ul></li><li><strong>Packet <code>n</code> in [rcvbase $-$ $N$, rcvbase $-$ $1$]</strong>:<ul><li>Send ACK(n). 解决 duplicate。</li></ul></li><li><strong>Otherwise</strong>:<ul><li>Ignore the packet.</li></ul></li></ul><h1>Connection-oriented transport: TCP</h1><h2 id="TCP-Segment-Structure">TCP Segment Structure</h2><p><img src="The-Transport-Layer/TCP-segment-structure.png" alt="TCP segment structure">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><strong>How to set sequence number and acknowledgment number?</strong></p><ul><li><strong>sequence number</strong>: represents the byte stream number of the first byte in the segment’s data.</li><li><strong>ACKs</strong>: indicates the sequence number of the next byte expected from the sender. Using cumulative acknowledgment.</li></ul><h2 id="TCP-Round-Trip-Time-and-Timeout">TCP Round Trip Time and Timeout</h2><p><strong>How to estimate $\mathbf{RTT}$?</strong></p><p>$$<br>\text{EstimateRTT} = (1 - \alpha) \cdot \text{EstimateRTT} + \alpha \cdot \text{SampleRTT}, \quad \text{Typically } \alpha = 0.125<br>$$</p><p><strong>How to set TCP timeout value?</strong></p><p>Longer than $\text{RTT}$, but $\text{RTT}$ varies.<br>$$<br>\text{DevRTT} = (1 - \beta) \cdot \text{DevRTT} + \beta \cdot |\text{SampleRTT} - \text{EstimateRTT}|, \quad \text{Typically } \beta = 0.25<br>$$</p><p>$$<br>\text{TimeOutInterval} = \text{EstimateRTT} + 4 \cdot \text{DevRTT}<br>$$</p><h2 id="TCP-Reliable-Data-Transfer">TCP Reliable Data Transfer</h2><h3 id="Fast-Retransmit">Fast  Retransmit</h3><p>If sender receives $3$ ACKs for same data, it assumes that segment after ACKed data was lost.</p><h2 id="Flow-control">Flow control</h2><p>Receiver side of TCP connection has a <strong>receive buffer</strong>.</p><p><img src="The-Transport-Layer/rwnd-buffer.png" alt="The receive window (rwnd) and the receive buffer (RcvBuffer)">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><h3 id="How-it-works">How it works?</h3><ul><li><strong>Receiver:</strong> advertises unused buffer space by including $\text{rwnd}$ value in segment header.</li><li><strong>Sender:</strong> limits unAcked bytes to $\text{rwnd}$.</li></ul><p>$$<br>\text{rwnd} = \text{RcvBuffer} - \left[\text{LastByteRcvd} - \text{LastByteRead} \right]<br>$$</p><p><strong>字节编号</strong>的问题。在TCP中：</p><ul><li>如果初始序列号为0，发送50字节后：<ul><li>这些字节的序号为：0, 1, 2, …, 49</li><li><strong>最后一个字节</strong>的序号为49，即 LastByteRcvd = 49</li><li>根据公式 $y = \text{LastByteRcvd} + 1$，得到确认号 y = 50</li></ul></li></ul><p>其中 y 是 ACK。</p><h2 id="Connection-Management">Connection Management</h2><h3 id="Three-Way-Handshake">Three Way Handshake</h3><p><strong>握手协议（Handshaking Protocol）</strong> 是指在两个通信实体（如客户端和服务器）之间建立通信连接之前，双方通过一系列消息的交换，协商通信参数、确认彼此身份、同步状态等，从而为后续的数据传输做好准备的过程。</p><ol><li><p><strong>Step 1</strong>:</p><ul><li>Client sends TCP <code>SYN</code> segment to server, specifying initial seq. No data.</li></ul></li><li><p><strong>Step 2</strong>:</p><ul><li>Server host receives <code>SYN</code>, replies with <code>SYNACK</code> segment. Server allocates buffers and specifies server initial seq.</li></ul></li><li><p><strong>Step 3</strong>:</p><ul><li>Client receives <code>SYNACK</code>, replies with ACK segment, which may contain data</li></ul></li></ol><h3 id="Closing-a-Connection">Closing a Connection</h3><ol><li><p><strong>Step 1</strong>:</p><ul><li>Client sends TCP <code>FIN</code> segment to server, specifying initial seq. No data.</li></ul></li><li><p><strong>Step 2</strong>:</p><ul><li>Server receives <code>FIN</code>, replies with ACK. Closes connection, sends <code>FIN</code>.</li></ul></li><li><p><strong>Step 3</strong>:</p><ul><li>Client receives <code>FIN</code>, replies with ACK.</li></ul></li><li><p><strong>Step 4</strong>:</p><ul><li>Server, receives ACK.  Connection closed.</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">客户端A                                      服务器B<br>   | ----------- SYN, Seq=1000 ------------&gt; |<br>   |                                         |<br>   | &lt;------ SYN+ACK, Seq=2000, Ack=1001 --- |<br>   |                                         |<br>   | ----------- ACK, Seq=1001, Ack=2001 --&gt; |<br></code></pre></td></tr></table></figure><p>上面所说的 <code>SYN</code> 和 <code>FIN</code> 都在 TCP segment 结构 header 中。</p><h1>Principles of Congestion control</h1><p>Too many sources sending too much data too fast for <strong>network (router)</strong> to handle.</p><h2 id="Approaches-towards-Congestion-Control">Approaches towards Congestion Control</h2><ul><li><strong>end-end congestion control</strong>: congestion inferred from end-system observed loss, delay.</li><li><strong>network-assisted congestion control</strong>: routers provide feedback to end systems.</li></ul><h1>TCP Congestion Control</h1><p><strong>Goal:</strong>  TCP sender should transmit as fast as possible, but without congesting network</p><p><strong>probing for bandwidth:</strong> increase transmission rate on receipt of ACK, until eventually loss occurs, then decrease transmission rate. //一种贪心策略</p><p>Sender limits rate by limiting number of unACKed bytes &quot;in pipeline&quot;:<br>$$<br>\text{LastByteSent} - \text{LastByteAcked} \leq \min {\text{cwnd}, \text{rwnd} }<br>$$</p><p>$$<br>\text{rate} \approx \frac{\text{cwnd}}{\text{RTT}}<br>$$</p><h2 id="Slow-Start-Phase">Slow Start Phase</h2><p>When connection begins, $\text{cwnd} = 1 , \text{MSS}$.</p><blockquote><p>$$ \text{MSS} = \text{MTU} - \text{IP头部大小} - \text{TCP头部大小} $$</p></blockquote><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>特性</th><th>MSS</th><th>MTU</th></tr></thead><tbody><tr><td>所属协议层</td><td>传输层 (TCP)</td><td>数据链路层</td></tr><tr><td>计量对象</td><td>TCP 数据部分</td><td>整个数据包（包括所有头部）</td></tr><tr><td>设置目的</td><td>避免 IP 分片</td><td>适应物理媒介的限制</td></tr><tr><td>典型值</td><td>1460 字节 (以太网)</td><td>1500 字节 (以太网)</td></tr><tr><td>协商方式</td><td>TCP 三次握手时协商</td><td>网络设备固定或自动发现</td></tr></tbody></table></div><p>Increase rate exponentially until first <strong>loss event</strong> or when <strong>threshold reached</strong>.</p><ul><li><strong>Double</strong> cwnd every RTT. 没有发生 loss 就以指数函数增长。</li><li>Done by incrementing cwnd by $1$ for every ACK received. 超过 $\text{ssthresh}$ 后线性增长。</li></ul><h2 id="Congestion-Avoidance">Congestion Avoidance</h2><p>When $\text{cwnd} \geq \text{ssthresh}$, increase $\text{cwnd}$ by $1$ $\text{MSS}$ per $\text{RTT}$.</p><h2 id="TCP-RENO">TCP RENO</h2><p><strong>Fast recovery</strong>: When triple duplicate ACKs occurs, $\text{ssthresh}$ sets to $\frac{\text{cwnd}}{2}$, $\text{cwnd}$ sets to $\text{ssthresh}$. 传快了，适当减小。</p><p>But when <strong>timeout</strong> occurs, $\text{ssthresh}$ sets to $\frac{\text{cwnd}}{2}$, $\text{cwnd}$ sets to $1$ $\text{MSS}$. 丢包。</p><h2 id="TCP-throughput">TCP throughput</h2><p><strong>Question:</strong> What’s the average throughput of TCP as a function of window size and RTT?</p><p><strong>Assumptions:</strong></p><ul><li>Ignoring slow start.</li><li>Let <code>W</code> be the window size when loss occurs.</li></ul><p><strong>Throughput Analysis:</strong></p><ol><li><p><strong>When window size is <code>W</code></strong>:</p><ul><li>Throughput = $\frac{W}{\text{RTT}}$.</li></ul></li><li><p><strong>Just after loss</strong>:</p><ul><li>Window size drops to $\frac{W}{2}$.</li><li>Throughput = $\frac{W}{2 \cdot \text{RTT}}$.</li></ul></li><li><p><strong>Average throughput</strong>:</p><ul><li>Average throughput = $0.75 \cdot \frac{W}{\text{RTT}}$.</li></ul></li></ol><h1>End-of-chapter exercises</h1><h2 id="R-4">R.4</h2><p><strong>Question:</strong></p><p>Describe why an application developer might choose to run an application over UDP rather than TCP.</p><p><strong>Answer:</strong></p><p>An application developer might choose to run an application over UDP rather than TCP for the following reasons:</p><ol><li><p><strong>Low Latency</strong>: UDP is a connectionless protocol, meaning it does not establish a connection before sending data. This reduces latency, making it suitable for real-time applications like video streaming, online gaming, and voice over IP (VoIP).</p></li><li><p><strong>No Overhead for Reliability</strong>: Unlike TCP, UDP does not provide reliability mechanisms such as retransmissions, acknowledgments, or congestion control. This reduces overhead and allows applications to handle reliability themselves if needed.</p></li><li><p><strong>Broadcast/Multicast Support</strong>: UDP supports broadcasting and multicasting, which is useful for applications like live video streaming or network discovery.</p></li><li><p><strong>Simple Protocol</strong>: UDP is simpler and requires fewer resources, making it ideal for lightweight applications or systems with limited processing power.</p></li><li><p><strong>Custom Error Handling</strong>: Some applications prefer to implement their own error handling and flow control mechanisms tailored to their specific needs, which is easier with UDP.</p></li><li><p><strong>Unordered Data Delivery</strong>: For applications where the order of data packets is not critical (e.g., DNS queries), UDP is a better choice as it does not enforce packet ordering.</p></li></ol><h2 id="P-4">P.4</h2><p><strong>Question:</strong><br>a. Suppose you have the following $2$ bytes: $01011100$ and $01010110$. What is the $1$s complement of the sum of these $2$ bytes?<br>b. Suppose you have the following $2$ bytes: $11011010$ and $00110110$. What is the $1$s complement of the sum of these $2$ bytes?<br>c. For the bytes in part (a), give an example where one bit is flipped in each of the $2$ bytes and yet the $1$s complement doesn’t change.</p><p><strong>Answer:</strong></p><ul><li><strong>a.</strong> $10110010$.</li><li><strong>b.</strong> $00010001$.</li><li><strong>c.</strong> $01011110$ and $01010100$.</li></ul><h2 id="P-11">P.11</h2><p><strong>Question:</strong></p><p>The sender side of $\text{rdt}3.0$ simply ignores (that is, takes no action on) all received packets that are either in error or have the wrong value in the acknum field of an acknowledgment packet. Suppose that in such circumstances, $\text{rdt}3.0$ were simply to retransmit the current data packet. Would the protocol still work? (Hint: Consider what would happen if there were only bit errors; there are no packet losses but premature timeouts can occur. Consider how many times the $n^{th}$ packet is sent, in the limit as $n$ approaches infinity.)</p><p><strong>Answer:</strong></p><p>在这种情况下，rdt $3.0$ 仍然是有效的。首先，该协议接收方可以通过检查 <strong>sequence number</strong> 来判断当前的包是否重复，这个检查方式一直有效。原本的 $\text{rdt}3.0$ 协议在超时后会重传，但现在只要检查出 <strong>acknowledgment packet</strong> 中出错就重传，这显然会增加网络负载，比如：在极端情况下，发送方可能会多次重传一个包，若 ACK 错误率为 $p$，则每个数据包平均需要发送 $1/(1-p)$ 次，直到接受到正确的 <strong>ACKs</strong>。总结：$\text{rdt}3.0$ 协议在这种情况下仍然是可靠的，但立即重传错误数据包会导致性能问题，因此这种修改并不是一个好的设计选择。</p><h2 id="P-14">P.14</h2><p><strong>Question:</strong></p><p>Consider the cross-country example shown in Figure $3.17$. How big would the window size have to be for the channel utilization to be greater than $95$ percent? Suppose that the size of a packet is $1,500$ bytes, including both header fields and data.</p><p><strong>Complement:</strong> $1$ Gbps link. RTT, is approximately $30$ milliseconds.</p><p><strong>Answer:</strong></p><p>$$<br>\text{d}_{trans} = \frac{L}{R} = \frac{1500 \times 8}{1 \times 10^9} = 1.2 \times 10^{-5} , \text{s}<br>$$</p><p>$$<br>\text{Utilization} = \frac{\text{rwnd} \times \frac{L}{R}}{\text{RTT} + \text{rwnd} \times \frac{L}{R}} \geq 0.95<br>$$</p><p>解得，$\text{rwnd} \geq 4750$。</p><h2 id="P-22">P.22</h2><p><strong>Questions and Answers:</strong></p><p>Answer true or false to the following questions and briefly justify your answer:</p><p><strong>a. With the SR protocol, it is possible for the sender to receive an ACK for a packet that falls outside of its current window.</strong></p><p><strong>True</strong>; 在 <strong>SR</strong> 协议中，由于网络延迟等原因，发送方可能收到对应于已经滑出当前窗口的数据包的 ACK。</p><p><strong>b. With GBN, it is possible for the sender to receive an ACK for a packet that falls outside of its current window.</strong></p><p><strong>False</strong>; 在 <strong>GBN</strong> 协议中，<strong>ACK</strong> 是累积的，表示所有序列号小于等于 ACK 的包已经被正确接收。</p><p><strong>c. The alternating-bit protocol is the same as the SR protocol with a sender and receiver window size of $1$.</strong></p><p><strong>True</strong>; 交替位协议是 SR 协议的一个特例，其中发送方和接收方的窗口大小均为 $1$。它只允许发送一个未确认的包，并通过序列号（$0$ 或 $1$）来区分包。</p><p><strong>d. The alternating-bit protocol is the same as the GBN protocol with a sender and receiver window size of $1$.</strong></p><p><strong>True</strong>; 交替位协议也可以看作是 GBN 协议的一个特例，其中发送方和接收方的窗口大小均为 $1$。在这种情况下，GBN 的行为与交替位协议完全一致，因为它只允许发送一个未确认的包，并在超时或收到 NAK 时重传该包。</p><h2 id="P-24">P.24</h2><p><strong>Questions and Answers:</strong></p><p>Consider transferring an enormous file of $L$ bytes from Host A to Host B. Assume an MSS of $536$ bytes.</p><p><strong>a. What is the maximum value of $L$ such that TCP sequence numbers are not exhausted? Recall that the TCP sequence number field has $4$ bytes.</strong></p><p>TCP segment structure 中 sequence number 有 $32$ bits，从 $0$ 开始。所以最大的 $L = 2^{32} - 1$。</p><p><strong>b. For the $L$ you obtain in (a), find how long it takes to transmit the file. Assume that a total of $66$ bytes of transport, network, and data-link header are added to each segment before the resulting packet is sent out over a $155$ Mbps link. Ignore flow control and congestion control so A can pump out the segments back to back and continuously.</strong></p><ul><li>MSS = $536$ bytes</li><li>每报文附加头部 = $66$ bytes</li><li>总报文尺寸 (536 + 66 = 602) bytes</li><li>报文数量<br>$$<br>N = \left\lceil \frac{L_{\max}}{\text{MSS}} \right\rceil<br>= \left\lceil \frac{2^{32}-1}{536} \right\rceil<br>= 8,012,999<br>$$</li><li>总传输位数<br>$$<br>B = N \times 602\ \text{bytes} \times 8\ \tfrac{\text{bits}}{\text{byte}}<br>= 8,012,999 \times 602 \times 8<br>\approx 3.85906\times 10^{10}\ \text{bits}<br>$$</li><li>链路速率 (R = 155\ \text{Mbps})</li><li>传输时间<br>$$<br>T = \frac{B}{R}<br>= \frac{3.85906\times 10^{10}}{155\times 10^6}<br>\approx 249\ \text{秒}<br>\approx 4.15\ \text{分钟}<br>$$</li></ul><h2 id="P-25">P.25</h2><p>Host A and B are communicating over a TCP connection, and Host B has already received from A all bytes up through byte $126$. Suppose Host A then sends two segments to Host B back-to-back. The first and second segments contain $70$ and $50$ bytes of data, respectively. In the first segment, the sequence number is $127$, the source port number is $302$, and the destination port number is $80$. Host B sends an acknowledgement whenever it receives a segment from Host A.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. In the second segment sent from Host A to B, what are the sequence number, source port number, and destination port number?</strong></p><ul><li>The sequence number is $197$, the source port number is $302$ and the dest port number is $80$.</li></ul><p><strong>b. If the first segment arrives before the second segment, in the acknowledgement of the first arriving segment, what is the acknowledgment number, the source port number, and the destination port number?</strong></p><ul><li>The acknowledgement number is $197$, the source port number is $80$ and the dest port number is $302$.</li></ul><p><strong>c. If the second segment arrives before the first segment, in the acknowledgement of the first arriving segment, what is the acknowledgment number?</strong></p><ul><li>The acknowledgement number is $127$.</li></ul><p><strong>d. Suppose the two segments sent by A arrive in order at B. The first acknowledgement is lost and the second acknowledgement arrives after the first timeout interval. Draw a timing diagram, showing these segments and all other segments and acknowledgements sent. (Assume there is no additional packet loss.) For each segment in your figure, provide the sequence number and the number of bytes of data; for each acknowledgement that you add, provide the acknowledgement number.</strong></p><ul><li>假设：</li><li>A→B 连续发送两段</li><li>B 收到每段即发 ACK</li><li>第一条 ACK(197) 丢失，第二条 ACK(247) 成功到达</li><li>超时重传未触发（因为第二条 ACK 收到后 A 已完成确认）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>Time →<br>Host A                          Host B<br>  |                                |<br>  |-- [Seq=127, Len=70] ----------&gt;|   接收 127-196，B 发送 ACK(197) → 丢失<br>  |                                |<br>  |-- [Seq=197, Len=50] ----------&gt;|   接收 197-246，B 发送 ACK(247)<br>  |                                |<br>  |      [超时等待 ACK(197)]       |<br>  |                                |<br>  |-- [Seq=127, Len=70] ----------&gt;|   重复包，B 再次发送 ACK(247)<br>  |                                |<br>  |&lt;----------- ACK(247) ----------|   A 收到确认，确认两段都已接收<br></code></pre></td></tr></table></figure><h2 id="P-31">P.31</h2><p><strong>Question and Answer:</strong></p><p>What is the relationship between the variable SendBase in Section $3.5.4$ and the variable LastByteRcvd in Section $3.5.5$?</p><p>在理想网络条件下（无丢包、延迟较小）：</p><p>$$\text{SendBase} - 1 = \text{LastByteRcvd}$$</p><p>这是因为：</p><ul><li>接收方接收到字节序号为 n 的数据后，LastByteRcvd = n</li><li>接收方发送 ACK(n+1)</li><li>发送方收到 ACK(n+1) 后，更新 SendBase = n+1</li></ul><p>由于网络延迟、丢包等因素：</p><ul><li>LastByteRcvd 可能<strong>小于</strong> SendBase-1（发送方已收到更新的确认）</li><li>LastByteRcvd 可能<strong>大于</strong> SendBase-1（某些已接收数据未被确认接收）</li></ul><h2 id="P-32">P.32</h2><p><strong>Question and Answer:</strong></p><p>What is the relationship between the variable $\text{LastByteRcvd}$ in Section $3.5.5$ and the variable $\text{y}$ in Section $3.5.4$?</p><p>由上题所述：</p><p>$$<br>\text{acknowledgement number} = \text{LastByteRcvd} + 1<br>$$</p><h2 id="P-34">P.34</h2><p>Compare GBN, SR, and TCP (no delayed ACK). Assume that the timeout values for all three protocols are sufficiently long such that $5$ consecutive data segments and their corresponding ACKs can be received (if not lost in the channel) by the receiving host (Host B) and the sending host (Host A) respectively. Suppose Host A sends $5$ data segments to Host B, and the $2^{nd}$ segment (sent from A) is lost. In the end, all $5$ data segments have been correctly received by Host B.</p><p><strong>Question and Answer:</strong></p><p><strong>a. How many segments has Host A sent in total and how many ACKs has Host B sent in total? What are their sequence numbers? Answer this question for all three protocols.</strong></p><p>题目没有指定 sequence number，这里默认从 $0$ 开始，所有 segment 大小为 $1$ byte。首先，receiver 收到多少个 segment 就会回多少个 ACK。</p><p>首先明确各协议的ACK机制：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>协议</strong></th><th><strong>确认机制</strong></th><th><strong>ACK含义</strong></th></tr></thead><tbody><tr><td>GBN</td><td>累积确认</td><td>ACK(n)表示期望收到序号n的段</td></tr><tr><td>SR</td><td>选择确认</td><td>ACK(n)表示已收到序号n的段</td></tr><tr><td>TCP</td><td>累积确认+SACK</td><td>ACK(n)表示期望收到序号n的段</td></tr></tbody></table></div><p>分析 GBN 协议，第一个 segment 的 sequence number 为 $0$，以此类推，接下来的 sequence number 分别为 $1$ $2$ $3$ $4$，相应的 ACK 为 $1$ $2$ $3$ $4$ $5$。但由于第二个包丢失，实际上的 ACK 为 $1$ 丢失 $1$ $1$ $1$， 再重发，$2$ $3$ $4$ $5$。再分析剩下两个协议，最终得到</p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr><th><strong>Protocol</strong></th><th><strong>Segments Sent</strong></th><th><strong>ACKs Received</strong></th><th><strong>Their Sequence</strong></th></tr></thead><tbody><tr><td>GBN</td><td>9</td><td>8</td><td>1 1 1 1 2 3 4 5</td></tr><tr><td>SR</td><td>6</td><td>5</td><td>0 2 3 4 1</td></tr><tr><td>TCP</td><td>6</td><td>5</td><td>1 1 1 1 5</td></tr></tbody></table></div><p><strong>b. If the timeout values for all three protocol are much longer than $5$ RTT, then which protocol successfully delivers all five data segments in shortest time interval?</strong></p><p>SR 和 TCP，因为这两种协议都只发送了 $6$ 次包。</p><h2 id="P-37">P.37</h2><p><strong>Questions and Answers:</strong></p><p><img src="The-Transport-Layer/TCP%20window%20size%20as%20a%20function%20of%20time.png" alt="TCP window size as a function of time">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p>Assuming TCP <strong>Reno</strong> is the protocol experiencing the behavior shown above, answer the following questions. In all cases, you should provide a short discussion justifying your answer.</p><p><strong>a. Identify the intervals of time when TCP slow start is operating.</strong></p><p>根据 TCP congestion control 机制，slow start phase 期间 <strong>cwnd</strong> 是以指数函数增长，从图中可以得出大概是在 $\text{Transmission round} \in [1, 6] \cup [23, 26]$ 期间。</p><p><strong>b. Identify the intervals of time when TCP congestion avoidance is operating</strong></p><p>TCP congestion avoidance 期间的特点是 <strong>cwnd</strong> 以 $ k = 1 $ MSS 的速率线性增长，从图中可以得出大概是在 $\text{Transmission round} \in [6, 16] \cup [17, 22]$ 期间。</p><p><strong>c. After the 16th transmission round, is segment loss detected by a triple duplicate ACK or by a timeout?</strong></p><p>从图中可以分析出，$\text{ssthresh} = \frac{\text{cwnd}}{2}$，$\text{cwnd} = \text{ssthresh}$，然后线性增长，所以 detected by a triple duplicate ACK。</p><p><strong>d. After the 22nd transmission round, is segment loss detected by a triple duplicate ACK or by a timeout?</strong></p><p><strong>cwnd</strong> 归一，进入 slow start phase，所以 detected by a timeout。</p><p><strong>e. What is the initial value of $\text{ssthresh}$ at the first transmission round?</strong></p><p>大概是 $32$ MSS，当 ${\text{cwnd} \geq \text{ssthresh}}$ 会进入 congestion avoidance phase，然后线性增长。</p><p><strong>f. What is the value of ssthresh at the $18^{th}$ transmission round?</strong></p><p>减半了，所以是，$\text{ssthresh} = \frac{\text{cwnd}}{2} = 21$ MSS</p><p><strong>g. What is the value of ssthresh at the $24^{th}$ transmission round?</strong></p><p>减半了，所以是，$\text{ssthresh} = \frac{\text{cwnd}}{2} = 13$ MSS</p><p><strong>h. During what transmission round is the $70^{th}$ segment sent?</strong></p><p>第一次 slow start phase 阶段后传了 63 个，所在第 $6$ 和 $7$ 轮之间。</p><p><strong>i. Assuming a packet loss is detected after the $26^{th}$ round by the receipt of a triple duplicate ACK, what will be the values of the congestion window size and of ssthresh?</strong></p><p>$\text{ssthresh} = \frac{\text{cwnd}}{2}$，$\text{cwnd} = \text{ssthresh}$，都是 $4$ segment.</p><p><strong>j. Suppose TCP Tahoe is used (instead of TCP Reno), and assume that triple duplicate ACKs are received at the $16^{th}$ round. What are the ssthresh and the congestion window size at the $19^{th}$ round?</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>特性</th><th>TCP Tahoe</th><th>TCP Reno</th></tr></thead><tbody><tr><td><strong>三次重复ACK时</strong></td><td>cwnd=1MSS, 进入慢启动</td><td>cwnd=ssthresh, 进入拥塞避免</td></tr><tr><td><strong>超时事件时</strong></td><td>cwnd=1MSS, 进入慢启动</td><td>cwnd=1MSS, 进入慢启动</td></tr><tr><td><strong>恢复速度</strong></td><td>较慢(需要重新慢启动)</td><td>较快(可能直接进入拥塞避免)</td></tr><tr><td><strong>快速恢复机制</strong></td><td>不支持</td><td>支持</td></tr></tbody></table></div><p>第 $16^{th}$ 出现了 triple duplicate ACKs，所以，第 $17^{th}$ $\text{ssthresh} = \frac{\text{cwnd}}{2} = 21$，$\text{cwnd} = 1$，然后进入 slow start 阶段，第 $19^{th}$ $\text{cwnd} = 4$</p><p><strong>k. Again suppose TCP Tahoe is used, and there is a timeout event at $22^{nd}$ round. How many packets have been sent out from $17^{th}$ round till $22^{nd}$ round, inclusive?</strong></p><p>需要注意的是，在第 $16^{th}$ 收到了三个 ACKs，同时，在第 $22^{th}$ 到达 ssthresh 所以实际收到 $1 + 2 + 4 + 8 + 16 + 21 = 52$ MSS。</p><h2 id="P-43">P.43</h2><p>Consider that only a single TCP (Reno) connection uses one $10$ Mbps link which does not buffer any data. Suppose that this link is the only congested link between the sending and receiving hosts. Assume that the TCP sender has a huge file to send to the receiver, and the receiver’s receive buffer is much larger than the congestion window. We also make the following assumptions: each TCP segment size is $1,500$ bytes; the two-way propagation delay of this connection is $100$ msec; and this TCP connection <strong>is always in congestion avoidance phase, that is, ignore slow start</strong>.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is the maximum window size (in segments) that this TCP connection can achieve?</strong></p><p>最大窗口大小由 <strong>带宽延迟积(BDP)</strong> 决定：</p><p>首先计算 RTT：</p><ul><li>传播延迟 = $100$ 毫秒</li><li>传输延迟 = 段大小/带宽 = ($1500 \times 8$) 比特/($10 \times 10^6$) 比特/秒 = $1.2$ 毫秒</li><li><strong>总RTT</strong> = $101.2$ 毫秒</li></ul><p>带宽延迟积：<br>$$<br>\text{BDP} = 10\text{ Mbps} \times 0.1012\text{ s} = 1.012 \times 10^6 \text{ bits}<br>$$</p><p>也就是 PPT 上的公式：<br>$$<br>\text{rate} \approx \frac{\text{cwnd}}{\text{RTT}}<br>$$</p><p>最大窗口大小(段数)：<br>$$<br>\text{最大窗口} = \frac{\text{BDP}}{\text{段大小}} = \frac{1.012 \times 10^6}{1500 \times 8} \approx 84.33 = \boxed{84\text{ 段}}<br>$$</p><p><strong>b. What is the average window size (in segments) and average throughput (in bps) of this TCP connection?</strong></p><p>根据TCP Reno特性，窗口大小在拥塞避免阶段会在 $\frac{W}{2}$ 和 $W$ 之间周期变化。</p><p>平均窗口大小：<br>$$<br>\text{平均窗口} = 0.75 \times W = 0.75 \times 84 = \boxed{63\text{ 段}}<br>$$</p><p>平均吞吐量：<br>$$<br>\text{平均吞吐量} = 0.75 \times \frac{W \times \text{段大小} \times 8}{\text{RTT}} = 0.75 \times \frac{84 \times 1500 \times 8}{0.1012} \approx \boxed{7.5\text{ Mbps}}<br>$$</p><p><strong>c. How long would it take for this TCP connection to reach its maximum window again after recovering from a packet loss?</strong></p><p>在TCP Reno中，丢包后窗口大小减半，然后每个RTT增加 $1$ 个MSS：</p><ul><li>初始窗口（丢包后）= $\frac{W}{2} = 42$ 段</li><li>每个RTT增加 $1$ 段</li><li>需要增加的段数 = $\frac{W}{2} = 42$ 段</li><li>所需RTT数 = $42$</li></ul><p>$$<br>\text{恢复时间} = 42 \times 0.1012 = \boxed{4.25\text{ 秒}}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Transport Layer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Application Layer</title>
    <link href="/2025/06/07/The-Application-Layer/"/>
    <url>/2025/06/07/The-Application-Layer/</url>
    
    <content type="html"><![CDATA[<h1>Principles of network applications</h1><h2 id="Application-architectures">Application architectures</h2><p><strong>Three Kinds:</strong></p><ul><li>Peer to Peer</li><li>Client-Server</li><li>hybrid of P2P and Client-Server</li></ul><h3 id="Client-Server">Client-Server</h3><p><strong>Client-Server architecture has following characteristics:</strong></p><ul><li>Server is <strong>always-on</strong> host;</li><li>Server has a <strong>permanent IP address</strong>;</li><li>Clients do not communicate with each other directly.</li></ul><blockquote><p>clients 之间通过 server 交流。</p></blockquote><h3 id="Pure-P2P">Pure P2P</h3><p>In <strong>P2P architecture</strong>, there is no always-on server, what’s more, arbitrary end systems communicate directly.</p><h3 id="Hybrid-of-Client-Server-and-P2P">Hybrid of Client-Server and P2P</h3><p>As the name suggests, this architecture is implemented with Client-Server and P2P.</p><p><strong>There are two important instance, Skype and QQ</strong></p><ul><li><strong>Skype:</strong> a voice-over-IP P2P application. If a host A wants to voice another host B, he will get B’s IP address from a server. And then they communicate with each other directly.</li><li><strong>QQ:</strong> a chat-over-IP P2P application.</li></ul><blockquote><p>clients 会给 server 提交自己的 IP address。</p></blockquote><h4 id="Client-Server-部分">Client-Server 部分</h4><ul><li>用户登录、查找好友、获取在线状态等操作都需要通过<strong>集中服务器</strong>完成。</li><li>服务器维护所有用户的索引和状态信息，起到“中介”作用。</li></ul><h4 id="P2P-部分">P2P 部分</h4><ul><li>当用户之间需要发送即时消息或文件时，<strong>实际数据传输可以直接在用户之间进行</strong>，不经过服务器。</li><li>这样可以减轻服务器压力，提高传输效率。</li></ul><h2 id="Processes-Communicating">Processes Communicating</h2><p><strong>Process</strong> is a program controlled by <strong>app developer</strong>, running within a host. Within a same host, two processes communicate with each other by <strong>inter-process communication</strong>. Between two hosts, processes communicate with each other by <strong>exchanging messages</strong>. Generally speaking, there are two kinds of processes, they are <strong>client process</strong> and <strong>server process</strong>. Client process initializes a communication, and server process waits to be contacted.</p><h2 id="Sockets">Sockets</h2><p>A <strong>door</strong> between application layer and transport layer.</p><h2 id="Addressing-Processes">Addressing Processes</h2><p>To receive message, process must have an <strong>identifier</strong>. Identifier includes both <strong>IP address</strong> and <strong>port numbers</strong> associated with process on host.</p><h2 id="App-layer-Protocol-Defines">App-layer Protocol Defines</h2><p><strong>What does an app-layer protocol define?</strong></p><ul><li>Type of message exchanged;</li><li>Message syntax: what fields in messages and how fields are delineated;</li><li>Message semantics: meaning of information in fields;</li><li>Rules for when and how a process requests and sends messages.</li></ul><blockquote><p>message 类型、语义、语法、传输时间和方式。</p></blockquote><p>Generally speaking, there are two sorts of app-layer protocols, they <strong>public-domain protocol</strong> and <strong>proprietary protocol</strong>.</p><blockquote><p>前者公开后者不公开。</p></blockquote><h2 id="What-transport-service-dose-an-application-need">What transport service dose an application need?</h2><p>We can consider four standards to select transport service.</p><ul><li>data loss</li><li>timing</li><li>throughput</li><li>security</li></ul><p>下面是常见的应用类型其需要的传输层服务：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>Application</strong></th><th><strong>Data Loss</strong></th><th><strong>Throughput</strong></th><th><strong>Time Sensitive</strong></th></tr></thead><tbody><tr><td>File transfer</td><td>No loss</td><td>Elastic</td><td>No</td></tr><tr><td>E-mail</td><td>No loss</td><td>Elastic</td><td>No</td></tr><tr><td>Web documents</td><td>No loss</td><td>Elastic</td><td>No</td></tr><tr><td>Real-time audio/video</td><td>Loss-tolerant</td><td>Audio: 5kbps-1Mbps<br>Video: 10kbps-5Mbps</td><td>Yes, 100’s msec</td></tr><tr><td>Stored audio/video</td><td>Loss-tolerant</td><td>Same as above</td><td>Yes, few secs</td></tr><tr><td>Interactive games</td><td>Loss-tolerant</td><td>Few kbps up</td><td>Yes, 100’s msec</td></tr><tr><td>Instant messaging</td><td>No loss</td><td>Elastic</td><td>Yes and no</td></tr></tbody></table></div><blockquote><p>远程医疗手术系统是 requires no data loss and is highly time-sensitive<br>实际上，在当今互联网中，语音和视频流量经常通过 <strong>TCP</strong> 发送，主要原因是<strong>防火墙和 NAT（网络地址转换）设备的兼容性和穿透性更好</strong>。许多防火墙和 NAT 设备默认只允许 TCP 流量通过，而对 UDP 流量进行限制或直接丢弃。这样做是出于安全性和管理的考虑，因为 TCP 连接有明确的建立和关闭过程，便于追踪和控制，而 UDP 是无连接的，容易被滥用。因此，为了确保语音和视频应用能够在各种网络环境下顺利传输数据，开发者往往选择基于 TCP 协议进行数据传输，即使 UDP 在实时性和低延迟方面更有优势。</p></blockquote><p>下面是常见的应用类型其需要的应用层、传输层协议：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>Application</strong></th><th><strong>Application Layer Protocol</strong></th><th><strong>Underlying Transport Protocol</strong></th></tr></thead><tbody><tr><td>E-mail</td><td>SMTP [RFC 2821]</td><td>TCP</td></tr><tr><td>Remote terminal access</td><td>Telnet [RFC 854]</td><td>TCP</td></tr><tr><td>Web</td><td>HTTP [RFC 2616]</td><td>TCP</td></tr><tr><td>File transfer</td><td>FTP [RFC 959]</td><td>TCP</td></tr><tr><td>Streaming multimedia</td><td>HTTP (e.g., YouTube), RTP [RFC 1889]</td><td>TCP or UDP</td></tr><tr><td>Internet telephony</td><td>SIP, RTP, proprietary (e.g., Skype)</td><td>Typically UDP</td></tr></tbody></table></div><h1>Web and HTTP</h1><p>Web pages consist of some <strong>objects</strong>, each object can be HTML file, Java script and so on. Each object is addressed by a URL, for example, <code>www.someschool.edu/someDept/pic.gif</code>. Among this URL, <code>www.someschool.edu</code> is host name and <code>someDept/pic.gif</code> is path name.</p><p><strong>Base HTML-file</strong> is the core of a page. It may includes several referenced objects.</p><h2 id="HTTP-Hypertext-Transfer-Protocol">HTTP: Hypertext Transfer Protocol</h2><p><strong>HTTP</strong> is Web’s application protocol with <strong>Client-Server model</strong>. Its transport layer protocol is <strong>TCP</strong>.</p><p>HTTP is <strong>stateless</strong>, this means server maintains no information of past clients requests. The reason why protocol that maintains state are complex is that if server or client crashes, their views of &quot;state&quot; may be inconsistent, must be reconciled.</p><blockquote><p>需要和后文的 cookie 区分开，cookie 并不和 stateless 的性质相违背，原因是：Cookie 只是让状态在客户端和服务器之间传递，而不是让服务器主动维护状态。</p></blockquote><h3 id="Non-Persistent-HTTP">Non-Persistent HTTP</h3><h4 id="RTT-Round-Trip-Time">RTT: Round Trip Time</h4><p><img src="The-Application-Layer/Non-Persistent-HTTP.png" alt="Non Persistent HTTP">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><strong>Definition of $\text{RTT}$:</strong> time for a small packet to travel from client to server and back.</p><p>From the picture, we can calculate total time. $\text{total time} = 2 \times \text{RTT} + \text{transmit time}_1$</p><h3 id="Persistent-HTTP">Persistent HTTP</h3><p>Persistent HTTP leaves <strong>TCP connection open</strong> after sending response. Client sends request as soon as it encounters a referenced object. As little as one RTT for all the referenced objects. $\text{total time} \approx 3 \times \text{RTT} + \text{transmit time}_1 + \text{transmit time}_2$</p><h2 id="HTTP-Message">HTTP Message</h2><p>Two types of HTTP message: <strong>request</strong> and <strong>response</strong>. <strong>Sent as ASCII text</strong></p><h3 id="Request">Request</h3><p><img src="The-Application-Layer/Request-Format.png" alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><ol><li><strong>Request Line</strong><ul><li><strong>Method:</strong> GET, POST, HEAD; PUT, DELETE;<ul><li><strong>POST:</strong> Server decides the path;</li><li><strong>PUT:</strong> Client decides the path;</li></ul></li><li><strong>URL:</strong> path;</li><li><strong>Version:</strong> HTTP version.</li></ul></li><li><strong>Header Lines</strong><ul><li><strong>Host:</strong></li><li><strong>User-Agent:</strong></li><li><strong>Connection:</strong> keep-alive or close;</li><li><strong>Accept-Language:</strong> .</li></ul></li><li><strong>Entity Body:</strong></li></ol><blockquote><p>如果是 keep-alive 则是 persistent connection；如果是 close 则是 non-persistent connection。</p></blockquote><h3 id="Response">Response</h3><p><img src="The-Application-Layer/Response-Format.png" alt="Response Format">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><strong>A few sample codes</strong></p><ul><li><code>200: OK</code></li><li><code>301: Moved Permanently</code></li><li><code>400: Bad Request</code></li><li><code>404: Not Found</code></li><li><code>505: HTTP Version Not Supported</code></li></ul><h2 id="User-Server-State-Cookies">User-Server State: Cookies</h2><p><strong>How to set cookies and use cookies?</strong><br>When a client first initialize HTTP TCP connection, server will <strong><code>set cookies</code></strong> in response message’s <strong>Header</strong> filed. After that, each request message from same client will take will <strong><code>cookies</code></strong> in request message <strong>HEADER</strong> filed.</p><p><strong>What cookies can bring:</strong></p><ul><li>authorization</li><li>shopping carts</li><li>recommendations</li><li>user session state (Web e-mail)</li></ul><p>比如：</p><ol><li>用户访问电商网站 → 服务器分配并下发 <code>user_id</code> Cookie</li><li>用户下单 → 浏览器携带 <code>user_id</code> Cookie → 服务器根据 <code>user_id</code> 更新购买记录</li><li>用户后续访问 → 服务器通过 Cookie 识别用户，展示其购买历史</li></ol><h2 id="Web-Caches">Web Caches</h2><p><strong>Goal</strong>: satisfy client request without involving origin server.</p><p><img src="The-Application-Layer/Web-Caches.png" alt="Web Caches">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><blockquote><p>typically cache is installed by ISP.</p></blockquote><p><strong>Why Web caching?</strong></p><ul><li><strong>reduce response time</strong> for client request</li><li><strong>reduce traffic</strong> on an institution’s access link.</li><li>Internet dense with caches: enables &quot;poor&quot; content providers to effectively deliver content (but so does P2P file sharing)</li></ul><h3 id="Conditional-GET">Conditional GET</h3><p><strong>Goal:</strong> don’t send object if cache has <strong>up-to-date</strong> cached version</p><p><strong>cache:</strong> specify date of cached copy in <strong>HTTP request</strong>: <code>If-modified-since: date</code><br><strong>server:</strong> <strong>response</strong> contains no object if cached copy <code>is up-to-date: HTTP/1.0 304 Not Modified</code></p><h1>FTP: the File Transfer Protocol</h1><p><strong>Goal:</strong> File transfers from/to remote host.</p><p><img src="The-Application-Layer/FTP.png" alt="FTP">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p>FTP client contacts FTP server at <strong>port 21</strong>, <strong>TCP</strong> is transport protocol. When server receives <strong>file transfer command</strong>, server opens $2^{nd}$ TCP connection for file to client. After transferring one file, server closes data connection. Server opens another TCP data connection to transfer another file.</p><p>这是一种 <strong>out-of-band</strong> 的协议。</p><ul><li><strong>带外（Out-of-band）</strong> 指的是控制信息和数据内容通过<strong>不同的通道</strong>进行传输，而不是混合在同一个通道中。</li></ul><h2 id="FTP-Commands-Responses">FTP Commands, Responses</h2><p>Sent as <strong>ASCII text</strong>, response: <strong>status code and phrase</strong>.</p><p><strong>Sample commands:</strong></p><ul><li><code>USER</code> username;</li><li><code>PASS</code> password;</li><li><code>LIST</code> return list of file in current directory;</li><li><code>RETR</code> filename retrieves (gets) file;</li><li><code>STOR</code> filename stores (puts) file onto remote host.</li></ul><p><strong>Sample return codes:</strong></p><ul><li><code>331</code> Username OK, password required;</li><li><code>125</code> data connection already open; transfer starting;</li><li><code>425</code> Can’t open data connection;</li><li><code>452</code> Error writing file.</li></ul><h1>Electronic Mail</h1><p><img src="The-Application-Layer/e-mail-system.png" alt="e mail system">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><strong>Three Major Components:</strong></p><ul><li>user agents;</li><li>mail servers;</li><li>simple mail transfer protocol: SMTP.</li></ul><p><strong>Mail Server</strong></p><ul><li><strong>mailbox</strong> contains incoming messages for user;</li><li><strong>message queue</strong> of outgoing (to be sent) mail messages</li><li>SMTP protocol <strong>between mail servers</strong> to send email messages</li></ul><h2 id="SMTP-Simple-Mail-Transfer-Protocol">SMTP: Simple Mail Transfer Protocol</h2><p><img src="The-Application-Layer/SMTP-example.png" alt="SMTP example">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><strong>Characteristics:</strong></p><ul><li>Uses <strong>TCP</strong> to reliably transfer email message from client to server, <strong>port 25</strong>;</li><li>Three phases of transfer;<ul><li><strong>Handshaking</strong> (Greeting);</li><li><strong>Transfer of Messages</strong>;</li><li><strong>Closure</strong>.</li></ul></li><li>Command/Response interaction;<ul><li>Commands: ASCII text;</li><li>Response: status code and phrase.</li></ul></li></ul><p><strong>What’s more:</strong></p><ul><li>SMTP uses <strong>persistent connections</strong>;</li><li>SMTP requires message (header &amp; body) to be in <strong>7-bit ASCII</strong>;</li><li>SMTP server uses <code>CRLF.CRLF</code> to determine end of message.</li></ul><p><strong>Comparison with HTTP</strong></p><ul><li>HTTP: pull; SMTP: push</li><li>HTTP: each object encapsulated in its own response msg; SMTP: <strong>multiple objects sent in multipart msg</strong>.</li></ul><h2 id="Mail-Message-Format">Mail Message Format</h2><p><img src="The-Application-Layer/Message-Format.png" alt="Message Format">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><h2 id="Mail-Access-Protocols">Mail Access Protocols</h2><p><img src="The-Application-Layer/Mail-Access-Protocol.png" alt="Mail Access Protocol">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><ul><li>SMTP: <strong>delivery/storage</strong> to receiver’s server;</li><li>Mail Access Protocol: <strong>retrieval</strong> from server.</li></ul><h3 id="POP3-Protocol">POP3 Protocol</h3><p><img src="The-Application-Layer/POP3.png" alt="POP3">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><strong>More about POP3:</strong> Previous example uses &quot;download and delete&quot; mode. Bob cannot re-read e-mail if he changes client;<strong>&quot;Download-and-keep&quot;:</strong> copies of messages on different clients; POP3 is stateless across sessions.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>模式</th><th>邮件服务器是否保留邮件</th><th>多终端访问体验</th><th>适用场景</th></tr></thead><tbody><tr><td>download-and-delete</td><td>否</td><td>仅首台设备可见</td><td>单一终端、节省空间</td></tr><tr><td>download-and-keep</td><td>是</td><td>多终端均可访问</td><td>多终端、备份安全</td></tr></tbody></table></div><h3 id="IMAP">IMAP</h3><ul><li>Keep all messages in one place: <strong>the server</strong>;</li><li>Allows user to <strong>organize</strong> messages in folders;</li><li>IMAP keeps user state across sessions: names of folders and mappings between message IDs and folder name.</li></ul><h1>DNS: Domain Name System</h1><p>组织的 Web 服务器和邮件服务器能否拥有相同的主机别名？对应的 RR 类型是什么？</p><p><strong>可以。</strong><br>一个组织的 Web 服务器和邮件服务器完全可以使用同一个主机别名（如 <code>foo.com</code>）。这是因为 DNS 允许为同一个域名设置不同类型的资源记录（Resource Record, RR），分别指向 Web 服务和邮件服务。</p><ul><li>当用户在浏览器中访问 <code>http://foo.com</code> 时，DNS 查询的是该域名的 <strong>A 记录</strong>（IPv4 地址）或 <strong>AAAA 记录</strong>（IPv6 地址），用于定位 Web 服务器。</li><li>当发送邮件到 <code>user@foo.com</code> 时，邮件系统会查询该域名的 <strong>MX 记录</strong>，用于定位邮件服务器。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>记录类型</th><th>作用说明</th></tr></thead><tbody><tr><td>A</td><td>域名到 IPv4 地址（Web 服务器）</td></tr><tr><td>MX</td><td>域名到邮件服务器主机名（邮件服务）</td></tr></tbody></table></div><p><strong>Hostname to IP address translation</strong></p><h2 id="Distributed-Hierarchical-Database">Distributed, Hierarchical Database</h2><p><img src="The-Application-Layer/DNS-Server.png" alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><h3 id="Top-Level-Domain-TLD-Servers">Top-Level Domain (TLD) Servers</h3><ul><li>Responsible for com, org, net, edu, etc, and all top-level country domains uk, fr, ca, jp;</li><li><strong>Network Solutions(a company)</strong> maintains servers for com TLD;</li><li><strong>Educause(an institution)</strong> for edu TLD</li></ul><h3 id="Authoritative-DNS-Servers">Authoritative DNS Servers</h3><p>Organization’s DNS servers, providing authoritative <strong>hostname to IP mappings</strong> for organization’s servers (e.g., Web, mail). Can be maintained by organization or service provider.</p><h3 id="Local-Name-Server">Local Name Server</h3><ul><li>Does not strictly belong to hierarchy;</li><li>Each <strong>ISP</strong> (residential ISP, company, university) has one;</li><li>When host makes DNS query, query is sent to its local DNS server.</li></ul><h2 id="DNS-Name-Resolution">DNS Name Resolution</h2><h3 id="Iterated-Query">Iterated Query</h3><p><img src="The-Application-Layer/Iterated-Query.png" alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p><h3 id="Recursive-Query">Recursive Query</h3><p><img src="The-Application-Layer/Recursive-Query.png" alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p><h2 id="DNS-Caching-and-Updating-Records">DNS: Caching and Updating Records</h2><ul><li>Once (any) name server learns mapping, it caches mapping;</li><li>Cache entries timeout (disappear) after some time;</li><li><strong>TLD servers</strong> typically cached in local name servers. Thus root name servers not often visited.</li></ul><h3 id="DNS-records">DNS records</h3><p>DNS: distributed db storing <strong>resource records (RR)</strong>.</p><p>RR format: <code>(name, value, type, ttl)</code>.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>Type</strong></th><th><strong>Name</strong></th><th><strong>Value</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>A</strong></td><td>Hostname</td><td>IP address</td><td>Maps hostname to IP address</td></tr><tr><td><strong>NS</strong></td><td>Domain (e.g., <code>foo.com</code>)</td><td>Hostname of authoritative name server</td><td>Specifies authoritative name server for domain</td></tr><tr><td><strong>CNAME</strong></td><td>Alias name</td><td>Canonical name</td><td>Maps alias to canonical (real) name</td></tr><tr><td><strong>MX</strong></td><td>Domain name</td><td>Mail server name</td><td>Specifies mail server associated with domain</td></tr></tbody></table></div><h2 id="DNS-Protocol-Messages">DNS Protocol, Messages</h2><p>DNS protocol : <strong>query</strong> and <strong>reply</strong> messages, both with <strong>same message format</strong>.</p><p><img src="The-Application-Layer/DNS-message-format.png" alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><strong>Identification:</strong> 16 bit <code>#</code> for query, reply to query uses same <code>#</code>.</p><p><strong>Flags:</strong></p><ul><li>query or reply;</li><li>recursion desired;</li><li>recursion available;</li><li>reply is authoritative.</li></ul><h1>P2P applications</h1><h2 id="Pure-P2P-Architecture">Pure P2P Architecture</h2><h3 id="File-Distribution-Server-Client-vs-P2P">File Distribution: Server-Client vs P2P</h3><ul><li>$u_s$: server upload bandwidth;</li><li>$u_i$: peer i upload bandwidth;</li><li>$d_i$: peer i download bandwidth;</li><li>$F$: file size.</li></ul><p><strong>Question: How much time to distribute file from one server to $N$ peers?</strong></p><p><strong>Answer with Client-Server</strong><br>$$<br>t_{cs} = \max \left {\frac{NF}{u_s}, \frac{F}{d_i} \right } \tag{1}<br>$$</p><p><strong>Answer with P2P</strong><br>$$<br>t_{p2p} = \max \left {\frac{F}{u_s}, \frac{F}{d_i}, \frac{NF}{u_s + \sum_{i} u_i} \right } \tag{2}<br>$$</p><h3 id="BitTorrent">BitTorrent</h3><p>基于 <strong>tit-for-tat</strong> （互惠）策略鼓励节点之间公平交换。每个节点会优先向那些<strong>当前向自己上传速度最快的节点</strong>上传数据块。</p><p>但是，即使 Alice 在 30 秒内持续向 Bob 上传数据块，Bob 也<strong>不一定会在同一时间段内回馈 Alice</strong>，原因如下：</p><ol><li><strong>带宽和资源限制</strong>：Bob 可能已经将上传带宽分配给了其他上传速度更快或更优先的 peer。</li><li><strong>块的可用性</strong>：Bob 可能没有 Alice 需要的数据块，无法立即回馈。</li><li><strong>策略调整延迟</strong>：BitTorrent 的“互惠”是基于一段时间内的统计结果，回馈行为可能会有延迟。</li><li><strong>乐善好施（optimistic unchoking）</strong>：每隔一段时间，客户端会随机选择一个 peer 上传数据块，以发现潜在的更优互惠对象，这也可能导致回馈不及时。</li></ol><p>上述 4. 解决了新加入节点启动问题。</p><h3 id="Skype">Skype</h3><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>用户查找与登录</td><td>通过 P2P 网络分布式存储和查找用户信息</td></tr><tr><td>媒体数据的传输</td><td>语音、视频、文件等数据优先点对点传输，必要时通过中继节点转发</td></tr></tbody></table></div><h1>Socket programming</h1><p><strong>Goal:</strong> learn how to <strong>build Client-Server application</strong> that communicate using sockets.</p><h2 id="Definition-of-Socket">Definition of Socket</h2><p><strong>An application-created, OS-controlled interface (a &quot;door&quot;) into which application process can both send and receive messages to/from another application process.</strong></p><h2 id="Socket-Programming-with-UDP">Socket Programming with UDP</h2><p><img src="The-Application-Layer/Socket-Programming-with-UDP.png" alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><h3 id="UDPClient-java">UDPClient.java</h3><p><img src="The-Application-Layer/UDPClient-java.png" alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><h2 id="Socket-programming-with-TCP">Socket programming with TCP</h2><p><img src="The-Application-Layer/Socket-Programming-with-TCP.png" alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><img src="The-Application-Layer/Three-kinds-of-Socket.png" alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><img src="The-Application-Layer/TCP-Socket.png" alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><h3 id="TCPClient-java">TCPClient.java</h3><p><img src="The-Application-Layer/TCPClient-java.png" alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><h1>End-of-chapter exercises</h1><h2 id="R-1">R.1</h2><p>List five nonproprietary Internet applications and the application-layer protocols that they use.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align:center"><strong>Type</strong></th><th style="text-align:center"><strong>Protocol(s)</strong></th></tr></thead><tbody><tr><td style="text-align:center">Email</td><td style="text-align:center">SMTP, IMAP, POP3</td></tr><tr><td style="text-align:center">Web Browser</td><td style="text-align:center">HTTP</td></tr><tr><td style="text-align:center">File Transfer</td><td style="text-align:center">FTP</td></tr><tr><td style="text-align:center">Domain Name Resolution</td><td style="text-align:center">DNS</td></tr><tr><td style="text-align:center">Remote Terminal Access</td><td style="text-align:center">SSH, Telnet</td></tr></tbody></table></div><h2 id="R-2">R.2</h2><p>What is the difference between network architecture and application architecture?（不太理解这里的 network architecture，默认和 application architecture 一样，都指的是在一个 OSI layer）</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th><strong>Aspect</strong></th><th><strong>Network Architecture</strong></th><th><strong>Application Architecture</strong></th></tr></thead><tbody><tr><td><strong>Definition</strong></td><td>Describes the organization of network layers and components for data transmission.</td><td>Describes how application components interact to achieve specific functionalities.</td></tr><tr><td><strong>Focus</strong></td><td>Focuses on data transmission methods, routing, switching, and protocol stacks.</td><td>Focuses on the logical structure and communication patterns of applications.</td></tr><tr><td><strong>Scope</strong></td><td>Concerned with the entire network, including physical, data link, and network layers.</td><td>Concerned with the application layer and its communication between processes.</td></tr><tr><td><strong>Examples</strong></td><td>Virtual circuit networks, datagram networks.</td><td>Client-server model, P2P model (e.g., Skype, HTTP).</td></tr></tbody></table></div><h2 id="R-6">R.6</h2><p>Suppose you wanted to do a transaction from a remote client to a server as fast as possible. Would you use UDP or TCP? Why?</p><ul><li>对于<strong>简单、小型且允许失败的事务</strong>（如状态查询、监控数据上报），可以选择<strong>UDP</strong></li><li>对于<strong>大多数商业事务</strong>（如金融交易、数据库操作），应选择<strong>TCP</strong>，因为：<ul><li>事务的<strong>完整性和正确性</strong>通常比速度更重要</li><li>TCP的<strong>可靠性保障</strong>减少了应用层的复杂度</li><li>虽然TCP建立连接有开销，但对于事务的整体成功率和效率更有保障</li><li>在现代网络环境中，<strong>TCP连接建立的时延</strong>相对事务处理总时间通常可以接受</li></ul></li><li>但题目要求 <strong>as fast as possible</strong>，所以还是用 <strong>UDP</strong>。</li></ul><h2 id="R-17">R.17</h2><p>Print out the header of an e-mail message you have recently received. How many <code>Received:</code> header lines are there? Analyze each of the header lines in the message.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Received: from codeforces.com (mx2.codeforces.com [77.234.215.195])<br>        by newxmmxszgpub6-1.qq.com (NewMX) with SMTP id BF70781A<br>        for &lt;1xx575xxxx@qq.com&gt;; Sat, 17 May 2025 00:47:55 +0800<br>Received: from localhost (gauss.codeforces.com [192.168.10.103])<br>        by codeforces.com (Postfix) with ESMTP id D7D9F322729C1<br>        for &lt;1xx575xxxx@qq.com&gt;; Fri, 16 May 2025 18:48:56 +0300 (MSK)<br>From: &quot;Codeforces@codeforces.com&quot; &lt;Codeforces@codeforces.com&gt;<br>To: &quot;1xx575xxxx@qq.com&quot; &lt;1xx575xxxx@qq.com&gt;<br>Subject: Codeforces Round 1025 (Div. 2)<br></code></pre></td></tr></table></figure><p>There are $2$ <code>Received:</code> header lines.</p><p>The first part is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Received: from codeforces.com (mx2.codeforces.com [77.234.215.195])<br>        by newxmmxszgpub6-1.qq.com (NewMX) with SMTP id BF70781A<br>        for &lt;1xx575xxxx@qq.com&gt;; Sat, 17 May 2025 00:47:55 +0800<br></code></pre></td></tr></table></figure><ul><li><code>Received: from codeforces.com (mx2.codeforces.com [77.234.215.195])</code>: The email was sent from the Codeforces mail server with public IP.</li><li><code>by newxmmxszgpub6-1.qq.com (NewMX)</code>: Received by QQ Mail’s mail server.</li><li>Using <strong>SMTP</strong> protocol, <code>Date\Time</code>: <code>Sat, 17 May 2025 00:47:55 +0800</code>.</li><li>其中的 <code>mx2</code> 指的是 <strong>Mail eXchanger 2</strong>，即 codeforces 的第二台邮件交换 server。</li></ul><p>The second part is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Received: from localhost (gauss.codeforces.com [192.168.10.103])<br>        by codeforces.com (Postfix) with ESMTP id D7D9F322729C1<br>        for &lt;1xx575xxxx@qq.com&gt;; Fri, 16 May 2025 18:48:56 +0300 (MSK)<br></code></pre></td></tr></table></figure><ul><li><code>Received: from localhost (gauss.codeforces.com [192.168.10.103])</code>: The email originated from the local server named <code>gauss.codeforces.com</code> (internal IP).</li><li><code>by codeforces.com (Postfix)</code>: Received by the main Codeforces mail server using Postfix.</li><li>Using <strong>ESMTP</strong> protocol.</li></ul><ol><li><p><strong>邮件头传输顺序说明</strong>：邮件头按照邮件传输的<strong>相反顺序</strong>排列（最新的记录在最上面）。因此第二个<code>Received</code>行实际上是邮件传输的<strong>起始点</strong>，第一个是<strong>最后一跳</strong>。</p></li><li><p><strong>时区分析</strong>：注意到两个头部行的时间戳不同:</p><ul><li>第一个记录: <code>Sat, 17 May 2025 00:47:55 +0800</code>(中国时区)</li><li>第二个记录: <code>Fri, 16 May 2025 18:48:56 +0300</code>(莫斯科时区MSK)<br>这说明邮件确实是从俄罗斯发往中国的，时间差符合时区差异。</li></ul></li><li><p><strong>ESMTP vs SMTP的区别</strong>：第二个头部使用ESMTP(扩展SMTP)而不是普通SMTP，这表明使用了更多高级功能(如身份验证、加密等)。</p></li></ol><h2 id="R-22">R.22</h2><p>What is an overlay network? Does it include routers? What are the edges in the overlay network? How is the query-flooding overlay network created and maintained?</p><p>An <strong>overlay network</strong> is a virtual network built on top of an existing physical network. It consists of logical connections (or &quot;edges&quot;) between nodes, which are typically end systems or hosts. These logical connections are established using the underlying physical network infrastructure.</p><ul><li><p><strong>Does it include routers?</strong><br>No, an overlay network does not include physical routers. Instead, the nodes in the overlay network are typically end systems (e.g., computers, servers) that communicate directly with each other using logical links. The physical routers are part of the underlying network and are not explicitly represented in the overlay.</p></li><li><p><strong>What are the edges in the overlay network?</strong><br>The edges in an overlay network are logical connections between nodes. These connections are established using the underlying physical network but are abstracted away from the physical topology. For example, in a peer-to-peer (P2P) network, the edges represent direct communication paths between peers.</p></li><li><p><strong>How is the query-flooding overlay network created and maintained?</strong><br>A query-flooding overlay network is created by connecting nodes in a logical topology where each node knows a subset of other nodes (its neighbors). When a query is initiated, it is broadcasted (or &quot;flooded&quot;) to all neighboring nodes, which in turn forward the query to their neighbors, and so on.<br>Maintenance of the overlay involves:</p><ol><li><strong>Node discovery:</strong> New nodes join the network by discovering existing nodes and establishing connections.</li><li><strong>Topology updates:</strong> Nodes periodically update their neighbor lists to reflect changes in the network (e.g., nodes joining or leaving).</li><li><strong>Failure handling:</strong> Mechanisms are implemented to detect and recover from node or connection failures to ensure the overlay remains functional.</li></ol></li></ul><h2 id="R-28">R.28</h2><p>For the client-server application over TCP described in Section $2.7$, why must the server program be executed before the client program? For the clientserver application over UDP described in Section $2.8$, why may the client program be executed before the server program?</p><ul><li><strong>For the TCP client-server application (Section $2.7$):</strong><br>The server program must be executed before the client because the server needs to create a socket, bind it to a port, and listen for incoming connections. If the client starts first, it will try to connect to the server’s port, but if the server isn’t running and listening yet, the connection will fail.</li><li><strong>For the UDP client-server application (Section $2.8$):</strong><br>The client program may be executed before the server because UDP is connectionless. The client can send a datagram to the server’s address and port even if the server isn’t running yet; the datagram may be lost, but the client doesn’t need to establish a connection first. When the server starts, it can immediately receive any new datagrams sent to its port.</li></ul><h2 id="P-4">P.4</h2><p>Consider the following string of ASCII characters that were captured by Wireshark when the browser sent an HTTP <code>GET</code> message (i.e., this is the actual content of an HTTP <code>GET</code> message). The characters <code>&lt;cr&gt;&lt;lf&gt;</code> are carriage return and line-feed characters (that is, the italized character string <code>&lt;cr&gt;</code> in the text below represents the single carriage-return character that was contained at that point in the HTTP header). Answer the following questions, indicating where in the HTTP GET message below you find the answer.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">GET /cs453/index.html HTTP/1.1&lt;cr&gt;&lt;lf&gt;Host: gai<br>a.cs.umass.edu&lt;cr&gt;&lt;lf&gt;User-Agent: Mozilla/5.0 (<br>Windows;U; Windows NT 5.1; en-US; rv:1.7.2) Gec<br>ko/20040804 Netscape/7.2 (ax) &lt;cr&gt;&lt;lf&gt;Accept:ex<br>t/xml, application/xml, application/xhtml+xml, text<br>/html;q=0.9, text/plain;q=0.8,image/png,*/*;q=0.5<br>&lt;cr&gt;&lt;lf&gt;Accept-Language: en-us,en;q=0.5&lt;cr&gt;&lt;lf&gt;Accept-<br>Encoding: zip,deflate&lt;cr&gt;&lt;lf&gt;Accept-Charset: ISO<br>-8859-1,utf-8;q=0.7,*;q=0.7&lt;cr&gt;&lt;lf&gt;Keep-Alive: 300&lt;cr&gt;<br>&lt;lf&gt;Connection:keep-alive&lt;cr&gt;&lt;lf&gt;&lt;cr&gt;&lt;lf&gt;<br></code></pre></td></tr></table></figure><p><strong>Questions:</strong></p><p>a. What is the URL of the document requested by the browser?<br>b. What version of HTTP is the browser running?<br>c. Does the browser request a non-persistent or a persistent connection?<br>d. What is the IP address of the host on which the browser is running?<br>e. What type of browser initiates this message? Why is the browser type needed in an HTTP request message?</p><p><strong>Answers:</strong></p><p><strong>a. What is the URL of the document requested by the browser?</strong></p><ul><li><code>http://gaia.cs.umass.edu/cs453/index.html</code>.</li></ul><p><strong>b. What version of HTTP is the browser running?</strong></p><ul><li><code>HTTP/1.1</code></li></ul><p><strong>c. Does the browser request a non-persistent or a persistent connection?</strong></p><ul><li><code>Connection:keep-alive</code>: a persistent connection.</li></ul><p><strong>d. What is the IP address of the host on which the browser is running?</strong></p><ul><li>The IP address of the host is not explicitly provided in the HTTP GET message. It would typically be determined by examining the network layer (IP) headers in the packet capture, which are not included in the provided data.</li></ul><p><strong>e. What type of browser initiates this message? Why is the browser type needed in an HTTP request message?</strong></p><ul><li>The browser type is <code>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.2) Gecko/20040804 Netscape/7.2 (ax)</code>.</li><li>The browser type is included in the <code>User-Agent</code> header. It is needed in an HTTP request message to allow the server to tailor its response based on the browser’s capabilities, such as supported features, rendering engine, or platform-specific optimizations.</li></ul><h2 id="P-5">P.5</h2><p>The text below shows the reply sent from the server in response to the HTTP <code>GET</code> message in the question above. Answer the following questions, indicating where in the message below you find the answer.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">HTTP/1.1 200 OK&lt;cr&gt;&lt;lf&gt;Date: Tue, 07 Mar 2008<br>12:39:45GMT&lt;cr&gt;&lt;lf&gt;Server: Apache/2.0.52 (Fedora)<br>&lt;cr&gt;&lt;lf&gt;Last-Modified: Sat, 10 Dec2005 18:27:46<br>GMT&lt;cr&gt;&lt;lf&gt;ETag: &quot;526c3-f22-a88a4c80&quot;&lt;cr&gt;&lt;lf&gt;Accept-<br>Ranges: bytes&lt;cr&gt;&lt;lf&gt;Content-Length: 3874&lt;cr&gt;&lt;lf&gt;<br>Keep-Alive: timeout=max=100&lt;cr&gt;&lt;lf&gt;Connection:<br>Keep-Alive&lt;cr&gt;&lt;lf&gt;Content-Type: text/html; charset=<br>ISO-8859-1&lt;cr&gt;&lt;lf&gt;&lt;cr&gt;&lt;lf&gt;&lt;!doctype html public &quot;-<br>//w3c//dtd html 4.0 transitional//en&quot;&gt;&lt;lf&gt;&lt;html&gt;&lt;lf&gt;<br>&lt;head&gt;&lt;lf&gt; &lt;meta http-equiv=&quot;Content-Type&quot;<br>content=&quot;text/html; charset=iso-8859-1&quot;&gt;&lt;lf&gt; &lt;meta<br>name=&quot;GENERATOR&quot; content=&quot;Mozilla/4.79 [en] (Windows NT<br>5.0; U) Netscape&quot;&gt;&lt;lf&gt; &lt;title&gt;CMPSCI 453 / 591 /<br>NTU-ST550A Spring 2005 homepage&lt;/title&gt;&lt;lf&gt;&lt;/head&gt;&lt;lf&gt;<br>&lt;much more document text following here (not shown)&gt;<br></code></pre></td></tr></table></figure><p><strong>Questions and Answers:</strong></p><p><strong>a. Was the server able to successfully find the document or not? What time was the document reply provided?</strong></p><ul><li><code>200 OK</code>: successfully find the document; <code>Tue, 07 Mar2008 12:39:45</code></li></ul><p><strong>b. When was the document last modified?</strong></p><ul><li><code>Last-Modified: Sat, 10 Dec2005 18:27:46</code></li></ul><p><strong>c. How many bytes are there in the document being returned?</strong></p><ul><li><code>Ranges: bytes&lt;cr&gt;&lt;lf&gt;Content-Length: 3874</code>: $3874$ bytes.</li></ul><p><strong>d. What are the first 5 bytes of the document being returned? Did the server agree to a persistent connection?</strong></p><ul><li><strong>First 5 bytes of the document:</strong> <code>&lt;!doc</code> (from the document content starting with <code>&lt;!doctype html public...</code>). 所选的 HTTP 报文内容声明了 <code>Content-Type: text/html; charset=ISO-8859-1</code>，该编码是单字节编码（每个字符 1 字节）</li><li><strong>Persistent connection:</strong> Yes, the server agreed to a persistent connection as indicated by the header <code>Connection: Keep-Alive</code>.</li></ul><h2 id="P-9">P.9</h2><p>Consider Figure $2.12$, for which there is an institutional network connected to the Internet. Suppose that the average object size is $850,000$ bits and that the average request rate from the institution’s browsers to the origin servers is $16$ requests per second. Also suppose that the amount of time it takes from when the router on the Internet side of the access link forwards an HTTP request until it receives the response is $3$ seconds on average (see $\text{Section}$ $2.2.5$). <strong>Model the total average response time as the sum of the average access delay (that is, the delay from Internet router to institution router) and the average Internet delay</strong>. For the average access delay, use $\Delta / (1 - \Delta \beta)$, where $\Delta$ is the average time required to send an object over the access link and $\beta$ is the arrival rate of objects to the access link.</p><p><strong>Complement:</strong> $15$ Mbps access link and $100$ Mbps LAN.</p><p><img src="The-Application-Layer/Bottleneck%20between%20an%20institutional%20network%20and%20the%20Internet.png" alt="Bottleneck between an institutional network and the Internet">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><strong>Questions and Answers:</strong></p><p><strong>a. Find the total average response time.</strong></p><p>The total average response time is the sum of the <strong>average access delay</strong> and the <strong>average Internet delay</strong>.</p><ol><li><p><strong>Given data:</strong></p><ul><li>Average object size: $L = 850,000$ bits</li><li>Access link rate: $R = 15$ Mbps</li><li>Request rate: $\beta = 16$ requests/second</li><li>Average Internet delay: $3$ seconds</li></ul></li><li><p><strong>Calculate $\Delta$:</strong><br>$$<br>\Delta = \frac{L}{R} = \frac{850,000}{15 \times 10^6} = 0.0567 , \text{seconds}<br>$$</p></li><li><p><strong>Calculate average access delay:</strong><br>$$<br>\text{Access delay} = \frac{\Delta}{1 - \Delta \beta} = \frac{0.0567}{1 - (0.0567 \times 16)} = \frac{0.0567}{1 - 0.9072} = \frac{0.0567}{0.0928} \approx 0.611 , \text{seconds}<br>$$</p></li><li><p><strong>Total average response time:</strong><br>$$<br>\text{Total response time} = \text{Access delay} + \text{Internet delay} = 0.611 + 3 = 3.611 , \text{seconds}<br>$$</p></li></ol><p><strong>b. Now suppose a cache is installed in the institutional LAN. Suppose the miss rate is $0.4$. Find the total response time.</strong></p><ol><li><p><strong>Given data:</strong></p><ul><li>Miss rate: $0.4$</li><li>Hit rate: $1 - 0.4 = 0.6$</li><li>Access delay (from part a): $0.611$ seconds</li><li>Internet delay: $3$ seconds</li></ul></li><li><p><strong>Calculate total response time with caching:</strong><br>$$<br>\text{Total response time} = (\text{Hit rate} \times \text{Access delay}) + (\text{Miss rate} \times (\text{Access delay} + \text{Internet delay}))<br>$$<br>Substituting values:<br>$$<br>\text{Total response time} = 0.6 \times \frac{850000}{100 \times 10^6} + 0.4 \times (0.611 + 3)<br>$$<br>$$<br>\text{Total response time} = 0.0051 + 0.4 \times 3.611 = 1.4495 , \text{s}<br>$$</p></li></ol><h2 id="P-15">P.15</h2><p><strong>Question:</strong></p><p>Read RFC $5321$ for SMTP. What does MTA stand for? Consider the following received spam email (modified from a real spam email). Assuming only the originator of this spam email is malacious and all other hosts are honest, identify the malacious host that has generated this spam email.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">From - Fri Nov 07 13:41:30 2008<br>Return-Path: &lt;tennis5@pp33head.com&gt;<br>Received: from barmail.cs.umass.edu<br>(barmail.cs.umass.edu [128.119.240.3]) by cs.umass.edu<br>(8.13.1/8.12.6) for &lt;hg@cs.umass.edu&gt;; Fri, 7 Nov 2008<br>13:27:10 -0500<br>Received: from asusus-4b96 (localhost [127.0.0.1]) by<br>barmail.cs.umass.edu (Spam Firewall) for<br>&lt;hg@cs.umass.edu&gt;; Fri, 7 Nov 2008 13:27:07 -0500<br>(EST)<br>Received: from asusus-4b96 ([58.88.21.177]) by<br>barmail.cs.umass.edu for &lt;hg@cs.umass.edu&gt;; Fri,<br>07 Nov 2008 13:27:07 -0500 (EST)<br>Received: from [58.88.21.177] by<br>inbnd55.exchangeddd.com; Sat, 8 Nov 2008 01:27:07 +0700<br>From: &quot;Jonny&quot; &lt;tennis5@pp33head.com&gt;<br>To: &lt;hg@cs.umass.edu&gt;<br>Subject: How to secure your savings<br></code></pre></td></tr></table></figure><p><strong>Answer:</strong></p><p><strong>最底部的 <code>Received:</code> 记录代表邮件的最初来源</strong>，即发件人最初连接的主机。</p><ul><li><p><strong>What does MTA stand for?</strong><br>MTA stands for <strong>Mail Transfer Agent</strong>. It is a software application used to transfer email messages from one server to another using protocols such as SMTP.</p></li><li><p><strong>Identify the malicious host:</strong><br>To identify the malicious host, we analyze the <code>Received</code> headers in reverse order (from bottom to top), as each <code>Received</code> header represents a hop in the email’s journey.</p><ol><li><p><strong><code>Received: from [58.88.21.177] by inbnd55.exchangeddd.com</code></strong></p><ul><li>This indicates that the email originated from the IP address <code>58.88.21.177</code>.</li></ul></li><li><p><strong><code>Received: from asusus-4b96 ([58.88.21.177]) by barmail.cs.umass.edu</code></strong></p><ul><li>This confirms that the email was sent from the same IP address <code>58.88.21.177</code>.</li></ul></li><li><p><strong><code>Received: from asusus-4b96 (localhost [127.0.0.1]) by barmail.cs.umass.edu</code></strong></p><ul><li>This shows that the email passed through a local host (<code>127.0.0.1</code>) on the <code>barmail.cs.umass.edu</code> server.</li></ul></li><li><p><strong><code>Received: from barmail.cs.umass.edu (barmail.cs.umass.edu [128.119.240.3]) by cs.umass.edu</code></strong></p><ul><li>This indicates that the email was forwarded by <code>barmail.cs.umass.edu</code> to <code>cs.umass.edu</code>.</li></ul></li></ol><p>Based on the analysis, the <strong>malicious host</strong> is the originator of the email, which is the IP address <strong><code>58.88.21.177</code></strong>. This is the source of the spam email.</p></li></ul><h2 id="P-18">P.18</h2><p><strong>Questions and Answers:</strong></p><p><strong>a. What is a whois database?</strong></p><p>A <strong>whois database</strong> is a publicly accessible database that contains information about the registered owners of domain names and IP address blocks. It is maintained by domain registrars and regional internet registries (RIRs). The database provides details such as:</p><ul><li>The name and contact information of the domain owner or organization.</li><li>The domain’s registration and expiration dates.</li><li>The domain’s associated name servers.</li><li>The registrar responsible for the domain.</li></ul><p>The <strong>whois database</strong> is commonly used for administrative purposes, such as verifying domain ownership, resolving technical issues, or investigating malicious activities.</p><p><strong>b. Use various whois databases on the Internet to obtain the names of two DNS servers. Indicate which whois databases you used.</strong></p><p>DNS server 的名字，通常指的是域名形式的主机名。</p><p>通过在 <a href="https://lookup.icann.org/">ICANN Lookup</a> 查询 <code>BiliBili.com</code> 得到其 Nameservers</p><ul><li><code>NS3.DNSV5.COM</code></li><li><code>NS4.DNSV5.COM</code></li></ul><p>通过在 <a href="https://whois.domaintools.com/">DomainTools</a> 查询 <code>Baidu.com</code> 得到其 Nameservers</p><ul><li><code>NS1.BAIDU.COM (has 805 domains)</code></li><li><code>NS2.BAIDU.COM (has 805 domains)</code></li><li><code>NS3.BAIDU.COM (has 805 domains)</code></li><li><code>NS4.BAIDU.COM (has 805 domains)</code></li><li><code>NS7.BAIDU.COM (has 805 domains)</code></li></ul><p><strong>c. Use nslookup on your local host to send DNS queries to three DNS servers: your local DNS server and the two DNS servers you found in part (b). Try querying for Type A, NS, and MX reports. Summarize your findings.</strong></p><p>我在终端输入的语句及其显示结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">(base) PS C:\Users\17657\Desktop\Github\HEXO&gt; nslookup<br>默认服务器:  UnKnown<br>Address:  10.3.9.5<br><br>&gt; set type=A<br>&gt; www.baidu.com<br>服务器:  UnKnown<br>Address:  10.3.9.5<br><br>非权威应答:<br>名称:    www.a.shifen.com<br>Addresses:  220.181.111.232<br>          220.181.111.1<br>Aliases:  www.baidu.com<br><br>&gt; set type=NS<br>&gt; baidu.com<br>服务器:  UnKnown<br>Address:  10.3.9.5<br><br>非权威应答:<br>baidu.com       nameserver = ns2.baidu.com<br>baidu.com       nameserver = ns7.baidu.com<br>baidu.com       nameserver = ns3.baidu.com<br>baidu.com       nameserver = dns.baidu.com<br>baidu.com       nameserver = ns4.baidu.com<br><br>ns2.baidu.com   internet address = 220.181.33.31<br>ns7.baidu.com   internet address = 180.76.76.92<br>dns.baidu.com   internet address = 110.242.68.134<br>ns3.baidu.com   internet address = 36.155.132.78<br>ns3.baidu.com   internet address = 153.3.238.93<br>ns4.baidu.com   internet address = 14.215.178.80<br>ns4.baidu.com   internet address = 111.45.3.226<br>&gt; set type=MX<br>&gt; baidu.com<br>服务器:  UnKnown<br>Address:  10.3.9.5<br><br>非权威应答:<br>baidu.com       MX preference = 20, mail exchanger = mx.baidu.com<br>baidu.com       MX preference = 10, mail exchanger = mx.maillb.baidu.com<br>&gt; server ns1.baidu.com<br>默认服务器:  ns1.baidu.com<br>Address:  110.242.68.134<br><br>&gt; set type=A<br>&gt; www.baidu.com<br>服务器:  ns1.baidu.com<br>Address:  110.242.68.134<br><br>非权威应答:<br>名称:    www.a.shifen.com<br>Addresses:  220.181.111.1<br>          220.181.111.232<br>Aliases:  www.baidu.com<br><br>&gt; set type=NS<br>&gt; baidu.com<br>服务器:  ns1.baidu.com<br>Address:  110.242.68.134<br><br>非权威应答:<br>baidu.com       nameserver = dns.baidu.com<br>baidu.com       nameserver = ns3.baidu.com<br>baidu.com       nameserver = ns4.baidu.com<br>baidu.com       nameserver = ns2.baidu.com<br>baidu.com       nameserver = ns7.baidu.com<br><br>ns7.baidu.com   internet address = 180.76.76.92<br>ns4.baidu.com   internet address = 14.215.178.80<br>ns4.baidu.com   internet address = 111.45.3.226<br>ns2.baidu.com   internet address = 220.181.33.31<br>ns3.baidu.com   internet address = 36.155.132.78<br>ns3.baidu.com   internet address = 153.3.238.93<br>dns.baidu.com   internet address = 110.242.68.134<br>&gt; set type=MX<br>&gt; baidu.com<br>服务器:  ns1.baidu.com<br>Address:  110.242.68.134<br><br>非权威应答:<br>baidu.com       MX preference = 20, mail exchanger = mx.baidu.com<br>baidu.com       MX preference = 10, mail exchanger = mx.maillb.baidu.com<br>&gt; server ns3.dnsv5.com<br>默认服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>&gt; set type=A<br>&gt; baidu.com<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    baidu.com<br>Addresses:  182.61.201.211<br>          182.61.244.181<br><br>&gt; set type=NS<br>&gt; baidu.com<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>baidu.com       nameserver = ns4.baidu.com<br>baidu.com       nameserver = ns7.baidu.com<br>baidu.com       nameserver = ns2.baidu.com<br>baidu.com       nameserver = ns3.baidu.com<br>baidu.com       nameserver = dns.baidu.com<br><br>ns7.baidu.com   internet address = 180.76.76.92<br>ns4.baidu.com   internet address = 14.215.178.80<br>ns4.baidu.com   internet address = 111.45.3.226<br>ns2.baidu.com   internet address = 220.181.33.31<br>ns3.baidu.com   internet address = 36.155.132.78<br>ns3.baidu.com   internet address = 153.3.238.93<br>dns.baidu.com   internet address = 110.242.68.134<br>&gt; set type=MX<br>&gt; baidu.com<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>baidu.com       MX preference = 10, mail exchanger = mx.maillb.baidu.com<br>baidu.com       MX preference = 20, mail exchanger = mx.baidu.com<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><code>www.baidu.com</code> 和 <code>baidu.com</code> 不是同一个东西。具体来说后者涵盖范围更广。</li><li>一个 Nameserver 能有多个 Internet address。</li><li><code>type=A</code> 模式返回的是域名的 IPv4 地址。</li><li><code>type=NS</code> 模式返回的是 Nameserver 的名字和其 internet address。</li><li><code>type=MS</code> 模式返回的是该域名的邮件服务器主机名及优先级。</li></ul><p><strong>d. Use nslookup to find a Web server that has multiple IP addresses. Does the Web server of your institution (school or company) have multiple IP addresses?</strong></p><p>查询 <code>www.bilibili.com</code> 得到结果如下，其有两个 IP address。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>&gt; set type=A <br>&gt; www.bilibili.com<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    a.w.bilicdn1.com<br>Addresses:  121.194.11.73<br>          121.194.11.72<br>Aliases:  www.bilibili.com<br><br></code></pre></td></tr></table></figure><p>貌似我们学校的 web server 只有一个 IP Address</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>&gt; ucloud.bupt.edu.cn<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    vn.bupt.edu.cn<br>Address:  10.3.19.2<br>Aliases:  ucloud.bupt.edu.cn<br><br>&gt; auth.bupt.edu.cn<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    vn.bupt.edu.cn<br>Address:  10.3.19.2<br>Aliases:  auth.bupt.edu.cn<br><br>&gt; www.bupt.edu.cn<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    vn46.bupt.edu.cn<br>Address:  10.3.19.2<br>Aliases:  www.bupt.edu.cn<br></code></pre></td></tr></table></figure><p><strong>e. Use the ARIN whois database to determine the IP address range used by your university.</strong></p><p>操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>nslookup www.bupt.edu.cn<br>服务器:  UnKnown<br>Address:  10.3.9.5<br><br>非权威应答:<br>名称:    vn46.bupt.edu.cn<br>Addresses:  2001:da8:215:4038::161<br>          10.3.19.2<br>Aliases:  www.bupt.edu.cn<br><br></code></pre></td></tr></table></figure><p>这里的 IPv4 地址是子网地址吧？我在 rain 上查询查到了一个美国机构，而且网页也提醒我了 <strong>These addresses are in use by many millions of independently operated networks, which might be as small as a single computer connected to a home gateway, and are automatically configured in hundreds of millions of devices.</strong> 所以我用的是 IPv6 的地址，这个地址能查到，显示：Net Range<br><code>2001:da8:: - 2001:da8:ffff:ffff:ffff:ffff:ffff:ffff</code>。</p><p><strong>f. Describe how an attacker can use whois databases and the nslookup tool to perform reconnaissance on an institution before launching an attack.</strong></p><p>An attacker 可以用 whois 和 nslookup 干如下的事情：</p><ul><li><strong>whois 数据库</strong>：公开的域名/IP 注册信息数据库，可查询域名所有者、联系方式、DNS 服务器、IP 地址段等信息。</li><li><strong>nslookup 工具</strong>：DNS 查询工具，可用来获取域名解析记录（如 A、NS、MX、CNAME 等），进一步了解目标机构的网络结构和服务部署。</li></ul><p>从而可以：</p><ul><li>查询目标机构的域名，获取注册人、联系方式、注册商、DNS 服务器、IP 地址段等信息。</li><li>通过 whois 查询 IP 地址，了解目标机构的公网 IP 范围、网络归属、可能的子网划分。</li><li>利用这些信息，攻击者可以锁定攻击目标、寻找潜在的弱点（如联系邮箱、技术负责人等）。</li><li>查询目标机构域名的 A 记录，获取 Web 服务器等主机的 IP 地址。</li><li>查询 NS 记录，了解目标机构使用的权威 DNS 服务器，判断是否存在 DNS 攻击面。</li><li>查询 MX 记录，获取邮件服务器信息，可能用于钓鱼邮件、垃圾邮件攻击。</li><li>查询 CNAME、TXT 等记录，发现隐藏的服务、第三方集成、邮件安全策略等。</li><li>通过对不同子域名的批量查询，发现更多内部服务和主机。</li></ul><p>进而：</p><ul><li>绘制目标机构的网络拓扑和服务分布图。</li><li>寻找潜在的攻击入口（如暴露的服务器、邮件系统、DNS 服务等）。</li><li>为后续的漏洞扫描、社工攻击、钓鱼邮件等攻击手段做准备。</li></ul><p><strong>g. Discuss why whois databases should be publicly available.</strong></p><p>whois数据库作为互联网基础设施的重要组成部分，其公开可用性具有多方面的价值与意义：</p><ol><li><p><strong>互联网透明度与问责制</strong></p><ul><li>提供域名和IP地址资源的<strong>所有权透明度</strong>，确保资源分配可追溯</li><li>建立互联网资源使用的<strong>公开记录</strong>，减少匿名滥用可能性</li><li>符合互联网作为<strong>公共资源</strong>的基本属性，保障公众知情权</li></ul></li><li><p><strong>技术协调与故障排除</strong></p><ul><li>网络管理员能迅速找到<strong>技术联系人</strong>解决网络问题</li><li>跨组织网络协作时提供必要的<strong>联络信息</strong></li><li>在安全事件、网络中断等紧急情况下提供<strong>快速响应渠道</strong></li></ul></li><li><p><strong>法律与知识产权保护</strong></p><ul><li>协助<strong>商标持有者</strong>保护其在线知识产权</li><li>为<strong>域名争议解决</strong>提供必要的所有权信息</li><li>帮助执法机构<strong>打击网络犯罪</strong>和识别不法行为</li></ul></li><li><p><strong>历史与文化因素</strong></p><ul><li>符合互联网早期建立的<strong>开放共享精神</strong></li><li>继承了学术网络环境下的<strong>信任与协作文化</strong></li><li>反映了互联网治理中的<strong>多方参与模式</strong></li></ul></li><li><p><strong>安全与风险的平衡</strong></p><ul><li>虽然公开信息存在被滥用的风险，但<strong>安全通过隐蔽</strong>不是可持续策略</li><li>现代whois服务已引入<strong>数据隐私保护机制</strong>（如代理注册服务）</li><li>信息公开带来的<strong>集体安全收益</strong>通常超过个体风险</li></ul></li></ol><p>总之，whois数据库的公开可用反映了互联网基于<strong>透明、协作和问责</strong>的核心价值观，在保护隐私和维护网络健康运行之间寻求平衡。尽管存在被攻击者利用的风险，但其对互联网正常运行、问题排除和资源管理的价值仍然超过潜在风险。</p><h2 id="P-20">P.20</h2><p><strong>Question and Answer:</strong><br>Suppose you can access the caches in the local DNS servers of your department. Can you propose a way to roughly determine the Web servers (outside your department) that are most popular among the users in your department? Explain.</p><p>To determine the most popular external Web servers among the users in my department, I would propose the following method:</p><ol><li><p><strong>Access the local DNS server’s cache:</strong></p><ul><li>The local DNS server maintains a cache of recently resolved domain names and their corresponding IP addresses.</li><li>By accessing this cache, I can retrieve a list of domain names that users in my department have recently accessed.</li></ul></li><li><p><strong>Filter out internal domain names:</strong></p><ul><li>Remove any domain names that belong to the local department or organization.</li></ul></li><li><p><strong>Count the frequency of external domain names:</strong></p><ul><li>For each external domain name in the cache, count how many times it appears.</li><li>This will give an estimate of how frequently users in the department access each external Web server.</li></ul></li><li><p><strong>Identify the most popular Web servers:</strong></p><ul><li>Sort the external domain names by their access frequency.</li><li>The domain names with the highest counts represent the most popular external Web servers among the users in the department.</li></ul></li></ol><p><strong>Explanation:</strong><br>This method works because the local DNS server’s cache reflects the browsing behavior of users in the department. By analyzing the cache, we can infer which external Web servers are most frequently accessed. However, this method has limitations, as it only provides a rough estimate and may not account for caching mechanisms in user devices or browsers.</p><h2 id="P-22">P.22</h2><p><strong>Question:</strong></p><p>Consider distributing a file of $F = 15$ Gbits to $N$ peers. The server has an upload rate of $u_s = 30$ Mbps, and each peer has a download rate of $d_i = 2$ Mbps and an upload rate of $u$. For $N = 10$, $100$, and $1,000$ and $u = 300$ Kbps, $700$ Kbps, and $2$ Mbps, prepare a chart giving the minimum distribution time for each of the combinations of $N$ and $u$ for both client-server distribution and P2P distribution.</p><p><strong>Answer:</strong></p><p>To calculate the minimum distribution time for both client-server distribution and P2P distribution, we use the following formulas:</p><ol><li><p><strong>Client-Server Distribution:</strong><br>$$<br>t_{cs} = \max \left{ \frac{N \cdot F}{u_s}, \frac{F}{d_i} \right}<br>$$</p></li><li><p><strong>P2P Distribution:</strong><br>$$<br>t_{p2p} = \max \left{ \frac{F}{u_s}, \frac{F}{d_i}, \frac{N \cdot F}{u_s + \sum_{i} u_i} \right}<br>$$</p></li></ol><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>$N$</th><th>$u , \text{Kbps}$</th><th>$t_{cs} , \text{seconds}$</th><th>$t_{p2p} , \text{seconds}$</th></tr></thead><tbody><tr><td>$10$</td><td>$300$</td><td>$\max{5000, 7500} = 7500$</td><td>$\max{500, 7500, 4545} = 7500$</td></tr><tr><td>$10$</td><td>$700$</td><td>$\max{5000, 7500} = 7500$</td><td>$\max{500, 7500, 4054} = 7500$</td></tr><tr><td>$10$</td><td>$2,000$</td><td>$\max{5000, 7500} = 7500$</td><td>$\max{500, 7500, 3000} = 7500$</td></tr><tr><td>$100$</td><td>$300$</td><td>$\max{50000, 7500} = 50000$</td><td>$\max{500, 7500, 25000} = 25000$</td></tr><tr><td>$100$</td><td>$700$</td><td>$\max{50000, 7500} = 50000$</td><td>$\max{500, 7500, 15000} = 15000$</td></tr><tr><td>$100$</td><td>$2,000$</td><td>$\max{50000, 7500} = 50000$</td><td>$\max{500, 7500, 6522} = 7500$</td></tr><tr><td>$1,000$</td><td>$300$</td><td>$\max{500000, 7500} = 500000$</td><td>$\max{500, 7500, 45455} = 45455$</td></tr><tr><td>$1,000$</td><td>$700$</td><td>$\max{500000, 7500} = 500000$</td><td>$\max{500, 7500, 20548} = 20548$</td></tr><tr><td>$1,000$</td><td>$2,000$</td><td>$\max{500000, 7500} = 500000$</td><td>$\max{500, 7500, 7389} = 7500$</td></tr></tbody></table></div><ol><li><p>当节点数量<strong>较少</strong>（N=10）时，无论使用何种上传速率，<strong>两种分发方式所需时间相同</strong>，均受限于节点的下载速率。</p></li><li><p>当节点数量<strong>增加</strong>时，客户端-服务器模式的分发时间<strong>显著上升</strong>，而P2P模式在节点上传速率足够高时<strong>效率更高</strong>。</p></li><li><p>当节点上传速率达到<strong>2 Mbps</strong>时，P2P模式的分发时间在各种节点数下都可以保持在<strong>较低水平</strong>，这显示了P2P架构在大规模分发时的优势。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Application Layer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>统计学习及监督学习概论</title>
    <link href="/2025/06/05/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/"/>
    <url>/2025/06/05/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>作为《统计学习方法》一书的开篇内容，本文旨在系统梳理统计学习领域中的基本概念与常见问题，为后续章节的深入学习奠定理论基础。</p><h2 id="模型评估与选择">模型评估与选择</h2><h3 id="训练误差与测试误差">训练误差与测试误差</h3><p>一般而言，统计学习方法具体采用的损失函数未必是评估时使用的损失函数。</p><p>假设学习到的模型是 $Y = \hat{f}(X)$，<strong>训练误差</strong>是模型 $Y = \hat{f}(X)$ 关于训练数据集的平局损失：</p><p>$$<br>R_{\text{emp}} = \frac{1}{N} \sum_{i = 1}^{N} L(y_i, \hat{f}(x_i))<br>$$</p><p>其中 $N$ 是训练样本容量。</p><p><strong>测试误差</strong>是模型 $Y = \hat{f}(X)$ 关于测试数据集的平均损失：</p><p>$$<br>e_{\text{emp}} = \frac{1}{N’} \sum_{i = 1}^{N’} L(y_i, \hat{f}(x_i))<br>$$</p><p>其中 $N’$ 是测试样本容量。</p><p>上面所述中的函数 $L$ 是损失函数。</p><p>常见的 $L$ 有指示函数 $I$，当满足函数内容是取 $1$。当损失函数是指示函数时，此时测试误差又叫做<strong>测试误差率</strong>：</p><p>$$<br>e_{\text{test}} = \frac{1}{N’} \sum_{i = 1}^{N’} I(y_i \neq \hat{f}(x_i))<br>$$</p><h3 id="过拟合">过拟合</h3><p>过拟合是统计学习和机器学习领域中常见且重要的问题之一。它指的是模型在训练数据上表现良好，能够取得较低的训练误差，但在未见过的测试数据或新样本上表现较差，导致<strong>泛化能力下降</strong>的现象。过拟合通常发生在模型复杂度过高、参数数量远大于训练样本数量，或训练过程中对训练数据<strong>记忆</strong>过多而忽略了数据的内在规律时。</p><p>造成过拟合的主要原因包括：模型容量过大、训练数据不足、特征冗余或噪声较多等。为缓解过拟合，常用的方法有：增加训练数据量、选择更简单的模型、采用正则化技术（如L1或L2正则化）、剪枝、交叉验证等。合理地控制模型复杂度和提升数据质量，是提升模型泛化能力、避免过拟合的关键。</p><h3 id="正则化与交叉验证">正则化与交叉验证</h3><h4 id="正则化">正则化</h4><p>正则化是<strong>结构风险最小化策略</strong>的实现，是在<strong>经验风险</strong>上加一个正则化项，一般具有下述形式：</p><p>$$<br>\min_{f \in \mathcal{F}} \quad \frac{1}{N} \sum_{i = 1}^{N}L(y_i, \hat{f}(x_i)) + \lambda J(f)<br>$$</p><h4 id="交叉验证">交叉验证</h4><p>如果样本数据不足，此时可以应用交叉验证。</p><h2 id="泛化能力">泛化能力</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Data Link Layer</title>
    <link href="/2025/06/04/The-Data-Link-Layer/"/>
    <url>/2025/06/04/The-Data-Link-Layer/</url>
    
    <content type="html"><![CDATA[<h1>交换机网络通信原理解析</h1><h2 id="交换机接口MAC地址的实际用途">交换机接口MAC地址的实际用途</h2><p>交换机每个接口虽有MAC地址，但<strong>并非用于普通数据转发</strong>，而主要用于：</p><ul><li><strong>管理访问</strong>（Telnet/SSH/Web界面登录）</li><li><strong>协议通信</strong>（STP生成树协议、LLDP等）</li><li><strong>故障诊断和监控</strong></li></ul><h2 id="数据帧如何通过交换机转发">数据帧如何通过交换机转发</h2><p>关键误解在于认为数据帧的目标MAC需要是交换机的MAC。实际上：</p><ol><li><p><strong>正常帧转发过程</strong>：</p><ul><li>主机A发送数据到F时，帧中<strong>目标MAC是路由器的MAC</strong>（不是交换机）</li><li>交换机收到帧后<strong>不检查&quot;这是否发给我&quot;</strong></li><li>交换机仅通过<strong>MAC地址表查询</strong>决定从哪个端口转发出去</li></ul></li><li><p><strong>交换机的核心工作原理</strong>：</p><ul><li>交换机维护一个<strong>MAC地址表</strong>，记录&quot;哪个MAC地址在哪个端口&quot;</li><li>收到帧后，查表找到目标MAC对应端口</li><li>从对应端口转发，<strong>不修改帧内容</strong></li></ul></li><li><p><strong>同网段和跨网段通信区别</strong>：</p><ul><li><strong>同网段</strong>：源MAC→主机A，目标MAC→主机B</li><li><strong>跨网段</strong>：源MAC→主机A，目标MAC→<strong>路由器</strong>接口</li></ul></li></ol><h2 id="结论">结论</h2><p>交换机处理所有收到的有效帧，<strong>不会因为目标MAC不是自己而丢弃</strong>。这与路由器不同，路由器只处理目标MAC是自己接口MAC的帧。</p><p><strong>正是因为交换机不修改MAC地址并且不以自身MAC为转发判断依据</strong>，才使得以太网能够高效透明地工作。</p><h1>Introduction and Service</h1><h2 id="Some-terminology">Some terminology</h2><p>我们规定：</p><ul><li><strong>Nodes</strong>: hosts and routers;</li><li><strong>Links</strong>: communication <strong>channels</strong> that connect adjacent nodes along communication path;<ul><li>wired links</li><li>wireless links</li><li>LANs</li></ul></li><li>layer-2 packet is a <strong>frame</strong>, encapsulates datagram.</li></ul><blockquote><p>这里就是在说 data link layer 的数据包叫做 frame。</p></blockquote><h2 id="Link-layer-context">Link layer: context</h2><p>Datagram transferred by different link protocols over different links, each  link protocol provides different services.</p><blockquote><p>不同的 link 用不同的 protocol。</p></blockquote><h2 id="Link-Layer-Services">Link Layer Services</h2><ul><li><strong>framing, link access</strong><ul><li>encapsulate datagram into frame, adding header, trailer.</li><li>channel access if shared medium.</li><li><strong>MAC</strong> addresses used in frame headers to identify source, dest.</li></ul></li><li><strong>reliable delivery between adjacent nodes</strong><ul><li>seldom used on low bit-error link (fiber, some twisted pair).</li></ul></li><li><strong>flow control</strong><ul><li>pacing between adjacent sending and receiving nodes.</li></ul></li><li><strong>error detection</strong><ul><li>errors caused by signal <strong>attenuation, noise</strong>.</li><li>receiver detects presence of errors: signals sender for retransmission or drops frame.</li></ul></li><li><strong>error correction</strong><ul><li>receiver identifies and <strong>corrects</strong> bit error(s) without resorting to retransmission.</li></ul></li><li><strong>half-duplex and full-duplex</strong>（半双工和全双工）<ul><li>with half duplex, nodes at both ends of link can transmit, but not at same time.</li></ul></li></ul><h2 id="Where-is-the-link-layer-implemented">Where is the link layer implemented?</h2><ul><li>The <strong>link layer is implemented in every host</strong>.</li><li>It is realized through an <strong>adaptor</strong>, also known as a <strong>Network Interface Card (NIC)</strong>.<ul><li>Examples include: <strong>Ethernet cards</strong>, <strong>PCMCIA cards</strong>, and <strong>802.11 wireless cards</strong>.</li></ul></li><li>The adaptor is responsible for implementing both the <strong>link layer</strong> and the <strong>physical layer</strong>.</li><li>It connects to the host via the <strong>system buses</strong>.</li><li>The adaptor is a <strong>combination of hardware, software, and firmware</strong>.</li></ul><p>In essence, the NIC handles the lower layers of network communication and serves as the interface between the host and the physical network.</p><p><img src="The-Data-Link-Layer/Network%20adapter.png" alt="Network adapter">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p><h2 id="Adaptors-Communicating">Adaptors Communicating</h2><p><img src="The-Data-Link-Layer/AdaptorsCommunicating.png" alt="Adaptors Communicating}">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p><h3 id="Sending-Side">Sending Side</h3><ul><li><strong>Encapsulates the network-layer datagram into a link-layer frame</strong>.</li><li><strong>Adds</strong>:<ul><li><strong>Error checking bits</strong> (e.g., CRC).</li><li><strong>Reliable data transfer (rdt)</strong> mechanisms (if needed).</li><li><strong>Flow control</strong> to manage data rate between sender and receiver.</li></ul></li></ul><h3 id="Receiving-Side">Receiving Side</h3><ul><li><strong>Checks</strong> the frame for:<ul><li><strong>Errors</strong> using error detection codes.</li><li><strong>Reliable data transfer</strong> mechanisms.</li><li><strong>Flow control</strong> compliance.</li></ul></li><li><strong>Extracts</strong> the datagram from the frame.</li></ul><h1>Error Detection and Correction</h1><p><img src="The-Data-Link-Layer/Error-detectionAnd-correctionScenario.png" alt="Error detection And correction Scenario">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p><ul><li><p><strong>EDC (Error Detection and Correction bits)</strong>:</p><ul><li>Extra <strong>redundant bits</strong> added to data to detect and possibly correct errors during transmission.</li></ul></li><li><p><strong>D (Data)</strong>:</p><ul><li>The actual data being protected by error checking.</li><li>May include <strong>header fields</strong> along with the payload.</li></ul></li></ul><blockquote><p>也就是整个 IP datagram。</p></blockquote><ul><li><strong>Important Notes</strong>:<ul><li><strong>Error detection is not 100% reliable</strong>.<ul><li>Some errors may go undetected, though this is <strong>rare</strong>.</li></ul></li><li>A <strong>larger EDC field</strong> generally provides:<ul><li><strong>Better error detection</strong> capability.</li></ul></li></ul></li></ul><h2 id="Parity-Checks">Parity Checks</h2><ul><li><strong>Even Parity Scheme:</strong> the total number of $1$s in the $ d + 1 $ bits is even.</li><li><strong>Odd Parity Scheme:</strong> the total number of $1$s in the $ d + 1 $ bits is odd.</li></ul><blockquote><p>偶校验和奇校验。</p></blockquote><p>If an odd number of $1$-valued bits are found with an even parity schemes, the receiver knows that at least one bit error has occurred.</p><h3 id="Two-dimensional-Parity">Two-dimensional Parity</h3><p>The receiver can thus not only <strong>detect</strong> the fact that a single bit error has occurred, but can use the column and row indices of the column and row with parity errors to actually identify the bit that was corrupted<br>and <strong>correct</strong> that error!</p><p><img src="The-Data-Link-Layer/Two-dimensional-even-parity.png" alt="Two dimensional even parity">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p><h2 id="Cyclic-Redundancy-Check-CRC">Cyclic Redundancy Check (CRC)</h2><p>An error-detection technique used widely in today’s computer networks is based on <strong>cyclic redundancy check (CRC) codes</strong>. CRC codes are also known as <strong>polynomial codes</strong>, since it is possible to view the bit string to be sent as a polynomial whose coefficients are the $0$ and $1$ values in the bit string, with operations on the bit string interpreted as polynomial arithmetic.</p><ul><li><strong>数据表示</strong>：将要发送的 $d$ 位数据 $D$ 看作一个二进制多项式。</li><li><strong>生成多项式 $G$</strong>：发送方和接收方事先约定一个 $r + 1$ 位的生成多项式 $G$。</li><li><strong>附加冗余位 $R$</strong>：发送方为 $D$ 选择 $r$ 位冗余位 $R$，并将其附加到 $D$ 后面，形成 $d + r$ 位的发送数据，使得整个 $d + r$ 位数据能被 $G$ 整除（模 2 运算下）。</li></ul><h3 id="How-the-Sender-Computes-R">How the Sender Computes $R$?</h3><p>简单地来讲：</p><ul><li>发送方将 $D$ 左移 $r$ 位（即在 $D$ 后面补 $r$ 个 0），得到 $D \cdot 2^r$。</li><li>用 $D \cdot 2^r$ 除以 $G$，得到余数 $R$。</li><li>将 $R$ 附加到 $D$ 后面，形成最终发送的数据。</li></ul><p><strong>公式表示：</strong><br>$$<br>R = \operatorname{remainder} \frac{D \cdot 2^r}{G}<br>$$</p><p><img src="The-Data-Link-Layer/CRCSample.png" alt="CRC Sample">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p><p>需要注意，$1 - 0 = 1$，$0 - 1 = 1$，$1 - 1 =0$，$0 - 0 = 0$，没有借位，最后的结果，比如：$11$，但是 $r = 3$，则在左侧高位补充 $0$，也就是 $R = 011$。</p><h1>Multiple Access Links and Protocols</h1><h2 id="Two-Types-of-Links">Two Types of Links</h2><h3 id="Point-to-Point-Links"><strong>Point-to-Point Links</strong></h3><ul><li><strong>定义</strong>：点对点链路是指仅有两个设备直接相连的通信链路。</li><li><strong>典型例子</strong>：<ul><li>拨号上网时使用的 PPP（Point-to-Point Protocol）协议。</li><li>以太网交换机与主机之间的连接。</li></ul></li><li><strong>特点</strong>：<ul><li>通信双方唯一，链路专用。</li><li>通常无需考虑信道竞争或冲突问题。</li><li>实现简单，性能稳定。</li></ul></li></ul><h3 id="Broadcast-Links"><strong>Broadcast Links</strong></h3><ul><li><strong>定义</strong>：广播链路是指多个设备共享同一个物理通信介质的链路，所有设备都能&quot;听到&quot;同一信道上的数据。</li><li><strong>典型例子</strong>：<ul><li>早期以太网（同轴电缆共享）。</li><li>HFC（Hybrid Fiber-Coaxial）上行链路。</li><li>802.11 WiFi（无线局域网）。</li></ul></li><li><strong>特点</strong>：<ul><li>多个节点共享信道，可能发生冲突。</li><li>需要多路访问协议（如CSMA/CD、ALOHA等）协调各节点的发送时机。</li><li>支持广播和组播通信。</li></ul></li></ul><h2 id="Multiple-Access-Protocol">Multiple Access Protocol</h2><ul><li>A <strong>single shared broadcast channel</strong> is used by multiple nodes.<ul><li>If two or more nodes transmit at the same time, their signals interfere, causing a <strong>collision</strong>.</li></ul></li><li>A <strong>multiple access protocol</strong> is needed to coordinate transmissions.<ul><li>This protocol is a distributed algorithm that determines when each node can transmit.</li><li>All coordination and communication about channel sharing must occur over the same channel—there is <strong>no separate control channel</strong>.</li></ul></li></ul><blockquote><p>多个结点共用一条 channel 进行传输，这条 channel 同一时间只能供一个结点传输。应用 multiple access protocol 来协调。</p></blockquote><ul><li><strong>链路（link）</strong> 更强调<strong>连接关系</strong>，即两个节点之间的直接连接。如上文介绍的两种 <strong>links</strong>。</li><li><strong>信道（channel）</strong> 更强调<strong>传输资源</strong>，即数据传输所依赖的物理或逻辑媒介。</li><li>在点对点链路中，link 和 channel 通常是一一对应的。</li><li>在广播链路中，多个 link（设备间的连接）共享同一个 channel（信道）。</li></ul><h3 id="Ideal-Multiple-Access-Protocol">Ideal Multiple Access Protocol</h3><ul><li>The broadcast channel has a total rate of <strong>$R$ bps</strong>.</li><li>If only one node transmits, it can use the full rate <strong>$R$</strong>.</li><li>If <strong>$M$</strong> nodes transmit simultaneously, each gets an average rate of <strong>$R/M$</strong>.</li><li>The system is <strong>fully decentralized</strong>:<ul><li>No central coordinator.</li><li>No clock or slot synchronization required.</li></ul></li><li>The approach is simple and efficient for sharing the channel.</li></ul><h2 id="MAC-Protocols-a-taxonomy">MAC Protocols: a taxonomy</h2><h3 id="Three-Broad-Classes-of-MAC-Protocols">Three Broad Classes of MAC Protocols</h3><ol><li><p><strong>Channel Partitioning</strong></p><ul><li>The channel is divided into smaller pieces (such as time slots, frequency bands, or codes).</li><li>Each node is allocated a piece for exclusive use.</li></ul></li><li><p><strong>Random Access</strong></p><ul><li>The channel is not divided; all nodes can transmit at any time.</li><li>Collisions may occur, but protocols are designed to <strong>detect and recover</strong> from collisions.</li></ul></li><li><p><strong>Taking Turns</strong></p><ul><li>Nodes take turns using the channel.</li><li>Nodes with more data to send can take longer turns.</li></ul></li></ol><h2 id="Channel-Partitioning-Protocols">Channel Partitioning Protocols</h2><p><strong>TDMA</strong>: Time Division Multiple Access<br><strong>FDMA</strong>: Frequency Division Multiple Access<br><strong>CDMA</strong>: Code Division Multiple Access</p><h3 id="TDMA">TDMA</h3><ul><li><strong>Mechanism:</strong><ul><li>Divides time into frames, and each frame into $N$ time slots (for $N$ nodes).</li><li>Each node is assigned a specific time slot in each frame.</li><li>When a node has data to send, it transmits only during its assigned slot.</li></ul></li><li><strong>Example:</strong><ul><li>In a four-node TDMA system, each node gets one slot per frame, and the slots repeat in a fixed order.</li></ul></li><li><strong>Advantages:</strong><ul><li>No collisions; perfectly fair (each node gets $R/N$ bps).</li></ul></li><li><strong>Drawbacks:</strong><ul><li>Each node is limited to $R/N$ bps even if others are idle.</li><li>Nodes must wait for their turn, even if they are the only one with data to send.</li></ul></li></ul><blockquote><p>只能用自己的。</p></blockquote><h3 id="FDMA">FDMA</h3><ul><li><strong>Mechanism:</strong><ul><li>Divides the total channel bandwidth ($R$ bps) into $N$ frequency bands, each with bandwidth $R/N$.</li><li>Each node is assigned a <strong>unique frequency band</strong> for exclusive use.</li></ul></li><li><strong>Example:</strong><ul><li>In a four-node FDM system, each node gets a $4$ KHz band out of a total $16$ KHz channel.</li></ul></li><li><strong>Advantages:</strong><ul><li>No collisions; fair bandwidth allocation.</li></ul></li><li><strong>Drawbacks:</strong><ul><li>Each node is limited to R/N bps, even if others are idle (same as TDMA).</li></ul></li></ul><p><img src="The-Data-Link-Layer/TDA-and-FDA-example.png" alt="TDA and FDA example">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p><h3 id="CDMA">CDMA</h3><ul><li><strong>Mechanism:</strong><ul><li>Each node is assigned a unique code.</li><li>Nodes encode their data using their code and transmit simultaneously over the same channel.</li><li>Receivers use the sender’s code to decode the intended message, even in the presence of other transmissions.</li></ul></li><li><strong>Features:</strong><ul><li>Allows multiple nodes to transmit at the same time without collisions, as long as codes are chosen carefully.</li><li>Widely used in wireless and cellular networks due to its anti-jamming properties.</li></ul></li><li><strong>Note:</strong><ul><li>CDMA codes serve a similar role as time slots in TDMA and frequency bands in FDMA, enabling multiple access to the channel.</li></ul></li></ul><blockquote><p>每个节点分配一个唯一的编码，所有节点可同时发送，接收端用对应的码提取目标信号。详细过程参考第六章。</p></blockquote><h2 id="Random-Access-Protocols">Random Access Protocols</h2><ul><li>When a node has a packet to send, it transmits at the full channel data rate $\mathbf{R}$.</li><li>There is <strong>no prior coordination</strong> among nodes before transmission.（也就是说这个结点传输前不会考虑其它因素）</li><li>If two or more nodes transmit at the same time, a <strong>collision</strong> occurs.</li><li>A <strong>random access MAC protocol</strong> defines:（干了两件事）<ul><li><strong>How to detect collisions</strong>.</li><li><strong>How to recover from collisions (e.g., by delaying and retransmitting)</strong>.（后传和重传）</li><li><strong>Examples:</strong><ul><li>Slotted ALOHA</li><li>ALOHA</li><li>CSMA, CSMA/CD, CSMA/CA</li></ul></li></ul></li></ul><h3 id="Slotted-ALOHA">Slotted ALOHA</h3><p><strong>Assumptions:</strong></p><ul><li>All frames are the same size.</li><li>Time is divided into equal-sized slots (each slot = time to transmit one frame).</li><li>Nodes can only begin transmission at the start of a slot.</li><li>All nodes are synchronized.</li><li>If two or more nodes transmit in the same slot, a collision occurs and is detected by all.</li></ul><p><strong>Operation:</strong></p><ul><li>When a node has a new frame, it transmits in the next available slot.</li><li>If there is no collision, the node can send a new frame in the next slot.</li><li>If a collision occurs, the node retransmits the frame in each subsequent slot with probability $p$ until successful.</li></ul><p><strong>Pros of Slotted ALOHA:</strong></p><ul><li>A single active node can continuously transmit at the full channel rate.</li><li>Highly decentralized; only slot synchronization among nodes is needed.</li><li>Simple to implement.</li></ul><p><strong>Cons of Slotted ALOHA:</strong></p><ul><li>Collisions can occur, wasting slots.</li><li>Idle slots may occur, reducing efficiency.</li><li><strong>Nodes may detect collisions before a full packet is transmitted</strong>.</li><li><strong>Requires clock synchronization among all nodes</strong>.</li></ul><blockquote><p>前提假设不太现实，要求所有的 frame 大小相同，这样才能确保将时间分为等长的时隙有用。</p></blockquote><p><strong>同步(synchronize)</strong> 指的是：</p><ul><li>所有网络节点<strong>共享一个统一的时钟参考</strong></li><li>每个节点能够<strong>准确识别时隙的开始和结束时刻</strong></li><li>通常通过<strong>集中式时钟信号</strong>或<strong>同步协议</strong>实现</li></ul><p><strong>Slotted Aloha efficiency</strong></p><ul><li><strong>Efficiency</strong> is defined as the long-run fraction of slots that contain a successful transmission (i.e., exactly one node transmits).</li><li>Suppose there are $N$ nodes, each always has frames to send, and each transmits in a slot with probability $p$.</li><li>The probability that a given node has a successful transmission in a slot:<br>$$p(1-p)^{N-1}$$</li><li>The probability that any node has a successful transmission in a slot:<br>$$Np(1-p)^{N-1}$$</li><li><strong>Maximum efficiency</strong> is achieved by choosing $p^*$ that maximizes $Np(1-p)^{N-1}$.</li><li>As $N$ becomes very large, the maximum efficiency approaches:<br>$$\boxed{1/e \approx 0.37}$$</li><li><strong>Interpretation:</strong><br>At best, the channel is used for successful transmissions only 37% of the time.</li></ul><blockquote><p>当前时隙有结点传输的概率。</p></blockquote><h1>TDMA与Slotted ALOHA对比分析</h1><p><strong>TDMA和Slotted ALOHA并不矛盾，它们是两种不同设计理念的多址接入协议</strong>，尽管都使用了时间分片的概念。</p><h2 id="关键区别">关键区别</h2><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>特性</th><th>TDMA</th><th>Slotted ALOHA</th></tr></thead><tbody><tr><td><strong>时隙分配</strong></td><td><strong>预先固定分配</strong>给特定节点</td><td><strong>动态竞争</strong>，任何节点可使用任何时隙</td></tr><tr><td><strong>传输决策</strong></td><td>只能在<strong>自己的专属时隙</strong>中传输</td><td>可以在<strong>任何时隙</strong>开始传输</td></tr><tr><td><strong>冲突可能性</strong></td><td><strong>无冲突</strong>（每个时隙专属一个节点）</td><td><strong>有冲突</strong>（多节点可能同时选择一个时隙）</td></tr><tr><td><strong>资源使用</strong></td><td>节点不传输时其时隙<strong>浪费</strong></td><td>任何节点都可以利用空闲时隙</td></tr><tr><td><strong>控制方式</strong></td><td><strong>集中式</strong>或预先协调</td><td><strong>分散式</strong>（各节点独立决策）</td></tr><tr><td><strong>最大效率</strong></td><td>理论上100%（无冲突）</td><td>理论上约37%（1/e）</td></tr></tbody></table></div><h2 id="本质区别">本质区别</h2><ul><li><p><strong>TDMA</strong>：<strong>预分配固定时隙</strong>的&quot;预约&quot;系统</p><ul><li>类似于餐厅固定座位：每人只能坐自己的座位</li><li>优点：无冲突，确定性高</li><li>缺点：资源可能浪费，缺乏灵活性</li></ul></li><li><p><strong>Slotted ALOHA</strong>：<strong>随机竞争时隙</strong>的&quot;抢座&quot;系统</p><ul><li>类似于餐厅先到先得：谁想坐就尝试坐，有冲突就重试</li><li>优点：简单实现，适应突发流量</li><li>缺点：存在冲突，效率有限</li></ul></li></ul><p>这两种协议代表了多址接入的两种不同设计思路：<strong>静态分配</strong>与<strong>动态竞争</strong>，各有优缺点，适用于不同应用场景。</p><h3 id="Pure-unslotted-ALOHA">Pure (unslotted) ALOHA</h3><p><img src="The-Data-Link-Layer/pure-ALOHA-sample.png" alt="pure ALOHA sample">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p><ul><li>Simpler than slotted ALOHA; <strong>no synchronization</strong> required.</li><li>When a frame arrives, the node <strong>transmits immediately</strong>.</li><li><strong>Higher collision probability</strong>:<ul><li>A frame sent at time $t_0$ will collide with any other frame sent in the interval $[t_0-1, t_0+1]$.</li></ul></li></ul><p><strong>Pure (Unslotted) ALOHA Efficiency:</strong></p><ul><li>Probability of success for a given node:<ul><li>$P(\text{success}) = P(\text{node transmits}) \times P(\text{no other node transmits in } [t_0-1, t_0]) \times P(\text{no other node transmits in } [t_0, t_0+1])$</li><li>$= p \cdot (1-p)^{N-1} \cdot (1-p)^{N-1}$</li><li>$= p \cdot (1-p)^{2(N-1)}$</li></ul></li><li><strong>Maximum efficiency</strong> (choosing optimal $p$ and letting $N \to \infty$):<ul><li>$\boxed{1/(2e) \approx 0.18}$</li></ul></li><li><strong>Interpretation:</strong><br>At best, the channel is used for successful transmissions only 18% of the time in pure ALOHA.</li></ul><blockquote><p>$t_0, , t_0 - 1, , t_0 + 1$ 三个时隙。</p></blockquote><h3 id="Carrier-Sense-Multiple-Access-CSMA">Carrier Sense Multiple Access (CSMA)</h3><p>发送前先侦听，发送时检测碰撞，以太网核心技术</p><p><strong>Carrier Sensing</strong>: a node listens to the channel before transmitting. <strong>If a frame from another node is currently being transmitted into the channel</strong>, a node then waits until it detects no transmissions for a short amount of time and then begins transmission.</p><p>In networks using CSMA (like <strong>traditional Ethernet or wireless</strong>), all nodes communicate over a single shared physical channel. Many network interfaces operating under CSMA protocols are designed for half-duplex communication, meaning they can either transmit OR receive at any given moment, but not both simultaneously. This is why a node can not transmit while receiving.</p><blockquote><p>半双工机制。</p></blockquote><h3 id="CSMA-with-collision-detection-CSMA-CD">CSMA with collision detection (CSMA/CD)</h3><p><strong>Collision Detection</strong>: a transmitting node listens to the channel while it is transmitting. If it detects that another node is transmitting an interfering frame, it stops transmitting and waits <strong>a random amount</strong> of time before repeating the sense-and-transmit-when-idle cycle.</p><blockquote><p>自己正在传的时候检测到有其他结点开始传了，停止自己的传输，随机等待一段时间后重试。</p></blockquote><h2 id="Taking-Turns-Protocols">Taking-Turns Protocols</h2><h3 id="Polling-Protocol">Polling Protocol</h3><p><strong>Polling Protocol（轮询协议）<strong>是一种</strong>轮流访问</strong>型的多路访问协议，常用于多个节点共享同一信道的场景。其核心思想是：</p><ul><li>网络中指定一个节点为<strong>主节点（master node）</strong>。</li><li>主节点按照固定顺序依次<strong>轮询</strong>每个从节点，询问它们是否有数据要发送。</li><li>只有被轮询到的节点才被允许发送数据。</li></ul><p>这个协议有着如下缺陷：</p><ol><li><strong>轮询延迟</strong>：每个节点都要等主节点轮询到自己才能发送数据，可能会有等待延迟，尤其是节点数量多时。</li><li><strong>主节点单点故障</strong>：如果主节点出现故障，整个信道就无法正常工作，所有通信都会中断。</li></ol><p><em><strong>Bluetooth protocol</strong></em></p><h3 id="Token-Passing-Protocol">Token-Passing Protocol</h3><p>A small, special-purpose frame known as a <strong>token</strong> is exchanged among the nodes in some fixed order.</p><blockquote><p>When a node receives a token, it holds onto the token only if it has some frames to transmit; otherwise, it immediately forwards the token to the next node. If a node does have frames to transmit when it receives the token, it sends up to a maximum number of frames and then forwards the token to the next node.</p></blockquote><p>But it has its problems as well. For example, the failure of one node can crash the entire channel. Or if a node accidentally neglects to release the token, then some recovery procedure must be invoked to get the token back in circulation.</p><p>将一个特制的 <strong>frame</strong> 视作一个 <strong>token</strong>，这个 token 会在结点中以一个固定的顺序传输，收到 token 的结点可以选择发送自己的 frames 或者立即传给下一个结点。缺陷：时延和崩坏。</p><p><em><strong>fiber distributed data interface (FDDI) protocol</strong></em></p><h1>Link-Layer Addressing and ARP</h1><h2 id="Addressing-in-Computer-Networks">Addressing in Computer Networks</h2><p>先回顾一下之前学过的 address。</p><h3 id="IP-Address-32-bit">IP Address (32-bit)</h3><ul><li><strong>Layer</strong>: Network layer address</li><li><strong>Primary function</strong>: Used to route datagrams to their destination IP subnet</li><li><strong>Scope</strong>: Global addressing for internet-wide routing</li></ul><h3 id="MAC-Address-48-bit">MAC Address (48-bit)</h3><ul><li><strong>Layer</strong>: Data link layer (physical addressing)</li><li><strong>Primary function</strong>: Used to transfer frames between directly connected interfaces on the same physical network</li><li><strong>Implementation</strong>: Permanently burned into NIC ROM hardware, though sometimes software-configurable</li><li><strong>Scope</strong>: Local addressing limited to a single network segment</li></ul><p>The fundamental distinction is that IP addresses enable routing across multiple networks, while MAC addresses handle the physical delivery between devices on the same network segment.</p><ul><li><strong>IP 地址</strong>：用于在不同网络之间进行路由，确保数据能够跨越多个网络到达最终目标。</li><li><strong>MAC 地址</strong>：用于在同一个网络段（如同一个局域网）内实现设备之间的物理交付。</li><li><strong>IP 地址</strong>负<strong>找路</strong>，确定数据应该到哪个网络。</li><li><strong>MAC 地址</strong>负责<strong>最后一公里</strong>，在本地网络中找到具体的设备。</li><li>路由器转发数据时，每经过一跳，都会用新的 MAC 地址封装数据帧，但 IP 地址保持不变。</li></ul><p>假设主机 A 要给主机 B 发送数据：</p><ol><li><strong>跨网传输</strong>：数据包通过多个路由器，依靠 IP 地址进行路由选择。</li><li><strong>到达目标网络</strong>：最后一跳，数据包到达 B 所在的局域网。</li><li><strong>本地交付</strong>：A 通过 ARP 协议获取 B 的 MAC 地址，将数据帧封装后，通过以太网物理传输到 B。</li></ol><h2 id="MAC-Addresses-and-ARP">MAC Addresses and ARP</h2><p><img src="The-Data-Link-Layer/MACAddress.png" alt="MAC Address">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p><p>Broadcast address = <code>FF-FF-FF-FF-FF-FF</code></p><h3 id="MAC-Address-Administration">MAC Address Administration</h3><ul><li><p><strong>分配权威（Allocation Authority）</strong><br>MAC 地址空间由 <strong>IEEE（电气和电子工程师协会）</strong> 统一管理和分配，确保全球唯一性。</p></li><li><p><strong>分配流程（Assignment Process）</strong><br>各网络设备制造商需要向 IEEE 购买一批 MAC 地址块。这样，每个厂商生产的设备都能分配到唯一的 MAC 地址，避免地址冲突。</p></li><li><p><strong>结构（Structure）</strong><br>MAC 地址总长 48 位，<strong>前 24 位</strong>通常用来标识制造商（称为 OUI，Organizationally Unique Identifier，组织唯一标识符），后 24 位由厂商自行分配给各自的设备。</p></li></ul><h3 id="Conceptual-Comparison">Conceptual Comparison</h3><ul><li><p><strong>MAC Address</strong>: Similar to a Social Security Number</p><ul><li>Permanent identifier tied to hardware</li><li>Remains with the device regardless of location</li></ul></li><li><p><strong>IP Address</strong>: Similar to a postal address</p><ul><li>Indicates location in the network topology</li><li>Changes when moving between networks</li></ul></li></ul><h3 id="Address-Structure-Implications">Address Structure Implications</h3><ul><li><p><strong>MAC Address (Flat)</strong>:</p><ul><li>Provides portability</li><li>LAN card maintains its address when moved between networks</li><li>No inherent network location information</li></ul></li><li><p><strong>IP Address (Hierarchical)</strong>:</p><ul><li>Not portable across networks</li><li>Contains network prefix that identifies subnet</li><li>Must change when moving to a different subnet</li><li>Enables efficient routing across internet</li></ul></li></ul><p>This fundamental difference in addressing philosophy reflects the different purposes of each address type: MAC for unique hardware identification, IP for routable network location.</p><h2 id="Address-Resolution-Protocol-ARP">Address Resolution Protocol (ARP)</h2><p>The Address Resolution Protocol (ARP) is used to discover the MAC address associated with a known IP address on the same local network:</p><ol><li><p><strong>Check Local ARP Table First</strong></p><ul><li>Every IP-enabled device maintains an ARP table</li><li>The table contains mappings of IP addresses to MAC addresses</li><li>Each entry format: <code>&lt;IP address; MAC address; TTL&gt;</code></li><li>TTL (Time To Live): Typically 20 minutes before entry expires</li></ul></li><li><p><strong>If MAC Address Not in Table:</strong></p><ul><li>Device broadcasts an ARP request to all devices on LAN</li><li>Uses broadcast MAC address: FF-FF-FF-FF-FF-FF</li><li>The request asks: &quot;Who has IP address B? Send your MAC address&quot;</li></ul></li><li><p><strong>Resolution Process:</strong></p><ul><li>Only the device with IP address B responds</li><li>Device B sends its MAC address directly to requester</li><li>Requester adds the IP-to-MAC mapping to its ARP table</li><li>Communication can now proceed using the discovered MAC address</li></ul></li><li><p><strong>When Entry Expires:</strong></p><ul><li>After TTL expires, the mapping is removed from ARP table</li><li>A new ARP request must be sent if communication is needed again</li></ul></li></ol><p>ARP is essential because link-layer delivery requires MAC addresses, while applications and higher protocols use IP addresses.</p><h2 id="ARP-Protocol-Same-LAN-Network">ARP Protocol: Same LAN (Network)</h2><p>When host A wants to send a datagram to host B on the same local network but doesn’t have B’s MAC address:</p><h3 id="ARP-Request-Process">ARP Request Process</h3><ul><li>Host A broadcasts an ARP query packet containing B’s IP address</li><li>Destination MAC address = <code>FF-FF-FF-FF-FF-FF</code> (broadcast address)</li><li>All machines on the LAN receive the ARP query</li><li>Only host B (with the matching IP address) processes and responds</li></ul><h3 id="ARP-Response">ARP Response</h3><ul><li>Host B replies to A with its (B’s) MAC address</li><li>Frame is sent directly to A’s MAC address (unicast)</li><li>A adds the IP-to-MAC mapping to its ARP table</li></ul><h3 id="Caching-Mechanism">Caching Mechanism</h3><ul><li>A caches (saves) the IP-to-MAC address pair in its ARP table</li><li>Mapping remains until the information becomes old (times out)</li><li>This is &quot;soft state&quot;: information expires unless refreshed through use</li></ul><h3 id="Key-Characteristics">Key Characteristics</h3><ul><li><strong>Self-configuring</strong>: ARP is &quot;plug-and-play&quot;</li><li><strong>Distributed</strong>: Nodes create their ARP tables without intervention from network administrators</li><li><strong>Automatic</strong>: Mappings are created and maintained dynamically as needed</li></ul><blockquote><p>自己也会创建置换表</p></blockquote><h2 id="Addressing-routing-to-another-LAN">Addressing: routing to another LAN</h2><p><img src="The-Data-Link-Layer/619.png" alt="routing to another LAN">{style=&quot;display: block; margin: 0 auto; width: 100%&quot;}</p><h2 id="Routing-Between-Different-LANs-Link-Layer-Process">Routing Between Different LANs: Link-Layer Process</h2><p>When data travels between hosts on different networks, the router plays a critical intermediary role:</p><h3 id="Initial-Transmission-Source-Network">Initial Transmission (Source Network)</h3><ol><li><p>Host A creates an IP datagram with:</p><ul><li>Source IP address: Host A’s address</li><li>Destination IP address: Host B’s address (on different LAN)</li></ul></li><li><p>Host A determines B is on another network, so packet must go through router R:</p><ul><li>A uses ARP to resolve router interface IP (111.111.111.110) to R’s MAC address</li><li>A creates an Ethernet frame with:<ul><li>Destination: R’s MAC address</li><li>Source: A’s MAC address</li><li>Payload: The A-to-B IP datagram</li></ul></li></ul></li><li><p>A’s network interface card transmits this frame onto the LAN</p></li></ol><blockquote><p>从此可以看出，LAN 内部是通过以太网传输数据的，用的是 MAC address。</p></blockquote><h3 id="Router-Processing">Router Processing</h3><ol start="4"><li><p>Router R’s interface receives the frame (recognizes its MAC address)</p></li><li><p>R extracts the IP datagram from the frame, examines the IP header:</p><ul><li>Sees destination IP is for host B on another network</li><li>Consults routing table to determine next hop</li></ul></li><li><p>R prepares to forward to the destination network:</p><ul><li>Uses ARP to resolve B’s IP address to B’s MAC address</li><li>Creates a new Ethernet frame with:<ul><li>Destination: B’s MAC address</li><li>Source: R’s MAC address (interface on B’s network)</li><li>Payload: The original A-to-B IP datagram (unchanged)</li></ul></li></ul></li></ol><blockquote><p>R 在不同网络段代表不同的路由器接口。</p></blockquote><h3 id="Final-Delivery-Destination-Network">Final Delivery (Destination Network)</h3><ol start="7"><li><p>Router’s interface on B’s network transmits the new frame</p></li><li><p>Host B receives the frame, extracts and processes the IP datagram</p></li></ol><p>Note: The IP datagram remains unchanged throughout this process, while the frame addressing changes at each network segment.</p><h1>Ethernet</h1><h2 id="The-Dominant-Wired-LAN-Technology">The Dominant Wired LAN Technology</h2><ul><li><strong>Cost-effective</strong>: Extremely affordable - approximately $20 for a Network Interface Card</li><li><strong>Pioneer technology</strong>: First widely used LAN technology, establishing the foundation for modern networks</li><li><strong>Simplicity and economy</strong>: Significantly simpler and more economical than token LANs and ATM alternatives</li><li><strong>Scalable performance</strong>: Successfully kept pace with speed requirements over decades:<ul><li>Started at 10 Mbps</li><li>Evolved through 100 Mbps and 1 Gbps</li><li>Now supports up to 10 Gbps and beyond</li></ul></li></ul><p>Ethernet’s combination of low cost, simplicity, and adaptability to increasing performance demands has secured its position as the predominant wired networking technology in local area networks worldwide.</p><h2 id="Ethernet-Physical-Topologies">Ethernet Physical Topologies</h2><h3 id="Historical-Evolution">Historical Evolution</h3><ul><li><strong>Bus topology</strong>: Popular through mid-1990s<ul><li>All nodes connected to a common shared cable</li><li><strong>Single collision domain</strong>: All nodes could interfere with each other’s transmissions</li><li>When one node transmitted, all others had to wait</li><li>Limited scalability due to increasing collision probability with more nodes</li></ul></li></ul><blockquote><p>前面提到过</p></blockquote><h3 id="Modern-Configuration">Modern Configuration</h3><ul><li><strong>Star topology</strong>: Dominant configuration today<ul><li><strong>Central active switch</strong>: Intelligent device at center of network</li><li>Point-to-point links between switch and end devices</li><li><strong>Separate collision domains</strong>: Each link operates as an independent Ethernet segment</li><li>Nodes connected to different switch ports cannot directly collide with each other</li><li>Dramatically improved performance and reliability compared to bus topology</li></ul></li></ul><p>The shift from bus to star topology represents a fundamental advance in Ethernet technology, effectively eliminating the collision problems that limited earlier implementations.</p><h2 id="Ethernet-frame-structure">Ethernet frame structure</h2><p><img src="The-Data-Link-Layer/620.png" alt="Ethernet frame structure">{style=&quot;display: block; margin: 0 auto; width: 100%&quot;}</p><ul><li><p><strong>Preamble</strong>:</p><ul><li>7 bytes with pattern 10101010 followed by one byte with pattern 10101011</li><li>Used to synchronize receiver and sender clock rates</li><li>Allows receivers to &quot;lock onto&quot; the sender’s transmission timing</li></ul></li><li><p><strong>Addresses</strong>: 6 bytes each</p><ul><li>Destination MAC address (first)</li><li>Source MAC address (second)</li><li>Processing logic:<ul><li>If adapter receives frame with matching destination address or broadcast address (FF-FF-FF-FF-FF-FF), it passes data to network layer</li><li>Otherwise, adapter <strong>discards the frame</strong></li><li>Broadcast frames (e.g., ARP packets) are processed by all recipients</li></ul></li></ul></li><li><p><strong>Type</strong>: 2 bytes</p><ul><li>Indicates the higher layer protocol encapsulated in the frame payload</li><li>Common values:<ul><li>0x0800: IPv4</li><li>0x0806: ARP</li><li>0x86DD: IPv6</li><li>Other protocols: Novell IPX, AppleTalk, etc.</li></ul></li></ul></li><li><p><strong>CRC</strong>: 4 bytes (32 bits)</p><ul><li>Cyclic Redundancy Check for error detection</li><li>Checked at receiver</li><li>If error is detected, frame is <strong>immediately dropped</strong></li><li>No error correction or retransmission at Ethernet level</li></ul></li><li><p>**Preamble（前导码）**是以太网帧结构中的一个字段。</p></li><li><p>由<strong>7 个字节的 10101010 模式</strong>，后跟<strong>1 个字节的 10101011</strong> 组成。</p></li><li><p><strong>时钟同步</strong>：用于同步接收端和发送端的时钟速率。</p></li><li><p><strong>锁定信号</strong>：让接收方能够<strong>锁定</strong>到发送方的传输时序，确保后续数据能被准确采样和解析。</p></li></ul><h2 id="Ethernet-Key-Characteristics">Ethernet: Key Characteristics</h2><h3 id="Connectionless-Protocol">Connectionless Protocol</h3><ul><li><strong>No handshaking</strong> between transmitting and receiving Network Interface Cards (NICs)</li><li>Each frame is sent independently without establishing a connection first</li><li>Sender simply transmits frames when the medium is available</li><li>No session establishment or termination phases</li></ul><h3 id="Unreliable-Service">Unreliable Service</h3><ul><li><strong>No acknowledgments (ACKs)</strong> or negative acknowledgments (NACKs) sent by receiving NICs</li><li>Sending NIC has no built-in way to know if frames were successfully delivered</li><li>Corrupted frames are simply discarded by the receiver (detected via CRC)</li><li>No automatic retransmission mechanism at the Ethernet level</li></ul><h3 id="Implications-for-Data-Delivery">Implications for Data Delivery</h3><ul><li>Stream of datagrams passed to the network layer may contain <strong>gaps</strong> (missing datagrams)</li><li>If the application uses TCP (Transport layer):<ul><li>Gaps will be detected and filled through TCP’s reliable delivery mechanisms</li><li>End users won’t see missing data</li></ul></li><li>If using UDP or other unreliable protocols:<ul><li>Application will see the gaps and must handle them if needed</li><li>Responsibility for reliability shifts to the application layer</li></ul></li></ul><h3 id="Medium-Access-Control">Medium Access Control</h3><ul><li>Ethernet’s MAC protocol: <strong>unslotted CSMA/CD</strong> (Carrier Sense Multiple Access with Collision Detection)</li><li>Provides a way to share the communication medium among multiple devices</li><li>Modern switched Ethernet largely eliminates collisions, but the protocol foundation remains</li></ul><h2 id="CSMA-CD-Algorithm-in-Ethernet">CSMA/CD Algorithm in Ethernet</h2><p>Ethernet’s original medium access control protocol uses CSMA/CD (Carrier Sense Multiple Access with Collision Detection) to handle shared medium access:</p><h3 id="Step-by-Step-Process">Step-by-Step Process</h3><ol><li><p><strong>Frame Creation</strong></p><ul><li>NIC receives datagram from network layer</li><li>Creates an Ethernet frame with appropriate headers</li></ul></li><li><p><strong>Channel Sensing</strong></p><ul><li>If NIC senses channel is <strong>idle</strong>: begins frame transmission immediately</li><li>If NIC senses channel is <strong>busy</strong>: waits until channel becomes idle, then transmits</li></ul></li><li><p><strong>Successful Transmission</strong></p><ul><li>If NIC transmits the entire frame without detecting another transmission</li><li>Transmission is complete and successful</li></ul></li><li><p><strong>Collision Handling</strong></p><ul><li>If NIC detects another transmission while transmitting</li><li>Immediately aborts transmission</li><li><strong>Sends a brief jam signal to ensure all stations recognize the collision</strong></li></ul></li><li><p><strong>Exponential Backoff</strong></p><ul><li>After aborting, NIC enters exponential backoff procedure:</li><li>After the mᵗʰ collision, NIC chooses K randomly from {0,1,2,…,2ᵐ-1}</li><li>NIC waits <strong>K·512 bit times</strong> before attempting retransmission</li><li>Returns to Step 2 to attempt transmission again</li></ul></li></ol><p>The exponential backoff mechanism ensures that after repeated collisions, stations spread their retransmission attempts over increasingly longer intervals, reducing the probability of repeated collisions.</p><h2 id="Ethernet’s-CSMA-CD-Technical-Details">Ethernet’s CSMA/CD: Technical Details</h2><h3 id="Collision-Handling-Components">Collision Handling Components</h3><ul><li><p><strong>Jam Signal</strong>:</p><ul><li>48-bit signal transmitted after detecting a collision</li><li>Purpose: Ensures all transmitting stations are aware of the collision</li><li>Small, fixed size makes collision detection efficient</li><li>Contains a deliberate pattern that cannot be mistaken for valid data</li></ul></li><li><p><strong>Bit Time</strong>:</p><ul><li>The time required to transmit one bit on the network</li><li><strong>For $10$ Mbps Ethernet: $0.1$ microseconds per bit</strong></li><li>Used as the basic time unit for backoff calculations</li><li>For <strong>$K = 1023$ (maximum backoff value)</strong>, wait time is approximately $50$ milliseconds</li></ul></li></ul><h3 id="Exponential-Backoff-Algorithm">Exponential Backoff Algorithm</h3><ul><li><p><strong>Goal</strong>: Adaptively adjust retransmission timing based on estimated network load</p><ul><li>Under heavy load conditions, stations wait longer before retrying</li><li>Helps prevent collision cascades when multiple stations are competing for access</li></ul></li><li><p><strong>Progressive Backoff Process</strong>:</p><ul><li>After first collision: Choose K randomly from ${0,1}$<ul><li>Wait time = $K × 512$ bit transmission times</li></ul></li><li>After second collision: Choose K randomly from ${0,1,2,3}$</li><li>After third collision: Choose K randomly from ${0,1,2,3,4,5,6,7}$</li><li>Pattern continues: After nth collision, range is ${0,1,2,…,2^n-1}$</li><li>After tenth collision: Choose K randomly from ${0,1,2,…,1023}$</li><li><strong>Maximum range is capped at ${0,1,2,…,1023}$ even after more collisions</strong></li></ul></li></ul><p>This adaptive algorithm ensures efficient channel utilization by dynamically adjusting to network congestion levels, minimizing repeated collisions while maintaining reasonable access times.</p><h2 id="CSMA-CD-efficiency">CSMA/CD efficiency</h2><ul><li>$t_{prop}$: max prop delay between $2$ nodes in LAN;</li><li>$t_{trans}$: time to transmit max-size frame.</li></ul><p>$$<br>\text{efficiency} = \frac{1}{1 + \frac{5 t_{prop}}{t_{trans}}}<br>$$</p><h2 id="Ethernet-Standards-Link-Physical-Layers">Ethernet Standards: Link &amp; Physical Layers</h2><p><img src="The-Data-Link-Layer/621.png" alt="alt text">{style=&quot;display: block; margin: 0 auto; width: 100%&quot;}</p><ul><li><p><strong>Common Foundation</strong>:</p><ul><li>All Ethernet variants share the same <strong>MAC protocol</strong> principles</li><li><strong>Frame format</strong> remains consistent across implementations</li><li>Upper layers interact with Ethernet through the same interface regardless of physical medium</li></ul></li><li><p><strong>Speed Evolution</strong>:</p><ul><li><strong>2 Mbps</strong>: Early experimental implementations</li><li><strong>10 Mbps</strong>: Original Ethernet standard (10BASE-T)</li><li><strong>100 Mbps</strong>: Fast Ethernet (100BASE-TX, 100BASE-FX)</li><li><strong>1 Gbps</strong>: Gigabit Ethernet (1000BASE-T, 1000BASE-SX/LX)</li><li><strong>10 Gbps</strong>: 10 Gigabit Ethernet (10GBASE-T, 10GBASE-SR/LR)</li><li><strong>Higher speeds</strong>: 40 Gbps, 100 Gbps, 400 Gbps technologies now available</li></ul></li><li><p><strong>Physical Media Diversity</strong>:</p><ul><li><strong>Copper cable</strong>:<ul><li>Twisted pair (Cat5e, Cat6, Cat6a, Cat7)</li><li>Coaxial cable (older implementations)</li></ul></li><li><strong>Optical fiber</strong>:<ul><li>Multimode fiber (shorter distances)</li><li>Single-mode fiber (longer distances)</li><li>Various wavelengths and transmission techniques</li></ul></li></ul></li></ul><p>This standardized approach allows equipment from different manufacturers to interoperate while enabling continuous performance improvements through new physical layer technologies.</p><h1>Link-Layer Switches</h1><h2 id="Hubs">Hubs</h2><p>physical-layer (dumb) repeaters:</p><ul><li>bits coming in one link go out all other links at same rate</li><li>all nodes connected to hub can collide with one another</li><li>no frame buffering</li><li>no CSMA/CD at hub: host NICs detect collisions</li></ul><p><img src="The-Data-Link-Layer/hub.png" alt="hub">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p><h2 id="Switch">Switch</h2><ul><li><p><strong>Link-layer intelligence</strong>:</p><ul><li>Smarter than hubs, taking an active role in network traffic management</li><li>Process frames at the data link layer (Layer 2) rather than merely repeating signals</li><li>Make forwarding decisions based on MAC addresses</li></ul></li><li><p><strong>Store-and-forward operation</strong>:</p><ul><li>Receive complete frames before forwarding</li><li>Buffer frames in memory, allowing for collision domain isolation</li><li>Check frames for errors (using CRC) before forwarding, improving network reliability</li></ul></li><li><p><strong>Selective forwarding</strong>:</p><ul><li>Examine incoming frame’s destination MAC address</li><li>Forward frame only to the specific port where destination device is connected</li><li>Send to multiple ports only when necessary (broadcasts, unknown destinations)</li><li>When forwarding frames onto a segment, uses CSMA/CD to access the medium</li></ul></li><li><p><strong>Transparent operation</strong>:</p><ul><li>Hosts are completely unaware of switches’ presence in the network</li><li>End devices communicate as if directly connected</li><li>No modification of frame content during transit through switch</li></ul></li><li><p><strong>Plug-and-play functionality</strong>:</p><ul><li>Self-learning capability builds forwarding tables automatically</li><li>Observes source MAC addresses of incoming frames to learn device locations</li><li>Dynamically updates tables when devices move to different ports</li><li>No manual configuration required for basic operation</li></ul></li></ul><p>These capabilities allow switches to significantly improve network performance by creating separate collision domains for each port while maintaining the same Ethernet protocol standards.</p><h3 id="Switch-Advanced-Link-Layer-Functionality">Switch: Advanced Link-Layer Functionality</h3><ul><li><p><strong>Simultaneous transmissions</strong>:</p><ul><li>Allows multiple pairs of nodes to transmit concurrently</li><li>Different ports can carry independent data streams at the same time</li><li>Dramatically increases total network throughput compared to hubs</li></ul></li><li><p><strong>Dedicated connections</strong>:</p><ul><li>Each host has a dedicated, direct connection to the switch</li><li>Full bandwidth of the link is available to each host-switch connection</li><li>No competition for bandwidth between devices on different ports</li></ul></li><li><p><strong>Frame buffering</strong>:</p><ul><li>Switches contain memory to store frames temporarily</li><li>Can hold frames when output ports are busy</li><li>Prevents frame loss during periods of network congestion</li><li>Enables handling of traffic between different speed interfaces</li></ul></li><li><p><strong>Collision elimination</strong>:</p><ul><li>Ethernet protocol used on each link but without collisions</li><li>Full-duplex operation: simultaneous transmission and reception</li><li>Each link is its own separate collision domain</li><li>CSMA/CD no longer needed on point-to-point links to switch</li></ul></li><li><p><strong>Parallel communications</strong>:</p><ul><li>Host A can transmit to host A’ while host B simultaneously transmits to host B’</li><li>No interference between unrelated data flows</li><li>Example: In a network with hosts A, A’, B, and B’ all connected to a switch:<ul><li>A→A’ and B→B’ transmissions occur in parallel</li><li>Network throughput effectively multiplied by number of concurrent transmissions</li></ul></li></ul></li><li><p><strong>Contrast with hubs</strong>:</p><ul><li>Hubs force a single shared collision domain among all connected devices</li><li>Only one device can transmit at any given time with a hub</li><li>Switches enable parallel, independent data flows that hubs cannot support</li></ul></li></ul><h2 id="Switch-Table">Switch Table</h2><p>Q: How does switch know that A’ reachable via interface 4, B’ reachable via interface 5?</p><p>A: Each switch has a switch table, each entry contains</p><ul><li>MAC address of host</li><li>Interface to reach host</li><li>Time stamp</li></ul><p>This structure is similar to a routing table, but operates at Layer 2 (MAC addresses) rather than Layer 3 (IP addresses).</p><p>Q: How are entries created, maintained in switch table? Something like a routing protocol?</p><p>A: Switch tables are built through self-learning</p><ol><li><p><strong>Self-learning process</strong>:</p><ul><li>Initially the switch table is empty</li><li>When a frame arrives, the switch records the sender’s MAC address and the interface on which it arrived</li><li>The switch learns the location of hosts based on the source MAC address of incoming frames</li></ul></li><li><p><strong>Table maintenance</strong>:</p><ul><li>Each entry has a time-to-live (typically 20-30 minutes)</li><li>Entries are refreshed when new frames from the same source arrive</li><li>Entries timeout and are removed if not refreshed before TTL expires</li></ul></li><li><p><strong>Handling unknown destinations</strong>:</p><ul><li>If destination MAC is unknown (not in table), the switch floods the frame to all interfaces except the one it arrived on</li><li>Once the destination host responds, its location is learned</li></ul></li><li><p><strong>Key differences from routing protocols</strong>:</p><ul><li>No explicit protocol messages exchanged between switches for MAC learning</li><li>Learning is passive, based solely on observing normal traffic</li><li>Completely automatic with no configuration required</li></ul></li></ol><h2 id="Switch-Self-Learning">Switch: Self-Learning</h2><h3 id="Learning-Host-Locations">Learning Host Locations</h3><ul><li><strong>Basic principle</strong>: Switches automatically learn which hosts are located on which interfaces</li><li><strong>No configuration required</strong>: Learning happens dynamically as frames traverse the switch</li><li><strong>Process for each incoming frame</strong>:<ol><li>Switch examines the <strong>source MAC address</strong> in the frame header</li><li>Switch records the <strong>interface</strong> on which the frame arrived</li><li>Switch associates this MAC address with this interface in its table</li><li>Timestamp is recorded for the entry for aging purposes</li></ol></li></ul><h3 id="Switch-Table-Management">Switch Table Management</h3><ul><li><strong>Dynamic updates</strong>: If a host moves to a different port, the switch updates its table when the host transmits</li><li><strong>Aging mechanism</strong>: Each entry includes a time-to-live (typically 20-30 minutes)<ul><li>Entries are refreshed when new frames from the same source arrive</li><li>If no frames are received from a MAC address before TTL expires, entry is removed</li></ul></li><li><strong>Adaptation to network changes</strong>: Tables automatically adjust when:<ul><li>New devices connect to the network</li><li>Existing devices are moved to different switch ports</li><li>Devices are removed from the network</li></ul></li></ul><h3 id="Handling-Unknown-Destinations">Handling Unknown Destinations</h3><ul><li><strong>Initial state</strong>: Empty table when switch boots up</li><li><strong>Flooding</strong>: When destination is unknown (not in table), switch forwards frame out all interfaces except the arrival interface</li><li><strong>Progressive learning</strong>: Table builds up as hosts send frames, gradually reducing the need for flooding</li><li><strong>Self-correcting</strong>: If an entry becomes outdated, flooding will occur until the host location is relearned</li></ul><p>This passive learning approach enables plug-and-play networking with minimal administrative overhead.</p><h2 id="Switch-Frame-Filtering-Forwarding">Switch: Frame Filtering/Forwarding</h2><h3 id="Frame-Processing-Algorithm">Frame Processing Algorithm</h3><p>When a frame is received by a switch, it follows this decision process:</p><ol><li><p><strong>Record source information</strong>:</p><ul><li>Record the link/interface associated with the sending host</li><li>Update or create switch table entry for source MAC address</li></ul></li><li><p><strong>Destination lookup</strong>:</p><ul><li>Index the switch table using the destination MAC address</li></ul></li><li><p><strong>Forwarding decision</strong>:</p><ul><li>If destination MAC entry is found in table:<ul><li>If destination is on same segment from which frame arrived:<ul><li>Drop the frame (no need to forward to the same segment)</li></ul></li><li>Else:<ul><li>Forward the frame on the interface indicated in the table entry</li></ul></li></ul></li><li>Else (destination not found in table):<ul><li>Flood the frame (forward on all interfaces except the one on which it arrived)</li></ul></li></ul></li><li><p><strong>Flooding process</strong>:</p><ul><li>When flooding is required, the frame is sent out all switch ports</li><li>Exception: Never send the frame back on the interface where it was received</li><li>This ensures the destination will receive the frame if it exists on the network</li><li>Subsequent replies will help the switch learn the destination’s location</li></ul></li></ol><p>This algorithm combines the efficiency of direct forwarding with the reliability of flooding when necessary, while also preventing unnecessary network traffic through frame filtering.</p><h2 id="Switches-vs-Routers-Key-Differences">Switches vs. Routers: Key Differences</h2><h3 id="Similarities">Similarities</h3><ul><li>Both are <strong>store-and-forward devices</strong><ul><li>Receive complete packets/frames before processing and forwarding</li><li>Buffer data during processing</li></ul></li></ul><h3 id="Fundamental-Differences">Fundamental Differences</h3><table><thead><tr><th>Characteristic</th><th>Switches</th><th>Routers</th></tr></thead><tbody><tr><td><strong>OSI Layer</strong></td><td>Link layer (Layer 2)</td><td>Network layer (Layer 3)</td></tr><tr><td><strong>Addressing</strong></td><td>Use MAC addresses</td><td>Use IP addresses</td></tr><tr><td><strong>Header Examination</strong></td><td>Examine frame headers</td><td>Examine packet headers</td></tr><tr><td><strong>Decision Making</strong></td><td>Simple forwarding based on MAC address</td><td>Complex routing decisions based on network topology</td></tr></tbody></table><h3 id="Table-Management">Table Management</h3><ul><li><p><strong>Switches</strong>:</p><ul><li>Maintain switch tables mapping MAC addresses to interfaces</li><li>Implement self-learning algorithms (passive learning from traffic)</li><li>Use filtering to prevent unnecessary traffic propagation</li><li>Tables built automatically without configuration</li></ul></li><li><p><strong>Routers</strong>:</p><ul><li>Maintain routing tables mapping network addresses to next hops</li><li>Implement dynamic routing algorithms (RIP, OSPF, BGP, etc.)</li><li>Exchange routing protocol messages with other routers</li><li>Often require explicit configuration</li></ul></li></ul><h3 id="Operational-Scope">Operational Scope</h3><ul><li><strong>Switches</strong>: Operate within a single network (broadcast domain)</li><li><strong>Routers</strong>: Connect multiple networks and provide inter-network communication</li></ul><p>These fundamental differences reflect their different roles in network architecture: switches optimize local traffic flow within networks, while routers enable traffic to traverse between different networks.</p><p><img src="The-Data-Link-Layer/624.png" alt="Route">{style=&quot;display: block; margin: 0 auto; width: 70%&quot;}</p><h2 id="Virtual-Local-Area-Networks-VLANs">Virtual Local Area Networks (VLANs)</h2><h3 id="802-1Q-VLAN-Frame-Format">802.1Q VLAN Frame Format</h3><ul><li>Compares standard 802.1 Ethernet frame with 802.1Q VLAN frame</li><li>802.1Q frame adds a 2-byte Tag Protocol Identifier (value: 81-00)</li><li>Includes Tag Control Information with 12-bit VLAN ID field and 3-bit priority field</li><li>CRC is recomputed to account for the added header fields</li><li>Allows frames to carry VLAN identification information</li></ul><h3 id="VLANs-Spanning-Multiple-Switches">VLANs Spanning Multiple Switches</h3><ul><li>VLANs can extend across multiple physical switches</li><li>Trunk ports connect switches and carry frames between VLANs</li><li>Frames forwarded between switches must use 802.1Q protocol to maintain VLAN information</li><li>Example shows Electrical Engineering VLAN (ports 1-8) and Computer Science VLAN (ports 9-15) spanning two switches</li><li>Trunk ports ensure proper VLAN segregation across the extended network</li></ul><h3 id="Port-based-VLAN">Port-based VLAN</h3><ul><li>Provides traffic isolation between different port groups</li><li>Supports dynamic membership where port</li><li>s can be reassigned to different VLANs</li><li>Communication between VLANs requires routing, similar to separate physical networks</li><li>VLANs can be defined by port numbers or by MAC addresses of endpoints</li><li>Vendors typically offer combined switch/router devices to facilitate inter-VLAN routing</li></ul><h3 id="VLAN-Concept-Overview">VLAN Concept Overview</h3><ul><li>Defines VLANs as virtual networks created on a single physical infrastructure</li><li>A single physical switch operates as multiple virtual switches</li><li>Logically separates networks (e.g., Electrical Engineering from Computer Science)</li><li>Provides network segmentation without requiring separate physical switches</li><li>Increases network flexibility, security, and management capabilities</li></ul><h1>End-of-chapter exercises</h1><h2 id="R-8">R.8</h2><p><strong>Question</strong></p><p>How big is the $\text{MAC}$ address space? The $\text{IPv4}$ address space? The $\text{IPv6}$ address space?</p><p><strong>Answer</strong></p><p>The sizes of the three address spaces are:</p><h3 id="MAC-Address-Space">MAC Address Space</h3><ul><li><strong>Size</strong>: $2^{48}$ possible addresses</li><li><strong>Format</strong>: $48$-bit addresses, typically represented as six groups of two hexadecimal digits (e.g., <code>00:1A:2B:3C:4D:5E</code>)</li></ul><h3 id="IPv4-Address-Space">IPv4 Address Space</h3><ul><li><strong>Size</strong>: $2^{32}$ possible addresses</li><li><strong>Format</strong>: $32$-bit addresses, typically represented as four decimal numbers separated by dots (e.g., <code>192.168.1.1</code>)</li></ul><h3 id="IPv6-Address-Space">IPv6 Address Space</h3><ul><li><strong>Size</strong>: $2^{128}$ possible addresses</li><li><strong>Format</strong>: $128$-bit addresses, typically represented as eight groups of four hexadecimal digits separated by colons (e.g., <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>)</li></ul><p>The IPv6 address space is vastly larger than both MAC and IPv4 address spaces, which was designed to address the IPv4 address exhaustion problem.</p><h2 id="P-4">P.4</h2><p><strong>Consider the previous problem, but instead of containing the binary of the numbers 0 through 9 suppose these 10 bytes contain.</strong></p><p><strong>Questions and Answers:</strong></p><p>a. the binary representation of the numbers 1 through 10.<br>b. the ASCII representation of the letters A through J (uppercase).<br>c. the ASCII representation of the letters a through j (lowercase).<br>Compute the Internet checksum for this data.</p><p>下面按 16-bit 大端顺序（高字节在前）计算 Internet 校验和（ones’complement sum）：</p><ol><li>每两个字节组成一个 16-bit 字，超出 0xFFFF 时将高位环回加到低位。</li><li>对所有字求和后取反。</li></ol><p>a. 数值 1 ～ 10（二进制，字节值 0x01～0x0A）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x01 0x02 → 0x0102  <br>0x03 0x04 → 0x0304  <br>0x05 0x06 → 0x0506  <br>0x07 0x08 → 0x0708  <br>0x09 0x0A → 0x090A  <br>Sum = 0x0102+0x0304+0x0506+0x0708+0x090A = 0x191E  <br>Checksum = ~0x191E = 0xE6E1<br></code></pre></td></tr></table></figure><p>b. 大写字母 A ～ J（ASCII 0x41～0x4A）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x41 0x42 → 0x4142  <br>0x43 0x44 → 0x4344  <br>0x45 0x46 → 0x4546  <br>0x47 0x48 → 0x4748  <br>0x49 0x4A → 0x494A  <br>Sum = 0x4142+0x4344+0x4546+0x4748+0x494A = 0x5A5F  <br>Checksum = ~0x5A5F = 0xA5A0<br></code></pre></td></tr></table></figure><p>c. 小写字母 a ～ j（ASCII 0x61～0x6A）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x61 0x62 → 0x6162  <br>0x63 0x64 → 0x6364  <br>0x65 0x66 → 0x6566  <br>0x67 0x68 → 0x6768  <br>0x69 0x6A → 0x696A  <br>Sum = 0x6162+0x6364+0x6566+0x6768+0x696A = 0xFAFF  <br>Checksum = ~0xFAFF = 0x0500<br></code></pre></td></tr></table></figure><h2 id="P-11">P.11</h2><p>Suppose four active nodes—nodes A, B, C and D—are competing for access to a channel using slotted ALOHA. Assume each node has an infinite number of packets to send. Each node attempts to transmit in each slot with probability p. The first slot is numbered slot 1, the second slot is numbered slot 2, and so on.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is the probability that node A succeeds for the first time in slot 5?</strong></p><p>在单个 slot 中成功的概率：$$P_{\text{succ}} = p (1 - p)^{3}$$</p><p>在前 4 个 slot 中都未成功的概率：$$P_{\text{4s}} = \left(1 - P_{\text{succ}}\right)^{4}$$</p><p>也就是：$$P(\text{first success in slot 5}) = \bigl[1 - p(1-p)<sup>3\bigr]</sup>4 \times p(1-p)^3.$$</p><p><strong>b. What is the probability that some node (either A, B, C or D) succeeds in slot 4?</strong></p><p>总共有 $N = 4$ 个结点，某个结点在 slot4 成功的概率为：<br>$$<br>P_{\text{succ}} = 4 \cdot p \cdot (1 - p)^{3}<br>$$</p><p><strong>c. What is the probability that the first success occurs in slot 3?</strong></p><p>第一次成功出现在 slot3 的概率<br>$$<br>P = (1-4p(1-p)<sup>3)</sup>2 \cdot 4p(1-p)^3<br>$$</p><p><strong>d. What is the efficiency of this four-node system?</strong></p><p>我们需要计算出使得 $Np(1-p)^{N-1}$ 最大的 $p$，记原式子为 $L(p)$，最优解为 $p^{\ast}$。对 $p$ 求偏导：<br>$$<br>\frac{\partial L(p)}{\partial p} = 4(1 - p)^{3} - 12p(1 - p)^{2}<br>$$</p><p>得到<br>$$<br>p^{\ast} = 0.25<br>$$</p><p>所以，效率为：<br>$$<br>\text{efficiency} = 4 \times 0.25 \times 0.75^3 = \frac{27}{64}<br>$$</p><h2 id="P-17">P.17</h2><p><strong>Question and Answer:</strong></p><p>Recall that with the CSMA/CD protocol, the adapter waits $K \cdot 512$ bit times after a collision, where $K$ is drawn randomly. For $K = 100$, how long does the adapter wait until returning to Step 2 for a $10$ Mbps Ethernet? For a $100$ Mbps Ethernet?</p><p>等待时间的计算公式为：<br>$$<br>T = K \cdot 512 \cdot t_{\text{bit}}<br>$$</p><p>其中，$t_{\text{bit}}$ 是比特时间，其计算公式为：<br>$$<br>t_{\text{bit}} = \frac{1}{\text{传输速率}}<br>$$</p><p>分别带入 $10$ Mbps 和 $100$ Mbps，解得分别等待时间为 <strong>$5.12$ ms</strong> 和 <strong>$0.512$ ms</strong>。</p><h2 id="P-18">P.18</h2><p><strong>Question and Answer:</strong></p><p>Suppose nodes A and B are on the same $10$ Mbps Ethernet bus, and the propagation delay between the two nodes is $325$ bit times. Suppose node A begins transmitting a frame and, before it finishes, node B begins transmitting a frame. Can A finish transmitting before it detects that B has transmitted? Why or why not? If the answer is yes, then A incorrectly believes that its frame was successfully transmitted without a collision. <em>Hint</em>: Suppose at time $t = 0$ bit times, A begins transmitting a frame. In the worst case, A transmits a minimum-sized frame of $512 + 64$ bit times. So A would finish transmitting the frame at $t = 512 + 64$ bit times. Thus, the answer is no, if B’s signal reaches A before bit time $t = 512 + 64$ bits. In the worst case, when does B’s signal reach A?</p><ol><li><p><strong>传播延迟计算</strong></p><ul><li>两节点之间的传播延迟为 $325$ 比特时间。</li><li>因此，B 的信号从 B 传播到 A 所需的时间为 $325$ 比特时间。</li></ul></li><li><p><strong>最小帧传输时间</strong></p><ul><li>A 传输一个最小帧所需的时间为 $512 + 64 = 576$ 比特时间。</li></ul></li><li><p><strong>碰撞检测条件</strong></p><ul><li>如果 B 的信号在 A 完成帧传输之前到达 A，则 A 可以检测到碰撞。</li><li>在最坏情况下，B 在传播延迟的最后一刻（即 $t = 325$ 比特时间）开始传输。</li><li>B 的信号需要 $325$ 比特时间到达 A，因此 B 的信号到达 A 的时间为：<br>$$<br>t_{\text{到达}} = 325 + 325 = 650 , \text{比特时间}<br>$$</li></ul></li><li><p><strong>结论</strong></p><ul><li>A 在 $t = 576$ 比特时间完成帧传输，而 B 的信号在 $t = 650$ 比特时间到达 A。</li><li>因此，A <strong>无法检测到碰撞</strong>，并会错误地认为其帧已成功传输。</li></ul></li></ol><h2 id="P-27">P.27</h2><p><strong>Question and Answer:</strong></p><p>Consider Figure $5.38$ in problem P$14$. Provide MAC addresses and IP addresses for the interfaces at Host A, both routers, and Host F. Suppose Host A sends a datagram to Host F. Give the source and destination MAC addresses in the frame encapsulating this IP datagram as the frame is transmitted <em>(i)</em> from A to the left router, <em>(ii)</em> from the left router to the right router, <em>(iii)</em> from the right router to F. Also give the source and destination IP addresses in the IP datagram encapsulated within the frame at each of these points in time.</p><p><img src="The-Data-Link-Layer/Three%20subnets,%20interconnected%20by%20routers.png" alt="Figure 5.38">{ style=&quot;display: block; margin: 0 auto; width: 50%&quot; }</p><p>Assign IP addresses to all of the interfaces. For Subnet $1$ use addresses of the form <code>192.168.1.xxx</code>; for Subnet $2$ uses addresses of the form <code>192.168.2.xxx</code>; and for Subnet $3$ use addresses of the form <code>192.168.3.xxx</code>. Assign MAC addresses to all of the adapters.</p><p>$14$ 和 $27$ 都没有明确说明 IP address 和 MAC address。先分配接口，如下表所示。</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>设备/接口</th><th>子网</th><th>IP 地址</th><th>MAC 地址</th></tr></thead><tbody><tr><td>Host A</td><td>Subnet 1</td><td>192.168.1.1</td><td>AA-AA-AA-AA-AA-AA</td></tr><tr><td>Host B</td><td>Subnet 1</td><td>192.168.1.2</td><td>BB-BB-BB-BB-BB-BB</td></tr><tr><td>Router1-接口1</td><td>Subnet 1</td><td>192.168.1.254</td><td>A1-B1-C1-D1-E1-F1</td></tr><tr><td>Router1-接口2</td><td>Subnet 2</td><td>192.168.2.1</td><td>A1-B2-C2-D2-E2-F2</td></tr><tr><td>Router2-接口1</td><td>Subnet 2</td><td>192.168.2.254</td><td>A2-B1-C1-D1-E1-F1</td></tr><tr><td>Router2-接口2</td><td>Subnet 3</td><td>192.168.3.1</td><td>A2-B2-C2-D2-E2-F2</td></tr><tr><td>Host C</td><td>Subnet 2</td><td>192.168.2.2</td><td>CC-CC-CC-CC-CC-CC</td></tr><tr><td>Host D</td><td>Subnet 2</td><td>192.168.2.3</td><td>DD-DD-DD-DD-DD-DD</td></tr><tr><td>Host E</td><td>Subnet 3</td><td>192.168.3.2</td><td>EE-EE-EE-EE-EE-EE</td></tr><tr><td>Host F</td><td>Subnet 3</td><td>192.168.3.3</td><td>FF-FF-FF-FF-FF-FF</td></tr></tbody></table></div><p><strong><em>(i)</em> from A to the left router</strong></p><ul><li><strong>Source MAC address</strong>: <code>AA-AA-AA-AA-AA-AA</code>.</li><li><strong>Destination MAC address</strong>: <code>A1-B1-C1-D1-E1-F1</code>.</li></ul><p><strong><em>(ii)</em> from the left router to the right router</strong></p><ul><li><strong>Source MAC address</strong>: <code>A1-B2-C2-D2-E2-F2</code>.</li><li><strong>Destination MAC address</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</li></ul><p><strong><em>(iii)</em> from the right router to F</strong></p><ul><li><strong>Source MAC address</strong>: <code>A2-B2-C2-D2-E2-F2</code>.</li><li><strong>Destination MAC address</strong>: <code>FF-FF-FF-FF-FF-FF</code>.</li></ul><h2 id="P-28">P.28</h2><p>Suppose now that the leftmost router in Figure $5.38$ is replaced by a switch. Hosts A, B, C, and D and the right router are all star-connected into this switch. Give the source and destination MAC addresses in the frame encapsulating this IP datagram as the frame is transmitted <em>(i)</em> from A to the switch, <em>(ii)</em> from the switch to the right router, <em>(iii)</em> from the right router to F. Also give the source and destination IP addresses in the IP datagram encapsulated within the frame at each of these points in time.</p><p>首先需要明确的是，switch 的每个接口都有一个 MAC address，但由于 switch 并不会修改经过它的 frame，这里简单地用一个 MAC address 概括。同时，理论上 subnet1 和 subnet2 应该合为一个 subnet，但接下来的结果仍做区分（因为题目要仍在问 MAC address）。</p><p>接上题的接口配置，做简单修改：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>设备/接口</th><th>子网</th><th>IP 地址</th><th>MAC 地址</th></tr></thead><tbody><tr><td>Host A</td><td>Subnet 1</td><td>192.168.1.1</td><td>AA-AA-AA-AA-AA-AA</td></tr><tr><td>Host B</td><td>Subnet 1</td><td>192.168.1.2</td><td>BB-BB-BB-BB-BB-BB</td></tr><tr><td>Switch</td><td>Subnet 1 2</td><td>192.168.1.254</td><td>A1-B1-C1-D1-E1-F1</td></tr><tr><td>Router2-接口1</td><td>Subnet 2</td><td>192.168.2.254</td><td>A2-B1-C1-D1-E1-F1</td></tr><tr><td>Router2-接口2</td><td>Subnet 3</td><td>192.168.3.1</td><td>A2-B2-C2-D2-E2-F2</td></tr><tr><td>Host C</td><td>Subnet 2</td><td>192.168.2.2</td><td>CC-CC-CC-CC-CC-CC</td></tr><tr><td>Host D</td><td>Subnet 2</td><td>192.168.2.3</td><td>DD-DD-DD-DD-DD-DD</td></tr><tr><td>Host E</td><td>Subnet 3</td><td>192.168.3.2</td><td>EE-EE-EE-EE-EE-EE</td></tr><tr><td>Host F</td><td>Subnet 3</td><td>192.168.3.3</td><td>FF-FF-FF-FF-FF-FF</td></tr></tbody></table></div><p><strong><em>(i)</em> from A to the switch</strong></p><ul><li><strong>Source MAC address</strong>: <code>AA-AA-AA-AA-AA-AA</code>.</li><li><strong>Destination MAC address</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</li></ul><p><strong><em>(ii)</em> from the switch to the right router</strong></p><ul><li><strong>Source MAC address</strong>: <code>A1-B1-C1-D1-E1-F1</code>.</li><li><strong>Destination MAC address</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</li></ul><p><strong><em>(iii)</em> from the right router to F</strong></p><ul><li><strong>Source MAC address</strong>: <code>A2-B2-C2-D2-E2-F2</code>.</li><li><strong>Destination MAC address</strong>: <code>FF-FF-FF-FF-FF-FF</code>.</li></ul><h2 id="P-32">P.32</h2><p><img src="The-Data-Link-Layer/A%20link-layer%20switch%20inter-connecting%20six%20nodes.png" alt="A link-layer switch inter-connecting six nodes">{ style=&quot;display: block; margin: 0 auto; width: 60%&quot; }</p><p>Let’s consider the operation of a learning switch in the context of Figure $5.24$. Suppose that <em>(i)</em> B sends a frame to E, <em>(ii)</em> E replies with a frame to B, <em>(iii)</em> A sends a frame to B, <em>(iv)</em> B replies with a frame to A. The switch table is initially empty. Show the state of the switch table before and after each of these events. For each of these events, identify the link(s) on which the transmitted frame will be forwarded, and briefly justify your answers.</p><p>按字典序从小到大的顺序分配接口，用如下表格总结题目所述过程：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>步骤</th><th>事件</th><th>表项变化</th><th>转发链路</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>B→E</td><td>+B@2</td><td>1,3,4,5,6</td><td>泛洪</td></tr><tr><td>2</td><td>E→B</td><td>+E@5</td><td>2</td><td>定向转发</td></tr><tr><td>3</td><td>A→B</td><td>+A@1</td><td>2</td><td>定向转发</td></tr><tr><td>4</td><td>B→A</td><td>B@2 刷新</td><td>1</td><td>定向转发</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Data Link Layer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>朴素贝叶斯法</title>
    <link href="/2025/06/04/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/"/>
    <url>/2025/06/04/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="text-Naive-Bayes">$\text{Naive Bayes}$</h2><p><strong>朴素</strong>贝叶斯法基于一个强假设，即特征条件独立性。由条件独立性假设可将公式 $(2)$ 化简为公式 $(3)$。此外，朴素贝叶斯法是对输入进行<strong>分类</strong>，这其中的机理涉及到两个概念：<strong>先验概率</strong>和<strong>后验概率</strong>；先验概率是类别的先验分布 $P(Y)$，条件概率 $P(X |Y)$ 是在类别条件下输入的分布，后验概率 $P(Y |X)$ 是在输入条件下类的分布；最后我们选择后验概率最大的分类情况作为输入的类标签。</p><h2 id="朴素贝叶斯法的学习与分类">朴素贝叶斯法的学习与分类</h2><h3 id="基本方法">基本方法</h3><p>设输入空间 $\mathcal{X} \in \mathbb{R}^n$ 为 $n$ 维向量的集合，输出空间类标记集合 $\mathcal{Y} = {c_1, c_2, \cdots, c_K }$。训练数据集</p><p>$$<br>T = {(x_1, y_1), (x_2, y_2), \dots, (x_N, y_N)}<br>$$</p><p>由 $P(X, Y)$ 独立同分布产生。</p><p>朴素贝叶斯法通过训练数据集学习联合概率分布 $P(X, Y)$。具体地，学习以下先验概率分布及条件概率分布。先验概率分布</p><p>$$<br>P(Y = c_k), \quad k = 1, 2, \cdots K \tag{1}<br>$$</p><p>条件概率分布</p><p>$$<br>P(X = x |Y = c_k) = P(X^{(1)} = x^{(1)}, \cdots, X^{(n)} = x^{(n)} |Y = c_k), \quad k = 1, 2, \cdots, K \tag{2}<br>$$</p><p>于是学习到联合概率分布 $P(X, Y)$。</p><p>由条件独立性假设得</p><p>$$<br>P(X = x |Y = c_k) = \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k) \tag{3}<br>$$</p><p>朴素贝叶斯法分类时，对给定的输入 $x$，通过学习到的模型计算后验概率分布 $P(Y = c_k |X = x)$，将后验概率最大的类作为 $x$ 的类输出。后验概率计算如下：</p><p>$$<br>P(Y = c_k |X = x) = \frac{P(X = x |Y = c_k) P(Y = c_k)}{\sum_{k} P(X = x |Y = c_k) P(Y = c_k)} \tag{4}<br>$$</p><p>也就是：</p><p>$$<br>P(Y = c_k |X = x) = \frac{P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)}{\sum_{k} P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)} \tag{5}<br>$$</p><p>这是朴素贝叶斯法分类的基本公式。于是，朴素贝叶斯分类器可表示为</p><p>$$<br>y = f(x) = \operatorname{arg} \max_{c_k} \frac{P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)}{\sum_{k} P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)} \tag{6}<br>$$</p><p>注意到分母对所有 $c_k$ 都是相同的，所以，</p><p>$$<br>y = f(x) = \operatorname{arg} \max_{c_k} P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k) \tag{7}<br>$$</p><h3 id="后验概率最大化的含义">后验概率最大化的含义</h3><p>朴素贝叶斯法将实例分到后验概率最大的类中。这等价于期望风险最小化。假设选择 0-1 损失函数：</p><p>$$<br>L(Y, f(X)) =<br>\begin{cases}<br>1, &amp;Y \neq f(X)<br>\[10pt]<br>0, &amp;Y = f(X)<br>\end{cases}<br>$$</p><p>式中 $f(X)$ 是分类决策函数。这时，期望风险函数为</p><p>$$<br>R_{\exp}(f) = \mathbf{E}[L(Y, f(X))]<br>$$</p><p>期望是对联合分布 $P(X, Y)$取的。由此取条件期望：</p><p>$$<br>R_{\exp}(f) = \mathbf{E_{X}} \sum_{k = 1}^{K}[L(c_k, f(X))] P(c_k |X)<br>$$</p><p>为了使期望风险最小化，只需对 $X = x$ 逐个极小化，由此得到：</p><p>$$<br>f(x) = \operatorname{arg} \max_{y \in \mathcal{Y}} P(y = c_k |X = x)<br>$$</p><h2 id="朴素贝叶斯法的参数估计">朴素贝叶斯法的参数估计</h2><h3 id="学习与分类算法">学习与分类算法</h3><p>输入：训练数据 $T = {(x_1, y_1), (x_2, y_2), \dots, (x_N, y_N)}$，其中 $x_i = (x_i^{(1)}, x_i^{(2)}, \dots, x_i<sup>{(n)})$，$x_i</sup>{(j)}$ 是第 $i$ 个样本的第 $j$ 个特征，$x_i^{(j)} \in {a_{j1}, a_{j2}, \cdots, a_{jS_j}}$ 是特征 $x_i^{(j)}$ 的可能取值，$y_i \in {c_1, c_2, \cdots, c_K}$。<br>输出：实例 $x$ 的分类。</p><p><strong>（1）计算先验概率及条件概率</strong><br>$$<br>\begin{align*}<br>P(Y = c_k) &amp;= \frac{\sum_{i = 1}^{N} I(y_i = ck)}{N}, \quad k = 1, 2, \cdots, K<br>\[10pt]<br>P(X^{(j)} = a_{jl} |Y = c_k) &amp;= \frac{\sum_{i = 1}^{N} I(x_i^{(j)} = a_{jl}, y_i = c_k)}{\sum_{i = 1}^{N} I(y_i = c_k)}<br>\[10pt]<br>j = 1, 2, \cdots, n; \quad l &amp;= 1, 2, \cdots, S_j; \quad k = 1, 2, \cdots, K<br>\end{align*}<br>$$<br><strong>（2）对于给定实例 $x = (x^{(1)}, x^{(2)}, \dots, x^{(n)})$，计算：</strong><br>$$<br>P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k), \quad k = 1, 2, \cdots, K<br>$$<br><strong>（3）确定实例 $x$ 的类</strong><br>$$<br>y = \operatorname{arg} \max_{c_k} P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)<br>$$</p><h3 id="贝叶斯估计">贝叶斯估计</h3><p>用极大似然估计可能会出现所要估计的概率值为 $0$ 的情况。这是采用贝叶斯估计。</p><p>$$<br>\begin{align*}<br>P_{\lambda}(X^{(j)} = a_{jl} |Y = c_k) &amp;= \frac{\sum_{i = 1}^{N} I(x_i^{(j)} = a_{jl}, y_i = c_k) + \lambda}{\sum_{i = 1}^{N} I(y_i = c_k) + S_j \lambda} \tag{8}<br>\[10pt]<br>P_{\lambda}(Y = c_k) &amp;= \frac{\sum_{i = 1}^{N} I(y_i = c_k) + \lambda}{N + K \lambda} \tag{9}<br>\end{align*}<br>$$</p><p>常取 $\lambda = 1$</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>期望极大</title>
    <link href="/2025/06/03/%E6%9C%9F%E6%9C%9B%E6%9E%81%E5%A4%A7/"/>
    <url>/2025/06/03/%E6%9C%9F%E6%9C%9B%E6%9E%81%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="EM-算法">EM 算法</h2><p>$\operatorname{EM}$ 算法通过迭代求 $L(\theta) = \log P(Y | \theta)$ 的极大似然估计。每次迭代包含两步：$\operatorname{E}$ 步，求期望；$\operatorname{M}$ 步，求极大化。</p><h3 id="算法步骤">算法步骤</h3><p>输入：观测变量数据 $Y$，隐变量数据 $Z$，联合分布 $P(Y, Z | \theta)$，条件分布 $P(Z | Y, \theta)$；<br>输出：模型参数$\theta$。</p><p><strong>（1）选择参数初始值 $\theta^{(0)}$，开始迭代；</strong></p><p><strong>（2）$\operatorname{E}$ 步：计算 Q 函数值</strong></p><p>$$<br>Q(\theta, \theta^{(i)}) = \sum_{Z} \log P(Y, Z | \theta) P(Z | Y, \theta^{(i)}) \tag{1}<br>$$</p><p>这里，$P(Z | Y, \theta^{(i)})$ 是在给定观测数据 $Y$ 和当前的参数估计 $\theta^{(i)}$ 下隐变量数据 $Z$ 条件概率分布；</p><p><strong>（3）$\operatorname{M}$ 步：求使 $Q(\theta, \theta^{(i)})$ 极大化的 $\theta$，确定第 $i + 1$ 次迭代的参数估计值 $\theta^{(i + 1)}$</strong></p><p>$$<br>\theta^{(i + 1)} = \operatorname{arg} \max_{\theta} Q(\theta, \theta^{(i)}) \tag{2}<br>$$</p><p><strong>（4）重复（2）（3）步直到收敛</strong></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>感知机</title>
    <link href="/2025/06/03/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <url>/2025/06/03/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="text-Perceptron">$\text{Perceptron}$</h2><p>感知机用于<strong>二分类线性问题</strong>，这说明感知机只能用于二分类问题，同时样本数据线性可分。</p><p>接下来会介绍感知机的<strong>数学定义</strong>，也就是感知机的输入输出映射；然后介绍感知机的学习算法，学习什么？学习的是感知机数学定义中提及到的<strong>参数</strong>；如何学习？会介绍两种方法，第一种是基于原始<strong>损失函数</strong>的迭代算法，另一种是基于原始损失函数的<strong>对偶形式</strong>的迭代算法，这两种算法本质上等价。</p><span id="more"></span><h2 id="感知机的数学定义">感知机的数学定义</h2><p>假设输入空间 $\mathcal{X} \subseteq \mathbb{R}^n$，输出空间是 $\mathcal{Y} = {+1, -1}$。由输入空间到输出空间的如下函数：</p><p>$$<br>f(x) = \operatorname{sign} (\mathbf{w} \cdot \mathbf{x} + b) \tag{1}<br>$$</p><p>称为感知机。其中，$w$ 和 $b$ 为感知机模型参数，前者叫权值 <strong>weight</strong>，后者叫偏置 <strong>bias</strong>，点乘运算为<strong>向量内积</strong>。$\operatorname{sign}$ 是符号函数，具体定义如下：</p><p>$$<br>\operatorname{sign}(x) =<br>\begin{cases}<br>+1,&amp; x \geq 0<br>\[10pt]<br>-1,&amp; x &lt; 0 \tag{2}<br>\end{cases}<br>$$</p><h2 id="感知机学习策略">感知机学习策略</h2><p>假设数据集<strong>线性可分</strong>，定义感知机学习的损失函数为：</p><p>$$<br>L(\mathbf{w}, b) = -\sum_{\mathbf{x}_i \in M} y_i(\mathbf{w} \cdot \mathbf{x}_i + b) \tag{3}<br>$$</p><p>其中，$M$ 是<strong>误分类点的集合</strong>，我们的目标是极小化 $L(\mathbf{w}, b)$。</p><h3 id="感知机学习算法的原始形式">感知机学习算法的原始形式</h3><p>随机初始化 $\mathbf{w}$ 和 $b$，分别记为 $\mathbf{w}_0$ 和 $b_0$，然后在训练数据集中选取数据 $(\mathbf{x}_i, y_i)$；如果 $y_i(\mathbf{w} \cdot \mathbf{x}_i + b) \leq 0$,</p><p>$$<br>\begin{align*}<br>&amp;\mathbf{w} \leftarrow \mathbf{w} + \eta y_i \mathbf{x}_i<br>\[10pt]<br>&amp;b \leftarrow b + \eta y_i<br>\end{align*}<br>$$</p><p>重复上述选择更新过程直至没有误分类点。</p><blockquote><blockquote><p>这个更新过程，根据《统计学习方法》的例题，需要这样更新。假设我有一训练数据集 $x_1, x_2, \cdots, x_N$，我初始化完 $\mathbf{w}$ 和 $b$ 后，我从 $x_1$ 开始，每次更新后都要从 $1 \to N$ 的顺序进行验证。</p></blockquote></blockquote><h3 id="感知机学习算法的对偶形式">感知机学习算法的对偶形式</h3><p>与原始形式不同，对原始形式使用拉格朗日对偶化，得到相应的对偶形式。首先初始化系数和偏置 $\mathbf{\alpha} \leftarrow \mathbf{0}, b \leftarrow 0$。再在训练集中选取数据 $(\mathbf{x}<em>i, y_i)$；如果 $y_i \left(\sum</em>{j = 1}^{N} \alpha_j y_j (\mathbf{x}_j \cdot \mathbf{x}_i) + b \right) \leq 0$，则更新</p><p>$$<br>\begin{align*}<br>&amp;\alpha_i \leftarrow \alpha_i + \eta<br>\[10pt]<br>&amp;b \leftarrow b + \eta y_i<br>\end{align*}<br>$$</p><p><strong>tips</strong></p><p>可以预处理出所有输入实例间的内积，并将其存为一个矩阵，这个矩阵叫做 Gram 矩阵，</p><p>$$<br>\mathbf{G} = [\mathbf{x}_i \cdot \mathbf{x}<em>j]</em>{N \times N}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上下文无关文法</title>
    <link href="/2025/06/03/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/"/>
    <url>/2025/06/03/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1>上下文无关文法的定义</h1><p>定义文法 $G = (V, T, P, S)$，其中产生式，除了空产生式外，有如下特点：</p><p>$$<br>\forall \alpha \to \beta \in P, \quad \beta \in (V \cup T)^{\ast}, \quad \text{All have } |\beta| \geq |\alpha|, \text{and } \alpha \in V<br>$$</p><h1>派生树</h1><p>设有 CFG $ G = (V, T, P, S)$，$G$ 的派生树是满足如<br>下条件的有序树。</p><ol><li>树的每个顶点有一个标记 $X$，且 $X \in V \cup T \cup {\epsilon}$；</li><li>树根的标记为 $S$；</li><li>如果非叶子顶点 $v$ 标记为 $A$，$v$ 的儿子从左到右依次为$v_1, v_2, \dots, v_n$，并且它们分别标记为$X_1, X_2, \dots, X_n$，则 $A \to X_1 X_2 \cdots X_n \in P$；</li><li>如果 $X$ 是一个<strong>非叶子顶点</strong>的标记，则 $X \in V$；</li><li>如果顶点 $v$ 标记为 $\epsilon$，则 $v$ 是该树的叶子，并且 $v$ 是其父顶点的<strong>惟一儿子</strong>。</li></ol><p>派生树都是 CFG 的派生树。</p><h2 id="顶点的结果">顶点的结果</h2><p>派生树 $T$ 的所有叶子结点从左到右的符号串为 $X_1 X_2 \cdots X_n$是 $T$ 的结果。</p><h1>CFG 的化简</h1><h2 id="删除无用符号">删除无用符号</h2><p><strong>无用符号</strong></p><h1>CNF：乔姆斯基范式文法</h1><p>CFG $G = (V, T, P, S)$ 中的产生式形式为：$A \to BC, , A\to a$，其中 $A,B,C \in V,, a \in T$，需要注意的是此 CFG 已完成化简。</p><p>利用 CNF 范式派生长度为 $n$ 的串，刚好需要 $2n-1$ 步。</p><h1>上下文无关文法的性质</h1><h2 id="CFL-的泵引理">CFL 的泵引理</h2><p>对于任意的 CFL $L$，存在仅仅依赖于 $L$ 的正整数 $N$，对于任意的 $z \in L$，当 $|z| \geq N$ 时，存在 $u, v, w, x, y$，使得 $z = uvwxy$，同时满足：</p><ol><li>$|vwx| \leq N$；</li><li>$|vx| \geq 1$；</li><li>对于任意的非负整数 $i$，$u v^i w x^i y \in L$。</li></ol><h3 id="利用-CFL-泵引理证明一个语言不是-CFL">利用 CFL 泵引理证明一个语言不是 CFL</h3><ol><li>首先假设该语言是 CFL，则其满足泵引理，任选 $N$；</li><li>找到语言中的句子 $z \in L$ 且 $|z| \geq N$；</li><li>分析 $v$、$x$ 的各种取值，当满足 $z = uvwxy$，且 $|vwx| \leq N$，$|vx| \geq 1$ 时，均能找到 $i \geq 0$，使得 $i$，$u v^i w x^i y \notin L$。</li></ol><h2 id="Ogden-引理">Ogden 引理</h2><p>对于任意的 CFL $L$，存在仅仅依赖于 $L$ 的正整数 $N$，对于任意的 $z \in L$，当 $z$ 中至少含有 $N$ 个特异点时，存在 $u, v, w, x, y$，使得 $z = uvwxy$，同时满足：</p><ol><li>$|vwx|$ 中的特异点的数目 $\leq N$；</li><li>$|vx|$ 中的特异点的数目 $\geq 1$；</li><li>对于任意的非负整数 $i$，$u v^i w x^i y \in L$。</li></ol><h2 id="CFL-在并、乘积、闭包运算下是封闭的，但在交运算下不封闭">CFL 在并、乘积、闭包运算下是封闭的，但在交运算下不封闭</h2><h1>CYK Algorithm</h1><p>输入：CNF $G = (V, T, P, S)$，$x$；<br>输出：$x \in L$ 或者 $x \notin L$；</p><p>$V_{i,k}$：可以派生出子串 $x_{i,k}$ 的变量集合，$x_{i,k}$ 表示从 $i$ 开始，长度为 $k$ 的子串。</p><ol><li><code>for i = 1 in |x|</code> $V_{i,1} = {A \mid A \to x_{i,1} \in P}$</li><li><code>for k = 2 in |x| &#123;for i = 1 to |x| - k + 1&#125;</code> $V_{i,k} = \Phi $<ol><li><code>for j = 1 to k - 1</code> $V_{i,k} = V_{i,k} \cup {A \mid A \to BC \text{ and } B \in V_{i,j} \text{ and } C \in V_{i + j,k - j}}$</li></ol></li></ol><h1>hw13</h1><p><strong>题目1：</strong> 使用CFL的泵引理证明 $L = { ww \mid w \in {a, b}^{\ast} }$ 不是上下文无关语言.</p><p><strong>解答1：</strong></p><p>我们使用 CFL 的泵引理来证明 $L = { ww \mid w \in {a, b}^\ast }$ 不是上下文无关语言。</p><p>假设 $L$ 是一个上下文无关语言，则它满足 CFL 的泵引理。</p><p>设 $N$ 为泵引理中的 $N$，取句子 $ z = a^{N} b^{N} a^{N} b^{N} \in L $</p><p>接下来分析 $vwx$ 的各种取值：</p><ol><li>因为 $|vwx| \leq N$，不妨先假设 $vwx \subseteq a^{N}$ 或者 $b^{N}$，显然对于 $\forall i &gt; 0$，都会破坏 $L$ 的结构，即要求 $ww \in L$。<br><br></li><li>然后再分析 $vwx$ 跨越了 $a$ 部分或者 $b$ 部分，由于 $|vwx| \leq N$，可以证明 $vwx$ 最多横跨一个 $a$ 和一个 $b$，也即是类似 $a \cdots ab \cdots b$ 和 $b \cdots ba \cdots a$ 的结构；<br><br><ol><li>假设 $vwx$ 横跨第一个 $a$ 和 $b$。设 $ v = a^{m}, , x = b^{n}$，则 $\forall i &gt; 0$，$u a^{im} w b^{in} y \notin L$，这很好证明：此时 $u a^{im} w b^{in} y$ 可以写成 $a^{N + im} b^{N + in} a^{N} b^{N}$ 的形式，为了保证 $ww$ 的结构，只能如此分割 $a^{N + im} b^{N + in}$ 和 $a^{N} b^{N}$，因为 $|vx| \geq 1$，所以不存在 $i$ 使得分割后得两个句子相等；<br><br></li><li>同理可以证明 $vwx$ 横跨第二个 $a$ 和 $b$ 时同样不满足泵引理；<br><br></li><li>对于 $vwx$ 横跨第一个 $b$ 和 第二个 $a$ 的情况，此时 $u a^{im} w b^{in} y$ 可以写成 $a^{N} b^{N + im} a^{N + in} b^{N}$ 的形式，同样为了保证 $ww$ 的结构，只能如此分割 $a^{N} b^{N + im}$ 和 $a^{N + in} b^{N}$，显然分割后的句子不相等，也就是不满足泵引理。<br><br></li></ol></li></ol><p>综上，$L$ 不是 CFL。</p><p><strong>题目2：</strong><br>给定文法 $G$ 如下：</p><p>[<br>\begin{align*}<br>&amp;S \to AB ,|, AA ,|, BC \<br>&amp;A \to CD ,|, a \<br>&amp;B \to BD ,|, SB ,|, b \<br>&amp;C \to c \<br>&amp;D \to DB ,|, b<br>\end{align*}<br>]</p><p>根据算法 CYK 算法，请识别字符串&quot;aabbc&quot;是否属于 $L(G)$?</p><p><strong>解答2：</strong><br>$x = \text{&quot;aabbc&quot;}$，长度 $|x| = 5$。</p><p>构造一个二维表 $V_{i,k}$，其中 $V_{i,k}$ 表示从位置 $i$ 开始，长度为 $k$ 的子串可以由哪些非终结符生成。</p><ol><li><p><strong>第一步：处理长度为 1 的子串</strong><br>根据文法的终结符规则，填充 $V_{i,1}$：</p><ul><li>$x_1 = a \implies V_{1,1} = {A}$</li><li>$x_2 = a \implies V_{2,1} = {A}$</li><li>$x_3 = b \implies V_{3,1} = {B, D}$</li><li>$x_4 = b \implies V_{4,1} = {B, D}$</li><li>$x_5 = c \implies V_{5,1} = {C}$</li></ul></li><li><p><strong>第二步：处理长度为 2 的子串</strong><br>根据文法的组合规则，填充 $V_{i,2}$：</p><ul><li>$x_{1,2} = &quot;aa&quot; \implies V_{1,2} = {S}$ （因为 $A \to AA$）</li><li>$x_{2,2} = &quot;ab&quot; \implies V_{2,2} = {B}$ （因为 $S \to AB$）</li><li>$x_{3,2} = &quot;bb&quot; \implies V_{3,2} = {B, D}$ （因为 $B \to BD$ 和 $D \to DB$）</li><li>$x_{4,2} = &quot;bc&quot; \implies V_{4,2} = {S}$ （因为 $S \to BC$）</li></ul></li><li><p><strong>第三步：处理长度为 3 的子串</strong><br>根据文法的组合规则，填充 $V_{i,3}$：</p><ul><li>$x_{1,3} = &quot;aab&quot; \implies V_{1,3} = {B}$ （因为 $S \to AB$）</li><li>$x_{2,3} = &quot;abb&quot; \implies V_{2,3} = {S}$ （因为 $S \to AB$ 和 $B \to SB$）</li><li>$x_{3,3} = &quot;bbc&quot; \implies V_{3,3} = {S}$ （因为 $S \to BC$）</li></ul></li><li><p><strong>第四步：处理长度为 4 的子串</strong><br>根据文法的组合规则，填充 $V_{i,4}$：</p><ul><li>$x_{1,4} = &quot;aabb&quot; \implies V_{1,4} = {S}$ （因为 $S \to AB$ 和 $B \to SB$）</li><li>$x_{2,4} = &quot;abbc&quot; \implies V_{2,4} = {S}$ （因为 $S \to BC$）</li></ul></li><li><p><strong>第五步：处理长度为 5 的子串</strong><br>根据文法的组合规则，填充 $V_{1,5}$：</p><ul><li>$x_{1,5} = &quot;aabbc&quot; \implies V_{1,5} = {S}$ （因为 $S \to AB$ 和 $B \to SB$）</li></ul></li></ol><p>最终，$V_{1,5}$ 包含 $S$，因此字符串 &quot;aabbc&quot; 属于文法 $G$ 的语言 $L(G)$。</p>]]></content>
    
    
    <categories>
      
      <category>形式语言与自动机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大熵模型</title>
    <link href="/2025/06/02/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/06/02/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Logistic-Regression">Logistic Regression</h2><h3 id="Logistic-Distribution">Logistic Distribution</h3><p>设$X$是连续随机变量，$X$服从 <strong>logistic distribution</strong> 是指$X$具有下列分布函数和密度函数：</p><p>$$<br>\begin{align}<br>F(x) &amp;= P(X \leq x) = \frac{1}{1 + e^{-(x-\mu)/\gamma}} \tag{1}<br>\<br>f(x) &amp;= F’(x) = \frac{e^{-(x-\mu)/\gamma}}{\gamma\left(1 + e<sup>{-(x-\mu)/\gamma}\right)</sup>2} \tag{2}<br>\end{align}<br>$$</p><h3 id="Binomial-Logistic-Regression-Model">Binomial Logistic Regression Model</h3><p>这是一种二分类模型，这里规定模型输出 $Y \in {0, 1}$， 也就是 $y_i \in {0, 1}$</p><p>$$<br>\begin{align}<br>P(Y = 0 | \mathbf{x}) &amp;= \frac{1}{1 + \exp (\mathbf{w} \cdot \mathbf{x} + b)} \tag{3}<br>\<br>P(Y = 1 | \mathbf{x}) &amp;= \frac{\exp (\mathbf{w} \cdot \mathbf{x} + b)}{1 + \exp (\mathbf{w} \cdot \mathbf{x} + b)} \tag{4}<br>\end{align}<br>$$</p><p>其中，$\mathbf{x} \in \mathbb{R}^n$ 是输入，$\mathbf{w} \in \mathbb{R}^n$ 和 $ b \in \mathbb{R}$ 分别是权值向量和偏置，$\mathbf{w} \cdot \mathbf{x}$ 是向量内积运算。</p><h3 id="Evaluation-of-Model-Parameters">Evaluation of Model Parameters</h3><p>采用极大似然估计法估计模型参数，从而得到 <em><strong>logistics regression model</strong></em>。</p><p>我们设</p><p>$$<br>P(Y = 1 | x) = \pi(x) \tag{5}<br>$$</p><p>则得到似然函数为</p><p>$$<br>\prod_{i=1}<sup>{N}[\pi(x_i)]</sup>{y_i}[1 - \pi(x_i)]^{1 - y_i} \tag{6}<br>$$</p><p>经过计算，对数似然函数为</p><p>$$<br>L(w) = \sum_{i=1}^{N} [y_i(\vec{w} \cdot \vec{x_i}) - \ln (1 + \exp (\vec{w} \cdot \vec{x_i}))] \tag{7}<br>$$</p><p>对 $L(w)$ 求极大值，得到 $w$ 的估计值 $\hat{w}$</p><hr><h2 id="Maximum-Entropy-Model">Maximum Entropy Model</h2><h3 id="The-Principle-of-Maximum-Entropy">The Principle of Maximum Entropy</h3><p>最大熵原理的核心在于，使得整个概率模型的熵最大。</p><h3 id="MaxEntropy-Model">MaxEntropy Model</h3><p>模型输入 $X \in \mathcal{X} \subseteq \mathbb{R}^n$，输出 $Y \in \mathcal{Y}$，条件概率分布 $P(Y | X)$ 表示对于给定输入 $X$ 以该条件概率输出 $Y$。</p><p>给定训练数据集，可以确定联合分布 $P(X, Y)$ 的经验分布和边缘分布。</p><p>$$<br>\begin{align}<br>\tilde{P}(X = x, Y = y) &amp;= \frac{\nu(X = x, Y = y)}{N} \tag{8}<br>\<br>\tilde{P}(X = x) &amp;= \frac{\nu(X = x)}{N} \tag{9}<br>\end{align}<br>$$</p><p>其中 $\nu(X = x, Y = y)$ 是样本 $(x, y)$ 出现的频数。</p><p>接下来介绍特征函数 <em><strong>feature function</strong></em> $f(x,y)$，$f()$ 描述输入 $x$ 与输出 $y$ 之间的某一个事实。</p><p>$$<br>f(x, y) =<br>\begin{cases}<br>1, &amp;\text{satisfying}<br>\<br>0, &amp;\text{otherwise} \tag{10}<br>\end{cases}<br>$$</p><p>特征函数关于经验分布的期望值</p><p>$$<br>E_{\tilde{P}}(f) = \sum_{x,y} \tilde{P}(x,y) f(x,y) \tag{11}<br>$$</p><p>特征函数关于模型与经验分布的期望值</p><p>$$<br>E_P(f) = \sum_{x,y} \tilde{P}(x) P(y|x) f(x,y) \tag{12}<br>$$</p><p>如果模型能够获得训练数据中的信息，则可以认为上述两个期望值相等，即</p><p>$$<br>E_{\tilde{P}}(f) = E_P(f) \tag{13}<br>$$</p><p>综上，我们引出最大熵模型。</p><p>假设满足所有约束条件的模型集合为</p><p>$$<br>\mathcal{C} \equiv {P \in \mathcal{P} \mid E_{\tilde{P}}(f_i) = E_P(f_i), \quad i=1,2,\dots,n} \tag{14}<br>$$</p><p>定义在条件概率分布 $P(Y|X)$ 上的条件熵为</p><p>$$<br>H(P) = -\sum_{x,y} \tilde{P}(x) P(y|x) \ln P(y|x) \tag{15}<br>$$</p><p>则模型集合 $\mathcal{C}$ 中条件熵 $H(P)$ 最大的模型称为最大熵模型。</p><h3 id="Training-a-Maximum-Entropy-Model">Training a Maximum Entropy Model</h3><p>类似 <strong>SVM</strong> 的学习过程。给定训练数据集 $T = {(x_1,y_1),(x_2,y_2),\dots,(x_N,y_N)}$ 以及特征函数 $f_i(x,y), \quad i = 1, 2, \dots, n$，最大熵模型的学习等价于约束最优化问题：</p><p>$$<br>\begin{align*}<br>\max_{P \in \mathcal{C}} \quad &amp; H(P) = -\sum_{x, y} \tilde{P}(x) P(y \mid x) \ln P(y \mid x)<br>\<br>\text{subject to} \quad &amp; E_{\tilde{P}}[f_i] = E_P[f_i], \quad i = 1, 2, \dots, n<br>\<br>&amp; \sum_{y} P(y \mid x) = 1<br>\end{align*}<br>$$</p><p>将其换为等价的最小化问题</p><p>$$<br>\begin{align*}<br>\min_{P \in \mathcal{C}} \quad -&amp;H(P) = \sum_{x, y} \tilde{P}(x) P(y \mid x) \ln P(y \mid x) \tag{16}<br>\<br>\text{subject to} \quad &amp; E_{\tilde{P}}[f_i] - E_P[f_i]= 0, \quad i = 1, 2, \dots, n \tag{17}<br>\<br>&amp; \sum_{y} P(y \mid x) = 1 \tag{18}<br>\end{align*}<br>$$</p><p>将约束最优化问题转换为无约束最优化的对偶问题。引入拉格朗日乘子 $w_0, w_1, \dots, w_n$，定义拉格朗日函数 $L(P, w)$：</p><p>$$<br>\begin{align*}<br>L(P, w) &amp;\equiv -H(P) + w_0 \left(1 - \sum_{y} P(y | x)\right) + \sum_{i = 1}^{n} w_i (E_{\tilde{P}}(f_i) - E_{P}(f_i)) \tag{19}<br>\<br>&amp;= \sum_{x,y} \tilde{P}(x) P(y | x) \ln P(y | x) + w_0\left(1 - \sum_{y} P(y | x)\right) +<br>\<br>&amp;\sum_{i = 1}^{n} w_i\left(\sum_{x, y} \tilde{P}(x, y) f_i(x, y) - \sum_{x, y} \tilde{P}(x) P(y | x) f_i(x, y) \right)<br>\end{align*}<br>$$</p><p>最优化的原始问题是</p><p>$$<br>\min_{P \in \mathcal{C}} \max_{w} L(P, w) \tag{20}<br>$$</p><p>对偶问题是</p><p>$$<br>\max_{w} \min_{P \in \mathcal{C}} L(P, w) \tag{21}<br>$$</p><p>先解决极小化问题， 记</p><p>$$<br>\Psi(w) = \min_{P \in \mathcal{C}} L(P, w) = L(P_w, w) \tag{22}<br>$$</p><p>求 $L(P, w)$ 对 $P(y | x)$ 的偏导数</p><p>$$<br>\begin{align*}<br>\frac{\partial L(P, w)}{\partial P(y | x)} &amp;= \sum_{x, y} \tilde{P}(x)(\ln P(y | x) + 1) - \sum_{y}w_0 - \sum_{x, y} \left(\tilde{P}(x) \sum_{i = 1}^{n} w_i f_i(x, y) \right)<br>\<br>&amp;= \sum_{x, y} \tilde{P}(x) \left(\ln P(y | x) + 1 - w_0 - \sum_{i = 1}^{n} w_i f_i(x, y) \right)<br>\end{align*}<br>$$</p><p>令偏导数等于 $0$， 在 $\tilde{P} &gt; 0$ 的情况下，解得</p><p>$$<br>P_w(y | x) = \frac{1}{Z_w(x)} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right) \tag{23}<br>$$</p><p>其中</p><p>$$<br>Z_w(x) = \sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right) \tag{24}<br>$$</p><p>称 $Z_w(x)$ 为归一化因子。</p><p>最后求解对偶问题外部的极大化问题</p><p>$$<br>\max_{w} \Psi(w) \tag{25}<br>$$</p><h3 id="Improved-Iterative-Scaling">Improved Iterative Scaling</h3><p>已知最大熵模型</p><p>$$<br>P_w(y | x) = \frac{1}{Z_w(x)} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)<br>$$</p><p>其中</p><p>$$<br>Z_w(x) = \sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)<br>$$</p><p>对数似然函数为</p><p>$$<br>L(w) = \sum_{x, y} \tilde{P}(x, y) \sum_{i = 1}^{n} w_i f_i(x, y) - \sum_{x} \tilde{P}(x) \ln Z_w(x)<br>$$</p><p>改进迭代算法的思路是，假设最大熵模型当前的参数向量是 $w = (w_1, w_2, \dots, w_n)^{T}$，我们希望找到一个新的参数向量 $w + \delta = (w_1 + \delta_1, \dots, w_n + \delta_n)^{T}$，使得模型的对数似然函数增值。</p><p><strong>算法步骤</strong></p><p><strong>输入</strong>：特征函数 $f_1, f_2, \dots, f_n$；经验分布 $\tilde{P}(X, Y)$；模型 $P_w(y | x)$</p><p><strong>输出</strong>：最优参数值 $w_i^{\ast}$；最优模型 $P_{w^{\ast}}$</p><p><strong>步骤1</strong>：对所有 $i \in {1, 2, \dots, n}$，取初值 $w_i = 0$。</p><p><strong>步骤2</strong>：对每一 $i \in {1, 2, \dots, n}$，执行以下操作：</p><p>首先，令 $\delta_i$ 为下列方程的解：</p><p>$$<br>\sum_{x, y} \tilde{P}(x) P(y | x) f_i(x, y) \exp \left(\delta_i f^{\Sigma}(x, y) \right) = E_{\tilde{P}}(f_i)<br>$$</p><p>其中，$f^{\Sigma}(x, y)$ 定义为：</p><p>$$<br>f^{\Sigma}(x, y) = \sum_{i = 1}^{n} f_i(x, y)<br>$$</p><p>然后，更新 $w_i$ 的值：</p><p>$$<br>w_i \leftarrow w_i + \delta_i<br>$$</p><p><strong>步骤3</strong>：如果不是所有 $w_i$ 都收敛，则重复步骤2。</p><h3 id="Quasi-Newton-Method-BFGS">Quasi-Newton Method : BFGS</h3><p>对最大熵模型而言，</p><p>$$<br>P_w(y | x) = \frac{\exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)}{\sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)}<br>$$</p><p>目标函数：</p><p>$$<br>\min_{w \in \mathbb{R}^n} f(w) = \sum_{x} \tilde{P}(x) \ln \sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right) - \sum_{x, y} \tilde{P}(x, y) \sum_{i = 1}^{n} w_i f_i(x, y)<br>$$</p><p>相应 $i$ 的梯度有，</p><p>$$<br>\frac{\partial f(w)}{\partial w_i} = \sum_{x, y} \tilde{P}(x) P_w(y | x) f_i(x, y) - E_{\tilde{p}}(f_i)<br>$$</p><p>定义 $g()$</p><p>$$<br>g(w) = \left(\frac{\partial f(x)}{\partial w_1}, \frac{\partial f(x)}{\partial w_2}, \dots,\frac{\partial f(x)}{\partial w_n} \right)^T<br>$$</p><p><strong>算法步骤</strong></p><p><strong>输入</strong>：特征函数 $f_1, f_2, \dots, f_n$；经验分布 $\tilde{P}(X, Y)$；目标函数 $f(w)$；梯度 $g(w) = \nabla f(w)$；精度要求 $\epsilon$；<br><strong>输出</strong>：最优参数值 $w_i^{\ast}$；最优模型 $P_{w^{\ast}}$</p><ol><li>选定初始点 $w^{(0)}$，取 $B_0$ 为正定对称矩阵，置 $k = 0$。</li><li>计算 $g_k = g(w^{(k)})$。<br>若 $\lVert g_k \rVert &lt; \epsilon$，则停止计算，得 $w^{*} = w^{(k)}$；否则转第 3 步。</li><li>由 $B_k p_k = -g_k$ 求出 $p_k$。</li><li>一维搜索，求 $\lambda_k$ 使得<br>$$<br>f(w^{(k)} + \lambda_k p_k) = \min_{\lambda \geq 0} f(w^{(k)} + \lambda p_k)<br>$$</li><li>置 $w^{(k + 1)} = w^{(k)} + \lambda_k p_k$。</li><li>计算 $g_{k + 1} = g(w^{(k + 1)})$。<br>若 $\lVert g_{k + 1} \rVert &lt; \epsilon$，则停止计算，得 $w^{*} = w^{(k + 1)}$；否则，按下式求出 $B_{k + 1}$：<br>$$<br>B_{k + 1} = B_k + \frac{y_k y_k<sup>T}{y_k</sup>T \delta_k} - \frac{B_k \delta_k \delta_k^T B_k}{\delta_k^T B_k \delta_k}<br>$$<br>其中，<br>$$<br>y_k = g_{k + 1} - g_k, \quad \delta_k = w^{(k + 1)} - w^{(k)}<br>$$</li><li>置 $k = k + 1$，转第 3 步。</li></ol><p><strong>补充说明</strong></p><p>在 BFGS 算法中，$B_k$ 是对目标函数 <em><strong>Hessian</strong></em> 矩阵的近似。初始时 $B_0$ 通常取为单位矩阵或其他对称正定矩阵。每次迭代后，$B_k$ 按如下公式更新：</p><p>$$<br>B_{k + 1} = B_k + \frac{y_k y_k<sup>T}{y_k</sup>T \delta_k} - \frac{B_k \delta_k \delta_k^T B_k}{\delta_k^T B_k \delta_k}<br>$$</p><p>其中，</p><ul><li>$\delta_k = w^{(k + 1)} - w^{(k)}$ 表示参数的变化，</li><li>$y_k = g_{k + 1} - g_k$ 表示梯度的变化。</li></ul><p>$B_k$ 的更新保证了其对称正定性，并逐步逼近真实的 Hessian 矩阵，从而提升搜索方向的准确性和收敛速度。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件随机场</title>
    <link href="/2025/06/01/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/"/>
    <url>/2025/06/01/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>本章仅讨论条件随机场在 <strong>标注问题（tagging problem）</strong> 的应用，因此主要讲述 <strong>线性链（linear chain）</strong> 条件随机场。</p><h2 id="概率无向图模型">概率无向图模型</h2><h3 id="成对马尔可夫性">成对马尔可夫性</h3><p>节点 $u$、$v$ 和所有其他节点 $O$，对应的随机变量分别为 $Y_u$、$Y_v$、$Y_O$（$Y$ 表示随机变量）。它们具有以下概率关系：<br>$$<br>P(Y_u, Y_v | Y_O) = P(Y_u | Y_O) P(Y_v | Y_O)<br>$$</p><h3 id="局部马尔可夫性">局部马尔可夫性</h3><p>节点 $v$，$W$ 是与 $v$ 相邻的所有节点，$O$ 是其余节点。它们具有以下概率关系：<br>$$<br>P(Y_v, Y_O | Y_W) = P(Y_v | Y_W) P(Y_O | Y_W)<br>$$</p><h3 id="全局马尔可夫性">全局马尔可夫性</h3><p>节点集合 $A$、$B$、$C$，其中 $A$ 和 $B$ 被 $C$ 分离。它们具有以下概率关系：<br>$$<br>P(Y_A, Y_B | Y_C) = P(Y_A | Y_C) P(Y_B | Y_C)<br>$$</p><h3 id="Definition-概率无向图模型">Definition: 概率无向图模型</h3><p>如果联合概率分布 $P(Y)$ 满足上述三个马尔可夫性质，就称此联合概率分布为概率无向图模型。</p><h3 id="Definition-团与最大团">Definition: 团与最大团</h3><p><strong>团（Clique）：</strong> 图中的一个子集，其中任意两个节点都相邻连接。</p><p><strong>最大团（Maximum Clique）：</strong> 不能再添加其他节点的团，即包含所有可能相邻节点的最大子集。</p><h3 id="概率无向图模型的因子分解">概率无向图模型的因子分解</h3><p>$$<br>\begin{align}<br>P(Y) &amp;= \frac{1}{Z} \prod_{C} \psi_{C}(Y_C), \quad C \text{ is a maximum clique}<br>\<br>Z &amp;= \sum_{Y} \prod_{C} \psi_{C}(Y_C), \quad Z \text{ is normalization factor}<br>\<br>\psi_{C}(Y_C) &amp;= \exp{-E(Y_C) }<br>\end{align}<br>$$</p><p>其中，$\psi$ 函数称为<strong>势函数</strong>，常用<strong>指数函数</strong>定义势函数。</p><p>$$<br>\psi_{C}(Y_{C}) = e ^{- H_{C}(Y_{C})}<br>$$</p><p>$H_{C}(Y_{C})$ 是一个定义在变量 $Y_{C}$ 上的实值函数，常见形式为</p><p>$$<br>H_{C}(Y_{C}) = \sum_{u,v \in C, u \neq v} \alpha_{uv} x_u x_v + \sum_{v \in C} \beta_v x_v<br>$$</p><p>其中，$\alpha_{uv}$ 和 $\beta_{v}$ 是参数。</p><hr><h2 id="CRF">CRF</h2><h3 id="Definition-线性链条件随机场">Definition: 线性链条件随机场</h3><p>我们假设 $X$ 和 $Y$ 是随机变量。如果随机变量 $Y$ 是一个马尔可夫随机场，即满足：<br>$$<br>P(Y_v | X, Y_w, w \neq v) = P(Y_v | X, Y_w, w \sim v)<br>$$<br>其中 $w \sim v$ 表示节点 $v$ 与节点 $w$ 相邻。</p><blockquote><p>通常情况下，我们认为 $X$ 与 $Y$ 具有相同的结构。</p></blockquote><img src="/2025/06/01/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/Linear-Chain.png" class="" title="具有相同结构的线性链"><div align = "center"><em>图1：线性链示例</em></div><p>我们有如下概率关系。<br>$$<br>P(Y_i | X, Y_1, \dots, Y_{i-1}, Y_{i+1}, \dots, Y_n) = P(Y_i | X, Y_{i - 1}, Y_{i + 1})<br>$$</p><h3 id="条件随机场的参数化形式">条件随机场的参数化形式</h3><p>$$<br>P(\mathbf{y} | \mathbf{x}) = \frac{1}{Z(\mathbf{x})} \exp \left(\sum_{i,k}\lambda_k t_k(y_{i -1}, y_i, \mathbf{x}, i) + \sum_{i,l}\mu_l s_l(y_i, \mathbf{x}, i))\right)<br>$$</p><p>其中，</p><p>$$<br>Z(\mathbf{x}) = \sum_{\mathbf{y}} \exp \left(\sum_{i,k}\lambda_k t_k(y_{i -1}, y_i, \mathbf{x}, i) + \sum_{i,l}\mu_l s_l(y_i, \mathbf{x}, i)\right)<br>$$</p><p>其中，$t_k$ 和 $s_l$ 是特征函数，$\lambda_k$ 和 $\mu_l$ 是对应的权重参数。</p><p><strong>Simplification</strong></p><p>$$<br>f_k(y_{i-1}, y_i, \mathbf{x}, i) =<br>\begin{cases}<br>t_k(y_{i-1}, y_i, \mathbf{x}, i), \quad &amp;k = 1,2, \dots,K_1 \\<br>s_l(y_i, \mathbf{x}, i), \quad &amp;k = K_1 + l; \text{ } l = 1,2,\dots, K_2<br>\end{cases}<br>$$</p><p>$$<br>f_k(\mathbf{y}, \mathbf{x}) = \sum_{i=1}^{n} f_k(y_{i-1}, y_i, \mathbf{x}, i), \quad k = 1,2,\dots,K<br>$$</p><p>$$<br>w_k =<br>\begin{cases}<br>\lambda_k, &amp;k = 1,2,\dots,K_1 \\<br>\mu_l, &amp;k = K_1 + l; \text{ } l = 1, 2, \dots, K_2<br>\end{cases}<br>$$<br>即，</p><p>$$<br>\begin{align*}<br>P(\mathbf{y} \mid \mathbf{x}) &amp;= \frac{1}{Z(\mathbf{x})} \exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right) \\<br>Z(\mathbf{x}) &amp;= \sum_{\mathbf{y}} \exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right)<br>\end{align*}<br>$$<br>注意，这里的 $\sum_{\mathbf{y}}$ 是在对所有可能的标签序列求和，而不仅仅是一个确定的标签序列。</p><p>最后，</p><p>$$<br>\begin{align}<br>P_{\mathbf{w}}(\mathbf{y} \mid \mathbf{x}) = \frac{\exp(\vec{w} \cdot \vec{F}(\mathbf{y}, \mathbf{x}))}{Z_{\mathbf{w}}(\mathbf{x})}<br>\end{align}<br>$$</p><p>$$<br>Z_{\mathbf{w}}(\mathbf{x}) = \sum_{\mathbf{y}} \exp(\vec{w} \cdot \vec{F}(\mathbf{y}, \mathbf{x}))<br>$$</p><h3 id="矩阵形式">矩阵形式</h3><p>对于每个标签序列，我们引入特殊的起始点和结束点标签，$y_0 = \text{start}$ 和 $y_{n+1} = \text{stop}$。对于观测序列 $\mathbf{x}$ 中的每个位置 $i = 1,2,\dots,n+1$，我们可以定义一个矩阵 $M_i \in \mathbb{R}^{m \times m}$：</p><p>$$<br>\begin{align*}<br>M_i(\mathbf{x}) &amp;= [M_i(y_{i-1}, y_i | \mathbf{x})]<br>\\<br>M_i(y_{i-1}, y_i |\mathbf{x}) &amp;= \exp \left(W_i(y_{i-1}, y_i | \mathbf{x})\right)<br>\\<br>W_i(y_{i-1}, y_i |\mathbf{x}) &amp;= \sum_{k=1}^{K}w_kf_k(y_{i-1},y_i,\mathbf{x},i)<br>\end{align*}<br>$$</p><p>因此：<br>$$<br>P_w(\mathbf{y} |\mathbf{x}) = \frac{1}{Z_w(\mathbf{x})} \prod_{i=1}^{n+1} M_i(y_{i-1}, y_i |\mathbf{x})<br>$$</p><p>特别地：<br>$$<br>Z_w(\mathbf{x}) = [M_1(\mathbf{x})M_2(\mathbf{x}) \cdots M_{n+1}(\mathbf{x})]_{\text{start},\text{stop}}<br>$$</p><p>也就是矩阵 $(\text{start}, \text{stop})$ 位置上的元素。</p><p>矩阵形式不难理解，CRF 中的 $M_i(\mathbf{x})$ 矩阵就是在每个位置 $i$ 上，枚举所有可能的标签对 $(y_{i-1}, y_i)$，并计算它们的转移得分。例如 $m = 2$，$Y = {A, B}$，则 $M_1$ 为：</p><p>$$<br>M_1(\mathbf{x}) =<br>\begin{bmatrix}<br>M_1(A, A \mid \mathbf{x}) &amp; M_1(A, B \mid \mathbf{x}) \\<br>M_1(B, A \mid \mathbf{x}) &amp; M_1(B, B \mid \mathbf{x})<br>\end{bmatrix}<br>$$</p><hr><h2 id="计算">计算</h2><p>接下来给出计算 $P(Y_i = y_i |\mathbf{x})$、$P(Y_{i - 1} = y_{i - 1}, Y_i = y_i |\mathbf{x})$ 以及相应数学期望的解决方法。</p><h3 id="前向-后向算法">前向-后向算法</h3><p>对于每个索引 $i = 0, 1, \dots, n + 1$，我们定义前向列向量 $\alpha_i(x)$：</p><p>$$<br>\alpha_0(y|\mathbf{x}) =<br>\begin{cases}<br>1, &amp;y = \text{start}<br>\\<br>0, &amp;\text{其他情况}<br>\end{cases}<br>$$</p><p>递推公式为：</p><p>$$<br>\alpha_i^T(y_i|\mathbf{x}) = \alpha_{i-1}^T (y_{i-1}|\mathbf{x}) [M_i(y_{i-1},y_i|\mathbf{x})],\quad i = 1,2,\dots,n+1 \tag{forward}<br>$$</p><p>同样地，我们定义后向行向量：</p><p>$$<br>\begin{align}<br>\beta_{n+1}(y_{n+1}|\mathbf{x}) &amp;=<br>\begin{cases}<br>1, &amp;y_{n+1} = \text{stop}<br>\\<br>0, &amp;\text{其他情况}<br>\end{cases}<br>\\<br>\beta_i(y_i|\mathbf{x})&amp; = [M_{i+1}(y_i,y_{i+1}|\mathbf{x})] \beta_{i+1}(y_{i+1}|\mathbf{x}) \tag{backward}<br>\end{align}<br>$$</p><h3 id="概率计算">概率计算</h3><p>$$<br>P(Y_i = y_i | \mathbf{x}) = \frac{\alpha_i^T(y_i | \mathbf{x}) \beta_i(y_i | \mathbf{x})}{Z(\mathbf{x})}<br>$$</p><p>$$<br>P(Y_{i-1} = y_{i-1}, Y_i = y_i |\mathbf{x}) = \frac{\alpha_{i-1}^T(y_{i-1} |\mathbf{x}) M_i(y_{i-1},y_i |\mathbf{x}) \beta_i(y_i |\mathbf{x})}{Z(\mathbf{x})}<br>$$</p><p>其中：</p><p>$$<br>Z(\mathbf{x}) = \alpha_n^T(\mathbf{x})\mathbf{1} = \mathbf{1}^T \beta_1(\mathbf{x})<br>$$</p><p><strong>可以仿照隐马尔科夫模型计算相似问题时引入 $\alpha$ 和 $\beta$ 矩阵</strong>，</p><h4 id="前向向量矩阵-alpha">前向向量矩阵 $\alpha$</h4><p>$$<br>\alpha = \begin{bmatrix}<br>\alpha_0(A) &amp; \alpha_0(B) &amp; \cdots &amp; \alpha_0(N) \\[10pt]<br>\alpha_1(A) &amp; \alpha_1(B) &amp; \cdots &amp; \alpha_1(N) \\[10pt]<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\[10pt]<br>\alpha_{n+1}(A) &amp; \alpha_{n+1}(B) &amp; \cdots &amp; \alpha_{n+1}(N)<br>\end{bmatrix}^{T} \tag{CRF-1}<br>$$</p><p>每一行表示在位置 $i$ 的前向向量 $\alpha_i$，每一列对应一个标签 $y_i \in \mathcal{Y}$。</p><h4 id="后向向量矩阵-beta">后向向量矩阵 $\beta$</h4><p>$$<br>\beta = \begin{bmatrix}<br>\beta_0(A) &amp; \beta_0(B) &amp; \cdots &amp; \beta_0(N) \\[10pt]<br>\beta_1(A) &amp; \beta_1(B) &amp; \cdots &amp; \beta_1(N) \\[10pt]<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\[10pt]<br>\beta_{n+1}(A) &amp; \beta_{n+1}(B) &amp; \cdots &amp; \beta_{n+1}(N)<br>\end{bmatrix} \tag{CRF-2}<br>$$</p><p>每一行表示在位置 $i$ 的后向向量 $\beta_i$，每一列对应一个标签 $y_i \in \mathcal{Y}$。</p><h3 id="期望值计算">期望值计算</h3><p>比较复杂，详情参考《统计学习方法》</p><hr><h2 id="优化学习算法">优化学习算法</h2><p>优化学习算法涉及改进迭代尺度法、梯度下降法以及拟牛顿法。这些方法曾在最大熵的学习算法中提及，可以比对学习。</p><h3 id="改进的迭代尺度法">改进的迭代尺度法</h3><p>已知训练数据集，由此可知经验概率分布 $\tilde{P}(X, Y)$。可以通过极大化训练数据的对数似然函数来求模型参数。</p><p>训练数据的对数似然函数为：</p><p>$$<br>L(w) = L_{\tilde{P}}(P_{w}) = \sum_{\mathbf{x} ,\mathbf{y}} \tilde{P}(\mathbf{x} ,\mathbf{y}) \log P_{w}(\mathbf{y} |\mathbf{x})<br>$$</p><p>若</p><p>$$<br>\begin{align*}<br>P(\mathbf{y} \mid \mathbf{x}) &amp;= \frac{1}{Z(\mathbf{x})} \exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right) \\<br>Z(\mathbf{x}) &amp;= \sum_{\mathbf{y}} \exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right)<br>\end{align*}<br>$$</p><p>则</p><p>$$<br>L(w) = \sum_{j = 1}^{N} \sum_{k = 1}^{K} w_{k} f_{k}(y_j, x_j) - \sum_{j = 1}^{N} \log Z_w(x_j)<br>$$</p><h3 id="拟牛顿法">拟牛顿法</h3><p>这里介绍的拟牛顿法是 $\mathbf{BFGS}$ 算法。</p><p><strong>输入</strong>：特征函数 $f_1, f_2, \cdots, f_n$；经验分布 $\tilde{P}(X, Y)$；精度要求 $\epsilon$；<br><strong>输出</strong>：最优参数值 $\hat{w}$；最优模型 $P_{\hat{w}}(\mathbf{y} |\mathbf{x})$。</p><ol><li>选定初始点 $w^{(0)}$，取 $B_0$ 为正定对称矩阵，置 $k = 0$。</li><li>计算 $g_k = g(w^{(k)})$。  若 $\lVert g_k \rVert &lt; \epsilon$，则停止计算，得 $w^{*} = w^{(k)}$；否则转第 3 步。</li><li>由 $B_k p_k = -g_k$ 求出 $p_k$。</li><li>一维搜索，求 $\lambda_k$ 使得<br>$$<br>f(w^{(k)} + \lambda_k p_k) = \min_{\lambda \geq 0} f(w^{(k)} + \lambda p_k)<br>$$</li><li>置 $w^{(k + 1)} = w^{(k)} + \lambda_k p_k$。</li><li>计算 $g_{k + 1} = g(w^{(k + 1)})$。  若 $\lVert g_{k + 1} \rVert &lt; \epsilon$，则停止计算，得 $w^{*} = w^{(k + 1)}$；否则，按下式求出 $B_{k + 1}$：<br>$$<br>B_{k + 1} = B_k + \frac{y_k y_k<sup>T}{y_k</sup>T \delta_k} - \frac{B_k \delta_k \delta_k^T B_k}{\delta_k^T B_k \delta_k}<br>$$<br>其中，<br>$$<br>y_k = g_{k + 1} - g_k, \quad \delta_k = w^{(k + 1)} - w^{(k)}<br>$$</li><li>置 $k = k + 1$，转第 3 步。</li></ol><h2 id="条件随机场的预测算法">条件随机场的预测算法</h2><p>采用隐马尔科夫模型相似的预测算法</p><h3 id="维特比算法">维特比算法</h3><p><strong>输入</strong>：</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Network Layer</title>
    <link href="/2025/05/30/The-Network-Layer/"/>
    <url>/2025/05/30/The-Network-Layer/</url>
    
    <content type="html"><![CDATA[<h1>Introduction</h1><p>网络层有如下功能：</p><ul><li>将从 transport layer 传来的 <strong>segment</strong> 打包成 <strong>datagram</strong>，再将 <strong>datagram</strong> 中的 <strong>segment</strong> 分离开传给 transport layer。</li><li>网络层协议应用在 <strong>host</strong> 和 <strong>router</strong> 中。</li></ul><p><strong>Router</strong> 和 <strong>Switch</strong> 都属于 <strong>packet switch</strong>。</p><p>尽管路由器和链路层交换机都被称为<strong>packet switches</strong>（分组交换机），但它们有以下根本区别：</p><ol><li><p><strong>工作层次不同</strong>：</p><ul><li>路由器（Router）：工作在<strong>网络层</strong>（第3层）</li><li>链路层交换机：工作在<strong>链路层</strong>（第2层）</li></ul></li><li><p><strong>转发决策依据</strong>：</p><ul><li>路由器：基于<strong>IP地址</strong>（网络层地址）做出转发决策</li><li>链路层交换机：基于<strong>MAC地址</strong>（物理地址）做出转发决策</li></ul></li><li><p><strong>功能范围</strong>：</p><ul><li>路由器：能够连接<strong>不同网络</strong>，执行<strong>路由决策</strong>和<strong>网络互联</strong></li><li>链路层交换机：主要在<strong>同一网络内</strong>转发帧</li></ul></li><li><p><strong>网络视角</strong>：</p><ul><li>路由器：能看到网络的<strong>拓扑结构</strong>，具有全局视野</li><li>链路层交换机：仅限于<strong>局部链路</strong>的连接情况</li></ul></li></ol><p>路由器拥有的IP地址数量<strong>通常等于其活跃网络接口的数量</strong>。这是因为：</p><ul><li>路由器的<strong>每个接口</strong>都需要一个IP地址来参与其所连接网络的通信</li><li>不同接口连接到不同的网络，因此需要不同的IP地址</li></ul><h2 id="Forwarding-and-Routing">Forwarding and Routing</h2><p>这两个功能十分好理解：</p><ul><li><strong>Forwarding：</strong> 一个 router 中，决定如何移动 datagram 到正确的输出。</li><li><strong>Routing：</strong> 决定 datagram 在整个网络中的传输路线。</li></ul><h2 id="Network-Service-Model">Network Service Model</h2><p>需要保证，对 <strong>individual datagram</strong>：正确传输和传输时间；对 <strong>a flow of datagrams</strong>： 顺序接受，完整传输和传输最小带宽。</p><h1>Virtual Circuit and Datagram Networks</h1><p>网络层有两种服务：<strong>connectionless service</strong> 和 <strong>connection service</strong>；这两种服务分别应用在 <strong>datagram network</strong> 和 <strong>virtual circuit network</strong>。</p><h2 id="Datagram-Network">Datagram Network</h2><p>数据包网络使用的是<strong>动态路由</strong>，每一个数据包可以根据当前的网络状况独立地选择路径。</p><h3 id="Forwarding-Table">Forwarding Table</h3><p><strong>Forwarding table</strong> 应用在 <strong>router</strong> 中，决定如何移动 datagram 到正确的输出。</p><p>具体形式如下表格所示，可以看到就是一个简单的地址到接口的映射</p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr><th style="text-align:center"><strong>Destination Address Range</strong></th><th style="text-align:center"><strong>Link Interface</strong></th></tr></thead><tbody><tr><td style="text-align:center">$\sim$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">$\sim$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">otherwise</td><td style="text-align:center">$2$</td></tr></tbody></table></div><p><strong>需要注意的是</strong>：表格中的 <strong>Destination Address Range</strong> 可以不是完整的 IP address，而是其的一个前缀；比如 <strong>00111000</strong>，对应的地址范围是 <strong>00111000 00000000 00000000 00000000</strong> 到 <strong>00111000 11111111 11111111 11111111 11111111</strong>。这时 forwarding table 变成：</p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr><th style="text-align:center"><strong>Header</strong></th><th style="text-align:center"><strong>Link Interface</strong></th></tr></thead><tbody><tr><td style="text-align:center">$\sim$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">$\sim$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">otherwise</td><td style="text-align:center">$2$</td></tr></tbody></table></div><h1>What’s inside a Router</h1><p>有两个重要的路由功能：</p><ul><li>运行路由算法。</li><li>推送 datagram。</li></ul><h2 id="Input-Port">Input Port</h2><div align="center"><pre><code class=" mermaid">flowchart LR    A[Line Termination &lt;br&gt; bit-level reception] --&gt; B[Data Link Processing]    B --&gt; C[Look up and Forwarding &lt;br&gt; Queueing]    C --&gt; D[Switch Fabric]</code></pre></div><p>这里涉及到的 <strong>look up and forwarding</strong> 的方式是 <strong>decentralized switching</strong>，也就是 <strong>forwarding table</strong> 已经存入到了 input port 的 <strong>memory</strong> 中。</p><h2 id="Switching-Fabric">Switching Fabric</h2><p>有三种 <strong>switching fabrics</strong>。</p><h3 id="Switching-via-Memory">Switching via Memory</h3><p>这时可以把路由器看作是一个 <strong>computer</strong>。使用电脑的 <strong>CPU</strong> 来 switching。</p><p>这个流程是，先把 datagram 拷贝到电脑 <strong>memory</strong> 中，在从 memory 传到相应的 output port。</p><p>可以分析的是：<strong>memory bandwidth</strong> 是限制 <strong>switching rate</strong> 的主要因素。同时需要注意的是，每个 datagram 会经过两次 <strong>system bus</strong>。</p><h3 id="Switching-via-Bus">Switching via Bus</h3><p>其中只用到一个 bus。bus bandwidth 限制了 <strong>switching speed</strong>。</p><h3 id="Switching-via-Interconnection-Network">Switching via Interconnection Network</h3><p>网状结构。先 <strong>fragmenting datagram</strong> into fixed length cells，再 switch cells through the fabric。</p><h2 id="Output-Port">Output Port</h2><div align="center"><pre><code class=" mermaid">flowchart LR    A[Switch Fabric] --&gt; B[Queueing: Buffer Management]    B --&gt; C[Data Link Processing]    C --&gt; D[Line Termination]</code></pre></div><h3 id="Output-Port-Queueing">Output Port Queueing</h3><p>Buffering when arrival rate via switch <strong>exceeds</strong> output line speed. Queueing (<strong>delay</strong>) and loss due to output port buffer overflows.</p><p>所以，需要多大的 buffer？假设 <strong>typical $\text{RTT}$</strong>（一般是 $250$ ms），link capacity $C$，有 $N$ 个 datagram flow。则：<br>$$<br>\text{buffering} = \frac{\text{RTT} \cdot C}{\sqrt{N}}<br>$$</p><h3 id="Input-Port-Queueing">Input Port Queueing</h3><p>同样，输入端也会堵塞。应用了名叫 <strong>Head-of-the-Line (HOL) blocking</strong> 的机制，这个机制很好理解：就是排在前面的 datagram 传输了，其后面的 datagram 才能传输。</p><h1>Internet Protocol</h1><p>这个协议干了三件事：<strong>addressing conventions</strong>（地址约定），<strong>datagram format</strong>，<strong>packet handling conventions</strong>（分组处理约定）。</p><h2 id="IP-Datagram-Format">IP Datagram Format</h2><h3 id="IPv4">IPv4</h3><p><img src="The-Network-Layer/IPv4%20datagram%20format.png" alt="IPv4 datagram format">{style=&quot;display: block; margin: 0 auto; width: 60%&quot;}</p><p><strong>总结表格：</strong></p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr><th>字段名</th><th>长度</th><th>作用/说明</th></tr></thead><tbody><tr><td>Version</td><td>4 位</td><td>IP 协议版本号</td></tr><tr><td>Header Length</td><td>4 位</td><td>首部长度（单位：$4$ 字节，最少 $5$ ）</td></tr><tr><td>Type of Service</td><td>8 位</td><td>服务类型/QoS</td></tr><tr><td>Datagram Length</td><td>16 位</td><td>数据报总长度（单位：$1$ 字节）</td></tr><tr><td>Identifier</td><td>16 位</td><td>分片标识符</td></tr><tr><td><strong>Flags</strong></td><td>3 位</td><td>分片控制标志</td></tr><tr><td><strong>Fragmentation Offset</strong></td><td>13 位</td><td>分片偏移量（单位：$8$ 字节）</td></tr><tr><td>Time-to-Live (TTL)</td><td>8 位</td><td>生存时间/最大跳数</td></tr><tr><td>Upper-layer Protocol</td><td>8 位</td><td>上层协议类型</td></tr><tr><td>Header Checksum</td><td>16 位</td><td>首部校验和</td></tr><tr><td>Source IP Address</td><td>32 位</td><td>源 IP 地址</td></tr><tr><td>Destination IP Address</td><td>32 位</td><td>目的 IP 地址</td></tr><tr><td>Options</td><td>可变</td><td>可选字段</td></tr><tr><td>Data</td><td>可变</td><td>负载数据</td></tr></tbody></table></div><p><strong>补充</strong>：</p><ul><li><strong>Flags</strong> 有 $3$ 位，第一位恒为 $0$，第二位表示 <strong>Don’t fragment</strong>（不可分片），第三位表示 <strong>More fragments</strong>（后续有分片）。为 $1$ 的时候相应功能开启。</li></ul><h3 id="IP-Fragmentation-and-Reassembly">IP Fragmentation and Reassembly</h3><p>从 IPv4 的 datagram format 中可以发现，必要时会对 datagram 切片。</p><p><strong>MTU</strong>：max transfer size。这是对 <strong>link</strong> 而言，也就是说不同的 <strong>link</strong> 有不同的 <strong>MTU</strong>。</p><p><strong>Fragmentation and Reassembly</strong> 的过程很简单，就是需要时切分 datagram，最后在最终目的主机的网络层进行：只有当所有分片都到达后，网络层才会将完整的数据报交给上层（如传输层）。</p><p>假设原 IP datagram 总长度为 $L$，待转发链路的 MTU 为 $M$，若 $L &gt; M$ 且 DF 为 $0$，则需要分片。</p><ul><li>先复制 <strong>Identifier</strong>。</li><li>一个切片可封装的数据为：$$d = \left \lfloor \frac{M - 20}{8} \right \rfloor \times 8$$</li><li>需要的总片数为：$$n = \left \lceil \frac{L - 20}{d} \right \rceil$$</li></ul><h2 id="IPv4-Addressing">IPv4 Addressing</h2><h3 id="Subnet">Subnet</h3><p><strong>IP address</strong>: subnet part (high order bits) $+$ host part (low order bits).</p><p>在一个 subnet 中的所有设备都可以直接<strong>物理意义上</strong>地连接。</p><p><strong>Subnet mask</strong>：用类似 <code>/24</code> 的形式表示。也就是说，前 $24$ 相同的 IP address 在同一个 subnet 中。</p><h4 id="Classes-Inter-Domain-Routing-CIDR">Classes Inter Domain Routing: CIDR</h4><p>规定了 address format 为 <code>a.b.c.d/x</code>。</p><h4 id="Dynamic-Host-Configuration-Protocol-DHCP">Dynamic Host Configuration Protocol: DHCP</h4><p><strong>Goal</strong>: allow host to dynamically get his IP address from a server when it joins network.</p><ul><li>Can renew its lease on address in use.</li><li>Allows reuse of address.</li><li>Support for mobile users who want to join network.</li></ul><p><strong>DHCP</strong>（Dynamic Host Configuration Protocol，动态主机配置协议）是一个<strong>网络管理协议</strong>，用于在IP网络中<strong>自动分配IP地址和其他网络配置参数</strong>给网络设备。DHCP运行在<strong>应用层</strong>，使用<strong>UDP协议</strong>，客户端使用<strong>端口68</strong>，服务器使用<strong>端口67</strong>。</p><p><img src="The-Network-Layer/DHCP%20client-server%20interaction.png" alt="DHCP client-server interaction">{style=&quot;display: block; margin: 0 auto; width: 50%&quot;}</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>步骤</th><th>消息类型</th><th>发送者</th><th>接收者</th><th>主要内容</th></tr></thead><tbody><tr><td>1</td><td>DISCOVER</td><td>客户端</td><td>广播</td><td>&quot;我需要一个IP地址&quot;</td></tr><tr><td>2</td><td>OFFER</td><td>服务器</td><td>客户端</td><td>&quot;你可以使用这个IP&quot;</td></tr><tr><td>3</td><td>REQUEST</td><td>客户端</td><td>广播</td><td>&quot;我想使用这个IP&quot;</td></tr><tr><td>4</td><td>ACK</td><td>服务器</td><td>客户端</td><td>&quot;IP已分配，租期为X&quot;</td></tr></tbody></table></div><p><strong>yiaddr</strong>（your IP address）是DHCP协议中表示<strong>服务器提供给客户端的IP地址</strong>的字段。</p><p><strong>补充</strong>：DHCP 还可以 return <strong>address of first-hop router for client</strong>，<strong>name and IP address of DNS server</strong>，<strong>network mask</strong>。</p><h3 id="Network-Address-Translation-NAT">Network Address Translation: NAT</h3><p><img src="The-Network-Layer/Network%20address%20translation.png" alt="Network address translation">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p>右边：局域网内通信，使用内部地址：<code>10.0.0/24</code>；左边：局域网外通信，共用唯一地址。注意，没有共用同一个端口号，因为端口号是用来区分的。比如：</p>  <div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align:center">WAN 侧 (对外显示)</th><th style="text-align:center">LAN 侧 (实际主机)</th></tr></thead><tbody><tr><td style="text-align:center">203.0.113.5:50001</td><td style="text-align:center">192.168.1.10:3345</td></tr><tr><td style="text-align:center">203.0.113.5:50002</td><td style="text-align:center">192.168.1.10:3346</td></tr><tr><td style="text-align:center">203.0.113.5:50003</td><td style="text-align:center">192.168.1.11:3345</td></tr></tbody></table>  </div><p>这样布置有一个比较好的优势：可以更换 ISP 的同时不改变局域网内的地址。</p><p>注意到中间的 <strong>NAT router</strong>。它的功能如下：</p><ul><li>对 <strong>outgoing datagrams</strong>，把原始 IP address 和 port 更换为自己的 IP address 和 port。</li><li>再把上述转换记下来记为 <strong>NAT translation table</strong>。</li><li>对 <strong>incoming datagrams</strong>，更换。</li></ul><p>现在回顾 NAT，不难察觉几个问题：</p><ul><li>如果 LAN 中的 host 想要通过 P2P 进行 communication，此时该怎么办？</li><li>如果一个服务器是 NAT 的 LAN 地址，怎么办？</li></ul><h2 id="Internet-Control-Message-Protocol-ICMP">Internet Control Message Protocol: ICMP</h2><p>这个协议 used by hosts and routers to communicate network-level information。具体包括：</p><ul><li>Error reporting.</li><li>Echo request and reply.</li></ul><p><strong>ICMP message</strong> 的结构包括：<strong>type</strong>、<strong>code</strong>、<strong>checksum</strong> 以及数据部分。</p><p>具体用来干什么？</p><ul><li>通过发送 UDP segment，在 IP datagram header 内设置适当的 TTL，来计算 $\text{RTT}$。</li><li>还可以用来停止 source 持续发送 UDP segment。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>字段名</th><th>长度</th><th>作用/说明</th></tr></thead><tbody><tr><td><strong>Type</strong></td><td>8位</td><td>消息类型（如0=回显回复，3=目的不可达，8=回显请求）</td></tr><tr><td><strong>Code</strong></td><td>8位</td><td>消息子类型（进一步说明类型）</td></tr><tr><td><strong>Checksum</strong></td><td>16位</td><td>校验和（覆盖整个ICMP消息）</td></tr><tr><td><strong>Rest of Header</strong></td><td>32位</td><td>取决于Type和Code的其他信息</td></tr><tr><td><strong>Data</strong></td><td>可变</td><td>负载数据（例如原始数据包的片段）</td></tr></tbody></table></div><h2 id="IPv6">IPv6</h2><p>为了解决 IPv4 地址不足。具体 format 不讲，但要注意 header 大小为 $40$ bytes，只有 address 大小变为 $128$ bits。</p><h3 id="Transition-from-IPv4-to-IPv6">Transition from IPv4 to IPv6</h3><p><img src="The-Network-Layer/Tunneling.png" alt="Tunneling">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><p><strong>Tunneling</strong>: IPv6 carried as payload in IPv4 datagram among Ipv4 routers.</p><h1>Routing Algorithms</h1><h2 id="Software-Defined-Networking-SDN">Software-Defined Networking: SDN</h2><p>实际上，network layer 可以分为 <strong>data plane</strong> 和 <strong>control plane</strong>，在 <strong>control plane</strong> 有一个 logically centralized routing controller，由它 compute paths。</p><h2 id="Link-State-Algorithm">Link State Algorithm</h2><h3 id="Dijkstra’s-Link-State-Algorithm">Dijkstra’s Link-State Algorithm</h3><p>伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">N = &#123;u&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : nodes) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isAdjacent</span>(u, a)) &#123;<br>      D[a] = <span class="hljs-built_in">Cost</span>(u, a);<br>      P[a] = u;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      D[a] = INF;<br>      P[a] = a;<br>      &#125;<br>&#125;<br><span class="hljs-keyword">while</span> (! all nodes in N) &#123;<br>    D[a] = <span class="hljs-built_in">min</span>(D)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> b : nodes) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isAdjacent</span>(b ,a)) &#123;<br>          D[b] = <span class="hljs-built_in">min</span>(D[b], <span class="hljs-built_in">Cost</span>(b, a) + D[a])<br>          <span class="hljs-keyword">if</span> (D[b] == <span class="hljs-built_in">Cost</span>(b, a) + D[a]) P[b] = a;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际做题的时候可以参考书上的风格：</p><p>记 $N’$ 为<strong>已找到最短路径</strong>的点集合，函数 $D(x)$ 为到点 $x$ 的最短路径，函数 $P(x)$ 为点 $x$ 的父母结点。可以规范化求解过程如下，其中 $0$ 轮初始化。</p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr><th style="text-align:center"><strong>Step</strong></th><th style="text-align:center"><strong>$N’$</strong></th><th style="text-align:center"><strong>$D(),P()$</strong></th><th style="text-align:center"><strong>$D(),P()$</strong></th><th style="text-align:center"><strong>$\cdots$</strong></th><th style="text-align:center"><strong>$D(),P()$</strong></th></tr></thead><tbody><tr><td style="text-align:center">$0$</td><td style="text-align:center">$u$</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td></tr><tr><td style="text-align:center">$1$</td><td style="text-align:center">$uv$</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td></tr><tr><td style="text-align:center">$2$</td><td style="text-align:center">$uvw$</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td></tr><tr><td style="text-align:center">$\cdots$</td><td style="text-align:center">$\cdots$</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td></tr><tr><td style="text-align:center">$N$</td><td style="text-align:center">$uvw \cdots l$</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td><td style="text-align:center">dis  node</td></tr></tbody></table></div><p>这样可以求出从起点到图中其它点的所有最短路径。可以用来制作 forwarding table。</p><p>可以用<strong>优先队列</strong>优化时间复杂度。</p><p>这里需要提到一个概念 <strong>Oscillation possible</strong>，指的是网络路由状态可能出现反复波动、难以稳定的现象，是网络设计和协议实现中需要重点关注和避免的问题。这可能会导致在 Link State Algorithm 中计算到无穷的结果。</p><h2 id="Distance-Vector-Algorithm">Distance Vector Algorithm</h2><p><strong>Distributed Bellman-Ford equation</strong>: $$D(x \to y) = \min_{v} {\text{Cost}_{x \to v} + D(v \to y), , D(x \to y)}$$</p><p>其中，$v$ 是 $x$ 的邻居。</p><p>这是一个 <strong>iterative</strong> 算法，需要多次计算，直到收敛。计算过程可以参考课本，如下表所述，结点 $z$ 的 table。</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align:center">$z$</th><th style="text-align:center">cost to</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">$x$</td><td style="text-align:center">$y$</td><td style="text-align:center">$z$</td><td style="text-align:center">$u$</td><td style="text-align:center">$v$</td></tr><tr><td style="text-align:center">from $x$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$3$</td></tr><tr><td style="text-align:center">from $y$</td><td style="text-align:center">$3$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$2$</td><td style="text-align:center">$\infty$</td></tr><tr><td style="text-align:center">from $z$</td><td style="text-align:center">$2$</td><td style="text-align:center">$5$</td><td style="text-align:center">$0$</td><td style="text-align:center">$7$</td><td style="text-align:center">$5$</td></tr><tr><td style="text-align:center">from $u$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$2$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center">from $v$</td><td style="text-align:center">$3$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$6$</td><td style="text-align:center">$1$</td><td style="text-align:center">$\infty$</td></tr></tbody></table></div><h1>Hierarchical Routing</h1><p><strong>Internet approach to scalable routing</strong>: aggregate routers into regions known as <strong>autonomous system (AS)</strong></p><p><img src="The-Network-Layer/AS%20structure.jpg" alt="AS structure">{style=&quot;display: block; margin: 0 auto; width: 100%&quot;}</p><h2 id="Intra-AS-Routing-Protocol">Intra-AS Routing Protocol</h2><ol><li>RIP: Routing Information Protocol (wasted).</li><li>OSPF: Open Shortest Path First (Link-State).</li><li>EIGRP: Enhanced Interior Gateway Routing Protocol.</li></ol><h3 id="OSPF-Open-Shortest-Path-First">OSPF: Open Shortest Path First</h3><p>classic link-state:</p><ol><li>Each router floods <strong>OSPF</strong> link-state advertisements (over IP) to all routers.</li><li>Multiple link costs metrics possible: bandwidth, delay.</li><li>Each router has full topology, Dijkstra algorithm.</li></ol><p>Security: all OSPF messages authenticated</p><p><img src="The-Network-Layer/Hierarchical%20OSPF.png" alt="Hierarchical OSPF">{style=&quot;display: block; margin: 0 auto; width: 80%&quot;}</p><h2 id="Inter-AS-Protocol">Inter-AS Protocol</h2><h3 id="BGP-Border-Gateway-Protocol">BGP: Border Gateway Protocol</h3><p>BGP provides each AS a means to:</p><ul><li>obtain destination network reachability information form neighboring ASes eBGP.</li><li>determine routers to other networks based on reachability information and policy.</li><li>propagate reachability information to all AS-internal routers: iBGP.</li><li>advertise (to neighboring networks) destination reachability information.</li></ul><p><img src="The-Network-Layer/eBGP%20and%20iBGP%20sessions.png" alt="eBGP and iBGP sessions">{style=&quot;display: block; margin: 0 auto; width: 90%&quot;}</p><ul><li>BGP对等体（BGP peers）通过<strong>半永久TCP连接</strong>（BGP会话）交换路由信息。</li><li>BGP会话不一定对应物理链路。</li><li>当AS2向AS1通告前缀时：<ul><li>AS2 <strong>承诺</strong>会为该前缀转发数据报。</li><li>AS2可以在通告中聚合前缀。</li></ul></li><li>通过eBGP会话，AS3将前缀可达性信息发送给AS1。</li><li>AS1内部的路由器（如1c）通过iBGP将新前缀信息分发给AS1内所有路由器。</li><li>AS1的1b路由器可以通过eBGP会话将新前缀信息再通告给AS2。</li><li>路由器学到新前缀后，会在转发表中为该前缀创建条目。</li><li>BGP通告的前缀包含<strong>BGP属性</strong>，前缀+属性即为<strong>路由</strong>。</li><li>两个重要属性：<ul><li><strong>AS-PATH</strong>：记录前缀通告经过的AS序列（如AS 67, AS 17）。</li><li><strong>NEXT-HOP</strong>：指明到下一个AS的具体内部路由器（可能有多条链路）。</li></ul></li><li>当网关路由器收到路由通告时，会根据<strong>import policy</strong>（导入策略）决定是否接受该路由。</li></ul><p>假设有以下网络拓扑结构：</p><div style="display: block; margin: 0 auto; width: fit-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">        +------+<br>        | AS65 |<br>        +------+<br>       /        \<br>      /          \<br>+------+        +------+<br>| AS23 |--------| AS17 |<br>+------+        +------+<br>   |                |<br>+------+        +------+<br>| AS45 |        | AS78 |<br>+------+        +------+<br>                 /<br>             +------+<br>             | AS99 |---前缀：192.168.99.0/24<br>             +------+<br></code></pre></td></tr></table></figure></div><p>AS-PATH传播过程</p><p>假设AS99宣告前缀192.168.99.0/24，我们跟踪这个前缀在网络中的传播：</p><ol><li><p><strong>AS99向AS78通告前缀</strong>：</p><ul><li>AS99向AS78发送BGP更新：<code>192.168.99.0/24, AS-PATH=&#123;99&#125;</code></li><li>AS78收到前缀后，将其存入路由表</li></ul></li><li><p><strong>AS78向AS17通告前缀</strong>：</p><ul><li>AS78在转发前，将自己的AS号添加到AS-PATH</li><li>AS78发送BGP更新：<code>192.168.99.0/24, AS-PATH=&#123;78, 99&#125;</code></li></ul></li><li><p><strong>AS17向多个AS传播</strong>：</p><ul><li>AS17向AS23发送：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li><li>AS17向AS65发送：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li></ul></li><li><p><strong>AS23收到两种路径</strong>：</p><ul><li>从AS17：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li><li>从AS45（假设AS45也与AS99间接相连）：<code>192.168.99.0/24, AS-PATH=&#123;45, ..., 99&#125;</code></li><li>AS23基于AS-PATH长度和其他策略选择最佳路径</li></ul></li><li><p><strong>AS65收到更新后</strong>：</p><ul><li>获得路由：<code>192.168.99.0/24, AS-PATH=&#123;65, 17, 78, 99&#125;</code></li><li>若之后收到AS23的路由通告，也会比较两条路径</li></ul></li></ol><h1>Subnet、Prefix和BGP Route的对比分析</h1><h2 id="Subnet（子网）">Subnet（子网）</h2><p><strong>子网</strong>是指<strong>物理网络的逻辑划分</strong>，具有以下特征：</p><ul><li>由<strong>共享相同网络前缀</strong>的IP地址集合组成</li><li>通过<strong>网络地址</strong>和<strong>子网掩码</strong>定义（如192.168.1.0/24）</li><li>子网内设备可<strong>直接通信</strong>，无需路由器转发</li><li>代表<strong>单一广播域</strong>内的网络段</li><li>通常属于<strong>单一管理实体</strong></li></ul><h2 id="Prefix（前缀）">Prefix（前缀）</h2><p><strong>前缀</strong>是<strong>IP地址空间中的地址块</strong>，具有以下特征：</p><ul><li>用<strong>CIDR表示法</strong>表示（如10.0.0.0/8）</li><li>表示IP地址中固定的<strong>网络部分位数</strong></li><li>是<strong>路由表聚合</strong>的基础单位</li><li>可以表示<strong>不同大小</strong>的地址块</li><li>是<strong>地址分配和路由通告</strong>的基本单位</li></ul><h2 id="BGP-Route（BGP路由）">BGP Route（BGP路由）</h2><p><strong>BGP路由</strong>是<strong>互联网核心路由系统</strong>中的路由条目：</p><ul><li>包含<strong>目的地前缀</strong>和<strong>完整路径属性</strong></li><li>核心属性包括<strong>AS_PATH</strong>（自治系统路径）、<strong>NEXT_HOP</strong>等</li><li>反映了<strong>网络政策</strong>和<strong>商业关系</strong></li><li>用于<strong>自治系统间</strong>的路由决策</li><li>通过BGP协议在全球互联网中<strong>传播和交换</strong></li></ul><p>NEXT-HOP属性在BGP中用于<strong>指明到达目标网络的下一跳路由器IP地址</strong>，具体使用方式如下：</p><ol><li><p><strong>路由转发决策</strong></p><ul><li>当路由器接收到目标数据包时，通过查询BGP表中的NEXT-HOP属性确定<strong>实际转发目标</strong></li><li>路由器必须能够通过IGP协议(如OSPF)到达NEXT-HOP地址</li></ul></li><li><p><strong>BGP会话中的传递规则</strong></p><ul><li><strong>eBGP传递</strong>：设置为发送更新的BGP对等体的IP地址</li><li><strong>iBGP传递</strong>：保持NEXT-HOP值不变（除非明确配置修改）</li><li><strong>多出口AS</strong>：帮助选择最佳出口点</li></ul></li><li><p><strong>策略实现</strong></p><ul><li>通过修改NEXT-HOP实现<strong>流量工程</strong></li><li>支持热备份和负载均衡策略</li><li>可设置为特定接口地址或第三方路由器地址</li></ul></li></ol><p>AS-PATH属性记录了<strong>路由通告经过的AS序列</strong>，在BGP中具有多重重要功能：</p><ol><li><p><strong>路由选择依据</strong></p><ul><li>作为BGP决策过程中的<strong>关键指标</strong>之一</li><li><strong>AS-PATH越短</strong>的路径通常被优先选择</li><li>影响决策优先级：Local Preference &gt; AS-PATH长度 &gt; Origin &gt; MED等</li></ul></li><li><p><strong>环路检测机制</strong></p><ul><li>当路由器在AS-PATH中发现<strong>自己的AS号</strong>时，自动拒绝该路由</li><li>避免路由环路产生，确保BGP路由收敛性</li><li>例如：AS17收到路径&quot;AS23, AS45, AS17, AS78&quot;会直接丢弃</li></ul></li><li><p><strong>路径操纵技术</strong></p><ul><li>通过<strong>AS-PATH预置</strong>(prepending)增加路径长度</li><li>例如：&quot;AS78, AS78, AS78, AS99&quot;使路径看起来更长</li><li>降低特定路径被选择的可能性，实现出站流量控制</li></ul></li><li><p><strong>路由过滤依据</strong></p><ul><li>基于AS-PATH中的特定AS创建<strong>过滤策略</strong></li><li>可拒绝包含竞争对手或不信任AS的路由</li><li>实现复杂的路由策略控制和商业关系维护</li></ul></li></ol><h2 id="三者关系对比">三者关系对比</h2><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>特性</th><th>Subnet</th><th>Prefix</th><th>BGP Route</th></tr></thead><tbody><tr><td><strong>范围</strong></td><td>局部网段</td><td>地址块</td><td>全球路由</td></tr><tr><td><strong>用途</strong></td><td>网络分段</td><td>地址分配与聚合</td><td>域间路由决策</td></tr><tr><td><strong>包含信息</strong></td><td>网络地址+掩码</td><td>地址块+长度</td><td>前缀+路径属性</td></tr><tr><td><strong>管理层次</strong></td><td>单一管理域内</td><td>可跨域使用</td><td>多AS协作</td></tr><tr><td><strong>通告机制</strong></td><td>不直接通告</td><td>内部路由协议</td><td>BGP协议</td></tr><tr><td><strong>聚合能力</strong></td><td>固定大小</td><td>可变大小</td><td>可聚合或特定</td></tr></tbody></table></div><h2 id="层次关系">层次关系</h2><p>这三个概念形成了一个层次结构：</p><ul><li><strong>Subnet</strong>：最基础，表示<strong>实际网络分段</strong></li><li><strong>Prefix</strong>：中间层，表示<strong>可路由的地址块</strong></li><li><strong>BGP Route</strong>：最高层，表示<strong>如何到达特定前缀的完整路径信息</strong></li></ul><p>一个BGP路由可以指向一个前缀，而一个前缀可以包含多个子网。</p><h1>End-of-chapter exercises</h1><h2 id="P-6">P.6</h2><p><strong>Questions:</strong></p><p>In the text we have used the term connection-oriented service to describe a transport-layer service and connection service for a network-layer service. Why the subtle shades in terminology?</p><p><strong>Answer:</strong></p><p>The subtle difference in terminology reflects the distinct roles and responsibilities of the transport and network layers:</p><ul><li><p><strong>Connection-oriented service (Transport Layer):</strong><br>At the transport layer, a connection-oriented service (such as TCP) establishes, maintains, and terminates a logical end-to-end connection. This connection is defined <strong>between two processes</strong> on the end hosts (e.g., two TCP sockets). This service ensures reliable, ordered, and error-checked delivery of data across the entire network path, directly between the communicating applications.</p></li><li><p><strong>Connection service (Network Layer):</strong><br>At the network layer, a connection service (such as a virtual circuit) refers to the establishment of a logical path through the network, typically between routers or switches. This connection is defined <strong>between two hosts</strong> (and their intervening routers in the case of virtual-circuit networks). This path helps guide packets from source to destination but does not necessarily guarantee reliability or ordering. The focus here is on the route and forwarding of packets within the network infrastructure.</p></li></ul><p><strong>In summary:</strong><br>The term &quot;connection-oriented service&quot; at the transport layer emphasizes end-to-end reliability and communication, while &quot;connection service&quot; at the network layer highlights the setup of a path through the network, without necessarily providing full end-to-end guarantees. The nuanced terminology helps clarify the different scopes and guarantees provided by each layer.</p><h2 id="P-9">P.9</h2><p><strong>Consider a datagram network using 32-bit host addresses. Suppose a router has four links, numbered 0 through 3, and packets are to be forwarded to the link interfaces as follows:</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align:center">Destination Address Range</th><th style="text-align:center">Link Interface</th></tr></thead><tbody><tr><td style="text-align:center"><div align = "center">11100000 00000000 00000000 00000000<br><strong>through</strong><br>11100000 00111111 11111111 11111111</div></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><div align = "center">11100000 01000000 00000000 00000000<br><strong>through</strong><br>11100000 01000000 11111111 11111111</div></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><div align = "center">11100000 01000001 00000000 00000000<br><strong>through</strong><br>11100001 01111111 11111111 11111111</div></td><td style="text-align:center">2</td></tr><tr><td style="text-align:center"><div align = "center">otherwise</div></td><td style="text-align:center">3</td></tr></tbody></table></div><p><strong>Questions and Answers:</strong></p><p><strong>a. Provide a forwarding table that has four entries, uses longest prefix matching, and forwards packets to the correct link interfaces.</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th>Header</th><th style="text-align:center">Link Interface(output)</th></tr></thead><tbody><tr><td>11100000 00</td><td style="text-align:center">0</td></tr><tr><td>11100000 01000000</td><td style="text-align:center">1</td></tr><tr><td>1110000</td><td style="text-align:center">2</td></tr><tr><td>otherwise</td><td style="text-align:center">3</td></tr></tbody></table></div><p><strong>Explanation:</strong></p><ul><li>Each entry uses the longest prefix that matches the given address range.</li><li>The router checks the destination address against each prefix, starting from the longest, and forwards the packet to the corresponding interface.</li></ul><p><strong>b. Describe how your forwarding table determines the appropriate link interface for datagrams with destination addresses</strong>:</p><div align = "center">11001000 10010001 01010001 01010101</div>  <div align = "center">11100001 01000000 11000011 00111100</div>  <div align = "center">11100001 10000000 00010001 01110111</div><ol><li><p><strong>11001000 10010001 01010001 01010101</strong></p><ul><li>This address does <strong>not</strong> match any of the specified prefixes (does not start with 111…), so it is forwarded to <strong>interface 3</strong>.</li></ul></li><li><p><strong>11100001 01000000 11000011 00111100</strong></p><ul><li>This address matches the third entry:<ul><li>Prefix: <code>1110000</code></li><li>So, it is forwarded to <strong>interface 2</strong>.</li></ul></li></ul></li><li><p><strong>11100001 10000000 00010001 01110111</strong></p><ul><li>This address matches the third entry:<ul><li>Prefix: <code>1110000</code></li><li>So, it is forwarded to <strong>interface 2</strong>.</li></ul></li></ul></li></ol><h2 id="P-10">P.10</h2><p><strong>Consider a datagram network using 8-bit host addresses. Suppose a router uses longest-prefix matching and has the following forwarding table:</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align:center">Prefix Match</th><th style="text-align:center">Interface</th></tr></thead><tbody><tr><td style="text-align:center">00</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">010</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">011</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">3</td></tr></tbody></table></div><p><strong>Question and Answer:</strong></p><p>For each of the four interfaces, give the associated range of destination host addresses and the number of addresses in the range.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align:center">Interface</th><th style="text-align:center">Destination Address Range</th><th style="text-align:right">Number of Addresses</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">00000000 - 00111111</td><td style="text-align:right">64</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">01000000 - 01011111</td><td style="text-align:right">32</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">01100000 - 01111111<br>10000000 - 10111111</td><td style="text-align:right">96</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">11000000 - 11111111</td><td style="text-align:right">64</td></tr></tbody></table></div><h2 id="P-17">P.17</h2><p><strong>Question and Answer:</strong></p><p>Consider sending a 2400-byte datagram into a link that has an MTU of 700 bytes. Suppose the original datagram is stamped with the identification number 422. How many fragments are generated? What are the values in the various fields in the IP datagram(s) generated related to fragmentation?</p><p>According to IPv4 datagram format, each fragment includes a 20-bytes header.</p><p>先计算数据大小 $d = \lfloor \frac{700 - 20}{8} \rfloor \times 8 = 680$ bytes。</p><p>所以需要分成 $n = \lceil \frac{2400 - 20}{d} \rceil = 4$</p><p>主要变化在 <code>Offset</code> 和 <code>Flag</code>，所以：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align:center">Fragment</th><th style="text-align:center">Datagram length</th><th style="text-align:center">Offset</th><th style="text-align:center">Flag</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">700</td><td style="text-align:center">0</td><td style="text-align:center">001</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">700</td><td style="text-align:center">85</td><td style="text-align:center">001</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">700</td><td style="text-align:center">170</td><td style="text-align:center">001</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">360</td><td style="text-align:center">255</td><td style="text-align:center">000</td></tr></tbody></table></div><h2 id="P-18">P.18</h2><p><strong>Question and Answer:</strong></p><p>Suppose datagrams are limited to 1,500 bytes (including header) between source Host A and destination Host B. Assuming a 20-byte IP header, how many datagrams would be required to send an MP3 consisting of 5 million bytes? Explain how you computed your answer.</p><p>MTU 为 $1500$ bytes，一个 datagram 的 data 大小为 $d = \lfloor \frac{1500 -20}{8} \rfloor \times 8 = 1480$ bytes。</p><p>最终，datagram 的数目为 $n = \lceil \frac{5 \times 10^6}{d} \rceil = 3379$ 个。</p><h2 id="P-19">P.19</h2><p><strong>Consider the network setup in Figure 4.22. Suppose that the ISP instead assigns the router the address 24.34.112.235 and that the network address of the home network is 192.168.1/24</strong>.</p><p><img src="The-Network-Layer/Network%20address%20translation.png" alt="Network address translation">{style=&quot;display: block; margin: 0 auto; width: 80%&quot;}</p><p><strong>Questions and Answers:</strong></p><p><strong>a. Assign addresses to all interfaces in the home network.</strong></p><p>也即是说，中间的 router WAN 的 IP address 是 <code>24.34.112.235</code>，LAN 的是 <code>192.168.1/24</code>，不妨和原图一样，设为 <code>192.168.1.4</code>。则右边的三个 host 的 LAN IP address 分别为：</p><ul><li>Host 1 address is 192.168.1.1</li><li>Host 2 address is 192.168.1.2</li><li>Host 3 address is 192.168.1.3</li></ul><p><strong>b. Suppose each host has two ongoing TCP connections, all to port 80 at host 128.119.40.86. Provide the six corresponding entries in the NAT translation table.</strong></p><p>总共有 $6$ 个 TCP connection，随便分几个端口号：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align:center">WAN side</th><th style="text-align:center">LAN side</th></tr></thead><tbody><tr><td style="text-align:center">24.34.112.235, 50001</td><td style="text-align:center">192.168.1.1, 3345</td></tr><tr><td style="text-align:center">24.34.112.235, 50002</td><td style="text-align:center">192.168.1.1, 3346</td></tr><tr><td style="text-align:center">24.34.112.235, 50003</td><td style="text-align:center">192.168.1.2, 3345</td></tr><tr><td style="text-align:center">24.34.112.235, 50004</td><td style="text-align:center">192.168.1.2, 3346</td></tr><tr><td style="text-align:center">24.34.112.235, 50005</td><td style="text-align:center">192.168.1.3, 3345</td></tr><tr><td style="text-align:center">24.34.112.235, 50006</td><td style="text-align:center">192.168.1.3, 3346</td></tr></tbody></table></div><h2 id="P-24">P.24</h2><p><img src="The-Network-Layer/P24.jpg" alt="Graph P.24">{style=&quot;display: block; margin: 0 auto; width: 80%&quot;}</p><p><strong>Question:</strong></p><p>Consider the following network. With the indicated link costs, use Dijkstra’s shortest-path algorithm to compute the shortest path from x to all network nodes. Show how the algorithm works by computing a table similar to Table 4.3.</p><p><strong>Answer:</strong></p><p>$N’ = {x}$</p><table><thead><tr><th style="text-align:center">step</th><th style="text-align:center">$D(x)$ $P(x)$</th><th style="text-align:center">$D(y)$ $P(y)$</th><th style="text-align:center">$D(z)$ $P(z)$</th><th style="text-align:center">$D(v)$ $P(v)$</th><th style="text-align:center">$D(u)$ $P(u)$</th><th style="text-align:center">$D(w)$ $P(w)$</th><th style="text-align:center">$D(t)$ $P(t)$</th><th style="text-align:center">$N’$</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">$0$    $x$</td><td style="text-align:center">$6$     $x$</td><td style="text-align:center">$8$     $x$</td><td style="text-align:center"><strong>$3$</strong>  $x$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$6$      $x$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$x$</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">$0$    $x$</td><td style="text-align:center"><strong>$6$</strong> $x$</td><td style="text-align:center">$8$     $x$</td><td style="text-align:center">$3$      $x$</td><td style="text-align:center">$6$     $v$</td><td style="text-align:center">$6$      $x$</td><td style="text-align:center">$7$     $v$</td><td style="text-align:center">$xv$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$0$    $x$</td><td style="text-align:center">$6$     $x$</td><td style="text-align:center">$8$     $x$</td><td style="text-align:center">$3$      $x$</td><td style="text-align:center"><strong>$6$</strong> $v$</td><td style="text-align:center">$6$      $x$</td><td style="text-align:center">$7$     $v$</td><td style="text-align:center">$xvy$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$0$    $x$</td><td style="text-align:center">$6$     $x$</td><td style="text-align:center">$8$     $x$</td><td style="text-align:center">$3$      $x$</td><td style="text-align:center">$6$     $v$</td><td style="text-align:center"><strong>$6$</strong>  $x$</td><td style="text-align:center">$7$     $v$</td><td style="text-align:center">$xvyu$</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$0$    $x$</td><td style="text-align:center">$6$     $x$</td><td style="text-align:center">$8$     $x$</td><td style="text-align:center">$3$      $x$</td><td style="text-align:center">$6$     $v$</td><td style="text-align:center">$6$      $x$</td><td style="text-align:center"><strong>$7$</strong>  $v$</td><td style="text-align:center">$xvyuw$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">$0$    $x$</td><td style="text-align:center">$6$     $x$</td><td style="text-align:center"><strong>$8$</strong> $x$</td><td style="text-align:center">$3$      $x$</td><td style="text-align:center">$6$     $v$</td><td style="text-align:center">$6$      $x$</td><td style="text-align:center">$7$     $v$</td><td style="text-align:center">$xvyuwt$</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">$0$    $x$</td><td style="text-align:center">$6$     $x$</td><td style="text-align:center">$8$     $x$</td><td style="text-align:center">$3$      $x$</td><td style="text-align:center">$6$     $v$</td><td style="text-align:center">$6$      $x$</td><td style="text-align:center">$7$     $v$</td><td style="text-align:center">$xvyuwtz$</td></tr></tbody></table><p>So the shortest path from $x$ to all nodes is follow.</p><table><thead><tr><th style="text-align:center">Destination</th><th style="text-align:center">Shortest Distance</th><th style="text-align:center">Path</th></tr></thead><tbody><tr><td style="text-align:center">$x$</td><td style="text-align:center">$0$</td><td style="text-align:center">$x$</td></tr><tr><td style="text-align:center">$v$</td><td style="text-align:center">$3$</td><td style="text-align:center">$x \to v$</td></tr><tr><td style="text-align:center">$y$</td><td style="text-align:center">$6$</td><td style="text-align:center">$x \to y$</td></tr><tr><td style="text-align:center">$w$</td><td style="text-align:center">$6$</td><td style="text-align:center">$x \to w$</td></tr><tr><td style="text-align:center">$u$</td><td style="text-align:center">$6$</td><td style="text-align:center">$x \to v \to u$</td></tr><tr><td style="text-align:center">$t$</td><td style="text-align:center">$7$</td><td style="text-align:center">$x \to v \to t$</td></tr><tr><td style="text-align:center">$z$</td><td style="text-align:center">$8$</td><td style="text-align:center">$x \to z$</td></tr></tbody></table><h2 id="P-26">P.26</h2><p><img src="The-Network-Layer/P26.png" alt="Graph P.26">{style=&quot;display: block; margin: 0 auto; width: 80%&quot;}</p><p><strong>Question:</strong></p><p>Consider the network shown below, and assume that each node initially knows the costs to each of its neighbors. Consider the distance-vector algorithm and show the distance table entries at node z.</p><p><strong>Answer:</strong></p><p><strong>Node z table:</strong></p><p><em><strong>First round</strong></em></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">cost to</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">x</td><td style="text-align:center">y</td><td style="text-align:center">z</td><td style="text-align:center">u</td><td style="text-align:center">v</td></tr><tr><td style="text-align:center">from x</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td></tr><tr><td style="text-align:center">from y</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td></tr><tr><td style="text-align:center">from z</td><td style="text-align:center">2</td><td style="text-align:center">$\infty$</td><td style="text-align:center">0</td><td style="text-align:center">$\infty$</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">from u</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td></tr><tr><td style="text-align:center">from v</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td></tr></tbody></table></div><p><em><strong>Second round</strong></em></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">cost to</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">$x$</td><td style="text-align:center">$y$</td><td style="text-align:center">$z$</td><td style="text-align:center">$u$</td><td style="text-align:center">$v$</td></tr><tr><td style="text-align:center">from $x$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$3$</td></tr><tr><td style="text-align:center">from $y$</td><td style="text-align:center">$3$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$2$</td><td style="text-align:center">$\infty$</td></tr><tr><td style="text-align:center">from $z$</td><td style="text-align:center">$2$</td><td style="text-align:center">$5$</td><td style="text-align:center">$0$</td><td style="text-align:center">$7$</td><td style="text-align:center">$5$</td></tr><tr><td style="text-align:center">from $u$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$2$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center">from $v$</td><td style="text-align:center">$3$</td><td style="text-align:center">$\infty$</td><td style="text-align:center">$6$</td><td style="text-align:center">$1$</td><td style="text-align:center">$\infty$</td></tr></tbody></table></div><p>Because the question only asks to show the distance table entries at node z, we do not need to compute the full routing tables for all nodes. The Second round result about node z is also the finial result. 到这一步 from z to other 的 cost 表就收敛了，题目也只问了 node z。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Network Layer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>提升方法</title>
    <link href="/2025/05/30/%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/"/>
    <url>/2025/05/30/%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="AdaBoost-算法">AdaBoost 算法</h2><p><em><strong>Data Information</strong></em>： <strong>二分类</strong>训练数据集 $T$<br>$$<br>\begin{align}<br>T&amp; = {(x_1, y_1), (x_2, y_2), \ldots, (x_N, y_N)}<br>\<br>x_i \in \mathcal{X}&amp; = \mathbb{R}^n, \quad y_i \in \mathcal{Y} = {+1, -1}, \quad i = 1, 2, \ldots, N<br>\end{align}<br>$$</p><p><em><strong>Algorithm Process</strong></em></p><ol><li><p>初始化训练数据的权值分布：<br>$$<br>D_1 = (w_{11}, w_{12}, \dots, w_{1N}), \quad w_{1i} = \frac{1}{N}, \quad i = 1, 2, \dots, N<br>$$</p></li><li><p>用权值分布 $D_i$<br>(a) 计算不正确率：<br>$$<br>e_m = \sum_{i=1}^{N} P(G_m(x_i) \neq y_i) = \sum_{i=1}^{N} w_{mi} I(G_m(x_i) \neq y_i)<br>$$</p><p>(b) 计算 $\alpha_m$:<br>$$<br>\alpha_m = \frac{1}{2} \ln \frac{1 - e_m}{e_m}<br>$$</p><p>© 更新权值分布:<br>$$<br>D_{m+1} = (w_{m+1,1}, \dots, w_{m+1, N})<br>$$<br>$$<br>w_{m+1,i} = \frac{w_{mi}}{Z_m} \exp(-\alpha_m y_i G_m(x_i))<br>$$<br>$Z_m$ 是归一化因子。<br>$$<br>Z_m = \sum_{i=1}^{N} w_{mi} \exp(-\alpha_m y_i G_m(x_i))<br>$$</p></li><li><p>构造基本分类器的线性组合<br>$$<br>f(x) = \sum_{m=1}^{M} \alpha_m G_m(x)<br>$$</p></li><li><p>得到最终分类器<br>$$<br>G(x) = \operatorname{sign}\left( \sum_{m=1}^{M} \alpha_m G_m(x) \right)<br>$$</p></li></ol><h2 id="回归问题的提升树算法">回归问题的提升树算法</h2><p><em><strong>Algorithm Process</strong></em><br>输入：训练数据集 $T = {(x_1, y_1),(x_2, y_2), \cdots, (x_N, y_N)}$；<br>输出：提升树 $f_M(x)$。<br>（1）初始化 $f_0(x) = 0$。<br>（2）对 $m = 1, 2, \cdots, M$。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>支持向量机</title>
    <link href="/2025/05/30/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2025/05/30/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="线性可分支持向量机">线性可分支持向量机</h2><p><strong>训练数据</strong><br>$$<br>T = {(x_1, y_1), (x_2, y_2), \ldots, (x_N, y_N)}<br>$$</p><p>$$<br>x_i \in \mathcal{X} = \mathbb{R}^n, \quad y_i \in \mathcal{Y} = {+1, -1}, \quad i = 1, 2, \ldots, N<br>$$</p><p><strong>分离超平面</strong></p><p>$$<br>w^* \cdot x + b^* = 0<br>$$</p><p><strong>分类决策函数</strong></p><p>$$<br>f(x) = \operatorname{sign}(w^* \cdot x + b^*)<br>$$</p><p><strong>函数间隔</strong></p><p>$$<br>\begin{align*}<br>\hat{\gamma}<em>i &amp;= y_i (w \cdot x_i + b)<br>\\<br>\hat{\gamma} &amp;= \min</em>{i = 1, 2, \ldots, N} \hat{\gamma}_i<br>\end{align*}<br>$$</p><p>规范化函数间隔得到<strong>几何间隔</strong></p><p>$$<br>\begin{align*}<br>\gamma_i &amp;= y_i \times \left(\frac{w \cdot x_i + b}{\lVert w \rVert}\right)<br>\\<br>\gamma &amp;= \min_{i=1, \ldots, N} \gamma_i<br>\end{align*}<br>$$</p><p>$\lVert w \rVert$ is $L_2$ 范数，也就是：</p><p>$$<br>\lVert w \rVert _{2} = \sqrt{w_1^2 + w_2^2 + \cdots + w_n^2}<br>$$</p><p>可以得到几何间隔和函数间隔之间的关系：</p><p>$$<br>\gamma_i = \frac{\hat{\gamma}_i}{\lVert w \rVert}<br>$$</p><h3 id="间隔最大化">间隔最大化</h3><p>原始问题如下：</p><p>$$<br>\begin{align*}<br>&amp;\max_{w, b} \quad \gamma<br>\\<br>&amp;s.t. \quad y_i\left(\frac{w}{\lVert w \rVert} \cdot x_i + \frac{b}{\lVert w \rVert}\right) \geq \gamma, \quad i = 1, 2, \ldots ,N<br>\end{align*}<br>$$</p><p>我们可以将原始问题转换为一个<strong>凸二次规划问题</strong>。</p><p>$$<br>\begin{align*}<br>&amp;\min_{w, b} \quad \frac{1}{2} \lVert w \rVert ^2<br>\\<br>&amp;s.t. \quad y_i(w \cdot x_i + b) - 1 \geq 0, \quad i = 1, 2, \ldots, N<br>\end{align*}<br>$$</p><p><strong>支持向量</strong>满足如下关系：</p><p>$$<br>y_i(w \cdot x_i + b) - 1 = 0<br>$$</p><p><strong>间隔</strong>的定义如下：</p><p>$$<br>d = \frac{2}{\lVert w \rVert}<br>$$</p><h4 id="学习的对偶算法">学习的对偶算法</h4><p>如何解上述的<strong>凸二次规划</strong>问题？应用拉格朗日对偶性得到原始问题的对偶问题：</p><p>$$<br>L(w, b, \alpha) = \frac{1}{2} \lVert w \rVert ^2 - \sum_{i = 1}^{N} \alpha_i y_i (w \cdot x_i + b) + \sum_{i = 1}^{N} \alpha_i<br>$$</p><p>在求极大极小问题，先求极小问题 $\min_{w, b} L(w, b, \alpha)$</p><p>分别对 $w$，$b$ 求偏导，并令偏导为 $0$ 得：</p><p>$$<br>\begin{align*}<br>\nabla_{w} L(w, b, \alpha) &amp;= w - \sum_{i = 1}^{N} \alpha_i y_i x_i = 0<br>\\<br>\nabla_b L(w, b, \alpha) &amp;= -\sum_{i = 1}^{N} \alpha_i y_i = 0<br>\end{align*}<br>$$</p><p>也就是</p><p>$$<br>\begin{align*}<br>&amp;w = \sum_{i = 1}^{N} \alpha_i y_i x_i<br>\\<br>&amp;\sum_{i = 1}^{N} \alpha_i y_i = 0<br>\end{align*}<br>$$</p><p>回代，得到</p><p>$$<br>\min_{w, b} L(w, b, \alpha) = -\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) + \sum_{i = 1}^{N} \alpha_i<br>$$</p><p>再求极大问题</p><p>$$<br>\max_{\alpha} \quad -\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) + \sum_{i = 1}^{N} \alpha_i<br>$$</p><p>去掉负号，也就是</p><p>$$<br>\begin{align*}<br>\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i<br>\\<br>\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0<br>\<br>&amp;\alpha_i \geq 0, \quad i = 1, 2, \cdots, N<br>\end{align*}<br>$$</p><h3 id="学习算法">学习算法</h3><ul><li><p><strong>输入</strong>：$T$</p></li><li><p><strong>输出</strong>：分离超平面和分类决策函数</p><ul><li>构造并求解约束最优化问题。</li></ul><p>$$<br>\begin{align*}<br>\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i<br>\\<br>\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0<br>\<br>&amp;\alpha_i \geq 0, \quad i = 1, 2, \cdots, N<br>\\<br>&amp;\alpha^* = (\alpha_1^{\ast}, \alpha_2^{\ast}, \ldots, \alpha_N^{\ast})<br>\end{align*}<br>$$</p><ul><li>计算</li></ul><p>$$<br>\begin{align*}<br>w^{\ast} &amp;= \sum_{i=1}^{N} \alpha_i^{\ast} y_i x_i<br>\\<br>\forall y_j &gt; 0, \quad b^\ast &amp;= y_j - \sum_{i=1}<sup>{N}\alpha_i</sup>\ast y_i(x_i \cdot x_j)<br>\end{align*}<br>$$</p></li></ul><hr><h2 id="线性支持向量机">线性支持向量机</h2><p>引进一个松弛变量 $\xi_i \geq 0$，</p><p>$$<br>y_i (w \cdot x_i + b) \geq 1 - \xi_i<br>$$</p><p>相应的原始最优化问题变为：</p><p>$$<br>\begin{align*}<br>\min_{w, b, \xi} \quad &amp;\frac{1}{2} \lVert w \rVert^2 + C \sum_{i = 1}^{N} \xi_i<br>\\<br>s.t. \quad &amp;y_i(w \cdot x_i + b) \geq 1 - \xi_i<br>\\<br>&amp;i = 1, 2, \ldots, N, \quad \xi_i \geq 0<br>\end{align*}<br>$$</p><p>这里 $C \geq 0$ 称为惩罚变量，值越大，对误分类的惩罚越大。</p><p>求解原始问题的拉格朗日对偶问题得到</p><p>$$<br>\begin{align*}<br>\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i<br>\\<br>\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0<br>\<br>&amp;C \geq \alpha_i \geq 0, \quad i = 1, 2, \cdots, N<br>\end{align*}<br>$$</p><h3 id="学习算法-2">学习算法</h3><ul><li><p><strong>输入</strong>：$T$</p></li><li><p><strong>输出</strong>：分离超平面和分类决策函数</p><ul><li>选择惩罚参数，构造并求解：<br>$$<br>\begin{align*}<br>\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i<br>\\<br>\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0<br>\<br>&amp;C \geq \alpha_i \geq 0, \quad i = 1, 2, \cdots, N<br>\end{align*}<br>$$</li></ul><p>得到最优解 $\alpha^* = (\alpha_1^{\ast}, \alpha_2^{\ast}, \ldots, \alpha_N^{\ast})$。</p><ul><li>计算</li></ul><p>$$<br>\begin{align*}<br>w^{\ast} &amp;= \sum_{i=1}^{N} \alpha_i^{\ast} y_i x_i<br>\\<br>\forall C &gt; \alpha_j^{\ast} &gt; 0, \quad b^\ast &amp;= y_j - \sum_{i=1}<sup>{N}\alpha_i</sup>\ast y_i(x_i \cdot x_j)<br>\end{align*}<br>$$</p></li></ul><hr><h2 id="荷叶损失函数">荷叶损失函数</h2><p>这是对线性支持向量机学习的一种解释，就是最小化以下目标函数：</p><p>$$<br>\min_{w, b} \quad \sum_{i = 1}^{N} [1 - y_i(w \cdot x_i + b)]_+ + \lambda \lVert w \rVert^2<br>$$</p><hr><h2 id="非线性支持向量机">非线性支持向量机</h2><p><strong>正定核函数</strong></p><p>$K :\mathcal{X} \times \mathcal{X} \to \mathbb{R}$ 是对称函数，$K(x, z)$ 是正定核函数 $\Leftrightarrow$ 对于任意 $x_i \in \mathcal{X}, \quad i = 1, 2, 3, \dots, m$，$K(x, z)$ 对应的格拉姆矩阵是半正定的。</p><p><strong>$Gram$ 矩阵</strong></p><p>$$<br>K = [K(x_i, x_j)]_{m \times m}<br>$$</p><p>如何判别这个矩阵是半正定的，可以采用<strong>特征值判别法</strong>，如果一个矩阵的所有特征值都 $\geq 0$，则这个矩阵是半正定的。</p><h3 id="学习算法-3">学习算法</h3><ul><li><p><strong>输入</strong>：$T$</p></li><li><p><strong>输出</strong>：分离超平面和分类决策函数</p><ul><li>选择惩罚参数，构造并求解：<br>$$<br>\begin{align*}<br>\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j K\left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i<br>\\<br>\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0<br>\<br>&amp;C \geq \alpha_i \geq 0, \quad i = 1, 2, \cdots, N<br>\end{align*}<br>$$</li></ul><p>得到最优解 $\alpha^* = (\alpha_1^{\ast}, \alpha_2^{\ast}, \ldots, \alpha_N^{\ast})$。</p><ul><li>计算</li></ul><p>$$<br>\begin{align*}<br>w^{\ast} &amp;= \sum_{i=1}^{N} \alpha_i^{\ast} y_i x_i<br>\\<br>\forall C &gt; \alpha_j^{\ast} &gt; 0, \quad b^\ast &amp;= y_j - \sum_{i=1}<sup>{N}\alpha_i</sup>\ast y_i K(x_i \cdot x_j)<br>\end{align*}<br>$$</p></li></ul><h2 id="序列最小最优化算法">序列最小最优化算法</h2><p><strong>两个变量二次规划的求解方式</strong></p><p>$$<br>\begin{align}<br>&amp;\min_{\alpha} \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}\alpha_i \alpha_j y_i y_j K(x_i \cdot x_j) - \sum_{i=1}^{N} \alpha_i \\<br>&amp;s.t. \quad \sum_{i = 1}^{N} \alpha_i y_i = 0, \quad C \geq \alpha_i \geq 0, \quad i = 1, 2, \ldots, N<br>\end{align}<br>$$</p><p>我们选择 $\alpha_1，\alpha_2$，规定其他 $\alpha_i (i = 3, 4, \dots, N)$。</p><h3 id="学习算法-4">学习算法</h3><p>下面只给出<strong>应试过程</strong></p><p>我们的<strong>目标</strong>是，求解下述最小化问题：</p><p>$$<br>\begin{align}<br>&amp;\min_{\alpha_1, \alpha_2} W(\alpha_1, \alpha_2) = \frac{1}{2} K_{11}\alpha_1^2 +  \frac{1}{2} K_{22}\alpha_2^2 +y_1y_2K_{12}\alpha_1\alpha_2 - (\alpha_1 + \alpha_2) + y_1\alpha_1\sum_{i=3}^{N}y_i\alpha_iK_{i1} + y_2\alpha_2\sum_{i=3}^{N}y_i\alpha_iK_{i2} \tag{1}<br>\\<br>&amp;s.t. \quad \alpha_1y_1 + \alpha_2y_2 = \sum_{i=3}^{N}y_i\alpha_i = \zeta, \quad 0 \leq \alpha_i \leq C, \quad i = 1, 2 \tag{2}<br>\end{align}<br>$$</p><p>$K_{ij} = K(x_i, x_j),i,j = 1,2, \dots, N$，$\zeta$ 是一个常数。同时需要注意的是，公式 $(1)$ 缺少了常数项</p><p>$$<br>\text{const} = \sum_{i=3}^N \alpha_i - \frac{1}{2} \sum_{i=3}^N \sum_{j=3}^N \alpha_i \alpha_j y_i y_j K(x_i, x_j)<br>$$</p><p>但这个常数项<strong>不会</strong>影响优化 $\alpha_1$ 和 $\alpha_2$ 的结果，故可以省略。</p><p>我们考虑 $\alpha_2$ 的最优化问题。</p><p>如果 $ y_1 \neq y_2 $</p><p>$$<br>L = \max(0, \alpha_2^{old} - alpha_1^{old}), \quad H = \min(C, C + \alpha_2^{old} - alpha_1^{old}) \tag{3}<br>$$</p><p>否则</p><p>$$<br>L = \max(0, \alpha_2^{old} + alpha_1^{old} - C), \quad H = \min(C, \alpha_2^{old} + alpha_1^{old}) \tag{4}<br>$$</p><p>为了叙述简单，记</p><p>$$<br>g(x) = \sum_{i=1}^{N}\alpha_i y_i K(x_i, x) + b<br>$$</p><p>令</p><p>$$<br>E_i = g(x_i) - y_i = \sum_{j=1}^{N}\alpha_j y_j K(x_j, x_i) + b - y_i, \quad i = 1, 2<br>$$</p><p>接下来我们更新 $\alpha_2$</p><p>$$<br>\alpha_2^{new,unc} = \alpha_2^{old} + \frac{y_2(E_1 - E_2)}{\eta}, \quad \eta = K_{11} + K_{22} - 2K_{12}<br>$$</p><p>$$<br>\alpha_2^{new} =<br>\begin{cases}<br>H, &amp;\alpha_2^{new,unc} &gt; H<br>\\<br>\alpha_2^{new,unc}, &amp;L \leq \alpha_2^{new,unc} \leq H<br>\\<br>L, &amp;\alpha_2^{new,unc} &lt; L<br>\end{cases}<br>$$</p><p>N然后再更新 $\alpha_1$</p><p>$$<br>\alpha_1^{new} = \alpha_1^{old} + y_1 y_2(\alpha_2^{old} - \alpha_2^{new})<br>$$</p><p><strong>如何选择 $\alpha_1$ 和 $\alpha_2$</strong></p><ol><li>在所有节点中选择具有最大 $E_i$ 值的节点作为 $\alpha_1$。</li><li>选择使得 $|E_1 - E_2|$ 最大的节点作为 $\alpha_2$。</li></ol><p><strong>求解阈值 b 和 E 的计算方法</strong></p><p>$$<br>b_1^{new} = -E_1 - y_1 K_{11} (\alpha_1^{new} - \alpha_1^{old}) - y_2 K_{21} (\alpha_2^{new} - \alpha_2^{old}) + b^{old}<br>$$</p><p>$$<br>b_2^{new} = -E_2 - y_1 K_{12} (\alpha_1^{new} - \alpha_1^{old}) - y_2 K_{22} (\alpha_2^{new} - \alpha_2^{old}) + b^{old}<br>$$</p><p>$$<br>b^{new} = \frac{b_1^{new} + b_2^{new}}{2}<br>$$</p><p><strong>此外</strong></p><p>更新 $E$：</p><p>$$<br>E_i^{new} = \sum_{\mathcal{S}}y_j \alpha_j K(x_i, x_j) + b^{new} - y_i<br>$$</p><p>其中 $\mathcal{S}$ 包含所有支持向量 $x_i$。样本 $x_i$ 是支持向量 $\Leftrightarrow$ $0 &lt; \alpha_i^* &lt; C$。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下推自动机</title>
    <link href="/2025/05/28/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2025/05/28/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1>背景知识</h1><h2 id="PDA形式化描述">PDA形式化描述</h2><p>$$<br>\text{PDA} \quad M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F) \tag{1}<br>$$</p><ul><li>$Q$：状态集合</li><li>$\Sigma$：字母表</li><li>$\Gamma$：栈符号表</li><li>$\delta$：状态转移函数</li><li>$q_0$：开始状态</li><li>$Z_0$：栈底符号</li><li>$F$：终态集合</li></ul><p>其中状态转移函数为</p><p>$$<br>\delta : Q \times (\Sigma \cup {\epsilon}) \times \Gamma \rightarrow 2^{Q \times \Gamma^*} \tag{2}<br>$$</p><h2 id="即时描述">即时描述</h2><p>$$<br>(q, w, \gamma) \in Q \times \Sigma^* \times \Gamma^* \tag{3}<br>$$</p><ul><li>当前状态是 $q$</li><li>未处理的输入字符串是 $w$</li><li>栈中符号串是 $\gamma$</li></ul><h2 id="接受语言">接受语言</h2><p>有两种方式描述：</p><p>$$<br>L(M) = {w \mid (q_0, w, Z_0)  \vdash ^* (p, \epsilon, \beta) \text{ and } p \in F } \tag{4}<br>$$</p><p>$$<br>L(M) = {w \mid (q_0, w, Z_0) \vdash ^* (p, \epsilon, \epsilon) } \tag{5}<br>$$</p><h1>构造PDA</h1><pre><code class=" mermaid">graph LR    A[&quot;Get Grammar&quot;] --&gt; B[&quot;CFG&quot;]    B[&quot;CFG&quot;] --&gt; C[&quot;GNF&quot;]    C[&quot;GNF&quot;] --&quot;finial states&quot;--&gt; D[&quot;PDA&quot;]    C[&quot;GNF&quot;] --&quot;empty stack&quot;--&gt; D[&quot;PDA&quot;]</code></pre><h1>PDA转换</h1><h2 id="终态换为空栈">终态换为空栈</h2><p>已知终态接受的 PDA $M_1$，公式化构造空战接受的 PDA $M_2$，具体过程如下：<br>$$<br>\text{PDA } M_1 = (Q, \Sigma, \Gamma, \delta_1, q_0, F) \tag{6}<br>$$</p><p>$$<br>\text{PDA } M_2 = (Q \cup {q_{02}, q_e }, \Sigma, \Gamma \cup {Z_{02} }, \delta_2, q_{02}, Z_{02}, F) \tag{7}<br>$$</p><p>We construct PDA $M_2$ to simulates PDA $M_1’s$ function. And first step, we need to get in PDA $M_1$.</p><p>$$<br>\delta_2(q_{02}, \epsilon, Z_{02}) = {(q_{01}, Z_{01}Z_{02})} \tag{8}<br>$$</p><p>PDA $M_2$ simulates each none $\epsilon$ step of PDA $M_1$.</p><p>$$<br>\forall (q, a, Z) \in Q \times \Sigma \times \Gamma, \delta_2(q, a, Z) = \delta_1(q, a, Z) \tag{9}<br>$$</p><p>PDA $M_2$ completely simulates PDA $M_1$ transition function in none finial states.</p><p>$$<br>\forall (q, Z) \in (Q - F) \times \Gamma, \delta_2(q, \epsilon, Z) = \delta_1(q, \epsilon, Z) \tag{10}<br>$$</p><p>In $M_1’s$ finial states, not only should $M_2$ simulates $M_1’s$ $\epsilon$ moves, but also simulates accepting moves.</p><p>$$<br>\forall (q, Z) \in F \times \Gamma, \delta_2(q, \epsilon, Z) = \delta_1(q, \epsilon, Z) \cup \{(q_e, \epsilon)\} \tag{11}<br>$$</p><p>$M_1’s$ stacks having been empty and in finial states, $M_2$ begins to cleat stack.</p><p>$$<br>\forall q \in F, \delta_2(q, \epsilon, Z_{02}) = {(q_e, \epsilon) } \tag{12}<br>$$</p><p>$$<br>\forall q \in \Gamma \cup {Z_{02} }, \delta_2(q_e, \epsilon, Z) = {(q_e, \epsilon) }<br>$$</p><h3 id="Empty-Stack-to-Finial-State">Empty Stack to Finial State</h3><p>已知空栈接受的 PDA $M_1$，要构造一个与之等价终态接受的 PDA $M_2$，核心思路在于<strong>只要 $M_2$ 发现 $M_1$ 在运行过程中将栈弹空，就可以进入终止状态</strong>。</p><p><strong>公式化构造</strong></p><p>设 PDA $M_1$ 为</p><p>$$<br>\text{PDA } M_1 =\left(Q, \Sigma, \Gamma, \delta_1, q_{01}, Z_{01}, \Phi\right)<br>$$</p><p>公式化构造 PDA $M_2$</p><p>$$<br>\text{PDA } M_2 = \left(Q \cup {q_0, q_f}, \Sigma, \Gamma \cup {Z_{02} }, \delta_2, q_{02}, Z_{02}, {q_f} \right)<br>$$</p><p>其中状态转移函数 $\delta_2$ 为</p><p>$$<br>\begin{align*}<br>&amp;\delta_2(q_{02}, \epsilon, Z_{02}) = {(q_{01}, Z_{01} Z_{02})}<br>\<br>&amp;\forall(q, a, Z) \in Q \times (\Sigma \cup {\epsilon}) \times \Gamma, \quad \delta_2(q, a ,Z) = \delta_1(q, a, Z)<br>\<br>&amp;\delta_2(q, \epsilon, Z_{02}) = {(q_f, \epsilon)}<br>\end{align*}<br>$$</p><h3 id="CFG-to-Empty-Stack">CFG to Empty Stack</h3><p>先考虑 $L$ 为不含 $\epsilon$ 的 CFL。$G$ 是该语言对应的 GNF 文法，考虑用 PDA 模拟 GNF 的最左派生。</p><p><strong>公式化构造</strong></p><p>设 GNF $G = (V, T, P, S)$。</p><p>取 PDA $M = ({q}, T, V, \delta, q, S, \Phi)$</p><p>$\forall A \in V, \quad a \in T, \quad \gamma \in V^{\ast}$ 我们有 $\delta(q, a, A) = {(q, \gamma) \mid A \to a\gamma \in P}$</p><p><strong>补充 ${\epsilon}$</strong></p><p>在 $M$ 的基础上，构造 $M_1$，具体是</p><p>$$<br>M_1 = ({q, q_0}, T, V \cup {Z}, \delta_1, q_0, Z, \Phi)<br>$$</p><p>对于状态转移函数 $\delta_1$，定义如下：</p><p>$$<br>\begin{align*}<br>\delta_1(q_0, \epsilon, Z) &amp;= {(q_0, \epsilon), (q, S)}<br>\<br>\delta_1(q, a, A) &amp;= \delta(q, a, A)<br>\end{align*}<br>$$</p><h3 id="Empty-Stack-to-CFG">Empty Stack to CFG</h3><p><strong>公式化构造</strong></p><p>设 PDA $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, \Phi)$，取 CFG $G = (V, \Sigma, P, S)$，其中：<br>$$<br>\begin{align*}<br>V &amp;= {S} \cup Q \times \Gamma \times Q，\text{特别地我们用$[q_i, A, q_j]$来表示变量}<br>\<br>P &amp;= {S \to [q_0, Z_0, q] \mid q \in Q}<br>\<br>&amp; \cup {[q, A, q_{n + 1}] \to a[q_1, A_1, q_2][q_2, A_2, q_3] \dots [q_n, A_n, q_{n + 1} \mid (q_1, A_1A_2 \dots A_n) \in \delta(q, a, A) \text{且} a \in \Sigma \cup {\epsilon}, n \geq 1}<br>\<br>&amp; \cup {[q, A, q_1] \to a \mid (q_1, \epsilon) \in \delta(q, a, A)}<br>\end{align*}<br>$$</p><h2 id="课后习题解答">课后习题解答</h2><h3 id="8-2-构造空栈接受的-PDA">8.(2) 构造空栈接受的 PDA</h3><img src="/2025/05/28/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/8(2).png" class="" title="8(2)"><div align = "center">图8.(2)</div><h3 id="补充题">补充题</h3><p><strong>Question:</strong><br>PDA $\to$ CFG 绘制此PDA状态转移图，按照定理7-4所述的文法构造方法进行转换。并对所得到的文法进行化简。</p><p>$$<br>\begin{align*}<br>\delta(q_0, a, Z) &amp;= {(q_0, AZ)} \tag{1}<br>\<br>\delta(q_0, a, A) &amp;= {(q_0, A)} \tag{2}<br>\<br>\delta(q_0, b, A) &amp;= {(q_1, \epsilon)} \tag{3}<br>\<br>\delta(q_1, \epsilon, Z) &amp;= {(q_2, \epsilon)} \tag{4}<br>\end{align*}<br>$$</p><p><strong>Answer:</strong></p><p>根据 $(4)$ 式，可以判断这是一个空栈接受的 PDA。</p><p>设 PDA $M = (Q, \Sigma, \Gamma, \delta, q_0, Z, \Phi)$</p><p>公式化构造 CFG。</p><p><strong>首先</strong></p>]]></content>
    
    
    <categories>
      
      <category>形式语言与自动机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo界面和GitHub page界面公式问题</title>
    <link href="/2025/05/28/hexo%E7%95%8C%E9%9D%A2%E5%92%8CGitHub%20page%E7%95%8C%E9%9D%A2%E5%85%AC%E5%BC%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2025/05/28/hexo%E7%95%8C%E9%9D%A2%E5%92%8CGitHub%20page%E7%95%8C%E9%9D%A2%E5%85%AC%E5%BC%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1>hexo界面和GitHub page界面公式问题</h1><p>位置: <code>theme/fluid/layout/_partials/head.ejs</code><br>整个替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;%<br>var separator = theme.title_join_string || theme.tab_title_separator<br>var title = page.title ? [page.title, config.title].join(separator) : config.title<br>var keywords = page.keywords || config.keywords<br>if (keywords instanceof Array) &#123;<br>  keywords = keywords.join(&#x27;,&#x27;)<br>&#125;<br>var description = page.description || page.excerpt || (is_post() &amp;&amp; page.content) || config.description<br>if (description) &#123;<br>  description = strip_html(description).substring(0, 200).trim().replace(/\n/g, &#x27; &#x27;)<br>&#125;<br>var ogImage = page.og_img || page.index_img<br>var ogConfig = Object.assign(&#123; image: ogImage &amp;&amp; url_for(ogImage) &#125;, theme.open_graph)<br>%&gt;<br><br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br><br>  &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;76x76&quot; href=&quot;&lt;%= url_for(theme.apple_touch_icon) %&gt;&quot;&gt;<br>  &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= url_for(theme.favicon) %&gt;&quot;&gt;<br>  &lt;% if (theme.canonical.enable) &#123; %&gt;<br>    &lt;link rel=&quot;canonical&quot; href=&quot;&lt;%= url_join(config.url, page.canonical_path.replace(&#x27;index.html&#x27;, &#x27;&#x27;)) %&gt;&quot;/&gt;<br>  &lt;% &#125; %&gt;<br><br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no&quot;&gt;<br>  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&gt;<br>  &lt;% if (theme.force_https) &#123; %&gt;<br>    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;<br>  &lt;% &#125; %&gt;<br>  &lt;meta name=&quot;theme-color&quot; content=&quot;&lt;%= theme.color.navbar_bg_color %&gt;&quot;&gt;<br>  &lt;meta name=&quot;author&quot; content=&quot;&lt;%= page.author || config.author %&gt;&quot;&gt;<br>  &lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= keywords %&gt;&quot;&gt;<br>  &lt;% if (theme.open_graph.enable) &#123; %&gt;<br>    &lt;%- open_graph(ogConfig) %&gt;<br>  &lt;% &#125; else &#123; %&gt;<br>    &lt;meta name=&quot;description&quot; content=&quot;&lt;%= description %&gt;&quot;&gt;<br>  &lt;% &#125; %&gt;<br>  &lt;% if ((theme.post.meta.views.enable &amp;&amp; theme.post.meta.views.source === &#x27;busuanzi&#x27;)<br>    || (theme.footer.statistics.enable &amp;&amp; theme.footer.statistics.source === &#x27;busuanzi&#x27;)) &#123; %&gt;<br>    &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer-when-downgrade&quot;&gt;<br>  &lt;% &#125; %&gt;<br>  &lt;% if (theme.custom_head) &#123; %&gt;<br>    &lt;%- theme.custom_head %&gt;<br>  &lt;% &#125; %&gt;<br>  &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;<br><br>  &lt;%- partial(&#x27;_partials/css.ejs&#x27;) %&gt;<br>  &lt;%- export_config() %&gt;<br>  &lt;%- js_ex(theme.static_prefix.internal_js, &#x27;utils.js&#x27;) %&gt;<br>  &lt;%- js_ex(theme.static_prefix.internal_js, &#x27;color-schema.js&#x27;) %&gt;<br>  &lt;%- partial(&#x27;_partials/plugins/analytics.ejs&#x27;) %&gt;<br><br>  &lt;%- inject_point(&#x27;head&#x27;) %&gt;<br>  &lt;% if (theme.math &amp;&amp; theme.math.engine === &#x27;mathjax&#x27;) &#123; %&gt;<br>    &lt;script&gt;<br>      window.MathJax = &#123;<br>        tex: &#123;<br>          inlineMath: [[&#x27;$&#x27;,&#x27;$&#x27;], [&#x27;\\(&#x27;,&#x27;\\)&#x27;]],<br>          displayMath: [[&#x27;$$&#x27;,&#x27;$$&#x27;], [&#x27;\\[&#x27;,&#x27;\\]&#x27;]],<br>          processEscapes: true,<br>          tags: &#x27;ams&#x27;<br>        &#125;,<br>        options: &#123;<br>          skipHtmlTags: [&#x27;script&#x27;,&#x27;noscript&#x27;,&#x27;style&#x27;,&#x27;textarea&#x27;,&#x27;pre&#x27;,&#x27;code&#x27;]<br>        &#125;,<br>        loader: &#123;<br>          load: [&#x27;[tex]/ams&#x27;]<br>        &#125;<br>      &#125;;<br>      MathJax.startup &amp;&amp; MathJax.startup.promise.then(() =&gt; MathJax.typeset());<br>    &lt;/script&gt;<br>    &lt;script src=&quot;&lt;%= theme.math.mathjax.cdn %&gt;&quot; async&gt;&lt;/script&gt;<br>  &lt;% &#125; %&gt;<br>&lt;/head&gt;<br><br></code></pre></td></tr></table></figure><p>此外, <button onclick="window.location.href='https://cps.ninja/2019/03/16/hexo-with-latex/'">to</button></p><p>不知道什么原因，使用kramed会导致Github page上无法显示 块级公式</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub Pages</tag>
      
      <tag>MathJax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>决策树</title>
    <link href="/2025/05/28/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2025/05/28/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="text-Decision-Tree">$\text{Decision Tree}$</h2><p>本文章中，总数据集是 $D$，属性集是 $a$，其中 $a = {a^1, a^2, \ldots, a^V }$，表示属性 $a$ 有 $V$ 种取值；$D^v = {D(\text{attribute}(a) = a^v)}$ 则表示总数据集 $D$ 中满足属性 $a = a^v$ 的数目。</p><p>决策树是一种分类算法，本文将介绍三种决策树算法，包括三种决策树算法涉及到的多个概念，比如信息熵、信息增益、信息增益比等等。</p><h2 id="信息熵">信息熵</h2><p>$$<br>p_k = \frac{\sum(sort = k)}{|D|} \quad (k = 1,2,\ldots,|\mathscr{Y}|)<br>$$</p><p>用符号 <strong>$\operatorname{Ent}$</strong> 表示信息熵</p><p>$$<br>\text{Ent}(D) = -\sum_{k=1}^{|\mathscr{Y}|}p_k\log_2p_k<br>$$</p><h2 id="信息增益">信息增益</h2><p>用符号 <strong>$\text{Gain}$</strong> 表示信息增益</p><p>$$<br>\text{Gain}(D, a) = \text{Ent}(D) - \sum_{v = 1}^{V} \frac{|D<sup>v|}{|D|}\text{Ent}(D</sup>v)<br>$$</p><h2 id="信息增益比">信息增益比</h2><p>用符号 <strong>$\text{Gain_ratio}$</strong> 表示信息增益比</p><p>$$<br>\text{Gain_ratio}(D,a) = \frac{\text{Gain}(D,a)}{\text{IV}(a)}<br>$$</p><p>其中，</p><p>$$<br>\text{IV}(a) = -\sum_{v = 1}<sup>{V}\frac{|D</sup>v|}{|D|} \log_2 \frac{|D^v|}{|D|}<br>$$</p><h2 id="基尼指数">基尼指数</h2><p>用符号 <strong>$\text{Gini_index}$</strong> 表示基尼指数</p><p>$$<br>\begin{align*}<br>\text{Gini}(D^v) &amp;= \sum_{k = 1}^{|\mathscr{Y}|}\sum_{k’ \neq k}p_k p_{k’}<br>\\<br>\text{Gini}(D^v) &amp;= 1 - \sum_{k = 1}<sup>{|\mathscr{Y}|}p_k</sup>{2}<br>\\<br>\text{Gini_index}(D,a) &amp;= \sum_{v = 1}^{V} \frac{|D^v|}{|D|} \text{Gini}(D^v)<br>\end{align*}<br>$$</p><h2 id="剪枝">剪枝</h2><h3 id="损失函数">损失函数</h3><p>假设决策树 $T$ 有 $|T|$ 个叶节点，每个叶节点 $t$ 有 $N_t$ 个样本，其中类别 $k = 1, 2, \ldots, K$ 的样本数为 $N_{tk}$。</p><p><strong>损失函数</strong></p><p>$$<br>C_\alpha(T) = \sum_{t=1}^{|T|}N_t \operatorname{Ent}(D_t) + \alpha |T|<br>$$</p><p>其中 $\operatorname{Ent}(D_t)$ 是叶节点 $t$ 上样本集合 $D_t$ 的信息熵，</p><p>$$<br>\operatorname{Ent}(D_t) = -\sum_{k=1}^{|\mathscr{Y}|} p_{tk} \log_2 p_{tk}<br>$$</p><p>其中 $p_{tk} = \frac{N_{tk}}{N_t}$，$N_{tk}$ 为叶节点 $t$ 上第 $k$ 类样本数，$N_t$ 为叶节点 $t$ 的样本总数。</p><p>所以可以将损失函数写成：</p><p>$$<br>\begin{align*}<br>C(T) &amp;= -\sum_{t=1}^{|T|} N_t \sum_{k=1}^{|\mathscr{Y}|} p_{tk} \log_2 p_{tk}<br>\\<br>C_\alpha(T) &amp;= C(T) + \alpha |T|<br>\end{align*}<br>$$</p><p>我们的<strong>目的</strong>就是最小化损失函数</p><p>$$<br>\min_{T} \quad C_\alpha(T) = \sum_{t=1}^{|T|}N_t \operatorname{Ent}(D_t) + \alpha |T|<br>$$</p><h4 id="算法步骤">算法步骤</h4><p>我们可以定义一个DP[]数组，并使用动态规划的思想来找到最优剪枝</p><ul><li>输入数据 $X = {(\vec{x}_1, y_1), (\vec{x}_2, y_2), \ldots, (\vec{x}_N, y_N) }$</li><li>输出 $T_\alpha$</li></ul><ol><li>对于树T中的每个节点t，计算 $H_t(T)$</li><li>从树的叶节点开始递归地向上回溯，比较 $C_\alpha(T_A)$ 和 $C_\alpha(T_B)$</li><li>返回步骤2</li></ol><h2 id="CART">CART</h2><h3 id="回归树">回归树</h3><p>回归树对应于输入空间的分割和分割单元内的输出值。</p><p>输入空间 $M = R_1, R_2, \ldots, R_M$，每个空间 $R_m$ 有一个输出值 $c_m$，我们可以定义回归树模型如下：</p><p><strong>回归树模型</strong><br>$$<br>f(x) = \sum_{m=1}^{M} c_m I (x \in R_m)<br>$$</p><p><strong>均方误差</strong><br>$$<br>\sum_{x_i \in R_m} (y_i - f(x_i))^2<br>$$</p><p>$$<br>\hat{c}_m = \text{ave}(y_i \mid x_i \in R_m)<br>$$</p><h4 id="分割算法">分割算法</h4><ul><li>输入：训练数据 $D$</li><li>输出：回归树 $f(x)$</li></ul><ol><li>选择 $x_j$，其输出为 $s$。空间 $R_1(j, s) = {x \mid x^{(j)} \leq s}$，空间 $R_2(j, s) = {x \mid x^{(j)} &gt; s}$</li><li>$$\min_{j,s}\left[\min_{c_1} \sum_{x_i \in R_1(j,s)} (y_i - c_1)^2 + \min_{c_2} \sum_{x_i \in R_2(j,s)} (y_i - c_2)^2 \right]$$</li><li>$$\frac{1}{N_m} \sum_{x_i \in R_m(j,s)} y_i, \quad x_i \in R_m, \quad m = 1, 2$$</li><li>重复步骤2和3，直至满足停止条件。</li></ol><h3 id="分类树">分类树</h3><p>根据<strong>基尼指数</strong>进行分类即可</p><p>$$<br>\begin{align*}<br>\text{Gini}(D^v) &amp;= \sum_{k = 1}^{|\mathscr{Y}|}\sum_{k’ \neq k}p_k p_{k’}<br>\\<br>\text{Gini}(D^v) &amp;= 1 - \sum_{k = 1}<sup>{|\mathscr{Y}|}p_k</sup>{2}<br>\\<br>\text{Gini_index}(D,a) &amp;= \sum_{v = 1}^{V} \frac{|D^v|}{|D|} \text{Gini}(D^v)<br>\end{align*}<br>$$</p><h3 id="text-CART-剪枝">$\text{CART}$ 剪枝</h3><p>$\text{CART}$ 剪枝算法由两步组成：手下从省城算法产生的决策树 $T_0$ 底端开始不断简直，直到 $T_0$ 的根节点，形成一个子树序列 ${T_0, T_1, \cdots T_n}$；然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</p><h4 id="text-CART-剪枝算法">$\text{CART}$ 剪枝算法</h4><p><strong>输入</strong>：$\text{CART}$ 算法生成的决策树 $T_0$；<br><strong>输出</strong>：最优决策树 $T_{\alpha}$。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>隐马尔科夫模型</title>
    <link href="/2025/05/27/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/05/27/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="隐马尔科夫模型的定义">隐马尔科夫模型的定义</h2><p>隐马尔科夫模型有如下两个假设：任意状态只依赖于前一时刻状态和任意时刻的观测只依赖于该时刻的马尔科夫链的状态。<br>设 $Q$ 是所有可能的状态的集合，$V$是所有可能的观测的集合：</p><p>$$<br>Q ={q_1, q_2, \dots, q_N}, \quad V = {v_1, v_2, \dots, v_M}<br>$$</p><p>其中，$N$ 是可能的状态数，$M$ 是可能的观测数。<br>$I$ 是长度为 $T$ 的状态序列，$O$ 是对应的观测序列：</p><p>$$<br>I = (i_1, i_2, \dots, i_T), \quad O =(o_1, o_2, \dots, o_T)<br>$$</p><p>$A$ 是状态转移概率矩阵：</p><p>$$<br>A = [a_{ij}]_{N \times N} \tag{1}<br>$$</p><p>其中，</p><p>$$<br>a_{ij} = P(i_{t + 1} = q_j | i_t = q_i), \quad i = 1, 2, \dots, N; \quad j = 1, 2, \dots, N \tag{2}<br>$$</p><p>$B$ 是观测概率矩阵：</p><p>$$<br>B = [b_j(k)]_{N \times N} \tag{3}<br>$$</p><p>其中，</p><p>$$<br>b_j(k) = P(o_t = v_k | i_t = q_j), \quad k = 1, 2, \dots, M; \quad j = 1, 2, \dots, N \tag{4}<br>$$</p><p>$\pi$ 是初始状态概率向量：</p><p>$$<br>\pi = (\pi_i) \tag{5}<br>$$</p><p>其中，</p><p>$$<br>\pi_i = P(i_1 = q_i), \quad i = 1, 2, \dots, N \tag{6}<br>$$</p><p>综上，可以将隐马尔科夫模型用三元符号表示，即</p><p>$$<br>\lambda = (A, B, \pi) \tag{7}<br>$$</p><h2 id="隐马尔科夫模型的3个基本问题">隐马尔科夫模型的3个基本问题</h2><h3 id="概率计算问题">概率计算问题</h3><p>给定模型 $\lambda = (A, B, \pi)$ 和观测序列 $O = (o_1, o_2, \dots, o_T)$，计算在模型 $\lambda$ 下观测序列 $O$ 出现的概率 $P(O | \lambda)$。</p><h4 id="前向算法">前向算法</h4><p>输入：隐马尔科夫模型 $\lambda$，观测序列 $O$；<br>输出：观测序列概率 $P(O | \lambda)$。</p><p>（1）初值</p><p>$$<br>\alpha_1(i) = \pi_i b_i(o_1), \quad i = 1, 2, \dots, N \tag{8}<br>$$</p><p>（2）递推，对 $t = 1, 2, \dots, T - 1$，</p><p>$$<br>\alpha_{t + 1}(i) = \left[\sum_{j = 1}^{N} \alpha_t(j) a_{ji}\right]b_i(o_{t + 1}), \quad i = 1, 2, \dots, N \tag{9}<br>$$</p><p>（3）终止</p><p>$$<br>P(O | \lambda) = \sum_{i = 1}^{N} \alpha_T(i) \tag{10}<br>$$</p><p>这个算法中的 $\alpha$ 可以用一个矩阵表示，其中下标表示行号，括号内表示列号</p><p>$$<br>\alpha = \begin{bmatrix}<br>\alpha_1(1) &amp; \alpha_1(2) &amp; \alpha_1(3) &amp; \cdots &amp; \alpha_1(N) \\[10pt]<br>\alpha_2(1) &amp; \alpha_2(2) &amp; \alpha_2(3) &amp; \cdots &amp; \alpha_2(N) \\[10pt]<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\[10pt]<br>\alpha_T(1) &amp; \alpha_T(2) &amp; \alpha_T(3) &amp; \cdots &amp; \alpha_T(N)<br>\end{bmatrix} \tag{11}<br>$$<br>每次迭代就是在一次计算行内容。</p><h4 id="后向算法">后向算法</h4><p>输入：隐马尔科夫模型 $\lambda$，观测序列 $O$；<br>输出：观测序列概率 $P(O | \lambda)$。</p><p>（1）<br>$$<br>\beta_T(i) = 1, \quad i = 1, 2, \dots, N \tag{12}<br>$$</p><p>（2）对 $t = T - 1, T - 2, \dots, 1$</p><p>$$<br>\beta_t(i) = \sum_{j = 1}^{N} a_{ij} b_j(o_{t + 1})\beta_{t + 1}(j) \tag{13}<br>$$<br>（3）</p><p>$$<br>P(O | \lambda) = \sum_{i = 1}^{N} \pi_i b_i(o_1) \beta_1(i) \tag{14}<br>$$</p><p>$\beta$ 矩阵</p><p>$$<br>\beta = \begin{bmatrix}<br>\beta_1(1) &amp; \beta_1(2) &amp; \beta_1(3) &amp; \cdots &amp; \beta_1(N) \\[10pt]<br>\beta_2(1) &amp; \beta_2(2) &amp; \beta_2(3) &amp; \cdots &amp; \beta_2(N) \\[10pt]<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\[10pt]<br>\beta_T(1) &amp; \beta_T(2) &amp; \beta_T(3) &amp; \cdots &amp; \beta_T(N)<br>\end{bmatrix} \tag{15}<br>$$</p><h3 id="一些概率与期望值的计算">一些概率与期望值的计算</h3><h4 id="单个状态的计算公式">单个状态的计算公式</h4><p>给定模型 $\lambda$ 和观测 $O$，在时刻 $t$ 处于状态 $q_i$ 的概率。记</p><p>$$<br>\gamma_t(i) = P(i_t = q_i |O, \lambda) \tag{16}<br>$$</p><p>可以通过前向后向概率计算：</p><p>$$<br>\gamma_t(i) = \frac{\alpha_t(i) \beta_t(i)}{P(O |\lambda)} = \frac{\alpha_t(i) \beta_t(i)}{\sum_{j = 1}^{N} \alpha_t(j) \alpha_t(j)} \tag{17}<br>$$</p><h4 id="两个状态的计算公式">两个状态的计算公式</h4><p>给定模型 $\lambda$ 和观测 $O$，在时刻 $t$ 处于状态 $q_i$，在时刻 $t + 1$ 处于 $q_j$ 的概率。记</p><p>$$<br>\xi_t(i, j) = \frac{\alpha_t(i)a_{ij}b_j(o_{t + 1})\beta_{t + 1}(j)}{\sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_t(i) a_{ij} b_j(o_{t + 1}) \beta_{t + 1}(j)} \tag{18}<br>$$</p><h4 id="在观测-O-下状态-i-出现的期望值">在观测 $O$ 下状态 $i$ 出现的期望值</h4><p>$$<br>\sum_{t = 1}^{T} \gamma_t(i) \tag{19}<br>$$</p><h4 id="在观测-O-下由状态-i-转移的期望值">在观测 $O$ 下由状态 $i$ 转移的期望值</h4><p>$$<br>\sum_{t = 1}^{T - 1} \gamma_t(i) \tag{20}<br>$$</p><h4 id="在观测-O-下由状态-i-转移到状态-j-的期望值">在观测 $O$ 下由状态 $i$ 转移到状态 $j$ 的期望值</h4><p>$$<br>\sum_{t = 1}^{T - 1} \xi_t(i, j) \tag{21}<br>$$</p><h2 id="学习算法">学习算法</h2><p>前文的内容是都和概率计算有关，那如何根据训练集训练一个隐马尔科夫模型模型呢？</p><h3 id="监督学习方法">监督学习方法</h3><p>如果已给训练数据集包含 $S$ 个长度相同的观测序列和对应的状态序列，我们可以用极大似然估计法来估计参数。分别的有：</p><p>$$<br>\begin{align*}<br>\hat{a_{ij}} &amp;= \frac{A_{ij}}{\sum_{j = 1}^{N} A_{ij}}, \quad i = 1, 2, \dots, N; \quad j = 1, 2, \dots, N \tag{22}<br>\[10pt]<br>\hat{b_{j}}(k) &amp;= \frac{B_{jk}}{\sum_{k = 1}^{M} B_{jk}}, \quad j = 1, 2, \dots, N; \quad k = 1, 2, \dots, M \tag{23}<br>\[10pt]<br>\hat{\pi_{i}} &amp;= \frac{\sum \text{初始状态为$q_i$} }{S} \tag{24}<br>\end{align*}<br>$$</p><p>其中 $A_{ij}$ 表示在训练数据中，从状态 $q_i$ 转移到状态 $q_j$ 的<strong>次数总和</strong>。$B_{jk}$ 表示在状态 $q_j$ 下，观测到符号 $v_k$ 的<strong>次数总和</strong>。</p><h3 id="Baum-Welch-算法">Baum-Welch 算法</h3><p>假定训练数据只包含 $S$ 个长度为 $T$ 的观测序列 ${O_1, O_2, \dots, O_S}$，我们将观测序列数据看作观测数据 $O$，状态序列数据看做不可观测的隐数据 $I$，那么存在如下概率模型</p><p>$$<br>P(O | \lambda) = \sum_{I} P(O |I, \lambda) P(I |\lambda) \tag{25}<br>$$</p><p>实际上，这个模型的参数学习可由 EM 算法实现。</p><p>（1）确定完全数据的对数似然函数。完全数据是$(O, I) = (o_1, o_2, \dots, o_T, i_1, i_2, \dots, i_T)$。</p><p>$$<br>\log P(O, T |\lambda) \tag{26}<br>$$</p><p>（2）E步</p><p>$$<br>Q(\lambda, \bar{\lambda}) = \sum_{I} \log P(O, I |\lambda) P(O, I |\bar{\lambda}) \tag{27}<br>$$</p><p>其中 $\bar{\lambda}$ 是当前模型参数的估计值，$\lambda$ 是要极大化的模型参数。</p><p>$$<br>P(O, I |\lambda) = \pi_{i_1}b_{i_1}(o_1)a_{i_1i_2}b_{i_2}(o_2) \cdots a_{i_{T-1}i_{T}}b_{i_{T}}(o_T) \tag{28}<br>$$</p><p>于是，函数 $Q$ 可以写成：</p><p>$$<br>\begin{align*}<br>Q(\lambda, \bar{\lambda}) = &amp;\sum_{I} \log \pi_{i_1} P(O, I |\bar{\lambda}) + \sum_{I} \left(\sum_{t = 1}^{T - 1} \log a_{i_t i_{t + 1}} \right) P(O, I |\bar{\lambda}) +<br>\[10pt]<br>&amp;\sum_{I} \left(\sum_{t = 1}^{T} \log b_{i_t}(o_t) \right) P(O, I |\bar{\lambda})<br>\end{align*}<br>$$</p><h4 id="算法步骤">算法步骤</h4><p>（1）初始化。对 $n = 0$，随机初始化 $\lambda^{(0)}$。<br>（2）递推。对 $n = 1, 2, \dots$，</p><p>$$<br>\begin{align*}<br>\alpha_{ij}^{(n + 1)} &amp;= \frac{\sum_{t = 1}^{T - 1} \xi_t(i, j)}{\sum_{t = 1}^{T - 1} \gamma_t(i)}<br>\[10pt]<br>b_{j}(k)^{(n + 1)} &amp;= \frac{\sum_{t = 1, o_t = v_k}^{T} \gamma_t(j)}{\sum_{t= 1}^{T} \gamma_t(j)}<br>\[10pt]<br>\pi_{i}^{(n + 1)} &amp;= \gamma_1(i)<br>\end{align*}<br>$$</p><h2 id="预测算法">预测算法</h2><h3 id="近似算法">近似算法</h3><p>由公式：<br>$$<br>\gamma_t(i) = \frac{\alpha_t(i) \beta_t(i)}{P(O |\lambda)} = \frac{\alpha_t(i) \beta_t(i)}{\sum_{j = 1}^{N} \alpha_t(j) \alpha_t(j)}<br>$$<br>知，在每一时刻 $t$ 最有可能的状态 $i_t^{\ast}$ 是<br>$$<br>i_t^{\ast} = \operatorname{arg} \max_{1 \leq i \leq N} [\gamma_t(i)], \quad t = 1, 2, \dots, T \tag{29}<br>$$</p><h3 id="维特比算法">维特比算法</h3><p>维特比算法是用动态规划解隐马尔科夫模型的预测问题。</p><h4 id="算法步骤-2">算法步骤</h4><p>输入：模型 $\lambda = (A, B, \pi)$ 和观测序列 $O = (o_1, o_2, \dots, o_T)$；<br>输出：最优路径 $I^{\ast} = (i_1^{\ast}, i_2^{\ast}, \dots, i_T^{\ast})$。</p><p>（1）初始化</p><p>$$<br>\begin{align*}<br>\delta_1(i) = \pi_i b_i(o_1), \quad i = 1, 2, \dots, N<br>\[10pt]<br>\Psi_1(i) = 0, \quad i = 1, 2, \dots, N<br>\end{align*}<br>$$</p><p>（2）递推。对 $t = 2, 3, \cdots, T$</p><p>$$<br>\begin{align*}<br>\delta_t(i) &amp;= \max_{1 \leq j \leq N} [\delta_{t - 1}(j) a_{ji}] b_i(o_t), \quad i = 1, 2, \cdots, N<br>\[10pt]<br>\Psi_t(i) &amp;= \operatorname{arg} \max_{1 \leq j \leq N}[\delta_{t - 1} a_{ji}], \quad i = 1, 2, \cdots, N<br>\end{align*}<br>$$</p><p>（3）终止</p><p>$$<br>\begin{align*}<br>P^{\ast} &amp;= \max_{1 \leq i \leq N} \delta_{T}(i)<br>\[10pt]<br>i_{T}^{\ast} &amp;= \operatorname{arg} \max_{1 \leq i \leq N} [\delta_{T}(i)]<br>\end{align*}<br>$$</p><p>（4）最优路径回溯。对 $t = T - 1, T - 2, \cdots, 1$</p><p>$$<br>i_t^{\ast} = \Psi_{t + 1}(i_{t + 1}^{\ast})<br>$$</p><p>求得最优路径 $I^{\ast} = (i_1^{\ast}, i_2^{\ast}, \dots, i_T^{\ast})$。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
