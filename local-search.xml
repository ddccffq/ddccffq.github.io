<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Transactions</title>
    <link href="/2025/12/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Transactions/"/>
    <url>/2025/12/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Transactions/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="transaction-management">Transaction Management</h2><ul><li><p>A single user’s access to the database (DB) is represented as one or more transactions executed by the Database System (DBS), including operations such as <strong>select, insert, delete, and update</strong>.</p><ul><li>Transactions are the fundamental logical units of the Database Application System (DBAS) and the basic units managed by the Database Management System (DBMS).</li></ul></li><li><p>Multi-user concurrent access to the database is represented as one or more transactions executed <strong>concurrently</strong> by the DBS.</p></li></ul><p>If more than two transactions access to shared data <span class="math inline">\(Q\)</span>, who ensures data <strong>integrities</strong> (ACID)?</p><ul><li><strong>Recovery-management</strong> in DBMS is responsible for <strong>atomicity</strong> and <strong>durability</strong>.</li><li><strong>Concurrency-control</strong> in DBMS is responsible for <strong>isolation</strong> and <strong>consistency</strong>.</li></ul><h2 id="transaction-concept">Transaction Concept</h2><ul><li><strong>Def</strong>. The <strong>transaction</strong> is a unit of <strong>DBAS</strong>, executing <strong>accesses</strong> and <strong>updates</strong> various data items in DB.</li><li><strong>Def</strong>. A transaction consists of <strong>operations</strong> delimited by <strong>statements</strong><ul><li><strong>begin</strong> transaction and <strong>end</strong> transaction.</li><li><strong>operations</strong>: <strong>read</strong> or <strong>write</strong> on DB.</li></ul></li></ul><p>A transaction is <strong>initialized</strong> by an <strong>application program</strong> written in</p><ul><li>DML, such as SQL.</li><li>programming languages, such as C++ embedded accesses.</li></ul><h2 id="transaction-model">Transaction Model</h2><p>Each data access, such as <strong>select</strong>, <strong>update</strong> in SQL is translated/decomposed into <strong>read</strong> and <strong>write</strong> operations. This means DBMS executes <strong>read</strong> and <strong>write</strong> operations to fulfill <strong>data access</strong> in transactions.</p><p>DBMS allocates <strong>local buffer</strong> in <strong>main memory</strong> as working area. THe DB <strong>permanently</strong> resides on disk, but some portion is <strong>temporarily</strong> residing in <strong>buffer</strong> in main memory.</p><ul><li><strong>Def</strong>. <code>read(X)</code><ul><li>transfers data item <code>X</code> from DB files on <strong>disk buffer</strong> or <strong>disk</strong> to a <strong>variable</strong>, also called <code>X</code>, in the <strong>local buffer</strong>, belonging to a <strong>transaction</strong> that executes the read operation.</li></ul></li><li><strong>Def</strong>. <code>write(X)</code><ul><li>transfers the value in <strong>variable</strong> <code>X</code> in <strong>local buffer</strong> back to <strong>data item</strong> <code>X</code> in DB files on <strong>disk</strong>, belonging to a <strong>transaction</strong> that executes the <strong>write</strong> operation.</li></ul></li></ul><blockquote><p><em>Note</em>: the write operation <strong>does not</strong> result in the <strong>immediate update</strong> of data on <strong>disk</strong>. It may be <strong>temporarily</strong> stored in <strong>disk buffer</strong>.</p></blockquote><h3 id="consistency">Consistency</h3><p>Execution of transactions in <strong>isolation</strong> preserves <strong>consistency</strong> of DB. DB is in a <strong>correct</strong> DB state, before and after the transaction execution.</p><ul><li><strong>Def</strong>. <strong>DB state</strong>: contents of tables in DB or DB instance</li><li><strong>Def</strong>. <strong>Consistency/correctness</strong>: <strong>integrity</strong> constraints are not violated.</li></ul><p>Consistency requirements include</p><ul><li><strong>Explicit integrity</strong> constraints such as <strong>primary key</strong> and <strong>foreign key</strong></li><li><strong>Implicit integrity</strong> constraints, for example, sum of balances of all accounts minus sum of loan amounts must equal value of cash-in-hand</li></ul><blockquote><p>The DB may be <strong>temporarily inconsistent</strong> during transaction execution, but the DB must be consistent when transaction completes successfully.</p></blockquote><h3 id="atomicity">Atomicity</h3><p>Either all operations of transaction are <strong>reflected/persisted</strong> or none. Ensure that updates of a <strong>partially</strong> executed transaction are not reflected.</p><h3 id="isolation">Isolation</h3><p><strong>Def</strong>. Even though multiple transactions execute <strong>concurrently</strong>, all transactions seem to execute <strong>serially</strong>, so the <strong>consistency</strong> is preserved.</p><blockquote><p>Each transaction is <strong>unaware</strong> of <strong>other transactions</strong> executing concurrently</p></blockquote><p>Isolation guarantees</p><ul><li><strong>correctness</strong> of concurrent execution of multiple transactions</li><li><strong>concurrency control</strong> ensures the isolation</li></ul><blockquote><p>Isolation can be ensured by running transactions <strong>serially</strong>, one after the other.</p></blockquote><h3 id="durability">Durability</h3><p><strong>Def</strong>. Once the transaction has completed, the updates to the database by the transaction must <strong>persist</strong> even if there are software or hardware failures.</p><blockquote><p>The <strong>modified</strong> values of data items in buffer should be reflected (write to DB on disk).</p></blockquote><h3 id="acid-guaranteeing">ACID Guaranteeing</h3><p>ACID mechanisms in DBS</p><ul><li>Atomicity: transaction management/recovery management component.</li><li>Consistency: integrity constraints; testing mechanism in DBMS.</li><li>Isolation: concurrency control component.</li><li>Durability: recovery management component.</li></ul><h2 id="transaction-atomicity-and-durability-state-model">Transaction Atomicity and Durability (State Model)</h2><ul><li><strong>Def</strong>. A transaction is termed <strong>aborted</strong>, if it may not complete its execution successfully.</li><li><strong>Def</strong>. A transaction is said to be <strong>committed</strong>, if it completes its execution successfully.</li><li><strong>Def</strong>. Once the changes by an<strong>aborted</strong> transaction has been <strong>undone</strong>, the transaction is said to be <strong>rollback</strong>.</li><li><strong>Def</strong>. A transaction is said to have <strong>terminated</strong>, if it has either committed or aborted.</li></ul><h3 id="transaction-states">Transaction States</h3><p><strong>Transaction states</strong> during its life cycle</p><ul><li><strong>active</strong>: the initial state<ul><li>the initial state, the transaction stays while it is executing from <code>begin-transaction</code></li><li>the transaction is created after <code>begin-transaction</code> is submitted</li><li><em>Note</em>: transaction operations are executed, but the modifications on DB issued by operations <strong>may</strong> only stored <strong>temporally</strong> in the disk buffer. Not <strong>reflected</strong> to DB file on disks immediately.</li></ul></li><li><strong>partially committed</strong>: after the final statement commit, executed<ul><li>the influences that the transaction operations have made are <strong>reflected</strong> from the disk buffer to the DB file</li></ul></li><li><strong>failed</strong>: the normal execution can no longer proceed<ul><li>the transaction is <strong>rolled back</strong> to restore DB to the <strong>state prior to the start of the transactions</strong></li></ul></li><li><strong>aborted</strong>: after the transaction has been rolled back the DB restored to its state prior to the start of the transaction<ul><li>two options after aborted:<ul><li><strong>restart</strong> the transaction: only if no internal logical error</li><li><strong>kill</strong> the transaction</li></ul></li><li>the transaction<ul><li>releases the resources occupied</li><li>reports ot its user that the transaction is aborted</li><li>terminated (quits DBS)</li><li>the cycle life of the transaction is ended</li></ul></li></ul></li><li><strong>committed</strong>: after successful completion (all results have been reflected to the DB file in the <strong>partial committed</strong> state). Then the transaction<ul><li>releases the resources occupied</li><li>terminated (quits DBS)</li><li>the cycle life of the transaction is ended</li></ul></li></ul><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Transactions/state%20diagram%20of%20a%20transaction.png" alt="state diagram of a transaction"><figcaption aria-hidden="true">state diagram of a transaction</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 1: State diagram of a transaction</div><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Transactions/A%20successful%20transaction.png" alt="A successful transaction"><figcaption aria-hidden="true">A successful transaction</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 2: A successful transaction</div><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Transactions/A%20rollback%20transaction.png" alt="A rollback transaction"><figcaption aria-hidden="true">A rollback transaction</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 3: A rollback transaction</div><h2 id="transaction-isolation">Transaction Isolation</h2><p>Concurrent execution of transactions allows high throughput and resource utilization, reducing waiting time. But transactions may contain operations on <strong>shared data</strong>, the different schedules may result in different final DB states.</p><h3 id="concurrent-executions-and-scheduling">*Concurrent Executions and Scheduling</h3><p><strong>Def</strong>. <strong>Schedule</strong> on a set of concurrent transactions, specifies <strong>the order</strong> of the executed operations of concurrency transactions.</p><ul><li>consists of <strong>all operations</strong> of transactions</li><li>preserves <strong>the order of</strong> operations in each individual transaction</li></ul><blockquote><p><em>Note</em>:</p><ul><li>A transaction that <strong>succeeds</strong> in execution will have a <strong>commit instruction</strong> as the last statement</li><li>A transaction that <strong>fails</strong> in execution will have an <strong>abort instruction</strong> as the last statement</li></ul></blockquote><p>Here is an example illustrating two scheduling: <strong>serial schedule</strong> and <strong>concurrent schedule</strong>. Suppose there are two transactions</p><ul><li><span class="math inline">\(T_1\)</span>: transfer <span class="math inline">\(50\)</span> funds from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span></li><li><span class="math inline">\(T_2\)</span>: transfer <span class="math inline">\(10\%\)</span> of the balance from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span></li><li>Initializing value of <span class="math inline">\(A = 1000\)</span>, <span class="math inline">\(B = 2000\)</span></li></ul><p>If we apply <strong>serial schedule</strong>, obviously, different sequence of <span class="math inline">\(T_1\)</span>, <span class="math inline">\(T_2\)</span> results in different final values of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. The following illustrate the condition that we execute <span class="math inline">\(T_1\)</span> first.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(t\)</span></th><th style="text-align: center;">transaction</th><th style="text-align: center;">values</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(T_1\)</span></td><td style="text-align: center;">read(<span class="math inline">\(A\)</span>) <br> <span class="math inline">\(A := A - 50\)</span> <br> write(<span class="math inline">\(A\)</span>) <br> read(<span class="math inline">\(B\)</span>) <br> <span class="math inline">\(B := B + 50\)</span> <br> write(<span class="math inline">\(B\)</span>) <br> commit</td><td style="text-align: center;"><span class="math inline">\(A = 950\)</span> <br> <span class="math inline">\(B = 2050\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(T_2\)</span></td><td style="text-align: center;">read(<span class="math inline">\(A\)</span>) <br> <span class="math inline">\(\text{temp} := A \times 0.1\)</span> <br> <span class="math inline">\(A := A - \text{temp}\)</span> <br> write(<span class="math inline">\(A\)</span>) <br> read(<span class="math inline">\(B\)</span>) <br> <span class="math inline">\(B := B + \text{temp}\)</span> <br> write(<span class="math inline">\(B\)</span>) <br> commit</td><td style="text-align: center;"><span class="math inline">\(A = 855\)</span> <br> <span class="math inline">\(B = 2145\)</span></td></tr></tbody></table></div><blockquote><p>If we execute <span class="math inline">\(T_2\)</span> first, the final value: <span class="math inline">\(A = 850\)</span>, <span class="math inline">\(B = 2150\)</span>.</p></blockquote><p>What about applying <strong>concurrent schedule</strong>? The core idea is allowing a transaction executes when another transaction <strong>is executing</strong>. Here is an example on <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_2\)</span>. We suppose we execute <span class="math inline">\(T_1\)</span> first.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(t\)</span></th><th style="text-align: center;">transaction</th><th style="text-align: center;">values</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(T_1\)</span></td><td style="text-align: center;">read(<span class="math inline">\(A\)</span>) <br> <span class="math inline">\(A := A - 50\)</span> <br> write(<span class="math inline">\(A\)</span>)</td><td style="text-align: center;"><span class="math inline">\(A = 950\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(T_2\)</span></td><td style="text-align: center;">read(<span class="math inline">\(A\)</span>) <br> <span class="math inline">\(\text{temp} := A \times 0.1\)</span> <br> <span class="math inline">\(A := A - \text{temp}\)</span> <br> write(<span class="math inline">\(A\)</span>)</td><td style="text-align: center;"><span class="math inline">\(A = 855\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(T_1\)</span></td><td style="text-align: center;">read(<span class="math inline">\(B\)</span>) <br> <span class="math inline">\(B := B + 50\)</span> <br> write(<span class="math inline">\(B\)</span>) <br> commit</td><td style="text-align: center;"><span class="math inline">\(B = 2050\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(T_2\)</span></td><td style="text-align: center;">read(<span class="math inline">\(B\)</span>) <br> <span class="math inline">\(B := B + \text{temp}\)</span> <br> write(<span class="math inline">\(B\)</span>) <br> commit</td><td style="text-align: center;"><span class="math inline">\(B = 2145\)</span></td></tr></tbody></table></div><blockquote><p><em>Note</em>, assuming, <strong>read</strong> fetches data directly from DB file <strong>on disk</strong>.</p></blockquote><h2 id="serializable">Serializable</h2><p>To identify whether a <strong>concurrent schedule</strong> on transactions is <strong>right</strong> (this schedule is <strong>equivalent</strong> to a <strong>serial schedule</strong>).</p><p>Basic assumption:</p><ul><li>each transaction preserves DB consistency</li><li>serial execution of transactions preserves DB consistency</li></ul><p><strong>Def</strong>. A schedule is <strong>serializable</strong> if it is <strong>equivalent</strong> to a <strong>serial schedule</strong>.</p><h3 id="conflict-serializable">Conflict serializable</h3><p>Two transactions <span class="math inline">\(T_i = \{l_i\}\)</span>, <span class="math inline">\(T_j = \{l_j\}\)</span>, and schedule <span class="math inline">\(S\)</span> on <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span>.</p><ul><li><strong>Def</strong>. <span class="math inline">\(l_i\)</span> of transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(l_j\)</span> of <span class="math inline">\(T_j\)</span> are conflict, <strong>if and only if</strong> for some item <span class="math inline">\(Q\)</span> accessed by both <span class="math inline">\(l_i(Q)\)</span> and <span class="math inline">\(l_j(Q)\)</span>, at least one of these two instructions is write(<span class="math inline">\(Q\)</span>).</li><li><strong>Def</strong>. <span class="math inline">\(S\)</span> and <span class="math inline">\(S&#39;\)</span> are <strong>conflict equivalent</strong> if the schedule <span class="math inline">\(S\)</span> can be transformed into <span class="math inline">\(S&#39;\)</span> by a series of swaps of <strong>non-conflicting</strong> instructions/operations.</li></ul><blockquote><p><em>Note</em>:</p><ul><li>Only swapping of two operations/instructions <span class="math inline">\(l_i\)</span> and <span class="math inline">\(l_j\)</span> that belong to two different <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> respectively are permitted</li><li>Swapping should not change the orders of instruction in each transaction</li><li>Swapping should not change orders of conflict instruction executing <span class="math inline">\(S\)</span></li></ul></blockquote><p><strong>Def</strong>. A <strong>concurrent</strong> schedule <span class="math inline">\(S\)</span> is <strong>conflict serializable</strong> if it is <strong>conflict equivalent</strong> to a serial schedule <span class="math inline">\(S&#39;\)</span></p><h3 id="identification-of-conflict-serializable">*Identification of Conflict Serializable</h3><ol type="1"><li>Starting from the concurrent <span class="math inline">\(S\)</span>, maintaining executing orders of conflicting, swapping executing orders of non-conflicting operations in <span class="math inline">\(S\)</span>. Observing whether a serial <span class="math inline">\(S&#39;\)</span> can be obtained.</li><li><strong>Precedence graph</strong></li></ol><p><strong>Def</strong>. <strong>Precedence graph</strong> <span class="math inline">\(G(S)\)</span> for the given transactions <span class="math inline">\(T_i\)</span>, <span class="math inline">\(T_j\)</span>,</p><ul><li>direct graph <span class="math inline">\(G(V, E)\)</span>, where the vertices are transactions</li><li>arc from <span class="math inline">\(T_i \to T_j\)</span>, for which one of three conditions holds<ul><li><span class="math inline">\(T_i\)</span> executes write(<span class="math inline">\(Q\)</span>) before <span class="math inline">\(T_j\)</span> executes read(<span class="math inline">\(Q\)</span>)</li><li><span class="math inline">\(T_i\)</span> executes read(<span class="math inline">\(Q\)</span>) before <span class="math inline">\(T_j\)</span> executes write(<span class="math inline">\(Q\)</span>)</li><li><span class="math inline">\(T_i\)</span> executes write(<span class="math inline">\(Q\)</span>) before <span class="math inline">\(T_j\)</span> executes write(<span class="math inline">\(Q\)</span>)</li></ul></li></ul><p><strong>Def</strong>. A schedule is <strong>conflict serializable</strong> if and only if its precedence graph is <strong>acyclic</strong>.</p><p>For example,</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(t\)</span></th><th style="text-align: center;"><span class="math inline">\(T_1\)</span></th><th style="text-align: center;"><span class="math inline">\(T_2\)</span></th><th style="text-align: center;"><span class="math inline">\(T_3\)</span></th><th style="text-align: center;"><span class="math inline">\(T_4\)</span></th><th style="text-align: center;"><span class="math inline">\(T_5\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"></td><td style="text-align: center;">read(<span class="math inline">\(X\)</span>)</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(2\)</span></td><td style="text-align: center;">read(<span class="math inline">\(Y\)</span>)</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td style="text-align: center;">read(<span class="math inline">\(Z\)</span>)</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(4\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">read(<span class="math inline">\(V\)</span>)</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(5\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">read(<span class="math inline">\(W\)</span>)</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(6\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">read(<span class="math inline">\(W\)</span>)</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(7\)</span></td><td style="text-align: center;"></td><td style="text-align: center;">read(<span class="math inline">\(Y\)</span>)</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(8\)</span></td><td style="text-align: center;"></td><td style="text-align: center;">write(<span class="math inline">\(Y\)</span>)</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(9\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">write(<span class="math inline">\(Z\)</span>)</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(10\)</span></td><td style="text-align: center;">read(<span class="math inline">\(U\)</span>)</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(11\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">read(<span class="math inline">\(Y\)</span>)</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(12\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">write(<span class="math inline">\(Y\)</span>)</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(13\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">read(<span class="math inline">\(Z\)</span>)</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(14\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">write(<span class="math inline">\(Z\)</span>)</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(15\)</span></td><td style="text-align: center;">read(<span class="math inline">\(U\)</span>)</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(16\)</span></td><td style="text-align: center;">write(<span class="math inline">\(U\)</span>)</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><pre><code class=" mermaid">graph TD    A[T1] --&gt; B[T2]    B --&gt; C[T4]    A --&gt; D[T3]    D --&gt; C    A --&gt; C    E[T5]</code></pre></div><div style="text-align: center; font-style: italic;">Figure 4: Precedence graph</div><h3 id="construction-of-conflict-serializable-schedule">Construction of Conflict Serializable Schedule</h3><p>Construct a <strong>serializable</strong> <span class="math inline">\(S&#39;\)</span>, conflict equivalent to s serializable schedule <span class="math inline">\(S\)</span>.</p><ul><li>starting from a given schedule <span class="math inline">\(S\)</span></li><li>maintaining executing orders of conflicting operations in <span class="math inline">\(S\)</span></li><li>swapping executing orders of non-conflicting operations in <span class="math inline">\(S\)</span></li><li>resulting in a conflict serializable <span class="math inline">\(S&#39;\)</span></li></ul><h2 id="transaction-isolation-and-atomicity">Transaction Isolation and Atomicity</h2><p>When transaction <span class="math inline">\(T_i\)</span> fails, operations <span class="math inline">\(T_j\)</span> that depends on <span class="math inline">\(T_i\)</span> already executed should be rollback/undone/aborted/canceled (ensures <strong>atomicity</strong>).</p><h3 id="recoverability">*Recoverability</h3><p><strong>Def</strong>. <strong>Recoverable schedule</strong> is a schedule for each pair of <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span>. If <span class="math inline">\(T_j\)</span> reads data item <span class="math inline">\(Q\)</span> previously <strong>written</strong> by <span class="math inline">\(T_i\)</span>, commit operations of <span class="math inline">\(T_i\)</span> appears <strong>before</strong> commit operation of <span class="math inline">\(T_j\)</span>.</p><p>Consider relation schemas: <em>SC</em>(S#, C#, grade), and <em>MaxGrade</em>(C#, maxG). What’s more, <strong>check</strong> grade in <em>SC</em> (<span class="math inline">\(0 \leq\)</span> grade <span class="math inline">\(\leq 100\)</span>).</p><p>The transactions are</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: left;"><span class="math inline">\(T_i\)</span></th><th style="text-align: left;"><span class="math inline">\(T_j\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">begin transaction <br> insert into SC value (103, 2, 97);</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">begin transaction <br> insert into MaxGrade(C#, maxG) <br> select C#, max(grade) <br> from SC <br> group by C#; <br> commit</td></tr><tr class="odd"><td style="text-align: left;">update SC <br> set grade = grade + 5; <br> commit</td><td style="text-align: left;"></td></tr></tbody></table></div><p>SQL server can use <code>SET XACT_ABORT &#123;ON | OFF&#125;</code></p><ul><li>If <code>ON</code>, entire transaction will terminate and rollback， <strong>recoverable schedule</strong></li><li>If <code>OFF</code>, only rollback where fails, and transaction will continue, <strong>probably non-recoverable schedule</strong></li><li>Default <code>OFF</code></li></ul><p>Here is an example of absolutely non-recoverable schedule. The transactions are:</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(T_1\)</span></th><th style="text-align: center;"><span class="math inline">\(T_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">read(<span class="math inline">\(A\)</span>)</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">write(<span class="math inline">\(A\)</span>)</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">read(<span class="math inline">\(A\)</span>)</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">commit</td></tr><tr class="odd"><td style="text-align: center;">read(<span class="math inline">\(B\)</span>)</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">commit</td><td style="text-align: center;"></td></tr></tbody></table></div><p>If <span class="math inline">\(T_1\)</span> is aborted after <span class="math inline">\(T_2\)</span> has <strong>been committed</strong>, the value if the item <span class="math inline">\(A\)</span> will be rollback to its old value before <span class="math inline">\(T_1\)</span> executes. But <span class="math inline">\(T_2\)</span> has read the new value of the data item <span class="math inline">\(A\)</span> and has been <strong>committed</strong>.</p><h3 id="cascadeless-schedules">Cascadeless Schedules</h3><p><strong>Def</strong>. <strong>Cascading rollback</strong>: <strong>a single transaction</strong> failure leads to <strong>series of transactions</strong> rollbacks.</p><blockquote><p>Cascading rollback is undesirable, because undoing of the previous works.</p></blockquote><p><strong>Def</strong>. <strong>Cascadeless schedules</strong> are the schedules that cascading rollback cannot occur. For each pair of <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span>, where <span class="math inline">\(T_j\)</span> reads <span class="math inline">\(Q\)</span> previously written by <span class="math inline">\(T_i\)</span>, the <strong>commit</strong> operations of <span class="math inline">\(T_i\)</span> appears <strong>before</strong> the <strong>read</strong> operation of <span class="math inline">\(T_j\)</span>.</p><blockquote><p>Cascadeless schedule is also recoverable, but a recoverable may not be a cascadeless schedule.</p></blockquote><h2 id="例题">例题</h2><p>Consider transaction <span class="math inline">\(T_1\)</span>, <span class="math inline">\(T_2\)</span>, <span class="math inline">\(T_3\)</span> and <span class="math inline">\(T_4\)</span> under <span class="math inline">\(S\)</span>. which concurrently access relational tables <em>Student</em>(stuID, stuName, age, height) and <em>Grade</em>(stuID, cosID, grade)</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: left;"><span class="math inline">\(T_1\)</span></th><th style="text-align: left;"><span class="math inline">\(T_2\)</span></th><th style="text-align: left;"><span class="math inline">\(T_3\)</span></th><th style="text-align: left;"><span class="math inline">\(T_4\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">begin transaction</td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">begin transaction</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">update <em>Student</em> <br> set stuName = ‘Li’ <br> where stuID = 10</td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">begin transaction</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">update <em>Student</em> <br> set age = age + 1 <br> where stuID = 20</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">select age <br> from <em>Student</em> <br> where stuID = 50</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">begin transaction</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">update <em>Student</em> <br> set height = height + 5 <br> where stuID = 30</td></tr><tr class="odd"><td style="text-align: left;">update <em>Grade</em> <br> set grade = grade + 1 <br> where stuID = 40 and cosID = 10</td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">commit</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">commit</td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">select stuID, grade <br> from <em>Grade</em> <br> where stuID = 40 and cosID = 10</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">commit</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">select height <br> from <em>Student</em> <br> where stuID = 30</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;">commit</td><td style="text-align: left;"></td></tr></tbody></table></div><p>problem:</p><p>(1). Construct the precedence graph for <span class="math inline">\(S\)</span></p><div style="display: block; margin: 0 auto; width: fit-content"><pre><code class=" mermaid">graph TD    A[T1] --&gt; B[T2]    A --&gt; C[T4]    C --&gt; D[T3]</code></pre></div><p>(2). If <span class="math inline">\(S\)</span> a serializable schedule? If not, give the reason</p><p>Yes.</p><p>(3). Is <span class="math inline">\(S\)</span> a recoverable schedule, and why?</p><p>No, <span class="math inline">\(S\)</span> is not a recoverable schedule. A recoverable schedule requires that for every pair of transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span>, if <span class="math inline">\(T_j\)</span> reads a data item <span class="math inline">\(Q\)</span> previously written by <span class="math inline">\(T_i\)</span>, the commit operation of <span class="math inline">\(T_i\)</span> must occur before the commit operation of <span class="math inline">\(T_j\)</span>. In this schedule, <span class="math inline">\(T_2\)</span> reads <code>stuName</code> where <code>stuID = 10</code>, which was written by <span class="math inline">\(T_1\)</span> at the beginning. However, <span class="math inline">\(T_2\)</span> commits before <span class="math inline">\(T_1\)</span>, violating the definition of a recoverable schedule.</p><p>(4). Is <span class="math inline">\(S\)</span> a cascadeless schedule, and why?</p><p>No, <span class="math inline">\(S\)</span> is not a cascadeless schedule. A cascadeless schedule requires that for every pair of transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span>, if <span class="math inline">\(T_j\)</span> reads a data item <span class="math inline">\(Q\)</span> previously written by <span class="math inline">\(T_i\)</span>, the commit operation of <span class="math inline">\(T_i\)</span> must occur before the read operation of <span class="math inline">\(T_j\)</span>. In this schedule, <span class="math inline">\(T_2\)</span> reads <code>stuName</code> where <code>stuID = 10</code>, which was written by <span class="math inline">\(T_1\)</span> at the beginning. However, <span class="math inline">\(T_1\)</span> has not committed before <span class="math inline">\(T_2\)</span> reads the data, violating the definition of a cascadeless schedule.</p>]]></content>
    
    
    <categories>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Chapter 16: Query Optimization</title>
    <link href="/2025/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Query_Optimization/"/>
    <url>/2025/12/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Query_Optimization/</url>
    
    <content type="html"><![CDATA[<p>Based on 12 rules to optimize relational algebra expression</p><span id="more"></span><h2 id="overview">Overview</h2><p>A query statement corresponds to <strong>several</strong> equivalent expressions. Different costs for equivalent evaluation plans. What <strong>query optimization</strong> does is to choose an <strong>efficient</strong> evaluation plan with <strong>lower</strong> costs.</p><p><strong>Query optimization procedure</strong>:</p><ol type="1"><li><strong>Generating</strong> the <strong>equivalent query trees/expressions</strong>, by transforming of <strong>relational algebra expressions</strong> using <strong>equivalence rules</strong></li><li><strong>Generating</strong> the alternative <strong>evaluation plans</strong>, by annotating the resultant equivalent expressions with algorithms for each operations</li><li><strong>Choosing</strong> the optimal or near-optimal plan based on the <strong>estimated cost</strong>, by <strong>heuristic optimization</strong> or <strong>cost-based optimization</strong></li></ol><h2 id="transformation-of-relational-expressions">Transformation of Relational Expressions</h2><p><strong>Def</strong>. <strong>Equivalent expression</strong> means two <strong>relational algebra</strong> expressions are <strong>equivalent</strong>, if two expressions generate the same set of tuples on all legal database instances.</p><h3 id="equivalence-rules">*Equivalence Rules</h3><ol type="1"><li><p><strong>Conjunctive</strong> selection operations can be deconstructed into a <strong>sequence</strong> of <strong>individual</strong> selections</p><p><span class="math display">\[\sigma_{\theta_1 \land \theta_2} (E) = \sigma_{\theta_1} (\sigma_{\theta_2} (E))\]</span></p></li><li><p>Selection operations are commutative</p><p><span class="math display">\[\sigma_{\theta_1}(\sigma_{\theta_2}(E)) = \sigma_{\theta_2}(\sigma_{\theta_1}(E))\]</span></p></li><li><p>Only the <strong>final</strong> operation in a sequence of project operations is needed</p><p><span class="math display">\[\Pi_{L_1} (\Pi_{L2} (\cdots (\Pi_{L_n} (E)))) = \Pi_{L_1}(E)\]</span></p><p>Required that <span class="math inline">\(L_1 \subseteq L_2 \subseteq \cdots \subseteq L_n\)</span></p><p>e.g. <span class="math inline">\(\Pi_{\text{ID}} (\Pi_{\text{ID}. \text{name}} (\text{instructor})) = \Pi_{\text{ID}} (\text{instructor})\)</span></p></li><li><p>Selections can be combined with Cartesian products and theta joins</p><p><span class="math display">\[\sigma_{\theta_1} (E_1 \Join_{\theta_2} E_2) = E_1 \Join_{\theta_1 \land \theta_2} E_2\]</span></p><p>Costs of the <strong>right hand</strong> are less than that of the left hand.</p><ul><li>Definition of <span class="math inline">\(\theta\)</span> join: <span class="math inline">\(\sigma_{\theta}(E_1 \times E_2) = E_1 \Join_{\theta} E_2\)</span></li></ul><p>e.g. <span class="math inline">\(\sigma_{\text{dept\_name} = \text{&#39;Music&#39;}} (\text{\text{instructor}} \Join_{\text{instructor.ID} = \text{teaches.ID}} \text{teaches}) = \text{instructor} \Join_{\text{instructor.ID} = \text{teaches.ID} \land \text{dept\_name} = \text{&#39;Music&#39;}} \text{teaches}\)</span></p></li><li><p>Theta join operations are commutative</p><p><span class="math display">\[E_1 \Join_{\theta} E_2 = E_2 \Join_{\theta} E_1\]</span></p><p>The expression with smaller size should be arranged as the <strong>left</strong> one in join operation</p></li><li><p>Associative</p><ul><li><strong>Natural join</strong> operations are associative: <span class="math inline">\((E_1 \Join E_2) \Join E_3 = E_1 \Join (E_2 \Join E_3)\)</span></li><li><strong>Theta joins</strong> are associative: <span class="math inline">\((E_1 \Join_{\theta_1} E_2) \Join_{\theta_2 \land \theta_3} E_3 = E_1 \Join_{\theta_1 \land \theta_3} (E_2 \Join_{\theta_2} E_3)\)</span><ul><li>where <span class="math inline">\(\theta_2\)</span> involves attributes from <strong>only</strong> <span class="math inline">\(E_2\)</span> and <span class="math inline">\(E_3\)</span></li></ul></li></ul></li><li><p>Selection operation distributes over theta join</p><ul><li>Attributes in <span class="math inline">\(\theta_0\)</span> involve <strong>only</strong> the attributes of one of the expressions, e.g. <span class="math inline">\(E_1\)</span>, being joined <span class="math inline">\(\sigma_{\theta_0} (E_1 \Join_{\theta} E_2) = (\sigma_{\theta_0} (E_1)) \Join_{\theta} E_2\)</span></li><li>Attributes in <span class="math inline">\(\theta_1\)</span> involves only attributes of <span class="math inline">\(E_1\)</span>, attributes in <span class="math inline">\(\theta_2\)</span> involves only attributes of <span class="math inline">\(E_2\)</span>, <span class="math inline">\(\sigma_{\theta_1 \land \theta_2} (E_1 \Join_{\theta} E_2) = (\sigma_{\theta_1}(E_1) \Join_{\theta} (\sigma_{\theta_2}(E_2)))\)</span></li><li><em>Note</em>: When <strong>7</strong> is applied, the <strong>size</strong> of relations participating in <strong>theta join</strong> operation is <strong>reduced</strong>, thus evaluation costs are reduced</li></ul></li><li><p>Projection operation distributes over theta join</p><ul><li><span class="math inline">\(L_1\)</span> and <span class="math inline">\(L_2\)</span> are the attributes of <span class="math inline">\(E_1\)</span> and <span class="math inline">\(E_2\)</span>, respectively, if join condition <span class="math inline">\(\theta\)</span> involves only attributes in <span class="math inline">\(L_1 \cup L_2\)</span>, then</li></ul><p><span class="math display">\[\Pi_{L_1 \cup L_2} (E_1 \Join_{\theta} E_2) = (\Pi_{L_1}(E_1)) \Join_{\theta} (\Pi_{L_2}(E_2))\]</span></p><ul><li>Consider a join <span class="math inline">\(E_1 \Join_{\theta} E_2\)</span><ul><li>Let <span class="math inline">\(L_1\)</span> and <span class="math inline">\(L_2\)</span> be sets of attributes from <span class="math inline">\(E_1\)</span> and <span class="math inline">\(E_2\)</span>, respectively</li><li>Let <span class="math inline">\(L_3\)</span> be attributes of <span class="math inline">\(E_1\)</span> that involved in join condition <span class="math inline">\(\theta\)</span>, but not in <span class="math inline">\(L_1 \cup L_2\)</span></li><li>Let <span class="math inline">\(L_4\)</span> be attributes of <span class="math inline">\(E_2\)</span> that involved in join condition <span class="math inline">\(\theta\)</span>, but not in <span class="math inline">\(L_1 \cup L_2\)</span></li></ul></li></ul><p><span class="math display">\[ \Pi_{L_1 \cup L_2} (E_1 \Join_{\theta} E_2) = \Pi_{L_1 \cup L_2} ((\Pi_{L_1 \cup L_3}(E_1)) \Join_{\theta} (\Pi_{L_2 \cup L_4} (E_2))) \]</span></p></li><li><p>The set operations union and intersection are <strong>commutative</strong></p></li><li><p>Set union and intersection are <strong>associative</strong></p></li><li><p>The selection operation distributes over <span class="math inline">\(\cup\)</span>, <span class="math inline">\(\cap\)</span> and <span class="math inline">\(-\)</span>. <span class="math inline">\(\sigma_{\theta}(E_1 - E_2) = \sigma_{\theta}(E_1) - \sigma_{\theta}(E_2)\)</span></p></li><li><p>The projection operation distributes over union. <span class="math inline">\(\Pi_{L}(E_1 \cup E_2) = (\Pi_{L} (E_1)) \cup (\Pi_{L} (E_2))\)</span></p></li></ol><p>Here are some examples</p><p>(1). Find the <strong>names</strong> of all instructors in the department Music, along with <strong>titles</strong> of the courses that they teach. The algebra expression is:</p><p><span class="math display">\[\Pi_{\text{name}, \text{title}} (\sigma_{\text{dept\_name} = \text{&#39;Music&#39;}} (\text{instructor} \Join (\text{teaches} \Join \Pi_{\text{course\_id}, \text{title}}(\text{course}))))\]</span></p><p>Transformation using rule <strong>7</strong>.</p><p><span class="math display">\[\Pi_{\text{name}, \text{title}} ((\sigma_{\text{dept\_name} = \text{&#39;Music&#39;}}(\text{instructor})) \Join (\text{teaches} \Join \Pi_{\text{course\_id}, \text{title}}(\text{course})))\]</span></p><p>(2). Find <strong>names</strong> of all instructors in Music department who taught in 2019, along with <strong>titles</strong> of the course that they taught. The algebra expression is:</p><p><span class="math display">\[\Pi_{\text{name}, \text{title}} (\sigma_{\text{dept\_name} = \text{&#39;Music&#39;}  \land (\text{year} = 2019)} (\text{instructor} \Join (\text{teaches} \Join \Pi_{\text{course\_id}, \text{title}} (\text{course}))))\]</span></p><p>Transformation using rule <strong>7</strong>.</p><p><span class="math display">\[\Pi_{\text{name}, \text{title}} ((\sigma_{\text{dept\_name} = \text{&#39;Music&#39;}} (\text{instructor})) \Join (\sigma_{\text{year} = 2019} (\text{teaches})) \Join (\Pi_{\text{course\_id}, \text{title}} (\text{course})))\]</span></p><p>(3). Why projection as early as possible reduces size of the relation to be joined?</p><p><span class="math display">\[\Pi_{\text{name}, \text{title}} ((\sigma_{\text{dept\_name} = \text{&#39;Music&#39;}} (\text{instructor}) \Join \text{teaches}) \Join \Pi_{\text{course\_id}, \text{title}}(\text{course}))\]</span></p><p>Computing <span class="math inline">\((\sigma_{\text{dept\_name} = \text{&#39;Music&#39;}} (\text{instructor}) \Join \text{teaches})\)</span> resulting in a schema with <strong>unneeded</strong> attributes (what we need may be course_id and name). We add a projection to eliminate unneeded attributes.</p><p><span class="math display">\[\Pi_{\text{course\_id}, \text{name}}(\sigma_{\text{dept\_name} = \text{&#39;Music&#39;}} (\text{instructor}) \Join \text{teaches})\]</span></p><h2 id="join-ordering">Join Ordering</h2><p>For all relations <span class="math inline">\(r_1\)</span>, <span class="math inline">\(r_2\)</span> and <span class="math inline">\(r_3\)</span></p><p><span class="math display">\[(r_1 \Join r_2) \Join r_3 = r_1 \Join (r_2 \Join r_3)\]</span></p><p>If <span class="math inline">\(r_2 \Join r_3\)</span> is quite large bu <span class="math inline">\(r_1 \Join r_2\)</span> is small, choose</p><p><span class="math display">\[(r_1 \Join r_2) \Join r_3\]</span></p><p>For example , consider the expression</p><p><span class="math display">\[\Pi_{\text{name}, \text{title}} (\sigma_{\text{dept\_name} = \text{Music}} (\text{instructor}) \Join \text{teaches} \Join \Pi_{\text{course\_id}, \text{title}} (\text{course}))\]</span></p><ol type="1"><li><p>Compute <span class="math inline">\((\text{teaches} \Join \Pi_{\text{course\_id}, \text{title}} (\text{course}))\)</span> first, and join result with <span class="math inline">\(\sigma_{\text{dept\_name} = \text{Music}} (\text{instructor})\)</span> as the result of the first join is likely to be a large relation</p></li><li><p>If <strong>only a small fraction</strong> of instructors are likely to be, it is better to first compute <span class="math inline">\(\sigma_{\text{dept\_name} = \text{Music}} (\text{instructor}) \Join \text{teaches}\)</span></p></li></ol><h2 id="choice-of-evaluation-plans-query-optimization">Choice of Evaluation Plans: Query Optimization</h2><p>Generate an <strong>evaluation plan</strong> for a relational algebra expression with <strong>the lowest or lower cost</strong></p><ol type="1"><li>Generating the <strong>optimized</strong> query trees</li><li>Selecting<ul><li>Implementation algorithms for each operations in the tree</li><li><strong>Pipeline</strong> or materialization strategy</li></ul></li></ol><h3 id="heuristic-optimization">Heuristic Optimization</h3><p><strong>Def</strong>. <strong>Heuristic optimization</strong></p><ul><li><strong>Heuristic</strong> (or <strong>heuristic rules</strong>) to choose a better plan</li><li><strong>Suboptimal</strong> plan with <strong>lower</strong> costs can be obtained</li></ul><p>Principles: transforms query tree by <strong>heuristics</strong> to reduce cost</p><ul><li>Perform <strong>selection</strong> early to <strong>reduce</strong> the number of <strong>tuples</strong></li><li>Perform <strong>projection</strong> early to <strong>reduce</strong> the number of <strong>attributes</strong></li><li>Perform <strong>join</strong> to substitute <strong>Cartesian product</strong> and <strong>selection</strong></li><li>Perform <strong>restrictive selection</strong> and <strong>join</strong> operations before other operations<ul><li>The most <strong>restrictive operations</strong> generate relations with <strong>the smallest size</strong></li></ul></li></ul><h3 id="steps-in-heuristic-optimization">Steps in Heuristic Optimization</h3><ol type="1"><li>将 conjunctive selection 分解为多个单独的选择操作以使单个选择操作尽可能沿查询树下移</li><li>根据选择操作的交换律和分配律，将查询树每个选择操作尽可能移向叶节点，以便尽早执行选择操作</li><li>根据连接操作的结合律和交换律，重新安排查询树中的叶节点，使得具有 restrictive selection 特征的叶节点先执行</li><li>利用以连接操作代替相邻的选择和笛卡尔乘积操作</li><li>将查询树上投影操作尽可能下移，早执行投影操作，减少中间计算结果</li></ol><p>Here are some examples</p><p>(1). Given</p><ul><li><em>S</em>(sID, sname, age, sex)</li><li><em>C</em>(cID, cname, teacher)</li><li><em>SC</em>(sID, cID, grade)</li></ul><p>Find students who are male and get grades more than <span class="math inline">\(90\)</span>, when they learn some course. Firstly, we get SQL statement.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> sname<br><span class="hljs-keyword">FROM</span> S, SC<br><span class="hljs-keyword">WHERE</span> S.S# <span class="hljs-operator">=</span> SC.S# <span class="hljs-keyword">AND</span> sex <span class="hljs-operator">=</span> male <span class="hljs-keyword">AND</span> grade <span class="hljs-operator">&gt;</span> <span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure><p>Then, get algebra expression of statement above.</p><p><span class="math display">\[\Pi_{\text{sname}} (\sigma_{(\text{S.sID = SC.sID}) \land (\text{sex = male}) \land (\text{grade} &gt; 90)} (\text{S} \times \text{SC}))\]</span></p><p>Transformation using rule <strong>4</strong>.</p><p><span class="math display">\[\Pi_{\text{sname}} (\sigma_{(\text{sex = male}) \land (\text{grade} &gt; 90)} (\text{S} \Join_{(\text{S.sID = SC.sID})} \text{SC}))\]</span></p><p>Transformation using rule <strong>7</strong>.</p><p><span class="math display">\[\Pi_{\text{sname}} ((\sigma_{(\text{sex = male})} (\text{S})) \Join_{(\text{S.sID = SC.sID})} (\sigma_{\text{grade} &gt; 90} (\text{SC})))\]</span></p><p>Transformation using rule <strong>8</strong>.</p><p><span class="math display">\[\Pi_{\text{sname}} (\Pi_{\text{sname, sID}} (\sigma_{(\text{sex = male})} (\text{S})) \Join_{(\text{S.sID = SC.sID})} \Pi_{\text{sID}} (\sigma_{\text{grade} &gt; 90} (\text{SC})))\]</span></p><p>(2). Consider the insurance DB</p><ul><li><em>Person</em>(<u>driver_id</u>, name, year)</li><li><em>Car</em>(<u>license</u>, model, year)</li><li><em>Accident</em>(<u>report_number</u>, date, location)</li><li><em>Participated</em>(<u>driver_id</u>, <u>license</u>, <u>report_number</u>, damage_amount)</li></ul><p>(a). Find out the <strong>driver name, license, report_number</strong> of the <strong>accidents</strong> which happened in Beijing and before May 3, 2024.</p><p>The SQL statement is</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> name, license, Accident.report_number<br><span class="hljs-keyword">FROM</span> Person, Accident, Participated<br><span class="hljs-keyword">WHERE</span> location <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Beijing&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-type">date</span> <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;5/3/2024&#x27;</span> <span class="hljs-keyword">AND</span> Participated.driver_id <span class="hljs-operator">=</span> Person.driver_id <span class="hljs-keyword">AND</span> Participated.report_number <span class="hljs-operator">=</span> Accident.report_number;<br></code></pre></td></tr></table></figure><p>The algebra expression of above statement is</p><p><span class="math display">\[\Pi_{\text{name, license, Accident.report\_number}} \\(\sigma_{\text{location = &#39;Beijing&#39;} \land \text{date &lt; &#39;5/3/2024&#39;} \land \text{Participated.driver\_id = Person.driver\_id} \land \text{Participated.report\_number = Accident.report\_number}} \\(\text{Person} \times \text{Participated} \times \text{Accident}))\]</span></p><p>(b). Give the initial query tree for this query</p><p>(c). Construct an optimized relation algebra expression</p><p><span class="math display">\[\Pi_{\text{name, license, Accident.report\_number}} \\(\Pi_{\text{name, license, report\_number}}((\Pi_{\text{name, drive\_id}}(\text{Person}) \Join_{\text{Participated.driver\_id = Person.driver\_id}} (\Pi_{\text{drive\_id, report\_number, license}}\text{Participated}))) \\\Join_{\text{Participated.report\_number = Accident.report\_number}} (\Pi_{\text{report\_number}}(\sigma_{\text{location = &#39;Beijing&#39;} \land \text{date &lt; &#39;5/3/2024&#39;}}\text{Accident})))\]</span></p><p>(3). Consider</p><ul><li><em>Employee</em>(<u>Employee#</u>, Name, Address, Super-E#, E-D#)</li><li><em>Department</em>(<u>D#</u>, Dname, manager#, depart-location)</li><li><em>Project</em>(<u>P#</u>, Pname, Plocation, P-D#)</li></ul><p>For projects located in Harbin, list their project number (P#), department number (P-D#), the name of the department manager, and the manager’s address.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> P#, P<span class="hljs-operator">-</span>D#, Name, Address<br><span class="hljs-keyword">FROM</span> Project, Employee, Department<br><span class="hljs-keyword">WHERE</span> Plocation <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Harbin&#x27;</span> <span class="hljs-keyword">AND</span> manager# <span class="hljs-operator">=</span> Employee# <span class="hljs-keyword">AND</span> D# <span class="hljs-operator">=</span> P<span class="hljs-operator">-</span>D#;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Database Design Using the ER Model</title>
    <link href="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Database_Design_Using_the_ER_Model/"/>
    <url>/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Database_Design_Using_the_ER_Model/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="overview-of-design-process">Overview of Design Process</h2><p><strong>Design design</strong> consists of two phases:</p><ol type="1"><li><strong>Analyzing</strong> of requirements<ul><li>What data should be stored</li><li>What operations/transaction are conducted such as insert, delete, and update</li></ul></li><li><strong>Designing</strong> of DB schemas, with the three-level <strong>data abstract</strong><ul><li><strong>Conceptual design</strong></li><li><strong>Logical design</strong></li><li><strong>Physical design</strong></li></ul></li></ol><div style="display: block; margin: 0 auto; width: fit-content"><pre><code class=" mermaid">flowchart TD    A[Application problems in real words] --&gt;|Requirements analysis| B[Specification of user requirements]    B --&gt;|&lt;span style=&quot;color:red;&quot;&gt;Conceptual DB design&lt;/span&gt;| C[DB conceptual schema, i.e. E-R diagram]    C --&gt;|Logical DB design| D[DB logical schema, i.e. relational data schema]    D --&gt;|Physical DB design| E[DB physical schema, e.g. physical storage structure]</code></pre></div><div style="text-align: center; font-style: italic;">Figure 1: DB design phases</div><blockquote><p>The lifecycle of Database Application System (DBAS) design consists of five phases: <strong>project planning, requirements analysis, system design, implementation and deployment, and operation management and maintenance</strong>.</p><p>Based on the composition and functionality of the software, the design is divided into three main lines: data organization and storage design, data access and processing design, and application design, which correspond to the design of the database, database transactions, and applications, respectively.</p><p>According to the three-level schema structure of the database system, the design phase is divided into three steps: conceptual design, logical design, and physical design.</p></blockquote><h2 id="the-entity-relationship-model">The Entity-Relationship Model</h2><p>ER Model employs three concepts: <strong>entity sets</strong>, <strong>relationship sets</strong>, and <strong>attributes</strong>. ER model has an associated <strong>diagrammatic representation</strong>, the ER diagram, expressing the <strong>overall logical structure</strong> of DB <strong>graphically</strong>.</p><h3 id="entity-sets">Entity Sets</h3><p><strong>Def</strong>. An <strong>entity</strong> is an object that exists <strong>distinguishable</strong> from other objects.</p><p><strong>Def</strong>. An <strong>entity set</strong> is a set of entities of the same type, sharing the same properties.</p><blockquote><p><em>Note</em>: an entity is represented by a set of <strong>attributes</strong> (descriptive properties of an entity set).</p></blockquote><p><strong>Def</strong>. A subset of the attributes form a <strong>primary key</strong></p><blockquote><p><em>Note</em>: a entity consists of <strong>all values of its all attributes</strong>.</p></blockquote><h3 id="relationship-sets">Relationship Sets</h3><p><strong>Def</strong>. A <strong>relationship</strong> is an <strong>association</strong> among several entities.</p><p><strong>Def</strong>. A <strong>relationship set</strong> is a <strong>mathematic relation</strong> among <span class="math inline">\(n\)</span> entities (<span class="math inline">\(n \geq 2\)</span>).</p><p><strong>Def</strong>. A <strong>relationship instance</strong> represents an <strong>association</strong> between the named entities in the real-word enterprise.</p><p><strong>Def</strong>. An <strong>attribute</strong> can also be associated with a <strong>relationship set</strong>.</p><p>For example, the <em>advisor</em> relationship set between <em>instructor</em> and <em>student</em> has an attribute <strong>date</strong> when student started being associated with the advisor</p><p><strong>Def</strong>. A <strong>role</strong> of entity is a <strong>function</strong> that an entity plays in a relationship.</p><p><strong>Def</strong>. <strong>Binary relationship</strong> involves <strong>two</strong> entity sets (<strong>degree two</strong>)</p><h2 id="complex-attributes">Complex Attributes</h2><p><strong>Def</strong>. The <strong>domain</strong> or values set of the attribute is the set or <strong>permitted values</strong>.</p><p>Attribute types:</p><ul><li>Simple and composite attributes</li><li>Single-valued and multi-valued attributes</li><li>Derived attributes (can be computed from <strong>other attributes</strong>, e.g. age, given date_of_birth)</li></ul><p><strong>Null</strong> value for a attribute means</p><ul><li>The attribute <strong>not applicable</strong> for the entity, <strong>not existing</strong></li><li>The <strong>value</strong> for the attribute <strong>exists</strong>, but is <strong>unknown</strong></li></ul><p><strong>Composite attributes</strong> allow us to divide attributes into <strong>subparts</strong>. For example</p><div style="display: block; margin: 0 auto; width: fit-content"><pre><code class=" mermaid">flowchart TD    A[name] --&gt; B[first_name]    A --&gt; C[middle_name]    A --&gt; D[last_name]</code></pre></div><div style="text-align: center; font-style: italic;">Figure 2: Composite attributes example</div><h3 id="redundant-attributes">Redundant Attributes</h3><p>Suppose we have entity sets:</p><ul><li><em>instructor</em>, with attributes: ID, name, dept_name, salary</li><li><em>department</em>, with attributes: dept_name, building, budget</li></ul><p><strong>Model</strong>: each instructor has an department using relationship set <em>inst_dept</em>.</p><blockquote><p>The attribute dept_name appears in both entity sets. Since it is <strong>the primary key</strong> for the entity set <em>department</em>, it replicates information present in the relationship. It is therefore <strong>redundant</strong> in the entity set <em>instructor</em>.</p></blockquote><h2 id="mapping-cardinalities-constraints">Mapping Cardinalities Constraints</h2><ul><li><strong>Semantic constraints</strong>, as <strong>integrity constraints</strong>, to maintain <strong>consistency</strong></li><li><strong>Integrity constraints</strong> on E or R<ul><li>Mapping cardinalities</li><li>Participation constraints</li><li>Cardinality limits</li><li>Keys</li></ul></li></ul><h3 id="mapping-cardinalities">Mapping Cardinalities</h3><p><strong>Def</strong>. <strong>Mapping Cardinalities</strong> are the number of entities to which another entity can be associated via a <strong>relationship set</strong>.</p><p><strong>Def</strong>. For a binary relationship set <span class="math inline">\(R\)</span>, from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>, the mapping cardinality must be: one to one, one to many, many to one, and many to many.</p><h4 id="one-to-one">One to One</h4><p>A student is associated with <strong>at most</strong> one instructor via the relationship <em>advisor</em>.</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Database_Design_Using_the_ER_Model/one%20to%20one%20example.png" alt="one to one example"><figcaption aria-hidden="true">one to one example</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 3: One to one example</div><blockquote><p><span class="math inline">\(\to\)</span> signifies <strong>one</strong>.</p></blockquote><h4 id="one-to-many">One to Many</h4><p>An instructor is associated with <strong>several</strong> (including <span class="math inline">\(0\)</span>) students via advisor. A student is associated with <strong>at most one</strong> instructor via advisor.</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Database_Design_Using_the_ER_Model/one%20to%20many%20example.png" alt="one to many example"><figcaption aria-hidden="true">one to many example</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 4: One to many example</div><blockquote><p><span class="math inline">\(-\)</span> signifies <strong>many</strong> (at least <strong>zero</strong>), <span class="math inline">\(=\)</span> signifies <strong>many</strong> too (at least <strong>one</strong>).</p></blockquote><h3 id="participate-constraints">Participate Constraints</h3><p><strong>Def</strong>. The participation of an <strong>entity</strong> <span class="math inline">\(E\)</span> in a relationship <span class="math inline">\(R\)</span> is <strong>total</strong>, if every entity in <span class="math inline">\(E\)</span> participates in <strong>at least one</strong> relationship in <span class="math inline">\(R\)</span>.</p><p><strong>Def</strong>. The participation of an entity <span class="math inline">\(E\)</span> in a relationship <span class="math inline">\(R\)</span> is <strong>partial</strong>, if some entities in <span class="math inline">\(E\)</span> may not participate in any relationship in <span class="math inline">\(R\)</span>.</p><h3 id="cardinality-limits-for-participation">Cardinality Limits for Participation</h3><p><strong>Def</strong>. <strong>Cardinality limits</strong> express <strong>quantitative</strong> constraints on participation.</p><blockquote><p>Explicit, recommended!</p></blockquote><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Database_Design_Using_the_ER_Model/cardinality%20limits%20example.png" alt="cardinality limits example"><figcaption aria-hidden="true">cardinality limits example</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 5: Cardinality limits example</div><blockquote><p>A maximum value * indicates <strong>no limit</strong></p></blockquote><h2 id="primary-keys">Primary Keys</h2><p><strong>Def</strong>. <strong>Key</strong> is a <strong>set</strong> of attributes (an <strong>entity set</strong> or <strong>relationship set</strong>). The values of these attributes in one <strong>entity</strong> to <strong>uniquely</strong> distinguish this entity from others and the values of these attributes in one <strong>relationship</strong> to uniquely identify the relationship.</p><h3 id="keys-for-entity-set">Keys for Entity Set</h3><p><strong>Def</strong>. A <strong>super key</strong> of an entity set is a set of <strong>one or more</strong> attributes, whose values <strong>uniquely</strong> determine each entity in the entity set. The super key may contain <strong>extraneous</strong> attributes.</p><p><strong>Def</strong>. A <strong>candidate key</strong> is the <strong>minimal</strong> super key (non-redundant super key).</p><p><strong>Def</strong>. The <strong>primary key</strong> is a candidate key chosen as the principal means of identifying entities within an entity set. Although <strong>several</strong> candidate keys may exists, <strong>one</strong> of the candidate keys is selected to be the <strong>primary key</strong>.</p><h3 id="keys-for-relationship-sets">Keys for Relationship Sets</h3><p><strong>Def</strong>. Keys for relationship sets <span class="math inline">\(R\)</span> on entities <span class="math inline">\(E_1\)</span>, <span class="math inline">\(E_2\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(E_n\)</span>, uniquely distinguish each <strong>relationship instances</strong>.</p><p><strong>Def</strong>. The <strong>super keys</strong> for <span class="math inline">\(R =\)</span> <span class="math inline">\(E_1\)</span>’s primary key <span class="math inline">\(\cup \cdots \cup E_n\)</span>’s primary key.</p><blockquote><p><em>Note</em>: if the attribute names of primary keys are <strong>not unique</strong>, the <strong>attributes with the same names</strong> should be renamed.</p></blockquote><p><strong>Def</strong>. The candidate keys for <span class="math inline">\(R\)</span> (minimal, non-redundant super keys).</p><h3 id="choice-of-primary-key-for-binary-relationship">Choice of Primary Key for Binary Relationship</h3><p>The <strong>candidate keys</strong> or <strong>primary key</strong> for <span class="math inline">\(R\)</span> among entity sets <span class="math inline">\(A\)</span> amd <span class="math inline">\(B\)</span> can be decided, in accordance with the mapping cardinality of <span class="math inline">\(R\)</span>, as follows</p><ul><li>If <span class="math inline">\(R\)</span> is <strong>many to many</strong>, <span class="math inline">\(R\)</span>’s primary key <span class="math inline">\(=\)</span> <span class="math inline">\(A\)</span>’s primary key <span class="math inline">\(\cup\)</span> <span class="math inline">\(B\)</span>’s primary key (may <span class="math inline">\(&gt; 1\)</span>?)</li><li>If <span class="math inline">\(R\)</span> is <strong>many to one</strong> from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>, <span class="math inline">\(R\)</span>’s primary key <span class="math inline">\(=\)</span> <span class="math inline">\(A\)</span>’s primary key</li><li>If <span class="math inline">\(R\)</span> is <strong>one to many</strong>, <span class="math inline">\(R\)</span>’s primary key <span class="math inline">\(=\)</span> <span class="math inline">\(B\)</span>’s primary key</li><li>If <span class="math inline">\(R\)</span> is <strong>one to one</strong>, <span class="math inline">\(R\)</span>’s primary key <span class="math inline">\(=\)</span> <span class="math inline">\(A\)</span>’s primary key or <span class="math inline">\(B\)</span>’s primary key</li></ul><h3 id="weak-entity-sets">Weak Entity Sets</h3><p><strong>Def</strong>. An entity set that does <strong>not</strong> have a primary key is a <strong>weak entity set</strong></p><p>Consider <em>section</em> entity set, identified by course_id, semester, year, sec_id. Entities in <em>section</em> are related to entities in <em>course</em>.</p><ul><li>Suppose a relationship set <em>sec_course</em> between entity sets <em>section</em> and <em>course</em></li><li>The information in <em>sec_course</em> is <strong>redundant</strong>, since <em>section</em> already has attribute course_id, which identifies the course with which the section is related</li><li>To deal with <strong>redundancy</strong> is to get rid of the relationship <em>sec_course</em>; however, relationship between <em>section</em> and <em>course</em> becomes <strong>implicit</strong></li></ul><p>We can introduce <strong>weak entity set</strong></p><ul><li><strong>Not</strong> store the attribute course_id in the <em>section</em> entity, <strong>but only</strong> store the remaining attributes section_id, year, and semester</li><li>However, the entity set <em>section</em> does <strong>not</strong> have enough attributes to identify a particular section entity <strong>uniquely</strong></li><li>To deal with this problem, we treat relationship <em>sec_course</em> as a <strong>special relationship</strong> that provides <strong>extra information</strong> (<em>section</em> is modeled as a <strong>weak entity set</strong>).</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Database_Design_Using_the_ER_Model/weak%20entity%20set%20example.png" alt="weak entity set example"><figcaption aria-hidden="true">weak entity set example</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 6: Weak entity set example</div><p><strong>Def</strong>. A <strong>weak entity set</strong> called <strong>identifying entity</strong> is one, whose existence is dependent on another entity.</p><p><strong>Def</strong>. <strong>Identifying relationship</strong> is the relationship associating the weak entity set with the identifying entity set.</p><blockquote><p><em>Note</em>: use <strong>identifying entity</strong>, along with extra attributes called <strong>discriminator</strong> to uniquely identify a weak entity, instead of a primary key.</p><p>Every weak entity must be associated with an <strong>identifying entity</strong>; weak entity set is <strong>existence dependent</strong> on identifying entity set.</p></blockquote><h3 id="expressing-weak-entity-sets">Expressing Weak Entity Sets</h3><p>A <strong>weak entity set</strong> is depicted via a <strong>double rectangle</strong>. Underline the <strong>discriminator</strong> of a weak entity set with a <strong>dashed line</strong>. The <strong>relationship set</strong> connecting weak entity set to identifying string entity set is depicted by a <strong>double diamond</strong></p><p><strong>Def</strong>. The <strong>discriminator (or partial key)</strong> of a weak entity set is the set of attributes that <strong>distinguishes</strong> among all those entities in weak entity set that depending on a <strong>particular strong entity</strong>.</p><h2 id="removing-redundant-attributes">Removing Redundant Attributes</h2><p>Suppose we have entity sets:</p><ul><li><em>student</em>, with attributes: ID, name, tot_cred, dept_name</li><li><em>department</em>, with attributes: dept_name, building, budget</li><li>Each student has an associated department using a relation set <em>stud_dept</em></li></ul><p>The attribute dept_name in <em>student</em> replicates information present in relationship. It is <strong>redundant</strong> and needs to be <strong>removed</strong>. But when converting back to <strong>tables</strong>, the attribute should be <strong>reintroduced</strong>.</p><h2 id="reducing-er-diagrams-to-relation-schemas">Reducing ER Diagrams to Relation Schemas</h2><p>Logical database design with steps: <strong>generation</strong> of initial relational schema from the ER diagram, and <strong>normalization</strong> of relational schema. Converting an ER diagram to a table format is the basis for <strong>deriving a relational database design</strong>.</p><p>A database which conforms to an ER diagram can be represented by a collection of <strong>schemas/tables</strong></p><ul><li><strong>Entity sets</strong> and <strong>relationship sets</strong> can be expressed uniformly as <strong>relation schemas</strong> that represent the <strong>contents</strong> of the database</li><li>There is a <strong>unique schema</strong> corresponding to either <strong>entity set</strong> or <strong>relationship set</strong></li><li>Each table has a number of columns, corresponding to their attributes</li></ul><p>A <strong>strong entity set</strong> reduces to a schema with the <strong>same attributes</strong>; a <strong>weak entity set</strong> becomes a table that <strong>includes a column for the primary key</strong> of the identifying <strong>strong entity set</strong></p><blockquote><p>Composite attributes are <strong>flattened</strong> by separate attributes.</p></blockquote><h2 id="representing-relationship-sets">Representing Relationship Sets</h2><p>Reduction of a <strong>relationship set</strong> into tables are <strong>strongly dependent on</strong> the <strong>mapping cardinality</strong> constraint and <strong>total/partial constraints</strong>.</p><ol type="1"><li>A <strong>many to many</strong> relationship sets is represented as a table with columns for the <strong>primary keys</strong> of two participating entity sets, and any <strong>descriptive attributes</strong> of the relationship set</li><li><strong>Many to one</strong> and <strong>one to many</strong> relationship sets that <strong>total on the many side</strong> can be represented by adding an extra attribute to the <strong>many</strong> side, containing the primary key of the <strong>one</strong> side. (one side means where <span class="math inline">\(\to\)</span> are)</li><li><strong>Many to one</strong> relationship sets with <strong>partial participation on the many side</strong>. The relationship is reduced ti an <strong>independent table</strong>, avoiding <strong>null</strong> values</li><li>For <strong>one to one</strong> relationship sets, either side can be chosen to act as the <strong>many</strong> side</li></ol><h2 id="extended-er-features">Extended ER Features</h2><ol type="1"><li><strong>Specialization</strong><ul><li>Top-down design process</li><li>We designate <strong>sub-groupings</strong> within an entity set that are distinctive from other entities</li><li>These sub-groupings become <strong>lower-level</strong> entity sets that have attributes or participate in relationships that <strong>do</strong> apply to the <strong>higher-level</strong> entity set<ul><li>Attributes and relationships <strong>specific to the lower-level</strong> entity sets</li></ul></li><li><strong>Depicted by a triangle component labeled ISA</strong></li></ul></li><li><strong>Attribute inheritance</strong><ul><li>A <strong>lower-level</strong> entity set <strong>inherits</strong> all the <strong>attributes</strong> and <strong>relationship participation</strong> of the <strong>higher-level</strong> entity set to which it is linked</li><li>A <strong>higher-level</strong> entity’s attributes and relationship can apply to all of its <strong>lower-level</strong> entities</li></ul></li><li><strong>Generalization</strong><ul><li>Bottom-up design process<ul><li>Combine a number of entity sets that share the same features into a higher-level entity set</li></ul></li></ul></li></ol><blockquote><p>Specialization and generalization are simple <strong>inversion</strong> of each other. They are represented in an ER diagram in the same way. The terms specialization and generalization are <strong>used interchangeably</strong>.</p></blockquote><h3 id="superclass-and-subclass">Superclass and Subclass</h3><p>The <strong>ISA</strong> relationship, or containment, is also referred to as <strong>superclass-subclass</strong> relationship.</p><p>For the entity sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, if <span class="math inline">\(A\)</span> is the generalization of <span class="math inline">\(B\)</span>, then <span class="math inline">\(A\)</span> is the superclass of <span class="math inline">\(B\)</span>, and <span class="math inline">\(B\)</span> is the subclass of <span class="math inline">\(A\)</span>.</p><h3 id="completeness-constraint">Completeness Constraint</h3><p><strong>Completeness constraint</strong> specifies whether or not an entity in the <strong>higher-level</strong> entity set must <strong>belong to</strong> at least one of the <strong>lower-level</strong> entity sets within a <strong>generalization</strong>.</p><ul><li><strong>Total</strong>: an entity must <strong>belong to</strong> one of the lower-level entity sets</li><li><strong>Partial</strong>: an entity <strong>need not</strong> belong to one of the lower-level entity sets</li></ul><p>We can specify total generalization by adding the keyword <strong>total</strong> in the diagram and drawing a dashed line from the keyword to the corresponding hollow arrow-head (for a total generalization), or to the set of hollow arrow-heads (for an overlapping generalization).</p><p>What’s more, constraints on whether or not a <strong>higher-level</strong> entity may <strong>belong to</strong> more than one <strong>lower-level</strong> entity set within <strong>a single specialization</strong></p><ul><li><strong>Disjoint</strong>: a higher-level entity can belong to <strong>only one</strong> lower-level entity set</li><li><strong>Overlapping</strong>: a higher-level entity can belong to <strong>more than one</strong> lower-level entity sets</li></ul><h3 id="representing-specialization-via-schemas">Representing Specialization via Schemas</h3><ol type="1"><li>Method 1<ul><li>Form a schema for the <strong>higher-level</strong> entity</li><li>Form a schema for each <strong>lower-level</strong> entity set, <strong>including</strong> primary key of <strong>higher-level</strong> entity set and local attributes.</li></ul></li><li>Method 2<ul><li>Form a schema for each entity set with all local and inherited attributes</li></ul></li><li>Method 3<ul><li>If specialization is <strong>disjoint</strong> and <strong>complete</strong>, creating two tables</li><li><span class="math inline">\(T_1(a_1, a_2, \cdots, a_m, c_1, c_2, \cdots, c_k, d_1, d_2, \cdots, d_j)\)</span></li><li><span class="math inline">\(T_2(b_1, b_2, \cdots, b_n, c_1, c_2, \cdots, c_k, d_1, d_2, \cdots, d_j)\)</span></li><li><span class="math inline">\(a_1\)</span>, <span class="math inline">\(a_2\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(a_m\)</span> are attributes of one lower-level entity set, <span class="math inline">\(b_1\)</span>, <span class="math inline">\(b_2\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(b_n\)</span> are attributes of the other lower-level entity set, and <span class="math inline">\(c_1\)</span>, <span class="math inline">\(c_2\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(c_k\)</span>, <span class="math inline">\(d_1\)</span>, <span class="math inline">\(d_2\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(d_j\)</span> are <strong>all attributes</strong> of higher-level entity set.</li></ul></li></ol><h2 id="er-design-issues">ER Design Issues</h2><ol type="1"><li>Not to use the <strong>primary key</strong> of an entity set as an attribute of another entity set (to represent <strong>implicitly association</strong> between two entity sets), it is better to use an <strong>relationship set</strong> to explicitly show this association.</li><li>If <span class="math inline">\(E\)</span> participate in <span class="math inline">\(R\)</span>, <strong>not to designate</strong> the primary key (<span class="math inline">\(E\)</span>) as attributes of <span class="math inline">\(R\)</span>, to avoid <strong>information redundancy</strong></li><li>Possible guideline is to <strong>designate</strong> a <strong>relationship</strong> set to describe an action that occurs between entities</li><li><strong>Prefer to</strong> using the <strong>binary</strong> relationship set, replace a non-binary relationship set by a number of binary relationship set</li></ol><h3 id="converting-non-binary-relationships-to-binary-form">Converting Non-Binary Relationships to Binary Form</h3><p>In general, any non-binary relationship can be represented using binary relationships by creating an artificial entity set <span class="math inline">\(E\)</span>.</p><p>For example, a 3-ary relationship set <span class="math inline">\(R = \{(a_i, b_i, c_i) \mid a_i \in A, b_i \in B, c_i \in C\}\)</span> among entity sets <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>, replace <span class="math inline">\(R\)</span> by an entity set <span class="math inline">\(E = \{e_{i}\}\)</span>, and three binary relationship set <span class="math inline">\(R_a\)</span>, <span class="math inline">\(R_b\)</span>, <span class="math inline">\(R_c\)</span>.</p><ul><li><span class="math inline">\(E = \{e_i\}\)</span>, <span class="math inline">\(|E| = |R|\)</span>, i.e. each <span class="math inline">\((a_i, b_i, c_i)\)</span> in <span class="math inline">\(R\)</span> corresponds to one <span class="math inline">\(e_i\)</span> in <span class="math inline">\(E\)</span></li><li><span class="math inline">\(R_a = \{(e_i, a_i) \mid e_i \in E, a_i \in A\}\)</span>, relating <span class="math inline">\(E\)</span> and <span class="math inline">\(A\)</span></li><li><span class="math inline">\(R_b = \{(e_i, b_i) \mid e_i \in E, a_i \in B\}\)</span>, relating <span class="math inline">\(E\)</span> and <span class="math inline">\(B\)</span></li><li><span class="math inline">\(R_c = \{(e_i, c_i) \mid e_i \in E, a_i \in C\}\)</span>, relating <span class="math inline">\(E\)</span> and <span class="math inline">\(C\)</span></li><li><span class="math inline">\(E\)</span> has an identifying attribute <span class="math inline">\(e\)</span> (candidate key) to distinguish each <span class="math inline">\(e_i\)</span> in <span class="math inline">\(E\)</span></li><li>All attributes of <span class="math inline">\(R\)</span> are assigned to <span class="math inline">\(E\)</span>.</li></ul><p>The attributes of relationship sets <span class="math inline">\(R\)</span> may be associated with one of its participating entity sets. For the attribute attr in relationship set <span class="math inline">\(R\)</span> between <span class="math inline">\(E_1\)</span> and <span class="math inline">\(E_2\)</span>, if the cardinality of <span class="math inline">\(R\)</span> is</p><ul><li><strong>One to one</strong>: attr can be assigned as attribute of either <span class="math inline">\(E_1\)</span> or <span class="math inline">\(E_2\)</span>, <strong>rather than</strong> relationship set <span class="math inline">\(R\)</span></li><li><strong>One to many</strong> from <span class="math inline">\(E_1\)</span> to <span class="math inline">\(E_2\)</span>: attr can <strong>only</strong> be assigned as the attribute of the entity set <span class="math inline">\(E_2\)</span> (many side), <strong>rather than</strong> the relationship set <span class="math inline">\(R\)</span></li><li><strong>Many to many</strong>: attr may only be assigned as the attribute of <span class="math inline">\(R\)</span>, <strong>not</strong> of its participating entity sets <span class="math inline">\(E_1\)</span> or <span class="math inline">\(E_2\)</span></li></ul><h2 id="summary-of-symbols-used-in-er-notation">Summary of Symbols Used in ER Notation</h2><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Database_Design_Using_the_ER_Model/summary%201.png" alt="summary 1"><figcaption aria-hidden="true">summary 1</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 7: Summary 1</div><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Database_Design_Using_the_ER_Model/summary%202.png" alt="summary 2"><figcaption aria-hidden="true">summary 2</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 8: Summary 2</div><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Database_Design_Using_the_ER_Model/summary%203.png" alt="summary 3"><figcaption aria-hidden="true">summary 3</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 9: Summary 3</div><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Database_Design_Using_the_ER_Model/Alternative%20ER%20Notations.png" alt="Alternative ER Notations"><figcaption aria-hidden="true">Alternative ER Notations</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 10: Alternative ER notations</div>]]></content>
    
    
    <categories>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Relational Database Design: Schema Normalization</title>
    <link href="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Relational_Database_Design_Schema_Normalization/"/>
    <url>/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Relational_Database_Design_Schema_Normalization/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="features-of-good-relational-design">Features of Good Relational Design</h2><h3 id="lossless-decomposition">Lossless Decomposition</h3><p><strong>Def</strong>. Let <span class="math inline">\(R\)</span> be a relation schema, and <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> form a decomposition of <span class="math inline">\(R\)</span>. That is <span class="math inline">\(R = R_1 \cup R_2\)</span>. The decomposition is a <strong>lossless decomposition</strong>, if there is <strong>no loss</strong> of information by replacing the schema <span class="math inline">\(R\)</span> with two relation schemas <span class="math inline">\(R_1 \cup R_2\)</span>.</p><p><strong>Def</strong>. The decomposition is a <strong>lossy decomposition</strong> if <span class="math inline">\(r \subset \Pi_{R_1} (r) \Join \Pi_{R_2} (r)\)</span></p><p>When certain decomposition are <strong>lossless</strong>? For <span class="math inline">\(R = (R_1, R_2)\)</span>, require that for all possible relations <span class="math inline">\(r\)</span> on schema <span class="math inline">\(R\)</span>. <span class="math inline">\(r = \Pi_{R_{1}} (r) \Join \Pi_{R_2}(r)\)</span></p><p><strong>Def</strong>. A decomposition of <span class="math inline">\(R\)</span> into <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> is <strong>lossless</strong> if <strong>at least one of</strong> the following dependencies is in <span class="math inline">\(F^{+}\)</span>: <span class="math inline">\(R_1 \cap R_2 \to R_1\)</span> and <span class="math inline">\(R_1 \cap R_2 \to R_2\)</span>.</p><p>If only <span class="math inline">\(R_1 \cap R_2 \to R_1\)</span> holds, then <span class="math inline">\(R_1 \cap R_2\)</span> is the <strong>primary key</strong> of <span class="math inline">\(R_1\)</span>, and the <strong>foreign key</strong> of <span class="math inline">\(R_2\)</span></p><p>Example, consider the schema: <em>in_dep</em>(ID, name, salary, dept_name, building, budget). Decompose it into the <em>instructor</em> and <em>department</em> schemas: <em>instructor</em>(ID, name, dept_name, salary) and <em>department</em>(dept_name, building, budget).</p><p>Consider the intersection of these two schemas, which is dept_name. Because of dept_name <span class="math inline">\(\to\)</span> building, budget, the <strong>lossless decomposition</strong> is satisfied</p><h3 id="functional-dependencies">Functional Dependencies</h3><p><strong>Def</strong>. An instance of a relation that satisfies all such real world constraints is called a <strong>legal instance of relation</strong>.</p><p><strong>Def</strong>. <strong>Functional dependency (FD)</strong></p><p>Constraints on the legal relations that</p><ul><li>The value for a <strong>certain set</strong> of attributes determines uniquely</li><li>The values for <strong>another set</strong> of attributes</li></ul><blockquote><p>A functional dependency is a <strong>generalization</strong> of the notion of a key.</p></blockquote><p><strong>Def</strong>. For a <strong>schema</strong> <span class="math inline">\(R\)</span> and <span class="math inline">\(\alpha \subseteq R\)</span>, <span class="math inline">\(\beta \subseteq R\)</span>, a <strong>relation instance</strong> <span class="math inline">\(r(R)\)</span> satisfies a <strong>FD</strong> <span class="math inline">\(\alpha \to \beta\)</span>, if for pairs of tuples <span class="math inline">\(t_i\)</span>, <span class="math inline">\(t_j\)</span> r(R)$ such that <span class="math inline">\(t_{i}[\alpha] = t_{i}[\alpha] \Leftarrow t_{i}[\beta] = t_{j}[\beta]\)</span>.</p><p><strong>Def</strong>. <span class="math inline">\(r(R)\)</span> is <strong>legal</strong> under <strong>FD</strong> <span class="math inline">\(\alpha \to \beta\)</span>, if <span class="math inline">\(\alpha \to \beta\)</span> is satisfied by <span class="math inline">\(r(R)\)</span></p><blockquote><p>The values for <strong>a certain set</strong> of attributes <strong>determines uniquely</strong> the values for <strong>another set</strong> of attributes.</p></blockquote><p>For example, given relation <span class="math inline">\(r(R)\)</span> shown below, which FD is satisfied by <span class="math inline">\(r\)</span>? (C)</p><ul><li>A. <span class="math inline">\(A \to B\)</span></li><li>B. <span class="math inline">\(AC \to B\)</span></li><li>C. <span class="math inline">\(BC \to A\)</span></li><li>D. <span class="math inline">\(B \to C\)</span></li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(t\)</span></th><th style="text-align: center;"><span class="math inline">\(A\)</span></th><th style="text-align: center;"><span class="math inline">\(B\)</span></th><th style="text-align: center;"><span class="math inline">\(C\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(t_1\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(4\)</span></td><td style="text-align: center;"><span class="math inline">\(2\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(t_2\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td style="text-align: center;"><span class="math inline">\(5\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(t_3\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td style="text-align: center;"><span class="math inline">\(4\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(t_4\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(t_5\)</span></td><td style="text-align: center;"><span class="math inline">\(9\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td></tr></tbody></table></div><p><strong>Def</strong>. Let <span class="math inline">\(R\)</span> be a relation schema <span class="math inline">\(\alpha \subseteq R\)</span> and <span class="math inline">\(\beta \subseteq R\)</span>. The <strong>FD holds on</strong> <span class="math inline">\(R\)</span>, if <strong>every</strong> legal instance <span class="math inline">\(r(R)\)</span> satisfies <span class="math inline">\(\alpha \to \beta\)</span></p><blockquote><p>If <span class="math inline">\(\alpha \to \beta\)</span> holds on <span class="math inline">\(R\)</span>, then <strong>every legal</strong> <span class="math inline">\(r_i(R)\)</span> satisfies this <span class="math inline">\(R\)</span>, but for schema <span class="math inline">\(R\)</span> and <span class="math inline">\(\alpha \to \beta\)</span>, if only some <span class="math inline">\(r_i(R)\)</span> satisfies <span class="math inline">\(R\)</span>, <span class="math inline">\(\alpha \to \beta\)</span> may <strong>not</strong> hold on <span class="math inline">\(R\)</span></p></blockquote><h3 id="keys-and-functional-dependencies">Keys and Functional Dependencies</h3><p><strong>Def</strong>. <span class="math inline">\(K\)</span> is a <strong>super key</strong> for relation schema <span class="math inline">\(R\)</span> <strong>if and only if</strong> <span class="math inline">\(K \to R\)</span>.</p><p><strong>Def</strong>. <span class="math inline">\(K\)</span> is a <strong>candidate key</strong> for <span class="math inline">\(R\)</span> <strong>if and only if</strong> <span class="math inline">\(K \to R\)</span> and for no <span class="math inline">\(\alpha \subset K\)</span>, <span class="math inline">\(\alpha \to R\)</span>.</p><p>For example, consider the schema: <em>in_dep</em>(<u>ID</u>, name, salary, <u>dept_name</u>, building, budget). We expect FD to hold: dept_name <span class="math inline">\(\to\)</span> building, or ID <span class="math inline">\(\to\)</span> building, but not to hold dept_name <span class="math inline">\(\to\)</span> salary.</p><h3 id="fd-as-integrity-constraints-in-db">FD as Integrity Constraints in DB</h3><p>While ER diagram describe <strong>objects</strong> and <strong>associations</strong> among them, FD illustrates <strong>relationships</strong> among <strong>attributes</strong> of objects.</p><blockquote><p>How to guarantee FD in DBS? Integrity mechanisms in DBMS, i.e. keys, checks, and triggers</p></blockquote><h3 id="use-of-functional-dependencies">Use of Functional Dependencies</h3><ol type="1"><li>Test relations to see if they are <strong>legal</strong>. If a relation <span class="math inline">\(r\)</span> is legal under an FD set <span class="math inline">\(F\)</span>, we say that <span class="math inline">\(r\)</span> satisfies <span class="math inline">\(F\)</span></li><li>Specify constraints on the set of legal relations. <span class="math inline">\(F\)</span> <strong>holds on</strong> <span class="math inline">\(R\)</span> if all legal relations on <span class="math inline">\(R\)</span> satisfy the FD set <span class="math inline">\(F\)</span>.</li></ol><blockquote><p><em>Note</em>: A specific instance of a relation schema may satisfy a FD in <span class="math inline">\(F\)</span> even if the FD does not hold on all legal instances.</p></blockquote><h3 id="trivial-functional-dependencies">Trivial Functional Dependencies</h3><p><strong>Def</strong>. A FD is <strong>trivial</strong> if it is satisfied by all instances of a relation (<span class="math inline">\(\alpha \to \beta\)</span> is trivial if <span class="math inline">\(\beta \subseteq \alpha\)</span>).</p><p><strong>Def</strong>. <strong>Primary attribute</strong> is the attribute appears in at least one candidate key.</p><h3 id="transitive-dependency">Transitive Dependency</h3><p><strong>Def</strong>. A functional dependency <span class="math inline">\(\alpha \to \gamma\)</span> is <strong>transitive</strong>, if</p><ul><li><span class="math inline">\(\alpha \to \beta\)</span> holds on, but <span class="math inline">\(\beta \to \alpha\)</span> does not hold</li><li><span class="math inline">\(\beta \to \gamma\)</span> holds on, and <span class="math inline">\(\gamma\)</span> is not in <span class="math inline">\(\alpha\)</span></li><li><span class="math inline">\(\gamma\)</span> is called transitive dependent on <span class="math inline">\(\alpha\)</span></li></ul><h3 id="partial-dependency">Partial Dependency</h3><p><strong>Def</strong>. A FD <span class="math inline">\(\alpha \to \beta\)</span> is <strong>partial</strong>, <span class="math inline">\(\beta\)</span> is <strong>partially</strong> dependent on <span class="math inline">\(\alpha\)</span> if there is a <strong>subset</strong> <span class="math inline">\(\gamma\)</span> if <span class="math inline">\(\alpha\)</span>, i.e. <span class="math inline">\(\gamma \subset \alpha\)</span>, such that <span class="math inline">\(\gamma \to \beta\)</span></p><h3 id="closure-of-fd-set">Closure of FD Set</h3><p><strong>Def</strong>. Use the notation <span class="math inline">\(F^{+}\)</span> to denote the <strong>closure</strong> of the FD set <span class="math inline">\(F\)</span>. The set of all FDs that can be inferred given the FD set <span class="math inline">\(F\)</span>. <span class="math inline">\(F^{+}\)</span> contains all of FDs in <span class="math inline">\(F\)</span>.</p><p>For example, <span class="math inline">\(F^{+} = \{A \to B, B \to C\}^{+} = \{A \to B, B \to C, A \to C, AB \to B, AC \to BC, \cdots\}\)</span></p><h2 id="normal-forms">Normal Forms</h2><h3 id="atomic-domains-and-first-normal-form">Atomic Domains and First Normal Form</h3><p><strong>Def</strong>. A relational schema <span class="math inline">\(R\)</span> is in <strong>first normal form</strong> if the domains of all attributes of <span class="math inline">\(R\)</span> are <strong>atomic</strong>.</p><blockquote><p>Domain is <strong>atomic</strong> if its elements are <strong>indivisible</strong> units.</p><p>Examples of <strong>non-atomic</strong> domains: names and composite attributes</p></blockquote><p><strong>Def</strong>. <strong>Atomicity</strong> is actually a property of how the elements of the domain are used. For example, strings would normally be considered <strong>indivisible</strong>.</p><blockquote><p>Students are given roll numbers which are strings of CS0012 or EE1127. If the first two characters are extracted to find the department, the domain of roll numbers is not atomic.</p></blockquote><h3 id="second-normal-form">Second Normal Form</h3><p><strong>Def</strong>. A relation schema <span class="math inline">\(R\)</span> is in <strong>2NF</strong> with respect to a FD set <span class="math inline">\(F\)</span>, if <span class="math inline">\(R\)</span> is in 1NF, and each attribute <span class="math inline">\(A\)</span> meets one of the <strong>criteria</strong></p><ul><li>It appears in a <strong>candidate key</strong> (a prime attribute)</li><li>It is (not partially) dependent on a <strong>candidate key</strong></li></ul><p>Here is an example about 2NF. Consider <em>SLC</em>(<u>S#</u>, SDpt, SLocation, <u>C#</u>, Grade). The FDs are</p><ul><li>(S#, C#) <span class="math inline">\(\to\)</span> Grade</li><li>(S#, C#) <span class="math inline">\(\to\)</span> SDpt</li><li>(S#, C#) <span class="math inline">\(\to\)</span> SLocation</li><li>SDpt <span class="math inline">\(\to\)</span> SLocation</li><li>S# <span class="math inline">\(\to\)</span> SDpt</li><li>S# <span class="math inline">\(\to\)</span> SLocation</li></ul><p>This schema is not in 2NF, because</p><ul><li>For non-primary attribute SDpt, there exists S# <span class="math inline">\(\to\)</span> SDpt, so SDpt is partially dependent on <strong>key</strong></li><li>For non-primary attribute SLocation, there exists S# <span class="math inline">\(\to\)</span> SLocation, so SLocation is partially dependent on <strong>key</strong></li></ul><h3 id="bcnf">BCNF</h3><p><strong>Def</strong>. A relation schema <span class="math inline">\(R\)</span> is in <strong>BCNF</strong> with respect to a FD set <span class="math inline">\(F\)</span> if for all functional dependencies in <span class="math inline">\(F^{+}\)</span> of the form <span class="math inline">\(\alpha \to \beta\)</span> where <span class="math inline">\(\alpha \subseteq R\)</span> and <span class="math inline">\(\beta \subseteq R\)</span>, <strong>at least one</strong> holds:</p><ul><li><span class="math inline">\(\alpha \to \beta\)</span> is <strong>trivial</strong></li><li><span class="math inline">\(\alpha\)</span> is a <strong>super key</strong></li></ul><h3 id="decompose-a-schema-into-bcnf">Decompose a Schema into BCNF</h3><p>Let <span class="math inline">\(R\)</span> be a schema <span class="math inline">\(R\)</span> that is <strong>not</strong> in <strong>BCNF</strong>. Let <span class="math inline">\(\alpha \to \beta\)</span> that causes <strong>violation</strong> of BCNF.</p><p>We decompose <span class="math inline">\(R\)</span> into:</p><ul><li><span class="math inline">\((\alpha \cup \beta)\)</span></li><li><span class="math inline">\((R - (\beta - \alpha))\)</span></li></ul><h3 id="bcnf-and-df-preservation">BCNF and DF Preservation</h3><p>Constraints on FDs, are <strong>costly</strong> to check in practice, unless they pertain to <strong>only one</strong> relation.</p><p>It test only those DFs on <strong>each</strong> individual relation of a decomposition to ensure <strong>all</strong> FDs hold, then that decomposition is <strong>dependency preserving</strong>.</p><blockquote><p><em>Note</em>: because it is <strong>not always</strong> possible to achieve both BCNF and dependency preservation, we consider a <strong>weaker normal form</strong>, known as the 3NF.</p></blockquote><h3 id="third-normal-form">Third Normal Form</h3><p><strong>Def</strong>. A relation schema <span class="math inline">\(R\)</span> is in <strong>third normal form (3NF)</strong> if for all: <span class="math inline">\(\alpha \to \beta\)</span> in <span class="math inline">\(F^{+}\)</span> <strong>at least one</strong> of the following holds:</p><ul><li><span class="math inline">\(\alpha \to \beta\)</span> is <strong>trivial</strong></li><li><span class="math inline">\(\alpha\)</span> is a <strong>super key</strong> for <span class="math inline">\(R\)</span></li><li>Each attribute in <span class="math inline">\(\beta - \alpha\)</span> is contained in a candidate key</li></ul><blockquote><p>If a schema is in BCNF, it is also in 3NF.</p></blockquote><p><strong>Def</strong>. A schema <span class="math inline">\(R\)</span> is in <strong>3NF</strong> with respect to a FD set, if there are no non-prime attributes <span class="math inline">\(A\)</span> for which <span class="math inline">\(A\)</span> is transitive dependent on a key</p><h2 id="functional-dependency-fd-theory">Functional Dependency (FD) Theory</h2><p>In this chapter, what we will talk about?</p><ul><li>The theory shows which FDs are <strong>implied logically</strong> by <strong>a given set</strong> of FDs.</li><li>Algorithms generating <strong>lossless decompositions</strong> into <strong>BCNF</strong> and <strong>3ND</strong>.</li><li>Algorithms testing if <strong>decomposition</strong> is <strong>dependency-preserving</strong>.</li></ul><blockquote><p>给定关系模式 <span class="math inline">\(R(A, B, C)\)</span> 和关系 <span class="math inline">\(r(R)\)</span>，利用 SQL 语句判断关系 <span class="math inline">\(r(R)\)</span> 是否满足函数依赖 <span class="math inline">\(B \to C\)</span></p><p>要求：如果 <span class="math inline">\(r(R)\)</span> 不满足该函数依赖，找出导致不满足的 <span class="math inline">\(r(R)\)</span> 中的<strong>元组</strong>；设计一个<strong>断言</strong>，以保证在 <span class="math inline">\(R(A, B, C)\)</span> 上成立 <span class="math inline">\(B \to C\)</span></p><p>方法：1. 使用元组变量，2. 使用 <code>GROUP BY</code>。如果查询结果为 <code>null</code>，<code>not exist</code>，则函数依赖成立。</p><p>参考 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> ASSERTION B_to_C <span class="hljs-keyword">CHECK</span><br>(<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> B <span class="hljs-keyword">FROM</span> R <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> B <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span> (<span class="hljs-keyword">DISTINCT</span> C) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure></blockquote><p>What’s <strong>logical implication</strong> between FDs? Given an FD set <span class="math inline">\(F\)</span>, there are <strong>other FDs</strong> <span class="math inline">\(f\)</span> that <strong>logically implied</strong> by <span class="math inline">\(F\)</span></p><ul><li>Example: if <span class="math inline">\(A \to B\)</span> and <span class="math inline">\(B \to C\)</span>, then infer that <span class="math inline">\(A \to C\)</span>.</li></ul><blockquote><p><strong>Def</strong>. Given a schema <span class="math inline">\(R\)</span>, a FD <span class="math inline">\(f\)</span> is <strong>logically implied</strong> by a FD set <span class="math inline">\(F\)</span>, if <strong>every</strong> instance <span class="math inline">\(r(R)\)</span> that satisfies <span class="math inline">\(F\)</span> also satisfies <span class="math inline">\(f\)</span></p><ul><li>Example: <span class="math inline">\(\{A \to B, B \to C\}^{+} = \{A \to B, B \to C, A \to C, \cdots\}\)</span></li></ul><p><strong>Def</strong>. The set of <strong>all FDs</strong> logically implied by <span class="math inline">\(F\)</span> is the <strong>closure</strong> of <span class="math inline">\(F\)</span>.</p><ul><li>Denote the closure of <span class="math inline">\(F\)</span> by <span class="math inline">\(F^{+}\)</span>.</li><li><span class="math inline">\(F^{+} = \{f \mid f \text{ is logically implied by } F\}\)</span></li></ul></blockquote><h3 id="closure-of-fds">7.4.1 Closure of FDs</h3><p>Compute <span class="math inline">\(F^{+}\)</span>, the closure of <span class="math inline">\(F\)</span>, by repeatedly applying <strong>Armstrong’s Axioms</strong>:</p><ul><li><strong>Reflexive rule</strong>: if <span class="math inline">\(\beta \subseteq \alpha\)</span>, then <span class="math inline">\(\alpha \to \beta\)</span>.</li><li><strong>Augmentation rule</strong>: if <span class="math inline">\(\alpha \to \beta\)</span>, then <span class="math inline">\(\gamma \alpha \to \gamma \beta\)</span>.</li><li><strong>Transitivity rule</strong>: if <span class="math inline">\(\alpha \to \beta\)</span>, and <span class="math inline">\(\beta \to \gamma\)</span>, then <span class="math inline">\(\alpha \to \gamma\)</span>.</li></ul><blockquote><p>These rules are</p><ul><li>Sound: generate only functional dependencies that actually hold.</li><li>Complete: generate all functional dependencies that hold.</li></ul><p>Additional rules:</p><ul><li><strong>Union rule</strong>: if <span class="math inline">\(\alpha \to \beta\)</span> holds and <span class="math inline">\(\alpha \to \gamma\)</span> holds, then <span class="math inline">\(\alpha \to \beta \gamma\)</span> holds.</li><li><strong>Decomposition rule</strong>: if <span class="math inline">\(\alpha \to \beta \gamma\)</span> holds, then <span class="math inline">\(\alpha \to \beta\)</span> holds and <span class="math inline">\(\alpha \to \gamma\)</span> holds.</li><li><strong>Pseudotransitivity rule</strong>: if <span class="math inline">\(\alpha \to \beta\)</span> holds and <span class="math inline">\(\gamma \beta \to \delta\)</span> holds, then <span class="math inline">\(\alpha \gamma \to \delta\)</span> holds.</li></ul><p>“holds” 理解为”满足“</p></blockquote><p>Here is an example of computing <span class="math inline">\(F^{+}\)</span> with using rules mentioned abov: <span class="math inline">\(R = (A, B, C, G, H, I)\)</span>, <span class="math inline">\(F = \{A \to B, A \to C, B \to H, CG \to H, CG \to I\}\)</span>.</p><p>Some members of <span class="math inline">\(F^{+}\)</span>. <span class="math inline">\(\{A \to H\} \subseteq F^{+}\)</span> (transitivity rule), <span class="math inline">\(\{AG \to I\} \subseteq F^{+}\)</span> (augmentation rule and transitivity rule), <span class="math inline">\(\{CG \to HI\}\)</span> (augmentation rule).</p><h3 id="closure-of-attribute-sets">7.4.2 Closure of Attribute Sets</h3><blockquote><p><strong>Def</strong>. An attribute <span class="math inline">\(B\)</span> is <strong>functionally determined</strong> by <span class="math inline">\(\alpha\)</span> under <span class="math inline">\(F\)</span> if <span class="math inline">\(\alpha \to B\)</span> under <span class="math inline">\(F\)</span></p><ul><li><span class="math inline">\(\alpha | F \to B\)</span></li></ul><p><strong>Def</strong>. Given a set of attributes <span class="math inline">\(\alpha\)</span>, define the <strong>closure</strong> of <span class="math inline">\(\alpha\)</span> under <span class="math inline">\(F\)</span> (denoted by <span class="math inline">\(\alpha^{+}\)</span>) as the set of attributes that are functionally determined by <span class="math inline">\(\alpha\)</span> under <span class="math inline">\(F\)</span>.</p><ul><li><span class="math inline">\(\alpha^{+} = \{\beta \mid \beta \text{ is functionally determined by } \alpha \text{ under } F\} = \{\beta \mid \alpha | F \to \beta\}\)</span></li></ul></blockquote><p><strong>Algorithm</strong>: compute <span class="math inline">\(\alpha^{+}\)</span>, the closure of <span class="math inline">\(\alpha\)</span>, under <span class="math inline">\(F\)</span>.</p><ul><li><strong>Input</strong>: <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(F\)</span></li><li><strong>Output</strong>: <span class="math inline">\(\alpha^{+}\)</span></li><li><strong>Result</strong> <span class="math inline">\(:= \alpha\)</span></li></ul><p>The process is as follow:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs process">while (changes to result) do<br>  for each beta_to_gamma in F do<br>    begin<br>      if beta subseteq result then result := result cup gamma<br>    end<br></code></pre></td></tr></table></figure><blockquote><p><span class="math inline">\(:=\)</span> 在数学定义里表示“被定义为”</p></blockquote><p>Here is an example of computing attribute set closure. We suppose <span class="math inline">\(R = (A, B, C, G, H, I)\)</span>, <span class="math inline">\(F = \{A \to B, A \to C, CG \to H, CG \to I, B \to H\}\)</span>. Compute <span class="math inline">\((AG)^{+}\)</span>.</p><ol type="1"><li><span class="math inline">\(res = AG\)</span></li><li><span class="math inline">\(res = ABCG\)</span> &gt; <span class="math inline">\((A \to C)\)</span> and <span class="math inline">\((A \to B)\)</span></li><li><span class="math inline">\(res = ABCGH\)</span> &gt; <span class="math inline">\((CG \subseteq ABCG)\)</span> and <span class="math inline">\((CG \to H)\)</span></li><li><span class="math inline">\(res = ABCGHI\)</span> &gt; <span class="math inline">\((CG \subseteq ABCGH)\)</span> and <span class="math inline">\((CG \to I)\)</span></li></ol><p>So <span class="math inline">\((AG)^{+} = R\)</span>, <span class="math inline">\(AG\)</span> <strong>is a superkey of</strong> <span class="math inline">\(R\)</span></p><blockquote><p>Is <span class="math inline">\(AG\)</span> a candidate key?</p><ol type="1"><li>Is <span class="math inline">\(AG\)</span> a super key?<ul><li>Does <span class="math inline">\(AG \to R\)</span>? <span class="math inline">\(==\)</span> Is <span class="math inline">\((AG)^{+} \subseteq R\)</span>?, yes</li></ul></li><li>Is any subset of <span class="math inline">\(AG\)</span> a superkey?<ul><li>Does <span class="math inline">\(A \to R\)</span>? <span class="math inline">\(==\)</span> Is <span class="math inline">\((A)^{+} \subseteq R\)</span>?, no</li><li>Does <span class="math inline">\(G \to R\)</span>? <span class="math inline">\(==\)</span> Is <span class="math inline">\((G)^{+} \subseteq R\)</span>?, no</li></ul></li></ol></blockquote><p>We can use attribute closure algorithm to</p><ol type="1"><li><strong>Test for superkey</strong><ul><li>To test if <span class="math inline">\(\alpha\)</span> is a superkey, we compute <span class="math inline">\(\alpha^{+}\)</span> and check if <span class="math inline">\(\alpha^{+} = R\)</span></li></ul></li><li><strong>Test functional dependencies</strong><ul><li>To check if FD <span class="math inline">\(\alpha \to \beta\)</span> holds (or, in other words, is in <span class="math inline">\(F^{+}\)</span>), just check if <span class="math inline">\(\beta \subseteq \alpha^{+}\)</span></li></ul></li></ol><blockquote><p><strong>Def</strong>. For two FDs <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span>, if <span class="math inline">\(F^{+} = G^{+}\)</span> then <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span> are <strong>equivalent</strong>.</p></blockquote><h3 id="canonical-cover">7.4.3 Canonical Cover</h3><blockquote><p><strong>Def</strong>. <strong>Extraneous</strong></p><ol type="1"><li>Sets of FDs may have redundant FDs that can be inferred from others.<ul><li><span class="math inline">\(A \to C\)</span> is redundant in <span class="math inline">\(\{A \to B, B \to C, A \to C\}\)</span>.</li></ul></li><li>Some attributes in the left or right sides of a FD may be extraneous<ul><li><span class="math inline">\(\{A \to B, B \to C, A \to CD\}\)</span> can be simplified to <span class="math inline">\(\{A \to B, B \to C, A \to D\}\)</span>.</li></ul></li><li>An attribute of FD in <span class="math inline">\(F\)</span> is extraneous if we can remove it wihtout changing <span class="math inline">\(F^{+}\)</span>.</li></ol></blockquote><ol type="1"><li><p>Removing an attribute from the <strong>left</strong> side of a FD could <strong>make it a stronger constraint</strong>. If we have <span class="math inline">\(AB \to C\)</span>, we may remove <span class="math inline">\(A\)</span> or <span class="math inline">\(B\)</span>. The choice depends on what FD set <span class="math inline">\(F\)</span> happens to be. Suppose that <span class="math inline">\(F = \{AB \to C, A \to D, D \to C\}\)</span>, then we can show that <span class="math inline">\(F\)</span> logically implies <span class="math inline">\(A \to C\)</span>, making extraneous <span class="math inline">\(B\)</span> in <span class="math inline">\(AB \to C\)</span>.</p></li><li><p>Removeing an attribute from the <strong>right</strong> side of a FD could <strong>make it a weaker constraint</strong>. If we have <span class="math inline">\(AB \to CD\)</span> and remove <span class="math inline">\(C\)</span>, we get possibly weaker result <span class="math inline">\(AB \to D\)</span>. Because using just <span class="math inline">\(AB \to D\)</span>, we can no longer infer <span class="math inline">\(AB \to C\)</span>. But, depending on what FD set <span class="math inline">\(F\)</span> happens to be, we may remove <span class="math inline">\(C\)</span> from <span class="math inline">\(AB \to CD\)</span> safely. Suppose that <span class="math inline">\(F = \{AB \to CD, A \to C\}\)</span>. Even after replacing <span class="math inline">\(AB \to CD\)</span> by <span class="math inline">\(AB \to D\)</span>, we can still infer <span class="math inline">\(AB \to C\)</span> and thus <span class="math inline">\(AB \to CD\)</span>.</p></li><li><p>Consider a set <span class="math inline">\(F\)</span> of FD and <span class="math inline">\(\alpha \to \beta\)</span> in F.</p><ul><li>Attribute <span class="math inline">\(A\)</span> is <strong>extraneous</strong> in <span class="math inline">\(\alpha\)</span>, if <span class="math inline">\(A \in \alpha\)</span>, and <span class="math inline">\(F\)</span> implies <span class="math inline">\((F - \{\alpha \to \beta\}) \cup {(\alpha - A) \to \beta} = F&#39;\)</span>.</li><li>Attribute <span class="math inline">\(A\)</span> is <strong>extraneous</strong> in <span class="math inline">\(\beta\)</span>, if <span class="math inline">\(A \in \beta\)</span>, and the set of FDs <span class="math inline">\(F&#39; = (F - \{\alpha \to \beta\}) \cup \{\alpha \to (\beta - A)\}\)</span> implies <span class="math inline">\(F\)</span>.</li></ul></li></ol><p>How to test if an attribute is extraneous? Here are two ways to make it.</p><p>Let <span class="math inline">\(R\)</span> be a relation schema and let <span class="math inline">\(F\)</span> be a set of FDs that hold on <span class="math inline">\(R\)</span>. Consider an attribute <span class="math inline">\(B\)</span> in the FD. For <span class="math inline">\(\alpha \to \beta\)</span></p><ol type="1"><li>Testing if attribute <span class="math inline">\(B \in \beta\)</span> is extraneous in <span class="math inline">\(\beta\)</span> under <span class="math inline">\(F\)</span>?<ul><li>Consider the set <span class="math inline">\(F&#39; = (F - \{\alpha \to \beta\}) \cup \{\alpha \to (\beta - B)\}\)</span>.</li><li>Compute <span class="math inline">\(\alpha^{+}\)</span> under <span class="math inline">\(F&#39;\)</span> and check if <span class="math inline">\(B \in \alpha^{+}\)</span> under <span class="math inline">\(F&#39;\)</span>? If it does, <span class="math inline">\(B\)</span> is extraneous in <span class="math inline">\(\beta\)</span>.</li></ul></li><li>Testing if attribute <span class="math inline">\(A \in \alpha\)</span> is extraneous in <span class="math inline">\(\alpha\)</span> under <span class="math inline">\(F\)</span>?<ul><li>Let <span class="math inline">\(\gamma = \alpha - \{A\}\)</span>. Compute <span class="math inline">\(\gamma^{+}\)</span> using the FDs in <span class="math inline">\(F\)</span>.</li><li>If <span class="math inline">\(\gamma^{+}\)</span> includes all attributes in <span class="math inline">\(\beta\)</span>, then <span class="math inline">\(A\)</span> is extraneous in <span class="math inline">\(\alpha\)</span>.</li></ul></li></ol><blockquote><p><strong>Def</strong>. A <strong>canonical cover</strong> of <span class="math inline">\(F\)</span>, denoted as <span class="math inline">\(F_{c}\)</span>, is a <strong>minimal</strong> set of FDs equivalent to <span class="math inline">\(F\)</span> without <strong>redundant</strong> FDs or attribute.</p><p>A <strong>canonical cover</strong> for <span class="math inline">\(F\)</span> is a set of FDs <span class="math inline">\(F_c\)</span> such that</p><ul><li><span class="math inline">\(F\)</span> logically implies all dependencies in <span class="math inline">\(F_c\)</span></li><li><span class="math inline">\(F_c\)</span> logically implies all dependencies in <span class="math inline">\(F\)</span></li><li>No FD in <span class="math inline">\(F_c\)</span> contains an extraneous attribute and each left side of FD in <span class="math inline">\(F_c\)</span> is unique.<ul><li>There are no two FDs in <span class="math inline">\(F_c\)</span>, <span class="math inline">\(\alpha_1 \to \beta_1\)</span> and <span class="math inline">\(\alpha_2 \to \beta_2\)</span> such that <span class="math inline">\(\alpha_1 = \alpha_2\)</span>.</li></ul></li></ul></blockquote><p>How to compute a canonical cover for <span class="math inline">\(F\)</span>? We repeat using the <strong>union rule</strong> to replace any FDs in <span class="math inline">\(F\)</span> of the form <span class="math inline">\(\alpha_1 \to \beta_1\)</span> and <span class="math inline">\(\alpha_1 \to \beta_2\)</span> with <span class="math inline">\(\alpha_1 \to \beta_1 \beta_2\)</span>, finding a FD <span class="math inline">\(\alpha \to \beta\)</span> in <span class="math inline">\(F_c\)</span> with an <strong>extraneous attribute</strong> either in <span class="math inline">\(\alpha\)</span> or in <span class="math inline">\(\beta\)</span>, until <span class="math inline">\(F_c\)</span> not change.</p><blockquote><p><em>Note</em></p><ol type="1"><li><p>Test for extraneous attributes done using <span class="math inline">\(F_c\)</span> not <span class="math inline">\(F\)</span>. IF an extraneous attribute is found, delete it from <span class="math inline">\(\alpha \to \beta\)</span></p></li><li><p>Union rule may become applicable after some extraneous attributes have been deleted, so it has to be reapplied.</p></li><li><p>There may be <strong>several</strong> <span class="math inline">\(F_c\)</span> for a set <span class="math inline">\(F\)</span> of FDs.</p></li></ol></blockquote><p>Here is an example of computing a canonical cover. Suppose <span class="math inline">\(R = (A, B, C)\)</span>, <span class="math inline">\(F = \{A \to BC, B \to C, A \to B, AB \to C\}\)</span>.</p><ol type="1"><li><p>Use <strong>union rules</strong> to combine <span class="math inline">\(A \to BC\)</span> and <span class="math inline">\(A \to B\)</span> into <span class="math inline">\(A \to BC\)</span>.</p></li><li><p><span class="math inline">\(A\)</span> is <strong>extraneous</strong> in <span class="math inline">\(AB \to C\)</span>.</p></li><li><p><span class="math inline">\(C\)</span> is <strong>extraneous</strong> in <span class="math inline">\(A \to BC\)</span>.</p></li><li><p>The canonical cover is <span class="math inline">\(\{A \to B, B \to C\}\)</span>.</p></li></ol><h3 id="lossless-join-decomposition">7.4.4 Lossless-join Decomposition</h3><blockquote><p><strong>Def</strong>. For <span class="math inline">\(R = (R_1, R_2)\)</span>, we require that for all possible relations <span class="math inline">\(r\)</span> on schema <span class="math inline">\(R\)</span>, <span class="math inline">\(r = \Pi_{R_1}(r) \Join \Pi_{R_2}(r)\)</span>.</p><p><strong>Def</strong>. Decomposition of <span class="math inline">\(R\)</span> into <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> is <strong>lossless join</strong> if at least one of the following dependencies is in <span class="math inline">\(F^{+}\)</span>.</p><ul><li><span class="math inline">\(R_1 \cap R_2 \to R_1\)</span> or <span class="math inline">\(R_1 \cap R_2 \to R_2\)</span></li></ul><p><em>Note</em>: The above FDs are a <strong>sufficient condition</strong> for lossless join decomposition; The dependencies are a <strong>necessary condition</strong> only if all constraints are FDs.</p><p><strong>Def</strong>. <strong>Lossy decomposition</strong>, <span class="math inline">\(r \neq \Pi_{R_1}(r) \Join \Pi_{R_2}(r) \cdots \Join \Pi_{R_n}(r)\)</span>, also known as <strong>lossy-join decomposition</strong>.</p></blockquote><p>Here is an example about lossless-join decomposition. Suppose that that <span class="math inline">\(R = (A, B, C)\)</span> and <span class="math inline">\(F = \{A \to B, B \to C\}\)</span>.</p><ul><li><span class="math inline">\(R_1 = (A, B)\)</span>, <span class="math inline">\(R_2 = (B, C)\)</span>. <span class="math inline">\(R_1 \cap R_2 = \{B\}\)</span> and <span class="math inline">\(B \to BC \in F^{+}\)</span>, so lossless-join decomposition</li></ul><h3 id="functional-dependency-preservation">7.4.5 Functional Dependency Preservation</h3><blockquote><p><strong>Def</strong>. For a schema <span class="math inline">\(R\)</span>, <span class="math inline">\(F\)</span> holds on <span class="math inline">\(R\)</span>, and decomposition <span class="math inline">\(\{R_1, R_2, \cdots, R_n\}\)</span> of <span class="math inline">\(R\)</span>, the <strong>restriction</strong> of <span class="math inline">\(F\)</span> to <span class="math inline">\(R_i\)</span>, denoted as <span class="math inline">\(F_i\)</span> is defined as</p><p><span class="math display">\[F_i = \{\alpha \to \beta \mid \alpha \to \beta \in F^{+} \And \alpha \beta \subseteq R_i\}\]</span></p><p>The set of FDs in <span class="math inline">\(F^{+}\)</span> that include only attributes in <span class="math inline">\(R_i\)</span>.</p><p><strong>Def</strong>. Let <span class="math inline">\(F_i\)</span> be <strong>restriction</strong> of <span class="math inline">\(F\)</span> to <span class="math inline">\(R_i\)</span>. A decomposition is <strong>dependency preserving</strong>, if <span class="math inline">\((F_1 \cup F_2 \cup \cdots \cup F_n)^{+} = F^{+}\)</span></p><p><em>Note</em>: Testing for dependency preservation take s exponential time.</p></blockquote><p><strong>Alogrithm</strong>. How to test for dependency preservation? Check if a FD <span class="math inline">\(\alpha \to \beta\)</span> is preserved in decomposition <span class="math inline">\(R\)</span> of <span class="math inline">\(R_1\)</span>, <span class="math inline">\(R_2\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(R_n\)</span>. We set <span class="math inline">\(res = \alpha\)</span> and repeat updating <span class="math inline">\(t = (res \cap R_i)^{+} \cap R_i\)</span>, <span class="math inline">\(res = res \cup t\)</span> for each <span class="math inline">\(R_i\)</span> in the decomposition until <span class="math inline">\(res\)</span> does not change. If <span class="math inline">\(res\)</span> contains all attributes in <span class="math inline">\(\beta\)</span>, the FD <span class="math inline">\(\alpha \to \beta\)</span> preserved.</p><p>Test on <strong>all FDs</strong> in <span class="math inline">\(F\)</span> to check if a decomposition is dependency preserving</p><ul><li>The decomposition is preserved, if and only if all <span class="math inline">\(\alpha \to \beta\)</span> in <span class="math inline">\(F\)</span> are preserved.</li><li>This procedure takes polynomial time.</li></ul><p>Here is an example. Suppose <span class="math inline">\(R = (A, B, C)\)</span>, <span class="math inline">\(F = \{A \to B, B \to C\}\)</span>, <span class="math inline">\(\text{Key} = \{A\}\)</span>, <span class="math inline">\(R\)</span> is not in BCNF, and decomposition is <span class="math inline">\(R_1 = (A, B)\)</span>, <span class="math inline">\(R_2 = (B, C)\)</span></p><ul><li><span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> in BCNF.</li><li>Lossless-join decomposition.</li><li>Dependency preserving.</li></ul><blockquote><p>Summary: In 7.4.5, we talk about the <strong>Def</strong> of <strong>Dependency Preserving</strong>, and two ways to test for dependency preservation (<span class="math inline">\((F_1 \cup F_2 \cup \cdots \cup F_n)^{+} = F^{+}\)</span> or <strong>Alogrithm</strong>)</p></blockquote><h2 id="algorithms-for-decomposition-using-fd">7.5 Algorithms for Decomposition Using FD</h2><h3 id="testing-for-bcnf">Testing for BCNF</h3><p><strong>Algorithm 1</strong>. To check if a non-trivial FD <span class="math inline">\(\alpha \to \beta\)</span> causes a violation of BCNF</p><ol type="1"><li>Compute <span class="math inline">\(\alpha^{+}\)</span> (the attribute closure of <span class="math inline">\(\alpha\)</span>).</li><li>Verify that it includes all attributes of <span class="math inline">\(R\)</span>, that is, it is a superkey of <span class="math inline">\(R\)</span>.</li></ol><blockquote><p><em>Simplified test</em>: To check if a relation schema <span class="math inline">\(R\)</span> is in BCNF, suffices to check only the FDs in <span class="math inline">\(F\)</span> for violation, rather than checking all FDs in <span class="math inline">\(F^{+}\)</span>. If none of the FDs in <span class="math inline">\(F\)</span> causes a violation of BCNF, none of the FDs in <span class="math inline">\(F^{+}\)</span> will cause a violation of BCNF either.</p><p>However, <em>simplified test</em> using only <span class="math inline">\(F\)</span> is incorrect when testing a relation in a <strong>decomposition</strong> of <span class="math inline">\(R\)</span>. Consider <span class="math inline">\(R = (A, B, C, D, E)\)</span>, with <span class="math inline">\(F = \{A \to B, BC \to D\}\)</span>. We decompose <span class="math inline">\(R\)</span> into <span class="math inline">\(R_1 = (A, B)\)</span> and <span class="math inline">\(R_2 = (A, C, D, E)\)</span>. Neither of the dependencies in <span class="math inline">\(F\)</span> contain only attributes from <span class="math inline">\((A, C, D, E)\)</span>, so we might be mislead into thinking <span class="math inline">\(R_2\)</span> satisfies BCNF. In fact, dependency <span class="math inline">\(AC \to D\)</span> in <span class="math inline">\(F^{+}\)</span> shows <span class="math inline">\(R_2\)</span> is not in BCNF.</p></blockquote><p><strong>Algorithm 2</strong>. Check if a relation <span class="math inline">\(R_i\)</span> in a <strong>decomposition</strong> of <span class="math inline">\(R\)</span> is in BCNF.</p><p>Either test <span class="math inline">\(R_i\)</span> for BCNF with respect to the restriction of <span class="math inline">\(F^{+}\)</span> to <span class="math inline">\(R_i\)</span> or use the original set of FDs <span class="math inline">\(F\)</span> that hold on <span class="math inline">\(R\)</span>, but with test:</p><ul><li>For every set of attributes <span class="math inline">\(\alpha \subseteq R_{i}\)</span>, check that <span class="math inline">\(\alpha^{+}\)</span> either includes no attribute of <span class="math inline">\(R_i - \alpha\)</span> or includes all attributes of <span class="math inline">\(R_i\)</span>.</li></ul><p>If the condition is violated by some <span class="math inline">\(\alpha \to \beta\)</span> in <span class="math inline">\(F^{+}\)</span>, the dependency <span class="math inline">\(\alpha \to (\alpha^{+} - \alpha) \cap R_i\)</span> can be shown to hold on <span class="math inline">\(R_i\)</span> and <span class="math inline">\(R_i\)</span> violates BCNF.</p><p><strong>Algorithm 3</strong>. Decomposition algorithm for lossless schema in BCNF.</p><blockquote><ul><li><span class="math inline">\(F^{+}\)</span> is computed at first to determine whether or not <span class="math inline">\(\alpha\)</span> is the superkey of subschema <span class="math inline">\(R_i\)</span>.</li><li>If other methods can be used to determine whether or not <span class="math inline">\(\alpha\)</span> is the superkey of subschema <span class="math inline">\(R_i\)</span>, then <span class="math inline">\(F^{+}\)</span> need not be computed.</li></ul></blockquote><p>Given <span class="math inline">\(R\)</span>, <span class="math inline">\(F\)</span> holding on <span class="math inline">\(R\)</span>. We set <span class="math inline">\(res := \{R\}\)</span>. If there is a non-BCNF subschema <span class="math inline">\(R_i\)</span> in <span class="math inline">\(res\)</span>, then let <span class="math inline">\(\alpha \to \beta\)</span> be a nontrivial FD that holds on <span class="math inline">\(R_i\)</span>, such that (1). <span class="math inline">\(\alpha\)</span> is not the superkey for <span class="math inline">\(R_i\)</span>; (2). <span class="math inline">\(\alpha \cap \beta = \phi\)</span>. Then update <span class="math inline">\(res := \{(res - R_{i})\} \cup \{\{(R_i - \beta)\} \cup \{(\alpha, \beta)\}\}\)</span></p><blockquote><p><em>Note</em></p><ul><li><p>To determine whether or not <span class="math inline">\(R_i\)</span> is in BCNF, the restriction of <span class="math inline">\(F\)</span> to <span class="math inline">\(R_i\)</span> and the candidate keys of <span class="math inline">\(R_i\)</span> should be computed.</p></li><li><p><span class="math inline">\(R_i\)</span> is not in BCNF, because of <span class="math inline">\(\alpha \to \beta\)</span> on <span class="math inline">\(R_i\)</span>, <span class="math inline">\(\alpha\)</span> is not the superkey of <span class="math inline">\(R_i\)</span>.</p></li><li><p>The algorithm replaces non-BCNF <span class="math inline">\(R_i\)</span> with <span class="math inline">\((R_i - \beta)\)</span> and <span class="math inline">\((\alpha, \beta)\)</span>.</p><ul><li><span class="math inline">\(R_i\)</span> is decomposed into <span class="math inline">\((R_i - \beta)\)</span> and BCNF <span class="math inline">\((\alpha, \beta)\)</span>.</li></ul></li><li><p>The restriction of <span class="math inline">\(F\)</span> to the schema <span class="math inline">\((\alpha, \beta)\)</span> is <span class="math inline">\(\alpha \to \beta\)</span>, and <span class="math inline">\(\alpha\)</span> is the superkey for <span class="math inline">\((\alpha, \beta)\)</span>. so <span class="math inline">\((\alpha, \beta)\)</span> is in BCNF.</p></li></ul></blockquote><h3 id="testing-for-3nf">Testing for 3NF</h3><blockquote><p>Why we decompose 3NF?</p><ul><li>There are some situations where<ul><li>BCNF is not dependency preserving.</li><li>Whereas checking for FD violation is important.</li></ul></li><li>Solution: Define a weaker normal form, called the <strong>Third Normal Form</strong> (3NF)<ul><li>Allows some redundancy (with resultant problems).</li><li>But check FDs on <strong>individual relations</strong> without computing a join.</li><li>There is a lossless-join, dependency-preserving decomposition into 3NF.</li></ul></li></ul></blockquote><p><strong>Algorithm 1</strong>. A decomposition algorithm that gives <strong>lossless</strong> and <strong>dependency preserving</strong> schema in 3NF.</p><blockquote><p><em>Note</em></p><ul><li>All candidate keys should be founded out.</li><li>Only one <span class="math inline">\(F_c\)</span> should be computed at first.</li></ul></blockquote><ol type="1"><li><p>Find out all candidate keys for <span class="math inline">\(R\)</span>.</p></li><li><p>Find out a <strong>canonical over</strong> <span class="math inline">\(F_c\)</span> for F.</p></li><li><p>Do for each FD <span class="math inline">\(\alpha \to \beta\)</span> in <span class="math inline">\(F_c\)</span>. If none of the schema <span class="math inline">\(R_i\)</span>, <span class="math inline">\(1 \leq j \leq i\)</span> contains <span class="math inline">\(\alpha \beta\)</span>, then <span class="math inline">\(i := i + 1\)</span>, <span class="math inline">\(R_i := \alpha \beta\)</span>.</p></li><li><p>If none of the schemas <span class="math inline">\(R_j\)</span>, <span class="math inline">\(1 \leq j \leq i\)</span> contains a candidate key for <span class="math inline">\(R\)</span>, then <span class="math inline">\(i := i + 1\)</span>, <span class="math inline">\(R_{i} :=\)</span> any candidate key for <span class="math inline">\(R\)</span>.</p></li><li><p>Return <span class="math inline">\((R_1, R_2, \cdots, R_i)\)</span>.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Advanced SQL</title>
    <link href="/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Advanced_SQL/"/>
    <url>/2025/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Advanced_SQL/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="accessing-sql-from-a-programming-language">Accessing SQL from a Programming Language</h2><blockquote><p>API (application program interface) to <strong>interact</strong> with DB server</p><p>Application <strong>conducts</strong> data processing, and <strong>makes calls</strong> to</p><ul><li><strong>Connect</strong> with the database server</li><li><strong>Send</strong> SQL commands to the database server</li><li><strong>Fetch</strong> tuples of result <strong>one-by-one</strong> into program variables</li></ul></blockquote><p>There are <strong>two</strong> approaches to accessing SQL</p><ol type="1"><li>Dynamic SQL<ul><li>General-purpose program: connects to and communicates with DB server using <strong>functions</strong></li><li>Program <strong>constructs</strong> an SQL query as <strong>a character string</strong>, <strong>submit</strong> the query, and <strong>retrieve</strong> result into program variables <strong>a tuple at a time</strong>.</li><li>Includes <strong>JDBC</strong> with Java and <strong>ODBC</strong> with C, C++, etc.</li></ul></li><li>Embedded SQL<ul><li>Statements are translated in high-level programs at <strong>compile time</strong> into <strong>function calls</strong></li><li><strong>Function calls</strong> connect to DB using an <strong>API</strong> that provides dynamic SQL facilities</li></ul></li></ol><h3 id="jdbc">JDBC</h3><p><strong>JDBC</strong> is a Java based API.</p><ul><li>Supports <strong>features</strong> for <strong>querying</strong> and <strong>updating</strong> data, and for <strong>retrieving</strong> query results</li><li>Supports <strong>metadata retrieval</strong> (<strong>querying</strong> about <strong>relations</strong> in DB and <strong>querying</strong> about <strong>names and types</strong> of relation attributes)</li></ul><p>Also known as the <strong>model</strong> for communicating with DB:</p><ul><li><strong>Open</strong> a connection, named as <code>conn</code><ul><li>Using the <code>getConnection</code> method od the <code>DriverManager</code> class</li><li>Parameters: <code>(URL, user_identifier, password)</code></li></ul></li><li><strong>Create</strong> a SQL statement object on the connection <code>conn</code><ul><li>Using the <code>createStatement</code> method</li><li>Its statement handle is named as <code>stmt</code></li><li>Invoke methods that <strong>ship</strong> an SQL statement foe execution</li></ul></li><li><strong>Update</strong> to database<ul><li>Using the <code>stmt.executeUpdate("SQL")</code></li></ul></li><li><strong>Execute</strong> query and fetch and print results<ul><li><code>ResultSet</code> object</li></ul></li></ul><blockquote><p><em>Note</em>: <strong>execute</strong> queries using <code>Statement</code> object <code>stmt</code> to <strong>send</strong> queries and fetch results</p><ul><li>Using <code>execute.query</code> or <code>execute.update</code> such as **insert/delete/update/create table`</li></ul><ol type="1"><li><strong>Parameters</strong>: SQL statement to be executed, <strong>represented as a string</strong></li><li><strong>Catch</strong> any exceptions or error conditions</li><li><strong>Fetch</strong> the query result, using the <code>try &#123;...&#125;/catch &#123;...&#125;</code> construct<ul><li>Retrieve the set of tuples in the result into a <code>ResultSet</code> object <code>rset</code>, <strong>fetch</strong> them on one tuple at a time</li><li>The <code>next()</code> method tests whether or nor the result set has at least one tuple and if so, fetches it</li></ul></li><li><strong>Close</strong> the statement <code>stmt</code> and the connection <code>conn</code> at the end</li></ol></blockquote><h3 id="jdbc-code-details">JDBC Code Details</h3><ul><li>Getting result fields:<ul><li><code>rs.getString("dept_name")</code> and <code>rs.getString(1)</code> are <strong>equivalent</strong>, if dept_name is the first argument of select result</li></ul></li><li>Dealing with null values<ul><li><code>rs.wasNULL()</code></li></ul></li></ul><h3 id="jdbc-subsections">JDBC Subsections</h3><ol type="1"><li>Prepared statements<ul><li><code>PreparedStatement pStmt = conn.prepareStatement("insert into instructor values(?, ?, ?, ?)");</code></li><li><code>pStmt.setString(1, "88877");</code></li></ul></li><li>Metadata Features<ul><li>After executing query to get a <code>ResultSet rs</code></li><li><code>ResultSetMetaDate rsmd = rs.getMetaData();</code></li></ul></li><li>Transaction Control<ul><li>Each SQL statement is treated as <strong>a separate transaction</strong> that is committed automatically by default</li><li>Turn off automatic commit on a connection: <code>conn.setAutoCommit(false);</code></li><li><em>Note</em>: transactions must then be committed or rolled back explicitly<ul><li><code>conn.commit();</code> and <code>conn.rollback();</code></li></ul></li></ul></li><li>Calling <strong>functions</strong> and <strong>procedures</strong><ul><li><code>CallableStatement cStmt1 = conn.prepareCall("&#123;? = call some function(?)&#125;");</code></li><li><code>CallableStatement cStmt2 = conn.prepareCall("&#123;call some procedure(?, ?)&#125;");</code></li></ul></li></ol><h3 id="odbc">ODBC</h3><p><strong>Open database connectivity</strong> standard</p><ul><li><strong>Application programs</strong> (as client) to communicate with DB server</li><li><strong>API</strong> to<ul><li>Open a connection with database</li><li>Send queries and updates</li><li>Get back results</li></ul></li></ul><h3 id="embedded-sql">Embedded SQL</h3><p>Embedded SQL</p><ul><li>In general-purpose programming languages, e.g. C</li><li>Executing of general-purpose programming language programs with SQL statement embedded results in DB access</li></ul><p><strong>Def</strong>. A language to which SQL queries are embedded is referred to as <strong>host language</strong>. The SQL structures permitted in host language comprise <strong>embedded SQL</strong></p><ul><li>EXEC SQL statement is used to identify <strong>embedded SQL</strong> request to the preprocessor<ul><li><code>EXEC SQL &lt;embedded SQL statement&gt;;</code></li></ul></li></ul><blockquote><p><em>Note</em>: this varies by language:</p><ul><li>In some languages, like COBOL, the <strong>semicolon</strong> is replaced with <code>END-EXEC</code></li><li>In Java embedding use <code># SQL&#123;...&#125;;</code></li></ul></blockquote><ul><li>Before executing any SQL statements, the program must first connect to the database.<ul><li><code>EXEC SQL connect to &lt;server&gt; user &lt;user_name&gt; using &lt;password&gt;;</code></li></ul></li></ul><blockquote><p><em>Note</em>: server identifies the server to which connection is to be established</p></blockquote><ul><li><strong>Variables</strong> of the <strong>host</strong> language can be used within embedded SQL statements. They are <strong>preceded</strong> by colon to (<code>:</code>) to distinguish from SQL variables, e.g. <code>:credit_amount</code></li></ul><blockquote><p><em>Note</em>: variables used as above must be <strong>declared</strong> within <code>DECLARE</code> section</p><p>The <strong>syntax</strong> for <strong>declaring the variables</strong> follows the usual host language syntax.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">EXEC SQL BEGIN DECLARE SECTION<br>  <span class="hljs-type">int</span> credit_amount;<br>EXEC SQL END DECLARE SECTION;<br></code></pre></td></tr></table></figure></blockquote><p>Example, from a host language, find the <strong>ID</strong> and <strong>name</strong> of students who have completed more than the number of <strong>credits</strong> stored in variable <code>credit_amount</code> in the host language. (<code>credi_amount</code> is the shared variable defined in the declaration part)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">EXEC SQL BEGIN DECLARE SECTION;<br><span class="hljs-type">int</span> credit_amount;<br>EXEC SQL END DECLARE SECTION;<br><br>credit_amount = <span class="hljs-number">100</span>;<br><br>EXEC SQL CONNECT TO my_database USER <span class="hljs-string">&#x27;username&#x27;</span> USING <span class="hljs-string">&#x27;password&#x27;</span>;<br><br>EXEC SQL<br>select ID, name<br>from student<br>where tot_cred &gt; :credit_amount<br>END-EXEC<br></code></pre></td></tr></table></figure><h3 id="cursor-in-embedded-sql">Cursor in Embedded SQL</h3><p>To write an embedded SQL query, we use the statement: <code>declare c cursor for &lt;SQL query&gt;</code>. The variable <code>c</code> is used to identify the query.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">EXEC SQL<br>declare c cursor <span class="hljs-keyword">for</span><br>select ID, name<br>from student<br>where tot_cred &gt; :credit_amount<br>END-EXEC<br></code></pre></td></tr></table></figure><blockquote><p>When using Embedded SQL for queries, if the query result includes multiple tuples, it cannot be directly passed to the host program through shared variables. In this case, the system allocates a dedicated working area to store the query result relation and uses a cursor to point to this area. The host program retrieves each tuple from the result relation sequentially by using the cursor with <code>OPEN</code>, <code>FETCH</code>, and <code>CLOSE</code> operations.</p><ul><li>The <code>OPEN</code> statement executes the query and save the results **within a temporary relation`</li><li>The <code>FETCH</code> statement causes the values of <strong>one tuple</strong> in the query result to <strong>to be replaced on host language variables</strong>. Repeated calls to fetch get successive tuples in the query result.</li><li>The <code>CLOSE</code> statement <strong>delete</strong> the <strong>temporary</strong> relation that holds the result of the query</li></ul><p><em>Note</em>: above details vary with language.</p></blockquote><p>Example</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">EXEC SQL BEGIN DECLARE SECTION<br><span class="hljs-type">int</span> credit_amount;<br><span class="hljs-type">char</span> si, sn;<br>EXEC SQL END DECLARE SECTION<br><br>credit_amount = <span class="hljs-number">100</span>;<br><br>EXEC SQL<br>declare c cursor <span class="hljs-keyword">for</span><br>select ID, name<br>from student<br>where tot_cred &gt; :credit_amount<br>END-EXEC<br><br>EXEC SQL open c END-EXEC<br>EXEC SQL fetch c into :si, :sn END-EXEC<br>EXEC SQL close c END-EXEC<br></code></pre></td></tr></table></figure><h3 id="update-through-embedded-sql">Update Through Embedded SQL</h3><p>Can <strong>update</strong> tuples <strong>fetched by cursor by declaring that the cursor is for update</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">EXEC SQL<br>declare c cursor <span class="hljs-keyword">for</span><br>select *<br>from instructor<br>where dept_name = <span class="hljs-string">&#x27;Music&#x27;</span><br>fo update<br>END-EXEC<br></code></pre></td></tr></table></figure><p>We <strong>iterate</strong> through the tuples by performing <strong>fetch</strong> operations on the cursor, after fetching each tuple we execute the following code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">EXEC SQL<br>update instructor<br><span class="hljs-built_in">set</span> salary = salary + <span class="hljs-number">1000</span><br>where current of c<br>END-EXEC<br></code></pre></td></tr></table></figure><h2 id="functions-and-procedures">Functions and Procedures</h2><p>SQL supports <strong>functions</strong> and <strong>procedures</strong></p><ul><li>Functions and procedures can be written in SQL itself, or an <strong>external programming language</strong> (C, Java)</li><li>Functions written in external languages are useful with <strong>specialized data</strong> types such as images</li><li>DBS support <strong>table-valued functions</strong> which can return <strong>a relation</strong> as a result.</li></ul><h3 id="sql-functions">SQL Functions</h3><p>For example, for the given the <strong>name</strong> of a department, returns the count of the number of instructors.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> dept_count(dept_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>))<br><span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INTEGER</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">DECLARE</span> dept_count <span class="hljs-type">INTEGER</span>;<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COALESCE</span>(<span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>), <span class="hljs-number">0</span>) <span class="hljs-keyword">INTO</span> dept_count<br>    <span class="hljs-keyword">FROM</span> instructor<br>    <span class="hljs-keyword">WHERE</span> instructor.dept_name <span class="hljs-operator">=</span> dept_name;<br>    <span class="hljs-keyword">RETURN</span> dept_count;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><h3 id="sql-procedures">SQL Procedures</h3><p>The <code>dept_count</code> function could be written as <strong>procedure</strong>.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> dept_count_proc(<span class="hljs-keyword">IN</span> dept_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>), <span class="hljs-keyword">OUT</span> d_count <span class="hljs-type">INTEGER</span>)<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">INTO</span> d_count<br>    <span class="hljs-keyword">FROM</span> instructor<br>    <span class="hljs-keyword">WHERE</span> instructor.dept_name <span class="hljs-operator">=</span> dept_count_proc.dept_name;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>Procedures can be <strong>invoked</strong> either from an SQL procedure or from embedded SQL, using the <strong>call</strong> statement. Procedures and functions can be invoked also from <strong>dynamic SQL</strong>.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">DECLARE</span> d_count <span class="hljs-type">INTEGER</span>;<br><span class="hljs-keyword">CALL</span> dept_count_proc(<span class="hljs-string">&#x27;Physics&#x27;</span>, d_count);<br></code></pre></td></tr></table></figure><h2 id="trigger">Trigger</h2><p><strong>Def</strong>. <strong>Trigger</strong> is an <strong>event-condition-action model</strong> based mechanism that is <strong>executed automatically</strong> as a <strong>side effect</strong> of modification to DB.</p><ul><li>Integrity definition, checking, and remedy</li><li>Specify what events cause the trigger to be executed (insert, delete, update)</li><li>Under <strong>which conditions</strong> the trigger execution will proceed<ul><li>Integrity constraints checking</li></ul></li><li>Specify <strong>actions</strong> to be taken when the trigger executes<ul><li>If <strong>constraints is violated</strong>, remedy actions are taken</li></ul></li></ul><blockquote><p><em>Note</em>: as an <strong>integrity control mechanism</strong>, trigger introduced to SQL-99, but supported even earlier using <strong>non-standard</strong> syntax.</p><p>Syntax illustrated here may not work exactly on your DBS</p></blockquote><h3 id="triggering-events-and-actions">Triggering Events and Actions</h3><p>Trigger event can be <strong>insert</strong>, <strong>delete</strong> or <strong>update</strong>.</p><blockquote><p><em>Note</em>:</p><ul><li>Triggers on update can be restricted to specific attributes</li><li><strong>Values of attributes</strong> before and after an update can be <strong>referenced</strong></li></ul></blockquote><p>Triggers can be activated before an event, which can serve as extra constraints. For example, convert blank grades to null.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> set_null_trigger BEFORE <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OF</span> takes<br><span class="hljs-keyword">REFERENCING</span> <span class="hljs-keyword">NEW</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AS</span> nrow<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">WHEN</span> (nrow.grade <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">ATOMIC</span><br>    <span class="hljs-keyword">SET</span> nrow.grade <span class="hljs-operator">=</span> <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><h3 id="trigger-to-maintain-referential-integrity">Trigger to Maintain Referential Integrity</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> time_slot_check1 AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> section<br><span class="hljs-keyword">REFERENCING</span> <span class="hljs-keyword">NEW</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AS</span> nrow<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">WHEN</span> nrow.time_slot_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span>(<span class="hljs-keyword">SELECT</span> time_slot_id <span class="hljs-keyword">FROM</span> timeslot)<br><span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">ATOMIC</span><br>    <span class="hljs-keyword">ROLLBACK</span><br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> time_slot_check2 AFTER <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> timeslot<br><span class="hljs-keyword">REFERENCING</span> <span class="hljs-keyword">OLD</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AS</span> orow<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> orow b<br><span class="hljs-keyword">WHEN</span> orow.time_slot_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span>(<span class="hljs-keyword">SELECT</span> time_slot_id <span class="hljs-keyword">FROM</span> timeslot) <span class="hljs-keyword">AND</span> orow.time_slot_id <span class="hljs-keyword">IN</span>(<span class="hljs-keyword">SELECT</span> time_slot_id <span class="hljs-keyword">FROM</span> section)<br><span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">ATOMIC</span><br>    <span class="hljs-keyword">ROLLBACK</span><br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><h3 id="statement-level-triggers">Statement Level Triggers</h3><p>Instead of <strong>executing</strong> a separate action for <strong>each affected row</strong>, a single action can be executed for <strong>all rows</strong> affected by a transaction.</p><ul><li>Use for each statement instead of <strong>for each row</strong></li><li>Use <strong>referencing old table</strong> or <strong>referencing new table</strong> to refer to <strong>temporary tables</strong> (called transition table) containing the affected rows</li><li>It’s more efficient when dealing with <strong>updates</strong> a large number of rows</li></ul><h3 id="when-not-to-use-triggers">When not to Use Triggers</h3><ul><li>Triggers were used earlier for tasks such as<ul><li>Maintaining summary data (e.g. total salary of each department)</li><li>Replicating database by recording changes to special relations (called <strong>changed</strong> or <strong>delta</strong> relations) and having a separate process that applies the changes over to a replica</li></ul></li><li>There are better ways of doing these now<ul><li>Databases today provide built-n materialized view facilities to maintain summary data</li><li>Databases provide built-in support for replication</li></ul></li><li>Encapsulation facilities can be used instead of triggers in many cases<ul><li>Define methods to update fields</li><li>Carry out actions as part of the update methods instead of through a trigger</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Intermediate SQL</title>
    <link href="/2025/12/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Intermediate_SQL/"/>
    <url>/2025/12/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Intermediate_SQL/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="join-expressions">Join Expressions</h2><p><strong>Def</strong>. <strong>Join operations</strong> take <strong>two</strong> relations and return as a result <strong>another relation</strong>.</p><p><strong>Def</strong>. <strong>Join operations</strong> is a <strong>Cartesian product</strong> requires that <strong>tuples</strong> in two relations match.</p><p><strong>Def</strong>. <strong>Join condition</strong> defines <strong>which tuples</strong> in two relations match, and <strong>what attributes</strong> are present as the result.</p><p><strong>Def</strong>. <strong>Join type</strong> defines <strong>how tuples</strong> in each relation that <strong>do not match</strong> any tuple in the other relation are treated.</p><p>We suppose we have two relations, their tables are as follow:</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">course_id</th><th style="text-align: center;">title</th><th style="text-align: center;">dept_name</th><th style="text-align: center;">credits</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">BIO-301</td><td style="text-align: center;">Genetics</td><td style="text-align: center;">Biology</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;">CS-190</td><td style="text-align: center;">Game Design</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">4</td></tr><tr class="odd"><td style="text-align: center;">CS-315</td><td style="text-align: center;">Robotics</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">3</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 1: Course table</div><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">course_id</th><th style="text-align: center;">prereq_id</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">BIO-301</td><td style="text-align: center;">BIO-101</td></tr><tr class="even"><td style="text-align: center;">CS-190</td><td style="text-align: center;">CS-101</td></tr><tr class="odd"><td style="text-align: center;">CS-347</td><td style="text-align: center;">CS-101</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 2: Prereq table</div><h3 id="natural-join-operations">Natural Join Operations</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> prereq;<br></code></pre></td></tr></table></figure><p>Which is equivalent to the following SQL query if only <strong>exist one same name column</strong>.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">JOIN</span> prereq <span class="hljs-keyword">ON</span> course.course_id <span class="hljs-operator">=</span> prereq.course_id;<br></code></pre></td></tr></table></figure><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">course_id</th><th style="text-align: center;">title</th><th style="text-align: center;">dept_name</th><th style="text-align: center;">credits</th><th style="text-align: center;">prereq_id</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">BIO-301</td><td style="text-align: center;">Genetics</td><td style="text-align: center;">Biology</td><td style="text-align: center;">4</td><td style="text-align: center;">BIO-101</td></tr><tr class="even"><td style="text-align: center;">CS-190</td><td style="text-align: center;">Game Design</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">4</td><td style="text-align: center;">CS-101</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 3: The result table of natural join</div><h3 id="outer-join">Outer Join</h3><p><strong>Def</strong>. Extension of the join operation <strong>avoids loss of information</strong>. This operation will compute the join, and then adds tuples form one relation that <strong>does not match</strong> tuples in another relation to the result of the join using the null values.</p><p>Left outer join:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> prereq<br></code></pre></td></tr></table></figure><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">course_id</th><th style="text-align: center;">title</th><th style="text-align: center;">dept_name</th><th style="text-align: center;">credits</th><th style="text-align: center;">prereq_id</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">BIO-301</td><td style="text-align: center;">Genetics</td><td style="text-align: center;">Biology</td><td style="text-align: center;">4</td><td style="text-align: center;">BIO-101</td></tr><tr class="even"><td style="text-align: center;">CS-190</td><td style="text-align: center;">Game Design</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">4</td><td style="text-align: center;">CS-101</td></tr><tr class="odd"><td style="text-align: center;">CS-315</td><td style="text-align: center;">Robotics</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">3</td><td style="text-align: center;">null</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 4: The result table of natural left outer join</div><p>Right outer join:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> prereq;<br></code></pre></td></tr></table></figure><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">course_id</th><th style="text-align: center;">title</th><th style="text-align: center;">dept_name</th><th style="text-align: center;">credits</th><th style="text-align: center;">prereq_id</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">BIO-301</td><td style="text-align: center;">Genetics</td><td style="text-align: center;">Biology</td><td style="text-align: center;">4</td><td style="text-align: center;">BIO-101</td></tr><tr class="even"><td style="text-align: center;">CS-190</td><td style="text-align: center;">Game Design</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">4</td><td style="text-align: center;">CS-101</td></tr><tr class="odd"><td style="text-align: center;">CS-347</td><td style="text-align: center;">null</td><td style="text-align: center;">null</td><td style="text-align: center;">null</td><td style="text-align: center;">CS-101</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 5: The result table of natural right outer join</div><p>Full outer join:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">FULL</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> prereq;<br></code></pre></td></tr></table></figure><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">course_id</th><th style="text-align: center;">title</th><th style="text-align: center;">dept_name</th><th style="text-align: center;">credits</th><th style="text-align: center;">prereq_id</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">BIO-301</td><td style="text-align: center;">Genetics</td><td style="text-align: center;">Biology</td><td style="text-align: center;">4</td><td style="text-align: center;">BIO-101</td></tr><tr class="even"><td style="text-align: center;">CS-190</td><td style="text-align: center;">Game Design</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">4</td><td style="text-align: center;">CS-101</td></tr><tr class="odd"><td style="text-align: center;">CS-315</td><td style="text-align: center;">Robotics</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">3</td><td style="text-align: center;">null</td></tr><tr class="even"><td style="text-align: center;">CS-347</td><td style="text-align: center;">null</td><td style="text-align: center;">null</td><td style="text-align: center;">null</td><td style="text-align: center;">CS-101</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 5: The result table of natural full outer join</div><p>More examples:</p><p>If <code>course INNER JOIN prereq ON course.course_id = prereq.course_id</code>, the result table is:</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">course_id</th><th style="text-align: center;">title</th><th style="text-align: center;">dept_name</th><th style="text-align: center;">credits</th><th style="text-align: center;">prereq_id</th><th style="text-align: center;">course_id</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">BIO-301</td><td style="text-align: center;">Genetics</td><td style="text-align: center;">Biology</td><td style="text-align: center;">4</td><td style="text-align: center;">BIO-101</td><td style="text-align: center;">BIO-301</td></tr><tr class="even"><td style="text-align: center;">CS-190</td><td style="text-align: center;">Game Design</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">4</td><td style="text-align: center;">CS-101</td><td style="text-align: center;">CS-190</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 6: The result table of inner join</div><p>If <code>course LEFT OUTER JOIN prereq ON course.course_id = prereq.course_id</code></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">course_id</th><th style="text-align: center;">title</th><th style="text-align: center;">dept_name</th><th style="text-align: center;">credits</th><th style="text-align: center;">prereq_id</th><th style="text-align: center;">course_id</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">BIO-301</td><td style="text-align: center;">Genetics</td><td style="text-align: center;">Biology</td><td style="text-align: center;">4</td><td style="text-align: center;">BIO-101</td><td style="text-align: center;">BIO-301</td></tr><tr class="even"><td style="text-align: center;">CS-190</td><td style="text-align: center;">Game Design</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">4</td><td style="text-align: center;">CS-101</td><td style="text-align: center;">CS-190</td></tr><tr class="odd"><td style="text-align: center;">CS-315</td><td style="text-align: center;">Robotics</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">3</td><td style="text-align: center;">null</td><td style="text-align: center;">null</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 7: The result table of left join</div><p>If <code>course FULL OUTER JOIN prereq USING(course_id)</code></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">course_id</th><th style="text-align: center;">title</th><th style="text-align: center;">dept_name</th><th style="text-align: center;">credits</th><th style="text-align: center;">prereq_id</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">BIO-301</td><td style="text-align: center;">Genetics</td><td style="text-align: center;">Biology</td><td style="text-align: center;">4</td><td style="text-align: center;">BIO-101</td></tr><tr class="even"><td style="text-align: center;">CS-190</td><td style="text-align: center;">Game Design</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">4</td><td style="text-align: center;">CS-101</td></tr><tr class="odd"><td style="text-align: center;">CS-315</td><td style="text-align: center;">Robotics</td><td style="text-align: center;">Comp.Sci</td><td style="text-align: center;">3</td><td style="text-align: center;">null</td></tr><tr class="even"><td style="text-align: center;">CS-347</td><td style="text-align: center;">null</td><td style="text-align: center;">null</td><td style="text-align: center;">null</td><td style="text-align: center;">CS-101</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 8: The result table of full outer join with using clause</div><h2 id="views">Views</h2><blockquote><p>Actually, not desirable for all users to see the <strong>entire</strong> logical model. A view hides <strong>certain data</strong> from view of certain users.</p><p><em>Note</em>:</p><ul><li>Views equal to <strong>projection</strong> on <strong>one or more</strong> relations</li><li>View is known as <strong>virtual relation/table</strong><ul><li>Only the <strong>definition of view</strong> itself is stored in DBS, the tuples of the view is stored in relations</li><li>Evaluation of view is reduced to evaluation of <strong>relation algebra expression</strong> that defines the view</li></ul></li><li>Differences between the <strong>with</strong> clause and the <strong>create view</strong> clause<ul><li><strong>With clause</strong> creates a <strong>temporal table</strong> to store the query results, the created table will be <strong>cancelled</strong> after SQL execution ends</li></ul></li></ul></blockquote><p><strong>Def</strong>. Any relation that is not of the <strong>conceptual</strong> model, but is made visible to a user as a <strong>virtual relation</strong>.</p><p><strong>Def</strong>. <strong>View</strong> is defined using the <strong>create view</strong> statement <code>CREATE VIEW v AS &lt;query expression&gt;</code>. The view name is represented by <strong>v</strong>.</p><ul><li>The view name can be used to refer to the <strong>virtual</strong></li><li>View definition is <strong>not the same as</strong> creating a new relation. A view definition causes the saving of an expression</li></ul><p>For example,</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQl"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> department_total_salary(dept_name, total_salary) <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> dept_name, <span class="hljs-built_in">SUM</span>(salary)<br><span class="hljs-keyword">FROM</span> instructor<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_name;<br></code></pre></td></tr></table></figure><blockquote><p><em>Note</em>: one view may be used in the expression defining another view.</p></blockquote><p><strong>Def</strong>. A view relation <span class="math inline">\(v_1\)</span> is said to <strong>depend directly</strong> on a view relation <span class="math inline">\(v_2\)</span>, if <span class="math inline">\(v_2\)</span> is used in the expression defining <span class="math inline">\(v_1\)</span>.</p><p><strong>Def</strong>. A view relation <span class="math inline">\(v_1\)</span> is said to <strong>depend on</strong> view relation <span class="math inline">\(v_2\)</span>, if either <span class="math inline">\(v_1\)</span> depends on directly to <span class="math inline">\(v_2\)</span> or there is a path of dependencies from <span class="math inline">\(v_1\)</span> to <span class="math inline">\(v_2\)</span>.</p><p><strong>Def</strong>. A view relation <span class="math inline">\(v\)</span> is said to be <strong>recursive</strong> if it depends on itself.</p><p>We can <strong>update</strong> a view. For example, add a new tuple to <em>faculty</em> view <code>INSERT INTO faculty VALUES('30765', 'Green', 'Music');</code>.</p><blockquote><p><strong>Materializing a view</strong> means creating a physical table containing all the tuples in the result of the query defined view. If relations used in the query are updated, the materialized view result becomes <strong>out of date</strong>.</p></blockquote><h2 id="transactions">Transactions</h2><p><strong>Def</strong>. A <strong>transaction</strong> consists of a sequence of query and/or update statements and it is a <strong>unit</strong> of work.</p><blockquote><p><em>Note</em>: <strong>ACID</strong> (atomicity, consistency, isolation, durability) properties.</p><p><strong>Atomic transaction</strong>: either fully executed or rolled back as if never occurred.</p><p><strong>Isolation</strong> from concurrent transactions.</p></blockquote><p>A transaction <strong>begins</strong> implicitly when <strong>an statement is executed</strong>, ends with <strong>statements</strong>.</p><ul><li>Commit work. The updates become permanent</li><li>Rollback work. All the updates performed are undone</li></ul><p>Here is an example</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- Declare a transaction name</span><br><span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@transfer_name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>);<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@transfer_name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;I-transfer-from-A-to-B&#x27;</span>;<br><br><span class="hljs-comment">-- Begin the transaction</span><br><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br><br><span class="hljs-comment">-- Switch to the target database</span><br>USE ACCOUNT;<br><br><span class="hljs-comment">-- Deduct balance from table A</span><br><span class="hljs-keyword">UPDATE</span> A<br><span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">50</span><br><span class="hljs-keyword">WHERE</span> branch_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Brooklyn&#x27;</span>;<br><br><span class="hljs-comment">-- Add balance to table A</span><br><span class="hljs-keyword">UPDATE</span> A<br><span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">50</span><br><span class="hljs-keyword">WHERE</span> branch_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Brooklyn&#x27;</span>;<br><br><span class="hljs-comment">-- Commit the transaction</span><br><span class="hljs-keyword">COMMIT</span> TRANSACTION;<br></code></pre></td></tr></table></figure><h2 id="integrity-constraints">Integrity Constraints</h2><p><strong>Def</strong>. <strong>Integrity constraints</strong> guard against <strong>accidental damage</strong> to DB, ensuring that the <strong>authorized changes</strong> to DB do not result in <strong>loss</strong> of data <strong>consistency</strong>.</p><blockquote><p>Examples</p><ul><li>An instructor name can <strong>not be null</strong></li><li><strong>No two instructors</strong> can have the same instructor ID</li><li>Every department name in <em>course</em> relation must have a matching department name in <em>department</em> relation.</li></ul></blockquote><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">type</th><th style="text-align: center;">attribute-level</th><th style="text-align: center;">tuple-level</th><th style="text-align: center;">relation-level</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">static</td><td style="text-align: center;">data type <br> data format <br> domain constraints <br> null value</td><td style="text-align: center;">constraints among attributes values</td><td style="text-align: center;">entity integrity <br> referential integrity <br> functional dependency</td></tr><tr class="even"><td style="text-align: center;">dynamic</td><td style="text-align: center;">constraints on updating of attribute values or attribute definition</td><td style="text-align: center;">constraints among attributes values</td><td style="text-align: center;">transaction constraint: ACID</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 9: Classification of integrity constraints</div><h3 id="constraints-on-single-relation">Constraints on Single Relation</h3><p>Integrity constraints include</p><ul><li><code>primary key</code></li><li><code>not null</code><ul><li>Declare name and budget to be not null</li></ul></li><li><code>unique</code></li><li><code>check(P)</code>, where P is a predicate</li></ul><p><strong>Def</strong>. <strong>Unique constraint</strong> is as follows: unique <span class="math inline">\((A_1, A_2, \cdots, A_m)\)</span>.</p><ul><li>Attributes <span class="math inline">\(A_i\)</span> form a <strong>candidate key</strong></li><li>Candidate keys are permitted to be <strong>null</strong> (in contrast to primary keys)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> customer (<br>  customer_id <span class="hljs-type">char</span>(<span class="hljs-number">15</span>),<br>  customer_name <span class="hljs-type">char</span>(<span class="hljs-number">15</span>),<br>  customer_city <span class="hljs-type">char</span>(<span class="hljs-number">30</span>),<br>  <span class="hljs-keyword">PRIMARY KEY</span> (customer_id),<br>  <span class="hljs-keyword">UNIQUE</span> (customer_name)<br>);<br></code></pre></td></tr></table></figure><p>The <strong>check clause</strong> is applied to <strong>relation declaration</strong> as well as <strong>domain declaration</strong>.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> section (<br>  course_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">8</span>),<br>  sec_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">8</span>),<br>  semester <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">6</span>),<br>  <span class="hljs-keyword">year</span> <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>),<br>  room_number <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">7</span>),<br>  <span class="hljs-keyword">PRIMARY KEY</span> (course_id, sec_id, semester, <span class="hljs-keyword">year</span>),<br>  <span class="hljs-keyword">CHECK</span> (semester <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;Fall&#x27;</span>, <span class="hljs-string">&#x27;Winter&#x27;</span>, <span class="hljs-string">&#x27;Spring&#x27;</span>, <span class="hljs-string">&#x27;Summer&#x27;</span>))<br>);<br></code></pre></td></tr></table></figure><h2 id="referential-integrity">Referential Integrity</h2><p><strong>Def</strong>. <strong>Referential integrity dependencies</strong></p><ul><li>Let <span class="math inline">\(r_1(R_1)\)</span> and <span class="math inline">\(r_2(R_2)\)</span> be relations with primary keys <span class="math inline">\(K_1\)</span> and <span class="math inline">\(K_2\)</span> respective</li><li>The subset <span class="math inline">\(\alpha\)</span> of <span class="math inline">\(R_2\)</span> (dept_name) is a <strong>foreign key</strong> (from <span class="math inline">\(r_2\)</span>, <em>course</em>) <strong>referencing</strong> <span class="math inline">\(K_1\)</span> in relation <span class="math inline">\(r_1\)</span> (dept_name in <em>department</em>), if every <span class="math inline">\(t_2\)</span> in <span class="math inline">\(r_2\)</span>, there must be a tuple <span class="math inline">\(t_1\)</span> in <span class="math inline">\(r_1\)</span> such that <span class="math inline">\(t_1 [K_1] = t_2 [\alpha]\)</span></li></ul><p><strong>Def</strong>. <strong>Referential integrity constraint</strong> called subset dependency since it can be written as <span class="math inline">\(\Pi_{\alpha}(r_2) \subseteq \Pi_{K_1}(r_1)\)</span>. <strong>Foreign key</strong> <span class="math inline">\(\alpha\)</span> of table <span class="math inline">\(r_2\)</span> references <strong>primary key</strong> attributes <span class="math inline">\(K_1\)</span> of the referenced table <span class="math inline">\(r_1\)</span>.</p><h3 id="cascading-actions-in-referential-integrity">Cascading Actions in Referential Integrity</h3><p>The <strong>delete/update</strong> operations on the <strong>referenced</strong> <em>department</em> will result in the <strong>delete/update</strong> on the referencing <em>course</em>.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> course (<br>  ...<br>  dept_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>  <span class="hljs-keyword">FOREIGN KEY</span> (dept_name) <span class="hljs-keyword">REFERENCES</span> department <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE,<br>  ...<br>)<br></code></pre></td></tr></table></figure><blockquote><p>What changes in <em>department</em> will happen in <em>course</em> on dept_name.</p></blockquote><h2 id="data-types-and-schemas">Data Types and Schemas</h2><h3 id="type-conversion">Type Conversion</h3><ul><li><code>CAST e AS t</code>: convert a <strong>character string</strong> e to the type t, e.g. <code>cast '2017-07-20</code> AS DATE`</li><li><code>EXTRACT VALUE d FROM DAY (or TIME)</code>: for day or time values d, its individual fields can be <strong>extracted</strong>, e.g. <code>EXTRACT (year FROM 2017-07-20) = 2017</code></li></ul><h3 id="default-values">Default Values</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><br><span class="hljs-keyword">CREATE TABLE</span> student (<br>  ID <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">5</span>),<br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  dept_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>  tot_cred <span class="hljs-type">numeric</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (ID)<br>);<br></code></pre></td></tr></table></figure><blockquote><p><code>INSERT INTO student(ID, name, dept_name) VALUES ('12789', 'Newman', 'Comp.Sci')</code> (tot_cred not required)</p></blockquote><h3 id="user-defined-types">User-defined Types</h3><p>The <strong>create type</strong> clause can be used for user-defined types, e.g.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> TYPE Dollars <span class="hljs-keyword">AS</span> <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">12</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">CREATE TABLE</span> department (<br>  dept_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>  building <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>),<br>  budget Dollars<br>);<br></code></pre></td></tr></table></figure><h3 id="user-defined-domains">User-defined Domains</h3><p><strong>Create domain</strong> construct creates <strong>user-defined domain</strong> types, e.g. <code>CREATE DOMAIN person_name CHAR(20) NOT NULL</code>.</p><blockquote><p>Types and domains are <strong>similar</strong>. Domains can have constraints, such as <strong>not null</strong>, specified on them</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> DOMAIN degree_level <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">CONSTRAINT</span> degree_level_test<br><span class="hljs-keyword">CHECK</span> (<span class="hljs-keyword">VALUE</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;Bachelors&#x27;</span>, <span class="hljs-string">&#x27;Masters&#x27;</span>, <span class="hljs-string">&#x27;Doctorate&#x27;</span>));<br></code></pre></td></tr></table></figure></blockquote><h3 id="complex-check-conditions-and-assertions">Complex Check Conditions and Assertions</h3><p>Some constructs such as <strong>check</strong> and <strong>assertion</strong> are defined to specify the complex integrity constraints. However, they are not currently supported by most database systems.</p><p>An <strong>assertion</strong> is a predicate expressing a condition that we wish the database always to <strong>satisfy</strong>. An assertion takes the form <code>CREATE ASSERTION &lt;assertion_name&gt; CHECK &lt;predicate&gt;</code>. This testing may introduce a significant amount of <strong>overhead</strong>, hence assertions should be used with great care. Here is an example</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> ASSERTION credits_earned_constraints <span class="hljs-keyword">CHECK</span><br>(<br>  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> ID <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> tot_cred <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(credits) <span class="hljs-keyword">FROM</span> takes <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> course <span class="hljs-keyword">WHERE</span> student.ID <span class="hljs-operator">=</span> takes.ID <span class="hljs-keyword">AND</span> grade <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">AND</span> grade <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;F&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><h2 id="index-definition-in-sql">Index Definition in SQL</h2><p>Many queries reference <strong>only a small proportion</strong> of the records in a table. It is <strong>efficient</strong> to read every record to find a record with particular value.</p><p><strong>Def</strong>. An <strong>index</strong> on an attribute of a relation is a data structure that allows the DBS to find those tuples in the relation that have a specified value for that attribute efficiently, <strong>without scanning through all the tuples of the relation</strong>.</p><p>Create an index with the <strong>create index</strong> command: <code>CREATE INDEX &lt;name&gt; ON &lt;relation_name&gt; (&lt;attribute_name&gt;);</code></p><blockquote><p><code>CREATE INDEX studentID_index ON student(ID)</code></p><p>The query:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> ID <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;12345&#x27;</span>;<br></code></pre></td></tr></table></figure><p>can be executed by using the <strong>index</strong> to find the required record, <strong>without looking at all records of student</strong>.</p></blockquote><h2 id="authorization">Authorization</h2><ul><li>Forms of authorization on parts of the <strong>database</strong><ul><li>Read allows reading, but <strong>not modification of data</strong></li><li>Insert allows modification, but <strong>not deletion of data</strong></li><li>Delete allows deletion of data</li></ul></li><li>Forms of authorization to modify the <strong>database schema</strong><ul><li>Resources allows <strong>creation of new relations</strong></li><li>Alteration allows <strong>addition or deletion of attributes</strong> in a relation</li><li>Drop allows deletion of relations</li><li>Index</li></ul></li></ul><p>The <strong>grant statement</strong> is used to confer authorization</p><ul><li><code>GRANT &lt;privilege_list&gt; ON &lt;relation_name or view_name&gt; TO &lt;user_list&gt;</code></li><li>user_list is a user_id and public, which allows all valid users the privilege granted</li></ul><blockquote><p>Granting a privilege on a <strong>view</strong> does not imply granting any privileges on the underlying relations.</p><p>The grantor of the privilege must already hold the privilege on the specified item (or be the database administrator).</p></blockquote><h3 id="privileges">Privileges</h3><ul><li><code>SELECT</code>: allows <strong>read access</strong> to relation, or <strong>ability to query</strong> using the view<ul><li>e.g. <code>GRANT SELECT ON instructor TO user_1, user_2, user_3</code></li></ul></li><li><code>INSERT</code></li><li><code>UPDATE</code></li><li><code>DELETE</code></li><li><code>ALL PRIVILEGES</code></li></ul><h3 id="revoking-authorization">Revoking Authorization</h3><p>The <strong>revoke</strong> statement is used to revoke authorization</p><ul><li><code>REVOKE &lt;privilege_list&gt; ON &lt;relation_name or view_name&gt; FROM &lt;user_list&gt;</code></li><li>e.g. <code>REVOKE SELECT ON instructor FROM user_1, user_2, user_3</code></li></ul><blockquote><p>Privilege_list may be <strong>all</strong> to revoke all privileges the revoker may hold.</p><p>If user_list includes <strong>public</strong>, all users lose the privilege <strong>except those granted it explicitly</strong>.</p></blockquote><h3 id="roles">Roles</h3><p>Chain of roles</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> ROLE dean;<br><span class="hljs-keyword">GRANT</span> instructor <span class="hljs-keyword">TO</span> dean;<br><span class="hljs-keyword">GRANT</span> dean <span class="hljs-keyword">TO</span> Satoshi<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>Privileges can be granted to roles<ul><li><code>GRANT select ON takes TO instructor;</code></li></ul></li><li>Roles can be granted to users, as well as to other roles<ul><li><code>CREATE ROLE teaching_assistant; GRANT teaching_assistant TO instructor;</code></li><li>Instructor inherits all privileges of teaching_assistant</li></ul></li></ul><h3 id="authorization-on-views">Authorization on Views</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> geo_instructor <span class="hljs-keyword">AS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> instructor <span class="hljs-keyword">WHERE</span> dept_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Geology&#x27;</span>);<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> geo_instructor <span class="hljs-keyword">TO</span> geo_staff;<br></code></pre></td></tr></table></figure><h3 id="other-authorization-features">Other Authorization Features</h3><ul><li>References privilege to <strong>create foreign key</strong><ul><li><code>GRANT REFERENCE(dept_name) ON department TO Mariano;</code></li></ul></li><li>Transfer of privilege<ul><li><code>GRANT SELECT ON department TO Amit WITH GRANT OPTION;</code></li><li><code>REVOKE SELECT ON department FROM Amit, Satoshi CASCADE;</code></li><li><code>REVOKE SELECT ON department FROM Amit, Satoshi RESTRICT;</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Reliable FS</title>
    <link href="/2025/12/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Reliable_FS/"/>
    <url>/2025/12/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Reliable_FS/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="threats-to-fs-reliability">Threats to FS Reliability</h2><p>Operation interruption</p><ul><li>A <strong>crash or power</strong> failure</li><li>A file operation often consists of many <strong>I/O updates</strong> to the storage</li><li>An example: <code>mv ./dir1/file1 ./dir2/file2</code><ul><li>Writing the <code>dir1</code> directory file to remove <code>file1</code></li><li>(optional) Growing the <code>dir2</code> directory’s file to include another block of storage to accommodate a new directory entry for ‘file2’</li><li>Writing the new directory entry to the directory file</li><li>Updating the last-modified time of the <code>dir1</code> directory</li><li>Updating the file system’s free space bitmap</li><li>Updating the size and last-modified time of the <code>dir2</code> directory</li></ul></li><li><strong>At physical level, operations complete one at a time.</strong></li></ul><p>Loss of stored data, either physical or electric.</p><blockquote><p>Reliability vs. Availability</p><ul><li>Reliability: the probability that storage system will continue to be reliable for some specified period of time.</li><li>Availability: the probability that the storage system will be available at any given time.</li></ul><p>What a Reliable FS Does?</p><ul><li>“All or nothing”<ul><li>Either an update is completed, or not at all</li><li>Must be guaranteed whenever a crash happens</li><li>Must be transparent to users/apps</li></ul></li><li>Quite similar to the <strong>critical section problem in concurrency</strong><ul><li>Avoid someone observing the state in an intermediate, inconsistent state</li><li>No control over “when it happens”</li></ul></li></ul></blockquote><h2 id="reliability-approach-1">Reliability Approach 1</h2><p>Careful ordering</p><ul><li>Sequence operations in a specific order<ul><li>Careful design to allow sequence to be interrupted safely</li></ul></li><li>Post-crash recovery<ul><li>Read data structures to see if there were any operations in progress</li><li>Clean up/finish as needed</li></ul></li><li>Approach taken by<ul><li>FAT and FFS (<code>fsck</code>) to protect filesystem structure/metadata</li><li>Many app-level recovery schemas (e.g. Word, emacs autosaves)</li></ul></li></ul><p>Issues with approach 1</p><ul><li>Complex reasoning<ul><li>So many possible operations and failures</li></ul></li><li>Slow updates<ul><li>File systems are forced to insert sync operations or barriers between dependent operations</li></ul></li><li>Extremely slow recovery<ul><li>Need to scan all of its disks inconsistent metadata structures</li></ul></li></ul><h2 id="transactions">Transactions</h2><p><strong>Def</strong>. Transaction is an atomic sequence of actions (reads/writes) on a storage system (or database). That takes it from one <strong>consistent state</strong> to another</p><ul><li>Use <strong>transactions</strong> for atomic updates<ul><li>Ensure that multiple related updates are performed atomically</li><li>i.e. If a crash occurs in the middle, the state of the systems reflects either <strong>all or none</strong> of the updates</li><li>Most modern file systems use transactions internally to update filesystem structures and metadata</li><li>Many applications implement their own transactions</li></ul></li><li>They extend concept of atomic update from memory to stable storage<ul><li>Atomically update multiple persistent data structures</li></ul></li></ul><h3 id="typical-structure">Typical Structure</h3><ol type="1"><li>Begin a transaction - get transaction <strong>id</strong>.</li><li>Do a bunch of updates<ul><li>If any fail along the way, <strong>roll-back</strong></li><li>Or, if any conflicts with other transactions, <strong>roll-back</strong>.</li></ul></li><li><strong>Commit</strong> the transaction</li></ol><h3 id="the-key-properties-of-transactions">The Key Properties of Transactions</h3><ul><li><strong>Atomicity</strong>: all actions in the transaction happen, or none happen</li><li><strong>Consistency</strong>: transactions maintain data integrity, e.g.<ul><li>Balance cannot be negative</li><li>Cannot reschedule meeting on February 30</li></ul></li><li><strong>Isolation</strong>: execution of one transaction is isolated from that of all others; no problem from concurrency</li><li><strong>Durability</strong>: if a transaction commits, its effects persist despite crashes.</li></ul><h2 id="logging">Logging</h2><ul><li>Instead of modifying data structures on disk directly, write changes to a journal/log<ul><li>Intention list: set of changes we intend to make</li><li>Log/journal is append-only</li><li>Single commit record commits transaction</li></ul></li><li>Once changes are in log, it is safe to apply changes to data structures on disk<ul><li>Recovery can read log to see what changes were intended</li><li>Can take our time making the changes<ul><li>As long as new requests consult the log first</li></ul></li></ul></li><li>Basic assumption<ul><li>Updates to sectors are atomic and ordered</li></ul></li></ul><p><strong>Def</strong>. <strong>Log</strong> is an append-only file containing log records</p><ul><li><code>&lt;start t&gt;</code>: transaction <code>t</code> has begun</li><li><code>&lt;t, x, v&gt;</code>: transaction <code>t</code> has updated block <code>x</code> and its new value is <code>v</code><ul><li>Can log block “diffs” instead of full blocks</li><li>Can log <em>operations</em> instead of data</li></ul></li><li><code>&lt;commit t&gt;</code>: transaction <code>t</code> has committed - updates will survive a crash</li></ul><blockquote><ul><li>Committing involves writing the records - the home data needn’t be updated at this time</li><li>Logs are often kept in a separation partition</li><li>Once transactions are committed, logs can be cleaned up</li></ul></blockquote><h3 id="implementing-transactions-redo-logging">Implementing Transactions: Redo Logging</h3><ol type="1"><li>Prepare<ul><li>Write all changes/updates to log</li><li>Can happen at once, or over time</li><li>Wait until all updates are written in log</li></ul></li><li>Commit<ul><li>Append a commit record to the log</li><li>Or can roll back (abandoned), write a roll-back record<ul><li>An atomic operation<ul><li>Before it, we can safely roll-back</li><li>After it, the transaction must take effect</li></ul></li></ul></li></ul></li><li>Write-back<ul><li>Write all of the transaction’s updates to disk</li></ul></li><li>Garbage collection<ul><li>Reclaim space in log</li></ul></li><li>Recovery<ul><li>Read log</li><li>Redo any operations for committed transactions</li><li>Garbage collect log</li></ul></li></ol><h3 id="implementation-details">Implementation Details</h3><ul><li>Deal with concurrent transactions<ul><li>Must identify which transaction does a record belong to</li></ul></li><li>Repeated write-backs are OK<ul><li>Works for idempotent updates:“write 42 to each byte of sector 74”</li><li>Redo log systems do not permit non-idempotent records such as “add 42 to each byte in sector 74”.</li></ul></li><li>Restarting recovery is OK<ul><li>If another crash occurs during recovery</li></ul></li><li>The performance of redo logging is not as bad as it looks like:<ul><li>Log updates are sequential</li><li>Asynchronous write-back<ul><li>Low latency for commit(); high throughput as updates can be batched</li></ul></li><li>Group commit: combine a set of transaction commits into one log write<ul><li>Amortize the cost of initiating the write (e.g., seek and rotational delays)</li></ul></li></ul></li><li>New requests (e.g., reads) need to consult the log first to ensure the data consistency<ul><li>Can be alleviated by caching</li></ul></li><li>Ordering is essential, as we must ensure:<ul><li>A transaction’s updates are on disk in the log before the commit is</li><li>The commit is on disk before any of the write-backs are</li><li>All of the write-backs are on disk before a transaction’s log records are garbage collected.</li></ul></li></ul><h2 id="transactional-file-systems">Transactional File Systems</h2><ul><li>Two ways to use transactions in file systems: journaling and logging<ul><li>Journaling: apply updates to the system’s metadata via transactions<ul><li>Microsoft’s NTFS,Apple’s HFS+, and Linux’s XFS/JFS</li></ul></li><li>(Full) Logging: apply both metadata and data in transactions<ul><li>Linux’s ext3 and ext4 can be configured to use either journaling or logging</li></ul></li></ul></li></ul><h3 id="journaling-file-systems">Journaling File Systems</h3><ul><li>Applies updates to system metadata (inodes, bitmaps, directories, and indirect blocks) using transactions<ul><li>So those critical data structures are always consistent</li></ul></li><li>Updates to non-directory files (i.e., user stuff) can be done in place (without logs), full logging optional<ul><li>Avoids writing file contents twice</li><li>If a program using a journaling file system requires atomic multi-block updates, it needs to provide them itself</li></ul></li></ul><h3 id="copy-on-write-file-system">Copy-on-Write File System</h3><ul><li>To update file system, write a new version of the file system containing the update<ul><li>Never update in place</li><li>Reuse existing unchanged disk blocks</li></ul></li><li>Optimization: batch updates<ul><li>Transform many small, random writes into large, sequential writes</li></ul></li><li>Approach taken in network file server appliances<ul><li>NetApp’s Write Anywhere File Layout (WAFL)</li><li>ZFS (Sun/Oracle) and OpenZFS</li></ul></li></ul><h2 id="raid-redundant-arrays-of-inexpensive-disks">RAID: Redundant Arrays of Inexpensive Disks</h2><blockquote><p>Storage Devices Failure</p><ul><li>Sector and page failure: one or more individual sectors of a disk are lost, but the rest of the disk continues to operate correctly</li><li>Full disk failure: a device stops being able to service reads or writes to all sectors</li></ul></blockquote><h3 id="raid-1-disk-mirroringshadowing">RAID 1: Disk Mirroring/Shadowing</h3><ul><li>Each disk is fully duplicated onto its “shadow”<ul><li>For high I/O rate, high availability environments</li><li>Most expensive solution: <span class="math inline">\(100\%\)</span> capacity overhead</li></ul></li><li>Bandwidth sacrificed on write:<ul><li>Logical write = two physical writes</li><li>Highest bandwidth when disk heads and rotation fully synchronized (hard to do)</li></ul></li><li>Reads may be optimized<ul><li>Can have two independent reads to same data</li></ul></li><li>Recovery:<ul><li>Disk failure <span class="math inline">\(\Rightarrow\)</span> replace disk and copy data to new disk</li><li>Hot Spare: idle disk already attached to system to be used for immediate replacement</li></ul></li></ul><h3 id="raid-5-high-io-rate-parity">RAID 5+: High I/O Rate Parity</h3><ul><li>Data stripped across multiple disks<ul><li>Successive blocks stored on successive (non-parity) disks</li><li>Increased bandwidth over single disk</li></ul></li><li>Parity block (in green) constructed by XORing data blocks in stripe<ul><li><span class="math inline">\(P0 = D0 \oplus D1 \oplus D2 \oplus D3\)</span></li><li>Can destroy any one disk and still reconstruct data</li><li>Suppose Disk 3 fails, then can reconstruct: <span class="math inline">\(D2= D0 \oplus D1 \oplus D3 \oplus P0\)</span></li></ul></li><li>Rotating parity<ul><li>The parity needs to be updated more often than normal data blocks.</li></ul></li><li>Striping data<ul><li>Balance parallelism vs. sequential access efficiency</li></ul></li></ul><blockquote><p>RAID 5 can recover the failed disk only if (i) only one disk fails and (ii) the failed disk is known.</p></blockquote><h2 id="distributed-systems-motivationissuespromise">Distributed Systems: Motivation/Issues/Promise</h2><ul><li>Why do we want distributed systems?<ul><li>Cheaper and easier to build lots of simple computers</li><li>Easier to add power incrementally</li><li>Users can have complete control over some components</li><li>Collaboration: much easier for users to collaborate through network resources (such as network file systems)</li></ul></li><li>The promise of distributed systems:<ul><li>Higher availability: one machine goes down, use another</li><li>Better durability: store data in multiple locations</li><li>More security: each piece easier to make secure</li></ul></li></ul><h3 id="distributed-systems-reality">Distributed Systems: Reality</h3><ul><li>Reality has been disappointing<ul><li>Worse availability: depend on every machine being up<ul><li>Lamport: “a distributed system is one where I can’t do work because some machine I’ve never heard of isn’t working!”</li></ul></li><li>Worse reliability: can lose data if any machine crashes</li><li>Worse security: anyone in world can break into system</li></ul></li><li>Coordination is more difficult<ul><li>Must coordinate multiple copies of shared state information (using only a network)</li><li>What would be easy in a centralized system becomes a lot more difficult</li></ul></li></ul><h3 id="distributed-systems-goalsrequirements">Distributed Systems: Goals/Requirements</h3><ul><li>Transparency: the ability of the system to mask its complexity behind a simple interface</li><li>Possible transparencies:<ul><li>Location: Can’t tell where resources are located</li><li>Migration: Resources may move without the user knowing</li><li>Replication: Can’t tell how many copies of resource exist</li><li>Concurrency: Can’t tell how many users there are</li><li>Parallelism: System may speed up large jobs by splitting them into smaller pieces</li><li>Fault Tolerance: System may hide various things that go wrong</li></ul></li><li>Transparency and collaboration require some way for different processors to communicate with one another</li></ul><h2 id="homework">Homework</h2><ol type="1"><li>The FastFile file system uses an inode array to organize the files on disk. Each inode consists of a user id (2 bytes), three time stamps (4 bytes each), protection bits (2 bytes), a reference count (2 byte), a file type (2 bytes) and the size (4 bytes). Additionally, the inode contains 13 direct indexes, 1 index to a 1st-level index table, 1 index to a 2nd-level index table, and 1 index to a 3rd level index table. The file system also stores the first 436 bytes of each file in the inode.<ul><li>Assume a disk sector is 512 bytes, and assume that any auxilliary index table takes up an entire sector, what is the maximum size for a file in this system.</li><li>Is there any benefit for including the first 436 bytes of the file in the inode?</li></ul></li><li>When user tries to write a file, the file system needs to detect if that file is a directory so that it can restrict writes to maintain the directory’s internal consistency. Given a file’s name, how would you design a file system to keep track of whether each file is a regular file or a directory?<ul><li>In FAT</li><li>In FFS</li><li>In NTFS</li></ul></li><li>Suppose a variation of FFS includes in each inode 12 direct, 1 indirect, 1 double indirect, 2 triple indirect, and 1 quadruple indirect pointers. Assuming 6 KB blocks and 6-byte pointers.<ul><li>What is the largest file that can be accessed with direct pointers only?</li><li>What is the largest file that can be accessed in total?</li></ul></li><li>Consider a disk queue holding requests to the following cylinders in the listed order: 116, 22, 3, 11, 75, 185, 100, 87. Using the elevator scheduling algorithm, what is the order that the requests are serviced, assuming the disk head is at cylinder 88 and moving upward through the cylinders?</li></ol><h2 id="答案">答案</h2><h3 id="fastfile-文件系统计算">1. FastFile 文件系统计算</h3><p><strong>题目分析：</strong></p><ul><li><strong>Inode 结构</strong>：<ul><li>固定元数据：用户ID(2) + 时间戳(12) + 保护位(2) + 引用计数(2) + 文件类型(2) + 大小(4) = <strong>24 字节</strong>。</li><li>嵌入数据：<strong>436 字节</strong>。</li><li>索引指针：13个直接 + 1个一级 + 1个二级 + 1个三级 = <strong>16 个指针</strong>。</li></ul></li><li><strong>扇区/块大小</strong>：512 字节。</li><li><strong>指针大小推断</strong>： 假设 Inode 占用一个扇区（512 字节），则剩余给指针的空间为 <span class="math inline">\(512 - 24 - 436 = 52\)</span> 字节。 <span class="math inline">\(52 \div 16 = 3.25\)</span>。因此，为了放入一个扇区，<strong>指针大小应为 3 字节（24位）</strong>。</li><li><strong>每个索引块的指针数</strong>：<span class="math inline">\(512 \div 3 = 170\)</span> 个指针（向下取整）。</li></ul><p><strong>解答：</strong></p><ul><li><p><strong>最大文件大小 (Maximum size)</strong>： 文件由以下部分组成：</p><ol type="1"><li><strong>Inode 内嵌数据</strong>：436 字节</li><li><strong>直接索引</strong>：<span class="math inline">\(13 \times 512\)</span> 字节</li><li><strong>一级间接索引</strong>：<span class="math inline">\(1 \times 170 \times 512\)</span> 字节</li><li><strong>二级间接索引</strong>：<span class="math inline">\(1 \times 170^2 \times 512\)</span> 字节</li><li><strong>三级间接索引</strong>：<span class="math inline">\(1 \times 170^3 \times 512\)</span> 字节</li></ol><p>计算主要由三级间接索引决定： <span class="math inline">\(170^3 \times 512 \text{ B} = 4,913,000 \times 512 \text{ B} \approx 2,515,456,000 \text{ B} \approx \mathbf{2.34 \text{ GB}}\)</span>。 <em>(精确值为：436 + 6,656 + 87,040 + 14,796,800 + 2,515,456,000 = 2,530,346,932 字节)</em></p></li><li><p><strong>将前 436 字节包含在 Inode 中的好处 (Benefit)</strong>：</p><ol type="1"><li><strong>性能优化 (Performance)</strong>：对于小于或等于 436 字节的小文件，只需读取 Inode 即可获取文件内容，无需额外的磁盘寻道和读取数据块操作（减少一次 I/O）。</li><li><strong>空间节省 (Space)</strong>：小文件不需要分配一个完整的 512 字节数据块，避免了内部碎片（Internal Fragmentation），节省了磁盘空间。</li></ol></li></ul><h3 id="区分文件与目录">2. 区分文件与目录</h3><p><strong>题目分析：</strong> 文件系统需要通过元数据来区分普通文件和目录。</p><p><strong>解答：</strong></p><ul><li><strong>In FAT (File Allocation Table)</strong>： 在<strong>目录项 (Directory Entry)</strong> 中，有一个属性字节 (Attribute Byte)。该字节的第 4 位（通常是 <code>0x10</code>）专门用于标识该条目是否为一个子目录。</li><li><strong>In FFS (Unix Fast File System)</strong>： 在 <strong>Inode</strong> 结构中，包含文件类型 (File Type) 或模式位 (Mode Bits)。例如 <code>st_mode</code> 字段中的一部分位用于指示文件类型（如 <code>S_IFDIR</code> 表示目录，<code>S_IFREG</code> 表示普通文件）。</li><li><strong>In NTFS (New Technology File System)</strong>： 在 <strong>MFT (Master File Table)</strong> 记录中，标准属性（如 <code>$STANDARD_INFORMATION</code> 或 <code>$FILE_NAME</code>）包含文件属性标志，其中有一位标识是否为目录。此外，目录本质上是一个包含索引属性（如 <code>$INDEX_ROOT</code>）的文件。</li></ul><h3 id="ffs-变体计算">3. FFS 变体计算</h3><p><strong>题目分析：</strong> - <strong>Inode 指针结构</strong>：12 直接，1 一级，1 二级，2 三级，1 四级。 - <strong>块大小</strong>：6 KB = 6144 字节。 - <strong>指针大小</strong>：6 字节。 - <strong>每块指针数</strong>：<span class="math inline">\(6144 \div 6 = 1024\)</span> 个指针。</p><p><strong>解答：</strong></p><ul><li><p><strong>仅使用直接指针访问的最大文件 (Largest file with direct pointers only)</strong>： <span class="math inline">\(12 \times 6 \text{ KB} = \mathbf{72 \text{ KB}}\)</span>。</p></li><li><p><strong>总共可访问的最大文件 (Largest file in total)</strong>： 总大小 = 直接 + 一级 + 二级 + 三级 + 四级 <span class="math inline">\(= (12 + 1024 + 1024^2 + 2 \times 1024^3 + 1 \times 1024^4) \times 6 \text{ KB}\)</span></p><p>由于 <span class="math inline">\(1024 = 2^{10}\)</span>，且四级间接指针占主导地位： 四级部分大小 = <span class="math inline">\(1 \times (2^{10})^4 \times 6 \times 2^{10} \text{ B} = 6 \times 2^{50} \text{ B} = \mathbf{6 \text{ PB}}\)</span>。 加上三级部分 (<span class="math inline">\(2 \times 1024^3 \times 6 \text{ KB} = 12 \text{ TB}\)</span>)，总大小约为 <strong>6 PB</strong> (Petabytes)。</p></li></ul><h3 id="磁盘调度-elevator-algorithm">4. 磁盘调度 (Elevator Algorithm)</h3><p><strong>题目分析：</strong> - <strong>请求队列</strong>：116, 22, 3, 11, 75, 185, 100, 87 - <strong>当前磁头位置</strong>：88 - <strong>移动方向</strong>：向上 (Upward/Increasing) - <strong>算法</strong>：电梯算法 (Elevator/SCAN/LOOK)。通常指磁头向一个方向移动处理请求，直到没有请求或到达边缘，然后反向。</p><p><strong>解答：</strong></p><ol type="1"><li><strong>向上移动 ( &gt; 88)</strong>：<ul><li>100</li><li>116</li><li>185</li></ul></li><li><strong>反向向下移动 ( &lt; 88)</strong>：<ul><li>87</li><li>75</li><li>22</li><li>11</li><li>3</li></ul></li></ol><p><strong>服务顺序 (Order serviced)</strong>： <strong>100, 116, 185, 87, 75, 22, 11, 3</strong></p>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FS Design</title>
    <link href="/2025/12/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FS_Design/"/>
    <url>/2025/12/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FS_Design/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="directory-structure">Directory Structure</h2><ul><li>Directory is treated as a file with a list of <code>&lt;file name: file number&gt;</code> mappings</li><li>The file number of the root directory is agreed ahead of time (in many Unix FSs. it’s 2).</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FS_Design/Example%20directory%20structure%20in%20Unix.png" alt="Example directory structure in Unix"><figcaption aria-hidden="true">Example directory structure in Unix</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 1: Example directory structure in Unix</div><ul><li>Stored in files, can be read, but typically don’t<ul><li>System calls to access directories</li><li><code>open</code> / <code>creat</code> traverse the structure</li><li><code>mkdir</code> / <code>rmdir</code> add/remove entries</li><li><code>link</code> / <code>unlink</code><ul><li>Link existing file to a directory<ul><li>Not in <strong>FAT</strong>!</li></ul></li><li>Forms a <strong>DAG</strong></li></ul></li></ul></li><li>When can file be <strong>deleted</strong>?<ul><li>Maintain re-count of links to the file.</li><li>Delete after the last reference is gone.</li></ul></li><li>libc support<ul><li><code>DIR * opendir(const char *dirname)</code></li><li><code>struct dirent * readdir(DIR *dirstream)</code></li><li><code>int readdir_r(DIR *dirstream, struct dirent *entry, struct dirent **result)</code></li></ul></li></ul><h2 id="directory-internals">Directory Internals</h2><p>Early implementations simply stored linear lists of <code>&lt;file name, file number&gt;</code> in directory files.</p><ul><li>Free spaces are for new entries. Note: files can be added/deleted.</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FS_Design/Example%20directory%20internals%20in%20Unix.png" alt="Example directory internals in Unix"><figcaption aria-hidden="true">Example directory internals in Unix</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 1: Example directory internals in Unix</div><blockquote><p>Works fine in most cases. But when there are thousands of files in a directory. The access could be slow!</p></blockquote><p>Modern FSs (Linux XFS, Microsoft NTFS, and Oracle ZFS) organize directory’s contents as a <strong>tree</strong>.</p><ul><li><strong>B/B<sup>+</sup></strong> tree: fast lookup, insert, and removal.</li><li>Names are first <strong>hashed into a key</strong>, which is used to find the file number in the tree.</li></ul><h2 id="directory-structure-access-cost">Directory Structure Access Cost</h2><p>How many disk accesses to resolve <code>/my/book/count</code>?</p><ul><li>Read in file header for <strong>root</strong> (fixed spot on disk)</li><li>Read in first <strong>data block</strong> for root<ul><li>Table of file name/index pairs. Search linearly - ok since directories typically very small</li></ul></li><li>Read in file header for <code>my</code></li><li>Read in first data block for <code>my</code>; search for <code>book</code></li><li>Read in file header for <code>book</code></li><li>Read in first data block for <code>book</code>; search for <code>count</code></li><li>Read in file header for <code>count</code></li></ul><p><strong>Current working directory</strong>: per-address-space pointer to a directory (inode) used for resolving file names</p><ul><li>Allow user to specify relative filename instead of absolute path</li></ul><h2 id="hard-link">Hard Link</h2><ul><li>In command <code>link()</code><ul><li>It creates another name in the directory you are creating the link to, and refers it to the same inode number of the original file.</li><li>OS maintains a reference count for each inode</li></ul></li></ul><h2 id="soft-link">Soft Link</h2><ul><li>In <code>-s</code> command - soft (or symbolic) <code>link()</code><ul><li>A special type of file (as against regular file/dir) whose contents are the pathname of the linked-to file.</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IO Devices and Disk</title>
    <link href="/2025/12/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO_Devices_and_Disk/"/>
    <url>/2025/12/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO_Devices_and_Disk/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="io-devices">I/O Devices</h2><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO_Devices_and_Disk/The%20old%20architecture%20of%20computer%20IO.png" alt="The old architecture of computer IO"><figcaption aria-hidden="true">The old architecture of computer IO</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 1: The old architecture of computer IO</div><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO_Devices_and_Disk/The%20modern%20architecture%20of%20computer%20IO.png" alt="The modern architecture of computer IO"><figcaption aria-hidden="true">The modern architecture of computer IO</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 2: The modern architecture of computer IO</div><p>A simple IO device should have two parts:</p><ol type="1"><li>Interface.</li><li>Internal structure.<ul><li>Implementation specific and is responsible for implementing the abstraction the device presents to the system.</li><li>Complex devices could have their own CPU and memory as well.</li></ul></li></ol><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO_Devices_and_Disk/A%20simple%20IO%20device%20structure.png" alt="A simple IO device structure"><figcaption aria-hidden="true">A simple IO device structure</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 3: A simple IO device structure</div><ul><li>A <strong>status</strong> register, which can be read to see the current status of the device;</li><li>A <strong>command</strong> register, to tell the device to perform a certain task;</li><li>A <strong>data</strong> register to pass data to the device, or get data from the device.</li></ul><blockquote><p>An example code may be like:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">While (STATUS == BUSY)<br>; <span class="hljs-comment">// wait until device is not busy</span><br></code></pre></td></tr></table></figure><p>But polling is inefficient. We use interrupts instead of polling.</p></blockquote><h3 id="direct-memory-access">Direct Memory Access</h3><p>A <strong>DMA engine</strong> is a very specific device that can orchestrate transfers between devices and main memory without much CPU intervention.</p><blockquote><p>To transfer data to the device, for example, the OS would program the DMA engine by telling it where the data lives in memory, how much data to copy, and which device to send it to. At that point, the OS is done with the transfer and can proceed with other work.When the DMA is complete, the DMA controller raises an interrupt, and the OS thus knows the transfer is complete.</p></blockquote><p>There are two complementary ways for CPU to access I/O devices.</p><blockquote><p>I/O devices have their own registers (or memory).</p></blockquote><ol type="1"><li>Memory-mapped I/O (MMIO): let memory and devices share the physical address space<ul><li>Most widely adopted.</li><li>Shared address bus.</li></ul></li><li>Port-mapped I/O (PMIO), or isolated I/O: use specialized instructions to R/W I/O devices.<ul><li>In Intel: outb, outw, etc.</li></ul></li></ol><h2 id="storage-devices">Storage Devices</h2><blockquote><p>Second storage:</p><ul><li>Magnetic disk: hard disk, floppy disk, etc.</li><li>Optical disk: CD, DVD, blu-ray, etc.</li><li>Flash memory: pen drive, SD card, etc.</li></ul></blockquote><p>Storage devices:</p><ol type="1"><li>Magnetic disks<ul><li>Storage that rarely becomes corrupted.</li><li>Large capacity at low cost.</li><li>Block level random access.</li><li>Slow performance for random access.</li><li>Better performance for sequential access.</li></ul></li><li>Flash memory<ul><li>Storage that rarely becomes corrupted.</li><li>Capacity at intermediate cos (5 - 20x disk).</li><li>Block level random access.</li><li>Good performance for reads; worse for random writes.</li><li>Erasure requirement in large blocks.</li><li>Wear patterns issue.</li></ul></li></ol><h3 id="the-magnetic-disk">The Magnetic Disk</h3><ul><li>Sector: the unit of transfer.</li><li>Track: ring of sectors<ul><li>~ <span class="math inline">\(1\)</span> um (<span class="math inline">\(10^{-6}\)</span> m) wide.<ul><li>Resolution of human eye: <span class="math inline">\(50\)</span> um</li><li>Wavelength of lights is ~ <span class="math inline">\(0.5\)</span> um.</li></ul></li></ul></li><li>Cylinder: attached to movable arms to read data.<ul><li><span class="math inline">\(2\)</span> per each platter for each surface.</li></ul></li><li>Storage capacity <span class="math inline">\(=\)</span> (head #) <span class="math inline">\(\times\)</span> (cylinder #) <span class="math inline">\(\times\)</span> (sector #) <span class="math inline">\(\times\)</span> (sector size)<ul><li>Often <span class="math inline">\(512\)</span> bytes.</li></ul></li></ul><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO_Devices_and_Disk/Magnetic%20disk%20physical%20structure.png" alt="Magnetic disk physical structure"><figcaption aria-hidden="true">Magnetic disk physical structure</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 4: Magnetic disk physical structure</div><p>Cylinders: all the tracks under the head at a given point on all surface.</p><p>Read/write data is a three-stage process:</p><ul><li>Seek time: position the <strong>head/arm</strong> over the <strong>proper track</strong>.</li><li>Rotation latency: wait for <strong>desired sector</strong> to rotate under r/w head.</li><li>Transfer time: transfer <strong>a block of bits</strong> (sector) under r/w head.</li></ul><p>Disk latency <span class="math inline">\(=\)</span> queuing time + controller time + seek time + rotation time + transfer time.</p><blockquote><p>Request <span class="math inline">\(\to\)</span> Software Queue <span class="math inline">\(\to\)</span> Hardware Controller <span class="math inline">\(\to\)</span> Media Time <span class="math inline">\(\to\)</span> Result</p></blockquote><p>Here is a disk performance example. We assume that</p><ul><li>Ignoring queuing and controller times for now.</li><li>Avg seek time of <span class="math inline">\(5\)</span> ms.</li><li><span class="math inline">\(7200\)</span> RPM <span class="math inline">\(\Rightarrow\)</span> time for rotation: <span class="math inline">\(60000\)</span> (ms/min) / <span class="math inline">\(7200\)</span> (rev/min) <span class="math inline">\(\approx\)</span> <span class="math inline">\(8\)</span> ms.</li><li>Transfer rate of <span class="math inline">\(4\)</span> MByte/s, sector size of <span class="math inline">\(1\)</span> KByte <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(1024\)</span> bytes / <span class="math inline">\(4 \times 10^6\)</span> (bytes/s) <span class="math inline">\(= 256 \times 10^{-6}\)</span> sec <span class="math inline">\(\approx 0.26\)</span> ms.</li></ul><p>Read sector from random place on disk:</p><ul><li>Seek (<span class="math inline">\(5\)</span> ms) + Rot.Delay (<span class="math inline">\(4\)</span> ms) + Transfer (<span class="math inline">\(0.26\)</span> ms) <span class="math inline">\(= 9.26\)</span> ms.</li><li>Approx <span class="math inline">\(10\)</span> ms to fetch/put data: <span class="math inline">\(100\)</span> KByte/sec.</li></ul><p>Read sector from random place in same cylinder:</p><ul><li>Rot.Delay (<span class="math inline">\(4\)</span> ms) + Transfer (<span class="math inline">\(0.26\)</span> ms) <span class="math inline">\(= 4.26\)</span> ms.</li><li>Approx <span class="math inline">\(5\)</span> ms to fetch/put data: <span class="math inline">\(200\)</span> KByte/sec.</li></ul><p>Read next sector on same track:</p><ul><li>Transfer (<span class="math inline">\(0.26\)</span> ms): <span class="math inline">\(4\)</span> MByte/sec.</li></ul><h3 id="intelligence-in-the-controller">Intelligence in the Controller</h3><ul><li>Sectors contain sophisticated error correcting codes<ul><li>Disk head magnet has a field wider than track.</li><li>Hide corruptions due to neighboring track writes.</li></ul></li><li>Sector sparing<ul><li>Remap bad sectors transparently to spare sectors on the same surface.</li></ul></li><li>Slip sparing<ul><li>Remap all sectors (when there is a bad sector) to preserve sequential behavior.</li></ul></li><li>Track skewing<ul><li>Sector numbers offset from one track to the next, to allow for disk head movement for sequential ops.</li></ul></li></ul><h3 id="solid-state-disks-ssds">Solid State Disks (SSDs)</h3><blockquote><ul><li><p>1995 – Replace magnetic media with non-volatile memory (battery backed DRAM)</p></li><li><p>2009 – Use NAND Multi-Level Cell (2 or 3-bit/cell) flash memory</p><ul><li>Sector (4 KB page) addressable, but stores 4-64 ”pages” per memory block.</li><li>Trapped electrons distinguish between 1 and 0.</li></ul></li><li><p>No moving parts (no rotate/seek motors)</p><ul><li>Eliminates seek and rotational delay (0.1-0.2ms access time)</li><li>Very low power and lightweight</li><li>Limited “write cycles”</li></ul></li><li><p>Rapid advances in capacity and cost ever since!</p></li></ul></blockquote><p>SSD architecture</p><ul><li>Read <span class="math inline">\(4\)</span> KB page: <span class="math inline">\(\sim 25\)</span> <span class="math inline">\(\mu\)</span>s<ul><li>No seek or rotational latency.</li><li>Transfer time: transfer a <span class="math inline">\(4\)</span> KB page<ul><li>SATA: <span class="math inline">\(300\)</span> - <span class="math inline">\(600\)</span> MB/s <span class="math inline">\(\Rightarrow \sim 4 \times 10^3\)</span> b / <span class="math inline">\(400 \times 10^6\)</span> bps <span class="math inline">\(\Rightarrow 10\)</span> <span class="math inline">\(\mu\)</span>s</li></ul></li></ul></li><li>Writing data is complex (<span class="math inline">\(\sim 200\)</span> <span class="math inline">\(\mu\)</span>s - <span class="math inline">\(1.7\)</span> ms)<ul><li>Can only write empty pages in a block.</li><li>Erasing a block takes <span class="math inline">\(\sim 1.5\)</span> ms.</li><li>Controller maintains pool of empty blocks by coalescing used pages (read, erase, write), also reserves some <span class="math inline">\(\%\)</span> of capacity.</li></ul></li><li>Rule of thumb: writes <span class="math inline">\(10\)</span>x reads, erasure <span class="math inline">\(10\)</span>x writes</li></ul><p>SSD summary:</p><ul><li>Pros (compared to hard disk drives):<ul><li>Low latency, high throughput (eliminate seek/rotational delay).</li><li>No moving parts:<ul><li>Very light weight, low power, silent, very shock insensitive.</li></ul></li><li>Read at memory speeds (limited by controller and I/O bus)</li></ul></li><li>Cons<ul><li>Asymmetric block write performance: read pg/erase/write pg<ul><li>Controller garbage collection (GC) algorithms have major effect on performance</li></ul></li><li>Limited drive lifetime<ul><li><span class="math inline">\(1\)</span> - <span class="math inline">\(10\)</span> K writes/page for MLC NAND</li><li>Avg failure rate is <span class="math inline">\(6\)</span> years, life expectancy is <span class="math inline">\(9\)</span> – <span class="math inline">\(11\)</span> years</li></ul></li></ul></li></ul><h3 id="disk-scheduling">Disk Scheduling</h3><p>Disk can do only one request at a time. What order do you choose to do queued requests?</p><blockquote><p>The scheduling can be done in OS, firmware, or both.</p></blockquote><ul><li>FIFO<ul><li>Fair among requesters, but order of arrival may be to random spots on the disk <span class="math inline">\(\Rightarrow\)</span> Very long seeks.</li></ul></li><li>SSTF: shortest seek time first<ul><li>Pick the request that’s closest on the disk</li><li>Although called SSTF, today must include rotational delay in calculation, since rotation can be as long as seek</li><li>Con: SSTF good at reducing seeks, but may lead to starvation</li></ul></li><li>SCAN<ul><li>Implements an Elevator Algorithm: take the closest request in a fixed direction of travel (reversed at the end)</li><li>No starvation, but retains flavor of SSTF</li></ul></li><li>C-SCAN: circular-scan<ul><li>Only goes in one direction</li><li>Skips any requests on the way back</li><li>Fairer than SCAN, not biased towards pages in middle</li></ul></li></ul><blockquote><p>A simple read() lifecycle</p><ul><li>A process issues a syscall read()</li><li>OS moves the calling thread to a wait queue (state=WAITING)</li><li>OS uses memory-mapped I/O to tell the disk to read the requested data and set up DMA so the disk can place the data in kernel’s memory</li><li>Disk reads the data and DMAs it into main memory</li><li>Disk triggers an interrupt</li><li>OS’s interrupt handler copies the data from the kernel’s buffer into the process’s address space</li><li>OS moves the thread to the ready list</li><li>The thread is scheduled on CPU, and returns from the read()</li></ul></blockquote><h2 id="file-system-abstraction">File System Abstraction</h2><blockquote><p>How files and directories are organized in memory and disk.</p></blockquote><p><strong>Def</strong>. <strong>File system</strong> is a layer of OS that transforms block interface of disks (or other block devices) into <strong>files</strong>, <strong>directories</strong>, etc.</p><p>File system components:</p><ul><li><strong>Naming</strong>: interface to find files by name, not by blocks.</li><li><strong>Disk management</strong>: collecting disk blocks into files.</li><li><strong>Protection</strong>: layers to keep data secure.</li><li><strong>Reliability/Durability</strong>: keeping of files despite crashes, media failures, attacks, etc.</li></ul><h3 id="disk-management-policies">Disk Management Policies</h3><ul><li>Basic entities on a disk:<ul><li>Files: user-visible group of blocks arranged sequentially in logical space.</li><li>Directory: user-visible index mapping names to files.</li></ul></li><li>Access disks as linear array of sectors. Two options;<ul><li>Identify sectors as vectors [cylinder, surface, sector], sort in cylinder-major order<ul><li>Used in BIOS, but not in OSes anymore</li></ul></li><li>Logical Block Addressing: Every sector has integer address from zero up to max number of sectors</li><li>Controller translates from address <span class="math inline">\(\Rightarrow\)</span> physical position<ul><li>First case: OS/BIOS must deal with bad sectors</li><li>Second case: hardware shields OS from structure of disk</li></ul></li></ul></li><li>Need way to track free disk blocks<ul><li>Link free blocks together <span class="math inline">\(\Rightarrow\)</span> too slow today</li><li>Use bitmap to represent free space on disk</li></ul></li><li>Need way to structure files: file header<ul><li>Track which blocks belong at which offsets within the logical file str ucture</li><li>Optimize placement of files’ disk blocks to match access and usage patterns</li></ul></li></ul><h2 id="file">File</h2><ul><li>Named permanent storage</li><li>Contains<ul><li>Data<ul><li>Blocks on disk somewhere</li></ul></li><li>Metadata (attributes)<ul><li>Owner, size, last opened</li><li>Access rights<ul><li>R, W, X</li><li>Owner, group, other (in Unix systems)</li><li>Access control list in Windows system.</li></ul></li></ul></li></ul></li></ul><h2 id="directory">Directory</h2><ul><li>Basically a hierarchical structure</li><li>Each directory entry is a collection of<ul><li>Files</li><li>Directories<ul><li>A link to another entries</li></ul></li></ul></li><li>Each has a name and attributes.<ul><li>Files have data</li></ul></li><li>Links (hard links) make it a DAG, not just a tree<ul><li>Softlinks (aliases) are another name for an entry.</li></ul></li><li>Conventions of directory<ul><li>Root directory: “/”</li><li>Home directory: “~/cur_dir/file.txt”</li><li>Absolute path: “/home/mwx/cur_dir/file.txt”</li><li>Relative path: “file.txt”</li><li>Volume: a collection of physical storage resources that form a logical storage device. Could be a part of or many physical devices.</li><li>Mount: an operation that creates a mapping from some path in the existing file system to the root directory of the mounted volume’s file system</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Chapter 15: Query Processing</title>
    <link href="/2025/12/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Query_Processing/"/>
    <url>/2025/12/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Query_Processing/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>Def</strong>. <strong>Query processing</strong> refers to activities (DBMS) <strong>extracting</strong> data from DB, including</p><ul><li>translation of <strong>queries</strong> in DB language into <strong>expressions</strong> that can be used at the physical level of the system<ul><li>SQL statement into a initial <strong>relational algebra expression</strong>.</li></ul></li><li><strong>query-optimizing</strong> transformations. (see chapter 16)</li><li><strong>actual evaluation</strong> of queries.</li></ul><h2 id="overview">Overview</h2><ol type="1"><li>Parsing and translation<ul><li>Translate <strong>query</strong> into <strong>parser-tree</strong><ul><li>Parser <strong>checks</strong> syntax, <strong>verifies</strong> the correctness of the relations.</li><li>Parser <strong>replace</strong> the <strong>view</strong> with <strong>relations</strong> on which built.</li></ul></li><li>The <strong>parser-tree</strong> is then translated into <strong>relational algebra</strong>.</li></ul></li><li>Query optimization<ul><li>Choose the <strong>lowest cost plan</strong> among <strong>equivalent</strong> query evaluation plans.</li><li>The cost is <strong>estimated</strong> using statistical information in data dictionary.<ul><li>e.g. the number of tuples, size of tuples, etc.</li></ul></li></ul></li><li>Evaluation plan execution: the query-execution engine<ul><li>Takes an <strong>optimized query-evaluation</strong> plan.</li><li>Executes the <strong>optimized</strong> plan, and returns answers to the query.</li></ul></li></ol><div style="display: block; margin: 0 auto; width: fit-content"><pre><code class=" mermaid">flowchart TD   A[query] --&gt; |parser and translator| B[relational algebra expression]   B --&gt; |optimizer| C[execution plan]   C --&gt; |evaluation engine| D[query output]</code></pre></div><div style="text-align: center; font-style: italic;">Figure 1: Steps in query processing</div><p><strong>Def</strong>. The <strong>evaluation-plan</strong> is an annotated expression specifying the detailed evaluation strategy, such as <strong>index</strong>, <strong>evaluation algorithms</strong>, etc.</p><blockquote><p>A <strong>relation algebra</strong> expression has equivalent expressions.</p><ul><li><span class="math inline">\(\sigma_{\text{salary} &lt; 75000} (\Pi_{\text{salary}(\text{instructor})})\)</span> is equivalent to <span class="math inline">\(\Pi_{\text{salary}}(\sigma_{\text{salary} &lt; 75000}(\text{instructor}))\)</span>.</li></ul><p>Each <strong>relational algebra</strong> operation can be evaluated with algorithms.</p><ul><li>e.g. the select operation can be evaluated using <span class="math inline">\(A_1\)</span>, <span class="math inline">\(A_2\)</span>, <span class="math inline">\(\cdots\)</span>, algorithms.</li><li>e.g. nested-loop join, merge join, hash join operation.</li></ul></blockquote><h2 id="measures-of-query-costs">Measures of Query Costs</h2><p><strong>Def</strong>. <strong>Cost</strong> is measured as <strong>the total elapsed time</strong> for answering query.</p><ul><li>Factors contribute to time cost.<ul><li>disk access, network communication.</li></ul></li></ul><p><strong>Def</strong>. <strong>Disk access</strong> is the <strong>predominant</strong> cost, measured by</p><ol type="1"><li><p>number of seeks <span class="math inline">\(\times\)</span> average-seek-cost</p><ul><li>数据定位时间，需要访问的 records 在 DB file 中的位置。</li></ul></li><li><p>numebr of blocks read <span class="math inline">\(\times\)</span> average-block-read-cost</p></li><li><p>number of blocks written <span class="math inline">\(\times\)</span> average-block-write-cost</p><ul><li>cost to <strong>write</strong> is greater than cost to read.</li><li>data is <strong>read back</strong> after being written to be ensured successful.</li></ul></li></ol><blockquote><p>假设一次业务处理（如SQL 查询）总开销是100%，其中</p><ul><li>7% 不到，真正处理业务逻辑</li><li>34%，用于缓冲区管理如缓冲区的加载替换、地址转化等</li><li>14%，处理对于内存数据结构互斥访问加锁 Latching</li><li>16%，处理事务并发访问时，事务处理加锁 Locking</li><li>12%，处理日志 Logging</li><li>16%，用于对 B 树索引的处理</li></ul></blockquote><p>We suppose that</p><ol type="1"><li>number of blocks transfered from disk <span class="math inline">\(t_T\)</span>.<ul><li><span class="math inline">\(t_{T}\)</span> is time to transfer one block (transfer speed in disk).</li></ul></li><li>number of seeks <span class="math inline">\(t_{S}\)</span><ul><li><span class="math inline">\(t_{S}\)</span> is time for one seek including 寻道时间和旋转延迟</li></ul></li></ol><p>Time cost for <span class="math inline">\(b\)</span> blocks transfer plus <span class="math inline">\(s\)</span> seeks is <span class="math inline">\(b \times t_{T} + s \times t_{S}\)</span>.</p><p>Algorithms can <strong>reduce</strong> disk I/O by using extrs <strong>buffer space</strong></p><ul><li>Amount of real memory available to <strong>buffer</strong> depends on concurrent queries and processes, known <strong>during execution</strong>.<ul><li>using the <strong>worst case estimates</strong>.</li><li>assuming the <strong>minimum amount of memory</strong> needed for the operation.</li></ul></li><li>Required data may be <strong>buffer resident</strong> already, avoiding disk I/O, hard to take into account for cost estimation.</li></ul><h2 id="selection-operation">Selection Operation</h2><p>Selection operation <span class="math inline">\(\sigma\)</span> on relation <span class="math inline">\(r\)</span> by <strong>file scan</strong>.</p><ul><li>Locating and scanning the file in which <span class="math inline">\(r\)</span> is stored to retrieving <strong>the records</strong> satisfying the selection conditions.</li></ul><p><strong>File Scan Algorithms</strong>.</p><ul><li>Linear search/scan - <span class="math inline">\(A_1\)</span>.</li><li>Selections using <strong>indices</strong> - <span class="math inline">\(A_2\)</span>, <span class="math inline">\(A_3\)</span>, <span class="math inline">\(A_4\)</span>.</li><li>Selections involving <strong>comparisons</strong> - <span class="math inline">\(A_5\)</span>, <span class="math inline">\(A_6\)</span>.</li><li>Complex selections - <span class="math inline">\(A_7\)</span>, <span class="math inline">\(A_8\)</span>, <span class="math inline">\(A_9\)</span>, <span class="math inline">\(A_{10}\)</span></li></ul><ol type="1"><li><span class="math inline">\(A_1\)</span> (linear search/scan)<ul><li>Scan each block and test all records to see whether satisfy selection condition.</li><li>Cost = <span class="math inline">\(b_r\)</span> block transfers <span class="math inline">\(+ 1\)</span> seek = <span class="math inline">\(b_r \times t_{T} + t_{S}\)</span></li><li>If selection is on <strong>the key attribute</strong>, it can stop on finding record equality, average case:</li><li>Cost = <span class="math inline">\((b_{r} / 2)\)</span> block transfers <span class="math inline">\(+ 1\)</span> seek = <span class="math inline">\((b_r / 2) \times t_{T} + t_{S}\)</span> &gt; Linear search can be applied regardless of selection condition, ordering of records, availability of indices, suitable for seeking on a relational table organized as the <strong>heap file</strong>, or seeking on a <strong>non-index</strong> attribute (non-search-key attribute) in a relational table organized as the <strong>sequential file</strong>, e.g. B/B<sup>+</sup>-tree file.</li></ul></li><li><span class="math inline">\(A_2\)</span> (clustering/primary index, B<sup>+</sup>-tree index, equality on key )<ul><li>Index scan/seek - search algorithms with <strong>an index</strong>.<ul><li>Selection condition on <strong>search-key</strong> of index.</li><li>With key-attributes or non-key-attributes.</li></ul></li><li>Retrieve <strong>a single</strong> record, using B<sup>+</sup>-tree as the clustering/primary index.</li><li>Cost <span class="math inline">\(= (h_i + 1) \times (t_{T} + t_{S})\)</span><ul><li><span class="math inline">\(h_{i}\)</span>: height of the tree.</li><li><span class="math inline">\(t_{T}\)</span>: time to transfer one block.</li><li><span class="math inline">\(t_{S}\)</span>: time for one seek.</li></ul></li></ul></li><li><span class="math inline">\(A_3\)</span> (primary/clustering index, B<sup>+</sup>-tree index, equality on non-key)<ul><li>Retrieve <strong>mutiple</strong> records that satisfy select conditions.<ul><li>e.g. Seek on <strong>non-key attribute</strong> branch_name in account and branch_name = ‘Perryride’.</li><li>Records are located on consecutive blocks.</li><li>Cost <span class="math inline">\(= h_i \times (t_{T} + t_{S}) + t_{S} + t_{T} \times b\)</span>.<ul><li>$b = $ number of blocks containing matching records.</li></ul></li></ul></li></ul></li><li><span class="math inline">\(A_4\)</span> (secondary index, B<sup>+</sup>-tree index, equality on key)<ul><li>If equality condition is <strong>on key</strong>, only a single record is retrieved.<ul><li>Cost <span class="math inline">\(= (h_i + 1) \times (t_{T} + t_{S})\)</span>.</li></ul></li><li>If equality condition is <strong>on non-key</strong>, mutiple records (<span class="math inline">\(n\)</span> records) are retrieved.</li><li>Each of <span class="math inline">\(n\)</span> matching records may be resident on a different block, which may result in on I/O operation per retrieved record.</li><li>Cost <span class="math inline">\(= (h_i + n) \times (t_T + t_S)\)</span>.</li></ul></li><li><span class="math inline">\(A_5\)</span> (clustering/primary index, B<sup>+</sup>tree index, comparison). (sorted by A)<ul><li>For <span class="math inline">\(\sigma_{A \geq V} (r)\)</span> use <strong>index</strong> to find the <strong>first</strong> tuple <span class="math inline">\(\geq v\)</span> and scan relation sequentially.</li><li>For <span class="math inline">\(\sigma_{A \leq V} (r)\)</span> just scan relation <strong>sequentially</strong> till the first tuple <span class="math inline">\(&gt; v\)</span>; do not use index.</li><li>Cost <span class="math inline">\(= h_i \times (t_{T} + t_{S}) + t_{S} + t_{T} \times b\)</span>.<ul><li><span class="math inline">\(b\)</span>: number of blocks containing matching records.</li></ul></li></ul></li><li><span class="math inline">\(A_6\)</span> (secondary index, B<sup>+</sup>tree index, comparison)<ul><li>For <span class="math inline">\(\sigma_{A \geq V} (r)\)</span> use <strong>index</strong> to find <strong>index entry</strong> <span class="math inline">\(\geq v\)</span> and scan index sequentially, to <strong>find pointers</strong> to records.</li><li>For <span class="math inline">\(\sigma_{A \leq V} (r)\)</span> scan <strong>leaf page</strong> of index finding <strong>pointers</strong> to records, till first entry <span class="math inline">\(&gt; v\)</span>.</li><li>Cost <span class="math inline">\(= (h_i + n) \times (t_{T} + t_{S})\)</span></li><li>In either case, retrieve records that are pointed.<ul><li>Requires <strong>an</strong> I/O for <strong>each</strong> record.</li><li><strong>Linear file scan</strong> may be cheaper.</li></ul></li></ul></li><li><span class="math inline">\(A_7\)</span> (conjunctive selection using one index)<ul><li>Select a combination of <span class="math inline">\(\theta_i\)</span> and algorithms <span class="math inline">\(A_1\)</span> through <span class="math inline">\(A_6\)</span> taht results in the least cost for <span class="math inline">\(\sigma_{\theta i} (r)\)</span>.</li><li>Test other conditions on tuple after fetching it into memory buffer.</li></ul></li><li><span class="math inline">\(A_8\)</span> (conjunctive selection using composite index)<ul><li>Use appropriate composite (mutiple-key) index if available.</li></ul></li><li><span class="math inline">\(A_9\)</span> (conjunctive selection by intersection of identifiers)<ul><li>Requires indices with record pointers.</li><li>Use corresponding <strong>index</strong> for each condition, take <strong>intersection</strong> of all the obtained sets of record <strong>pointers</strong>.</li><li>If some conditions <strong>do not have appropriate indices</strong>, apply test in memory.<ul><li>Step 1. 利用定义在每个查询条件 <span class="math inline">\(\theta_{i}\)</span> 的查询属性上的索引，查找满足 <span class="math inline">\(\theta_{i}\)</span> 的元组集合</li><li>Step 2. 取各个元组集合的交集</li></ul></li></ul></li><li><span class="math inline">\(A_{10}\)</span> (disjunctive selection by union of identifiers)<ul><li>Applicable if conditions have <strong>available indices</strong>, otherwise use <strong>linear scan</strong>.</li><li>Use corresponding index for <strong>each condition</strong></li><li>Take <strong>union</strong> of all the obtained sets of record pointers.</li><li>Fetch records from file.</li><li>Negation: <span class="math inline">\(\sigma_{\lnot \theta} (r)\)</span><ul><li>Use <strong>linear scan on file</strong>.</li><li>If very few records satisfy <span class="math inline">\(\not \theta\)</span>, and an index is applicable to <span class="math inline">\(\theta\)</span> (find satisfying records using index and fetch from file).</li></ul></li></ul></li></ol><h2 id="sorting">Sorting</h2><p>Let <span class="math inline">\(M\)</span> denote memory size.</p><ol type="1"><li>Create sorted runs<ul><li>Let <span class="math inline">\(i\)</span> be <span class="math inline">\(0\)</span> initially. Repeatedly do the following till the end of the relation:<ul><li>Read <span class="math inline">\(M\)</span> blocks of relation into memory.</li><li>Sorted the in-memory blocks.</li><li>Write sorted data to run <span class="math inline">\(R_{i}\)</span>;</li></ul></li><li>Increment <span class="math inline">\(i\)</span>. Let the final value of <span class="math inline">\(i\)</span> be <span class="math inline">\(N\)</span>.</li></ul></li><li>Merge the runs.</li></ol><h2 id="evaluation-of-expressions">Evaluation of Expressions</h2><p>Evaluate an <strong>expression</strong> containing multiple evaluation primitives</p><ul><li>Key: how to process intermediate computing results.</li></ul><p><strong>Materialization</strong> and <strong>pipeline</strong> are used for expression evaluation.</p><ul><li><strong>Materialization</strong>: generate results of an expression whose <strong>inputs are relations</strong> or are already computed, materialize (store) it on disk. Repeat.</li><li><strong>Pipelining</strong>: <strong>pass on tuples to parent operations</strong> even as an operation is being executed.</li></ul><h3 id="materialization">Materialization</h3><p>Principles:</p><ul><li>Start from the lowest-level (i.e. at the bottom of the tree) evaluate one operation at a time.</li><li>The results of each evaluation (i.e. intermediate computing results) are stored in <strong>temporal relations</strong> on the disk for subsequent evaluation. (serial evaluating)</li></ul><p>Cost of <strong>writing results to disk and reading them back</strong> can be quite high.</p><ul><li>Overall cost <span class="math inline">\(=\)</span> sum of costs of individual operations <span class="math inline">\(+\)</span> cost of writing intermediate results to disk.</li></ul><h3 id="pipelined">Pipelined</h3><p>Principles of pipelined evaluation: evaluate several operations simultaneously in a pipeline, with the results of one operation passed to the next, without need to store temporary relations in disk. (parallel evaluating)</p><p>Much cheaper than materialization: no need to store a temporary relation to disk. Instead, pass tuples directly to the join; similarly, don’t store result of join, pass tuples directly to projection.</p>]]></content>
    
    
    <categories>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Readers, Writers and Deadlock</title>
    <link href="/2025/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Readers_Writers_and_Deadlock/"/>
    <url>/2025/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Readers_Writers_and_Deadlock/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="readerswriters-problem">Readers/Writers Problem</h2><p>Motivation: Consider a shared database.</p><ul><li>Two classes of users:<ul><li>Readers - never modify database.</li><li>Writers - read and modify database.</li></ul></li></ul><blockquote><p>Is using a single lock on the whole database sufficient?</p><ul><li>Like to have many readers at the same time.</li><li>Only one writer at a time.</li></ul></blockquote><h2 id="basic-readerswriters-solution">Basic Readers/Writers Solution</h2><ul><li>Correctness Constraints:<ul><li>Readers can access database when no writers.</li><li>Writers can access database when no readers or writers.</li><li>Only <strong>one thread</strong> manipulates <strong>state variables</strong> at a time.</li></ul></li><li>Basic structure of a solution:<ul><li>Reader()<ul><li>Wait until no writers</li><li>Access database</li><li>Check out - wake up a waiting writer</li></ul></li><li>Writer()<ul><li>Wait until no active readers or writers</li><li>Access database</li><li>Check out - wake up waiting readers or writers</li></ul></li><li>State variables (protected by a lock called “lock”)<ul><li>int AR: Number of active readers; initially = 0</li><li>int WR: Number of waiting readers; initially = 0</li><li>int AW: Number of active writers; initially = 0</li><li>int WW: Number of waiting readers; initially = 0</li><li>Condition okToRead = NIL</li><li>Condition okToWrite = NIL</li></ul></li></ul></li></ul><p>For reader</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">Reader() &#123;<br>    lock.Acquire();<br>    <span class="hljs-keyword">while</span> ((AW + WW) &gt; <span class="hljs-number">0</span>) &#123;<br>        WR++;<br>        okToRead.wait(&amp;lock)<br>        WR--;<br>    &#125;<br>    AR++;<br>    lock.Release();<br><br>    AccessDatabase();<br><br>    lock.Acquire();<br>    AR--;<br>    <span class="hljs-keyword">if</span> (AR == <span class="hljs-number">0</span> &amp;&amp; WW &gt; <span class="hljs-number">0</span>) okToWriter.signal();<br>    lock.Release();<br>&#125;<br></code></pre></td></tr></table></figure><p>For writer</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">Writer() &#123;<br>    lock.Acquire();<br>    <span class="hljs-keyword">while</span> ((AR + AW) &gt; <span class="hljs-number">0</span>) &#123;<br>        WW++;<br>        okToWrite.wait(&amp;lock)<br>        WW--<br>    &#125;<br>    AW++;<br>    lock.Release();<br><br>    AccessDatabase();<br><br>    lock.Acquire();<br>    AW--;<br>    <span class="hljs-keyword">if</span> (WW &gt; <span class="hljs-number">0</span>) &#123;<br>        okToWrite.signal();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        okToRead.broadcast();<br>    &#125;<br><br>    lock.Release();<br>&#125;<br></code></pre></td></tr></table></figure><p>Now we wrad the code into a RWlock class.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RWLock</span> &#123;</span><br>    Lock lock;<br>    CV canRead; <span class="hljs-comment">// okToRead</span><br>    CV canWrite; <span class="hljs-comment">// okToWrite</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">RWLock::startRead</span><span class="hljs-params">()</span> &#123;<br>    lock.Acquire()<br>    WR++;<br>    <span class="hljs-keyword">while</span> ((AW + WW) &gt; <span class="hljs-number">0</span>) &#123;<br>        canRead.wait(&amp;lock);<br>    &#125;<br>    WR--;<br>    AR++;<br>    lock.Release();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">RWLock::doneRead</span><span class="hljs-params">()</span> &#123;<br>    lock.Acquire()<br>    AR--;<br>    <span class="hljs-keyword">if</span> (AR == <span class="hljs-number">0</span> &amp;&amp; WW &gt; <span class="hljs-number">0</span>) canWrite.signal();<br>    lock.Release();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">RWLock::startWrite</span><span class="hljs-params">()</span> &#123;<br>    lock.Acquire();<br>    WW++;<br>    <span class="hljs-keyword">while</span> ((AW + AR) &gt; <span class="hljs-number">0</span>) &#123;<br>        canWrite.wait(&amp;lock);<br>    &#125;<br>    WW--;<br>    AW++;<br>    lock.Release();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">RWLock::doneWrite</span><span class="hljs-params">()</span> &#123;<br>    lock.Acquire();<br>    AW--;<br>    assert(AW == <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (WW &gt; <span class="hljs-number">0</span>) canWrite.signal();<br>    <span class="hljs-keyword">else</span> canRead.broadcast();<br>    lock.Release();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="deadlock">Deadlock</h2><p><strong>Def</strong>. Deadlock A cycle of waiting among a set of threads, where each thread waits for some other thread in the cycle to take some action.</p><blockquote><p>If a deadlock occurs, it can be resolved if one thread backs up preempt resources and rollback.</p><p>Deadlocks occur with multiple resources. Means you cannot decompose the problem. Cannot solve deadlock for each resource independently.</p></blockquote><h3 id="four-requirements-for-deadlock">Four Requirements for Deadlock</h3><ol type="1"><li>Mutual exclusion<ul><li>Only one thread at a time can use a resource.</li></ul></li><li>Hold and wait<ul><li>Thread holding at least one resource is waiting to acquire additional resources held by other thread.</li></ul></li><li>No preemption<ul><li>Resources are released only voluntarily by the thread holding the resource, after thread is finished with it.</li></ul></li><li>Circular wait<ul><li>There exists a set <span class="math inline">\(\{T_1, T_2, \cdots, T_n\}\)</span> of waiting threads.</li><li><span class="math inline">\(T_i\)</span> is waiting for a resource that is held by <span class="math inline">\(T_{i + 1}\)</span>.</li></ul></li></ol><h3 id="methods-for-handling-deadlocks">Methods for Handling Deadlocks</h3><ol type="1"><li>Allow system to enter deadlock and then recover<ul><li><strong>Requires deadlock detection algorithm</strong>.</li><li>Som technique for forcibly preempting resources and/or terminating tasks.</li></ul></li><li>Ensure that system will <strong>never</strong> enter a deadlock.<ul><li>Need to <strong>monitor</strong> all lock acquisitions.</li><li>Selectively deny those that <strong>might</strong> lead to deadlock.</li></ul></li><li>Ignore the problem and pretend that deadlocks never occur in the system.<ul><li>Used by most operating systems, including UNIX.</li></ul></li></ol><h2 id="preventing-deadlocks">Preventing Deadlocks</h2><h3 id="removing-circular-wait">Removing circular wait</h3><p>Just make sure all locks acquired in the same order.</p><ul><li>Total ordering.</li><li>Partial ordering.</li></ul><blockquote><p>e.g. We can enforce lock ordering by lock address.</p></blockquote><h3 id="preventing-hold-and-wait">Preventing Hold and Wait</h3><p>Just use another lock to lock the locks.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">Lock globalLock; <span class="hljs-comment">// 额外的全局锁</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_func</span><span class="hljs-params">()</span> &#123;<br>    globalLock.acquire();      <span class="hljs-comment">// 先获得全局锁</span><br>    L1.acquire();              <span class="hljs-comment">// 再获得所有需要的资源锁</span><br>    L2.acquire();<br>    globalLock.release();      <span class="hljs-comment">// 释放全局锁</span><br><br>    <span class="hljs-comment">// 临界区操作</span><br>    <span class="hljs-comment">// ...</span><br><br>    L2.release();<br>    L1.release();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Cons: must know which locks will be used beforehand; concurrency decreased.</p></blockquote><h3 id="preventing-mutual-exclusion">Preventing Mutual Exclusion</h3><p>Design lock-free (or wait-free) data structures and algorithms using <strong>powerful hardware instructions</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">CompareAndSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> *address, <span class="hljs-type">int</span> expected, <span class="hljs-type">int</span> new)</span> &#123;<br>    <span class="hljs-keyword">if</span> (*address == expected) &#123;<br>        *address = new;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// success</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// failure</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Using <code>CompareAndSwap</code> to implement “increment a value by <span class="math inline">\(n\)</span>”.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">AtomicIncrement</span><span class="hljs-params">(<span class="hljs-type">int</span> *value, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-type">int</span> old = *value;<br>    &#125; <span class="hljs-keyword">while</span> (CompareAndSwap (value, old, old + n) == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Using <code>CompareAndSwap</code> to implement “insert an element to a list head”.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// without deadlock prevention</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-type">node_t</span> *n = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>));<br>    assert(n != <span class="hljs-literal">NULL</span>);<br>    n -&gt; value = value;<br>    n -&gt; next = head;<br>    head = n;<br>&#125;<br><br><span class="hljs-comment">// with deadlock prevention</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-type">node_t</span> *n = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">node_t</span>));<br>    assert(n != <span class="hljs-literal">NULL</span>);<br>    n -&gt; value = value;<br>    <span class="hljs-keyword">do</span> &#123;<br>        n -&gt; next = head;<br>    &#125; <span class="hljs-keyword">while</span> (CompareAndSwap(&amp;head, n -&gt; next, n) == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Cons: too complicated; hardware support needed (possibly performance degradation).</p></blockquote><h3 id="smart-scheduling">Smart Scheduling</h3><p><strong>Def</strong>. Resource-Allocation Graph</p><ul><li>System Model<ul><li>A set of Threads <span class="math inline">\(\{T_1, T_2, \cdots, T_n\}\)</span>.</li><li>Resource types <span class="math inline">\(\{R_1, R_2, \cdots, R_m\}\)</span><ul><li>CPU cycles, memory space, I/O devices.</li></ul></li><li>Each resource type <span class="math inline">\(R_i\)</span> has <span class="math inline">\(W_i\)</span> instances.</li><li>Each thread utilizes a resource as follows:<ul><li>Request() / Use() / Release().</li></ul></li></ul></li><li>Resource-Allocation Graph:<ul><li>V is partitioned into two types:<ul><li><span class="math inline">\(T = \{T_1, T_2, \cdots, T_n\}\)</span>, the set threads in the system.</li><li><span class="math inline">\(R = \{R_1, R_2, \cdots, R_m\}\)</span>, the set of resource types in system.</li></ul></li><li>Request edge - directed edge <span class="math inline">\(T_i \to R_j\)</span>.</li><li>Assignment edge - directed edge <span class="math inline">\(R_{j} \to T_{i}\)</span>.</li></ul></li></ul><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Readers_Writers_and_Deadlock/Resource%20Allocation%20Graph%20Examples.png" alt="Resource Allocation Graph Examples"><figcaption aria-hidden="true">Resource Allocation Graph Examples</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 1: Resource Allocation Graph Examples</div><p><strong>Algorithm - Deadlock Detection</strong>.</p><ul><li>Only one of each type of resource <span class="math inline">\(\Rightarrow\)</span> <strong>look for loops</strong>.</li><li>More General Deadlock Detection Algorithm<ul><li><p>Let [X] represent an m-ary vector of non-negative integers (quantities of resources of each type):</p><ul><li></li><li></li><li></li></ul></li><li><p>See if tasks can eventually terminate on their own</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pseudo">[Avail] = [FreeResources]<br>Add all nodes to UNFINISHED<br>do &#123;<br>    done = true<br>    Foreach node in UNFINISHED &#123;<br>        if ([Request_&#123;node&#125;] &lt;= [Avail]) &#123;<br>            remove node from UNFINISHED<br>            [Avail] = [Avail] + [Alloc_&#123;node&#125;]<br>            done = false<br>        &#125;<br>    &#125;<br>&#125; until (done)<br></code></pre></td></tr></table></figure></li><li><p>Nodes left in UNFINISHED <span class="math inline">\(\Rightarrow\)</span> deadlocked.</p></li></ul></li></ul><p>What to do when detect deadlock?</p><ul><li><p>Terminate thread, force it to give up resources.</p><ul><li>But, not always possible - killing a thread holding a mutex leaves world inconsistent.</li></ul></li><li><p>Preempt resources without killing off thread</p><ul><li>Take away resources from thread temporarily.</li><li>Doesn’t always fit with semantics of computation.</li></ul></li><li><p>Roll back actions of deadlock threads</p></li><li><p>Many operating systems use other options.</p></li></ul><h3 id="bankers-algorithm">Bankers Algorithm</h3><blockquote><ul><li><p>What if you don’t know the order/amount of requests ahead of time?</p></li><li><p>Must assume some worst-case “max” resource needed by each process.</p></li><li><p>Toward right idea.</p><ul><li>State maximum resource needs in advance.</li><li>Allow particular thread to proceed if: (available resources - #requested) <span class="math inline">\(\geq\)</span> max remaining that might be needed by any thread.</li><li>Invariant: At all times, every request would succeed.</li></ul></li></ul></blockquote><p><strong>Algorithm - Bankers Algorithm</strong>.</p><ul><li><p>Invariant: At all times, there exists some order of requests that would succeed.</p></li><li><p>Key ideas:</p><ul><li>A thread states its maximum resource requirements, but acquires and releases resources incrementally as the thread executes.</li><li>The runtime system delays granting some requests to ensure that the system never deadlock.</li></ul></li></ul><blockquote><ul><li>Safe state: For any possible <strong>sequence of resource requests</strong>, there is at least one safe <strong>sequence of processing</strong> the requests that eventually succeeds in granting all pending and future requests.<ul><li>A system in a safe state controls its own destiny: for any workload, it can avoid deadlock by delaying the processing of some requests.</li></ul></li><li>Unsafe state: There is at least one sequence of future resource requests that leads to deadlock no matter what processing order is tried.<ul><li>An unsafe state does not always lead to deadlock.</li><li>However, as long as the system remains in an unsafe state, a bad workload or unlucky scheduling of requests can force it to deadlock.</li></ul></li><li>Deadlocked state: The system has at least one deadlock.</li></ul></blockquote><p>The banker’s algorithm delays any request that takes it from a safe to an unsafe state.</p><p>How to implement this ?</p><ul><li>Allocate resources dynamically.<ul><li>Evaluate each request and grant if some ordering threads is still deadlock free afterward.</li><li>Use <strong>deadlock detection algorithm</strong> presented ealier.<ul><li>But assume each process needs “max” resources to finish.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pseudo">[Avail] = [FreeResources]<br>Add all nodes to UNFINISHED<br>do &#123;<br>    done = true<br>    Foreach node in UNFINISHED &#123;<br>        if ([MAX_&#123;node&#125;] - [Alloc_&#123;node&#125;] &lt;= [Avail]) &#123;<br>            remove node from UNFINISHED<br>            [Avail] = [Avail] + [Alloc_&#123;node&#125;]<br>            done = false<br>        &#125;<br>    &#125;<br>&#125; until (done)<br></code></pre></td></tr></table></figure></li></ul></li></ul><blockquote><ul><li><p>Keep system in a safe state, i.e. there exists a sequence <span class="math inline">\(\{T_1, T_2, \cdots, T_n\}\)</span> with <span class="math inline">\(T_{1}\)</span> requesting all remaining resources, finishing, then <span class="math inline">\(T_2\)</span> requesting all remaining resources, etc….</p></li><li><p>vs. “Require all before starting”, the Banker’s algorithm allows the sum of maximum resource needs of all current threads to be greater than total resources.</p></li></ul></blockquote><p><strong>Example</strong>. Page Allocation with the Banker’s Algorithm Suppose we have a system with <span class="math inline">\(8\)</span> pages of memory and three processors: A, B, and C, which need <span class="math inline">\(4\)</span>, <span class="math inline">\(5\)</span> and <span class="math inline">\(5\)</span> pages to complete, respectively.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">Process</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th><th style="text-align: center;">8</th><th style="text-align: center;">9</th><th style="text-align: center;">10</th><th style="text-align: center;">11</th><th style="text-align: center;">12</th><th style="text-align: center;">13</th><th style="text-align: center;">14</th><th style="text-align: center;">15</th><th style="text-align: center;">16</th><th style="text-align: center;">17</th><th style="text-align: center;">18</th><th style="text-align: center;">19</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">4</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">B</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">wait</td><td style="text-align: center;">wait</td><td style="text-align: center;">wait</td><td style="text-align: center;">wait</td><td style="text-align: center;">3</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">wait</td><td style="text-align: center;">wait</td><td style="text-align: center;">wait</td><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">wait</td><td style="text-align: center;">wait</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">Total</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td><td style="text-align: center;">8</td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td><td style="text-align: center;">8</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td><td style="text-align: center;">0</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 1: Banker’s Algorithm Process</div>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Chapter 14: Indexing</title>
    <link href="/2025/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Indexing/"/>
    <url>/2025/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Indexing/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="basic-concepts">Basic Concepts</h2><p><strong>Def</strong>. <strong>Search key</strong> is an <strong>attribute</strong> or a set of attributes used to look up records.</p><blockquote><p>Why we need indexing mechanisms. We create a DB indexed file <strong>instructor</strong> and its index file. The file <strong>instructor</strong> is logically a sequential file, but its records may be stored <strong>non-contiguously</strong> or <strong>non-ordered</strong> on disk.</p></blockquote><p><strong>Def</strong>. An <strong>index file</strong> consists of records (called <strong>index entries</strong>) of the <strong>form</strong> below.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">search key</th><th style="text-align: center;">pointer</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">…</td><td style="text-align: center;">…</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 1: index file form</div><p><strong>Def</strong>. <strong>Indexing</strong> is the process of mapping from <strong>search key</strong> to <strong>storage locations</strong> of the <strong>records</strong> in disk (search key <span class="math inline">\(\to\)</span> storage locations).</p><p>DBS files with <strong>indexing mechanism</strong> include:</p><ul><li><strong>Indexed file</strong>, in which <strong>data records</strong> are stored.</li><li><strong>Index file</strong>, in which <strong>index entries</strong> are included.</li></ul><blockquote><p><strong>Review</strong>: The <strong>indexed file</strong> can be organized (sequential file, heap file, hash file, clustering file).</p></blockquote><p><strong>Def</strong>. <strong>Ordered indices</strong>, a kind of <strong>indexing</strong>. In ordered indices, search key and address of the records are stored in <strong>sorted order</strong>.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">search key</th><th style="text-align: center;">pointer</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(S_1\)</span></td><td style="text-align: center;">…</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(S_2\)</span></td><td style="text-align: center;">…</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(S_3\)</span></td><td style="text-align: center;">…</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(S_4\)</span></td><td style="text-align: center;">…</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 2: example index file with ordered indices</div><p><strong>Def</strong>. <strong>Hash Indices</strong> <strong>Hash function</strong> map search key to the address of the records.</p><ul><li>The records are stored in <strong>buckets</strong>.</li><li>The <strong>number</strong> of buckets is the address of the records.</li><li>Determined by hash function.</li></ul><blockquote><p>Ordered indexing Vs Hashing</p><p>Expected queries:</p><ul><li>Hashing is better at retrieving records having a specified value of the key.</li><li>If range queries are common, the ordered indices are to be preferred. (Hashing index does not support range query)</li></ul></blockquote><h3 id="the-primaryclustering-index">*The Primary/Clustering Index</h3><p><strong>Def</strong>. The <strong>Primary/Clustering Index</strong> (in the index file)</p><ul><li>The search key of the index specifies the sequential order of the indexed file.</li><li>The indexed file is a <strong>sequential</strong> file.</li></ul><blockquote><p>聚集索引：索引文件搜索键所规定顺序与被索引文件纪录顺序一致。</p><p>主索引：</p><ul><li>建立在<strong>主键</strong>的索引：当表定义了主键后，DBMS 自动为该表在主键上建立<strong>聚集索引</strong>，该索引又是<strong>主索引</strong>。</li><li>主索引一定是聚集索引，但聚集索引不一定是主索引。</li><li><span class="math inline">\(1\)</span> 个表上只能建立 <span class="math inline">\(1\)</span> 个聚集索引，也只能有 <span class="math inline">\(1\)</span> 个主索引。</li><li>如果表没有定义主键，不会有主索引；但可以为该表建立聚集索引。</li></ul><p>在<strong>没有定义主键</strong>的关系表中插入数据：在关系表所在数据库文件中，各个记录顺序一般是无序的，取决于数据插入顺序（heap 文件）。但在<strong>有主键</strong>的关系表中插入数据：数据库文件是有序的，按照主键顺序排列。</p></blockquote><p>Example: the data file instructor is stored in order of ID (the primary key).</p><ul><li>sequential scanning of <strong>ID</strong> of the <strong>first six</strong> tuples/records, i.e. 10101-33456, will fetch block <span class="math inline">\(n\)</span> and block <span class="math inline">\(n + 1\)</span></li><li>sequential scanning on <strong>salary</strong> of the <strong>first six</strong> tuples/records, i.e. 40000-75000, will fetch block <span class="math inline">\(n\)</span>, <span class="math inline">\(n + 1\)</span>, <span class="math inline">\(n + 2\)</span>, <span class="math inline">\(n + 3\)</span></li></ul><h3 id="the-secondarynon-clustering-index">*The Secondary/Non-Clustering Index</h3><p><strong>Def</strong>. The <strong>Secondary/Non-Clustering</strong> Index</p><ul><li>A search key specifies an order <strong>different</strong> from the sequential order of the file.</li><li>Secondary indices have to be <strong>dense indices</strong></li></ul><blockquote><p>Index record points to a <strong>bucket</strong> that contains pointers to the actual records with that particular search key value.</p></blockquote><p><strong>Def</strong>. <strong>Index-Sequential File</strong> Ordered sequential file with a primary/clustering index on the search key.</p><blockquote><ol type="1"><li>Sequential scan using <strong>primary index</strong> is efficient.</li><li>Sequential scan using <strong>secondary index</strong> is expensive. This is because each record access may fetch a <strong>new block</strong> from disk.</li></ol></blockquote><p><strong>Example</strong>.</p><ul><li>A DB file is made up of the <span class="math inline">\(128\)</span>-byte fix-sized <strong>logical records</strong>. It is stored on disk in unit of <strong>block</strong> that is of <span class="math inline">\(1024\)</span>-byte in size.</li><li>The size of the file is <span class="math inline">\(10240\)</span>-byte.</li><li>Physical I/O operations transfer data on disk into an DBMS <strong>buffer</strong> in main memory, in terms of <span class="math inline">\(1024\)</span>-byte <strong>block</strong>.</li></ul><p>If a transaction issues read requests in a <strong>sequential access manner</strong>, what is the percentage of read requests that result in I/O operations?</p><ul><li>The file contains <span class="math inline">\(10240 / 128 = 80\)</span> records.</li><li>A block holds <span class="math inline">\(1024 / 128 = 8\)</span> records.</li><li>The file is stored in <span class="math inline">\(10240 / 1024 = 10\)</span> blocks.</li><li>Percentage <span class="math inline">\(= 10 / 80 = 12.5 \%\)</span></li></ul><blockquote><p>按照记录存储顺序，依次访问每个记录时，每个记录的访问都对应一个 I/O 请求。每次 I/O 访问，DBMS 将 1 个 block 中的 8 个记录读取到内存 buffer 中，即当后续再访问这 8 个记录时，直接从 buffer 中读，无需访问 disk，即无需 I/O 访问。每 8 个 I/O 请求导致 1 个实际 I/O 操作。</p></blockquote><h3 id="dense-and-sparse-indices">Dense and Sparse Indices</h3><p><strong>Def</strong>. <strong>Dense Index</strong></p><ul><li>The index record appears for <strong>every</strong> search key value in the <strong>indexed file</strong>.</li><li>Each value of search key corresponds to an <strong>index entry</strong> in the <strong>index file</strong>.</li></ul><p>For dense primary index, the index record contains the search key value.</p><ul><li><strong>A pointer to the first record</strong> according to that search key value.</li><li>The rest of the records with the <strong>same</strong> search key value would be stored <strong>sequentially</strong> after the first record.</li></ul><p><strong>Def</strong>. <strong>Sparse Index</strong> Index file contains index entries for <strong>only some</strong> search key values.</p><p>For sparse index, to locate a file record with the search key value <span class="math inline">\(K\)</span>.</p><ul><li>Find index entry with <strong>the largest search key value</strong> <span class="math inline">\(\leq K\)</span>.</li><li>Search file sequentially <strong>starting</strong> at the record to which this index entry points.</li></ul><h2 id="multi-level-indices">Multi-level Indices</h2><p>The index file may be very large, and cannot be entirely kept in memory. If primary index does not fit in memory, access becomes expensive.</p><p>Solution: Treat primary index kept on disk as <strong>a sequential file</strong> and construct <strong>a sparse index</strong> on it.</p><ul><li>Outer index - a sparse index of primary index file.</li><li>Inner index - the primary index file.</li></ul><blockquote><p>If even outer index is too large to fit in main memory, yet another level of index can be created, and so on.</p></blockquote><h3 id="b-tree-properties">B<sup>+</sup>-tree Properties</h3><p><strong>Def</strong>. B<sup>+</sup>-tree is a rooted tree, with the parameter degree (branching) factor <span class="math inline">\(n\)</span>. All paths from root to leaf are of the same length: balanced tree.</p><ul><li>Each <strong>internal</strong> node (not root or leaf) has bewteen <span class="math inline">\(\lceil n / 2\rceil\)</span> and <span class="math inline">\(n\)</span> children.</li><li>Each <strong>leaf</strong> node has bewteen <span class="math inline">\(\lceil (n - 1) / 2\rceil\)</span> and <span class="math inline">\(n - 1\)</span> search key values.</li><li>Special cases for the root:<ul><li>If the root is not a leaf, it has at least 2 children.</li><li>If the root is a leaf, it has between 0 and <span class="math inline">\(n - 1\)</span> values.</li></ul></li></ul><p>Advantages:</p><ul><li>Since the inter-node connections are done by <strong>pointers</strong>, logically close blocks need not be physically close.</li><li>The non-leaf levels of B<sup>+</sup>-tree form a hierarchy of <strong>sparse indices</strong>. If there are <span class="math inline">\(K\)</span> search key values, the height is no more than <span class="math inline">\(\lceil \log_{\lceil n/2 \rceil}(K)\rceil\)</span></li></ul><h3 id="b-tree-node-structure">B<sup>+</sup>-tree Node Structure</h3><p>The search keys in a node are ordered.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><span class="math inline">\(P_1\)</span></th><th><span class="math inline">\(K_1\)</span></th><th><span class="math inline">\(P_2\)</span></th><th><span class="math inline">\(K_2\)</span></th><th><span class="math inline">\(\cdots\)</span></th><th><span class="math inline">\(P_{n - 1}\)</span></th><th><span class="math inline">\(K_{n - 1}\)</span></th><th><span class="math inline">\(P_{n}\)</span></th></tr></thead><tbody></tbody></table></div><div style="text-align: center; font-style: italic;">Table 3: typical B<sup>+</sup>-tree node structure</div><ul><li><span class="math inline">\(K_i\)</span> are the search key values.</li><li><span class="math inline">\(P_i\)</span> are<ul><li>pointers to childer (<strong>non-leaf nodes</strong>).</li><li>pointers to records or buckets of records (<strong>leaf nodes</strong>).</li></ul></li></ul><h3 id="leaf-nodes-in-b-tree">Leaf Nodes in B<sup>+</sup>-tree</h3><p>Leaf node properties</p><ul><li><span class="math inline">\(P_i\)</span> points to a record with search key value <span class="math inline">\(K_i\)</span>, <span class="math inline">\(i &lt; n - 1\)</span>.</li><li><span class="math inline">\(P_n\)</span> points to the next leaf node.</li></ul><blockquote><p>If <span class="math inline">\(L_i\)</span>, <span class="math inline">\(L_j\)</span> are leaf nodes, such that <span class="math inline">\(i &lt; j\)</span>, <span class="math inline">\(L_i\)</span>’s search key values are less than or equal to <span class="math inline">\(L_j\)</span>’s search key values.</p></blockquote><h3 id="non-leaf-nodes-in-b-tree">Non-leaf Nodes in B<sup>+</sup>-tree</h3><p>Non-leaf nodes <strong>with</strong> <span class="math inline">\(n\)</span> <strong>pointers</strong> form a multi-level sparse index on leaf nodes.</p><ol type="1"><li><span class="math inline">\(P_1\)</span>: The search keys to which <span class="math inline">\(P_1\)</span> points have values. <span class="math inline">\(P_1 &lt; K_1\)</span>.</li><li><span class="math inline">\(P_i\)</span>: The search keys to which <span class="math inline">\(P_i(2 \leq i \leq n - 1)\)</span>, points have values. <span class="math inline">\(K_{i - 1} \leq P_{i} &lt; K_i\)</span>.</li><li><span class="math inline">\(P_n\)</span>: The search keys to which <span class="math inline">\(P_n\)</span> points have values. <span class="math inline">\(K_{n - 1} \leq P_{n}\)</span>.</li></ol><h3 id="non-unique-keys">Non-unique Keys</h3><p><strong>Def</strong>. Non-unique Keys If a search key <span class="math inline">\(a_i\)</span> is not unique, create an index on a <strong>composite key</strong><span class="math inline">\((a_i, A_p)\)</span>, which is unique. <span class="math inline">\(A_p\)</span> could be a primary key, or any other attribute that guarantees uniqueness.</p><p>Search for <span class="math inline">\(a_i = v\)</span> by a range search on composite key. More I/O operations are needed to fetch the actual records</p><ul><li>if the index is <strong>clustering</strong>, all accesses are sequential</li><li>if the index is <strong>non-clustering</strong>, each record access may need an I/O operation</li></ul><blockquote><p><em>Note</em>：MySQL 数据库中，索引树 <span class="math inline">\(n \leq 100\)</span>，一张表可支持 <span class="math inline">\(10\)</span> 已行数据，但为了控制 B<sup>+</sup>-tree 索引深度，一般不超过 <span class="math inline">\(2000\)</span> 万行。其中的原因是</p><ul><li>B<sup>+</sup>-tree 索引（非叶子结点）需要全部调入内存</li><li>B<sup>+</sup>-tree 深度与索引树中非叶子结点数目 <span class="math inline">\(S\)</span> 所占内存空间取决于表中不同 search-key 数目，如 <em>instructor</em> 表中 ID 的数目</li><li>假设系统分配给数据库系统可用内存大小为 <span class="math inline">\(M\)</span>，要求 <span class="math inline">\(S \leq M\)</span></li><li>根据内存 <span class="math inline">\(M\)</span>、索引树节点大小 <span class="math inline">\(n\)</span> 值可以确定关系表中的行数</li></ul></blockquote><h3 id="b-tree-index-files">B-tree Index Files</h3><p><strong>Def</strong>. B-tree allows search key values to appear <strong>only once</strong>.</p><p>Non-Leaf nodes: search keys appear <strong>nowhere else</strong>.</p><ul><li>An <strong>additional pointer</strong> field for each search key must be included.</li><li>Pointer <span class="math inline">\(B_i\)</span> are the <strong>bucket</strong> or the <strong>record</strong> pointer to leaf node.</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><span class="math inline">\(P_1\)</span></th><th><span class="math inline">\(B_1\)</span></th><th><span class="math inline">\(K_1\)</span></th><th><span class="math inline">\(P_2\)</span></th><th><span class="math inline">\(B_2\)</span></th><th><span class="math inline">\(K_2\)</span></th><th><span class="math inline">\(\cdots\)</span></th><th><span class="math inline">\(P_{n - 1}\)</span></th><th><span class="math inline">\(B_{n - 1}\)</span></th><th><span class="math inline">\(K_{n - 1}\)</span></th><th><span class="math inline">\(P_{n}\)</span></th></tr></thead><tbody></tbody></table></div><div style="text-align: center; font-style: italic;">Table 4: typical B-tree node structure</div><ul><li>Advantages: less tree nodes and find search key value before reaching leaf node.</li><li>Disadvantages:<ul><li>Only small fraction of all serach key are found early.</li><li>Fan-out is reduced, as non-leaf nodes are larger.</li><li>Insertion and deletion are more complicated.</li></ul></li></ul><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Indexing/Comparison%20between%20B%20tree%20and%20B+%20tree.png" alt="Comparison between B tree and B+ tree"><figcaption aria-hidden="true">Comparison between B tree and B+ tree</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 1: B-tree above and B<sup>+</sup>-tree below on same data</div><h2 id="hash-indices">*Hash Indices</h2><blockquote><p>The records are stored in <strong>buckets</strong>.</p><ul><li>Bucket is a unit of storage containing records (a bucket is a disk block).</li><li>Bucket can be obtained from search key using <strong>hash function</strong>.</li></ul></blockquote><p><strong>Def</strong>. Hash function <span class="math inline">\(h\)</span></p><ul><li>A function from search key <span class="math inline">\(K\)</span> to bucket address.</li><li>Entries with different search keys mapped to the same bucket.</li><li>The entire bucket searched <strong>sequentially</strong> to locate an entry.</li></ul><p><strong>Def</strong>. Hash Index <strong>Buckets</strong> store entries with pointers to records.</p><p><strong>Def</strong>. Hash File Organization Buckets store records of the hash file. The <strong>process</strong> of obtaining the bucket of a record from search key using <strong>hashing function</strong>.</p><p><strong>Def</strong>. Static Hashing Hash function <span class="math inline">\(h\)</span> cannot be modified.</p><p><strong>Def</strong>. Dynamic Hashing Hash function <span class="math inline">\(h\)</span> can be modified dynamically.</p><p><strong>Example</strong> of hash file organization</p><p>Hash the <em>instructor</em> file, using dept_name as key. There are <span class="math inline">\(10\)</span> buckets. The binary representation of the <span class="math inline">\(i\)</span> character is the integer <span class="math inline">\(i\)</span>. The hash function returns the <strong>sum</strong> of the binary representations of the characters modulo <span class="math inline">\(10\)</span></p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Indexing/hash%20file%20organization%20example.png" alt="hash file organization example"><figcaption aria-hidden="true">hash file organization example</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 2: Possible buckets</div><h2 id="bucket-overflows">Bucket Overflows</h2><p><strong>Def</strong>. Bucket Overflow It occurs because of</p><ul><li>Insufficient buckets.</li><li>Non-uniform distribution of records due to:<ul><li>Multiple records have same search key value.</li><li>Hash function produces non-uniform distribution of the key values.</li></ul></li></ul><blockquote><p>The probability of bucket overflow can be reduced, but cannot be eliminated; It is handled by using <strong>overflow buckets</strong>.</p></blockquote><p><strong>Def</strong>. Overflow Chaining The overflow buckets of a given bucket are chained together.</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Indexing/overflow%20chaining.png" alt="overflow chaining"><figcaption aria-hidden="true">overflow chaining</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 3: Overflow chaining</div><h2 id="multiple-key-access">Multiple-Key Access</h2><p><strong>Def</strong>. Composite Search Keys Composite search keys are search keys containing <strong>more than one</strong> attribute. e.g.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name(column1, column2, ...);<br></code></pre></td></tr></table></figure><p><strong>Def</strong>. Lexicographic Ordering. <span class="math inline">\((a_1, a_2) &lt; (b_1, b_2)\)</span> if either <span class="math inline">\(a_1 &lt; b_1\)</span> or <span class="math inline">\(a_1 = b_1\)</span> and <span class="math inline">\(a_2 &lt; b_2\)</span>.</p><blockquote><p>复合索引左前缀原则</p><p>Suppose we have an index on composite search keys <code>(dept_name, salary)</code> with the where clause <code>where dept_name = "Finance" and salary = 8000;</code>. Index on <code>(dept_name, salary)</code> to fetch records with both conditions.</p><ul><li>Can also efficiently handle <code>where dept_name = "Finance" and salary &lt; 8000;</code></li><li>Can also efficiently handle <code>where dept_name = "Finance";</code></li></ul><p>But cannot efficiently handle</p><ol type="1"><li><code>where dept_name &lt; "Finance" and salary = 8000;</code>. May fetch many records that satisfy the first but not the second condition.</li><li><code>where salary = 8000;</code>. The index is not used for query.</li></ol><p>查询条件必须包含复合索引的前缀列，索引才能被高效利用。</p></blockquote><h2 id="creation-of-indices">Creation of Indices</h2><blockquote><ul><li>Indices on <strong>primary key</strong> created automatically.</li><li>Indices can speed up <strong>lookups</strong>, but impose <strong>cost</strong> on updates.</li></ul></blockquote><p><strong>Def</strong>. Index Definition in SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-operator">&lt;</span>index<span class="hljs-operator">-</span>name<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">on</span> <span class="hljs-operator">&lt;</span>relation<span class="hljs-operator">-</span>name<span class="hljs-operator">&gt;</span>(<span class="hljs-operator">&lt;</span>attributes<span class="hljs-operator">-</span>list<span class="hljs-operator">&gt;</span>);<br><br><span class="hljs-keyword">DROP</span> INDEX <span class="hljs-operator">&lt;</span>index<span class="hljs-operator">-</span>name<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>Use <code>CREATE UNIQUE INDEX</code> to indirectly specify and enforce the condition that the search key is a <strong>candidate</strong> key.</p></blockquote><p>We can enforce DB to use index.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tbMROData <span class="hljs-keyword">WITH</span> (INDEX <span class="hljs-operator">=</span> timeide) <span class="hljs-keyword">WHERE</span> ...<br></code></pre></td></tr></table></figure><p>Also we can enforce not.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> INDEX timeide <span class="hljs-keyword">on</span> tbMRODatanew<br>DISABLE<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tbMRODatanew <span class="hljs-keyword">WHERE</span> ...<br></code></pre></td></tr></table></figure><blockquote><p>我们应该在哪些属性上建立索引，可以从以下几个角度分析。</p><ol type="1"><li><p>对 <code>SELECT</code> 查询，针对 <code>SELECT</code>，<code>FROM</code>，<code>WHERE</code>，<code>GROUPBY</code>，<code>HAVING</code> 操作，在以下属性上建立聚集或非聚集索引，有利于提高访问速度。</p><ul><li><code>WHERE</code> 子句涉及到的<strong>查询属性</strong>，<strong>连接属性</strong>。</li><li><code>GROUPBY</code> 子句中的<strong>分组属性</strong>。</li></ul></li><li><p>对 <code>DELETE</code>，<code>FROM</code>，<code>WHERE</code> 操作，如果在 <code>WHERE</code> 查询条件属性上建立索引，有利于在数据库文件中快速定位由 <code>WHERE</code> 条件定义的需要删除的元组。但删除这些元组后，将引起 DBMS 对索引进行调整重组，引起额外的系统开销，可能会降低 <code>DELETE</code> 的执行速度。</p></li><li><p>对 <code>INSERT</code> 操作，在关系表中插入新元组后，DBMS 将根据新插入的元组在索引属性上的值，对表中的索引进行调整重组，必然引起额外系统开销，降低 <code>INSERT</code> 的执行速度。</p></li><li><p>对 <code>UPDATE</code>，<code>SET</code>，<code>WHERE</code> 操作，如果在 <code>WHERE</code> 查询条件属性上建立了索引，有利于在数据库文件中快速定位 <code>UPDATE</code> 需要访问的元组。但如果 <code>SET</code> 操作修改了索引涉及到的属性的值，则会引发 DBMS 对索引的重组。索引重组带来额外的系统开销，降低了 <code>UPDATE</code> 的执行速度。</p></li></ol></blockquote><h2 id="例题">例题</h2><p>Consider the following tables:</p><ul><li><em>factory</em>(<u>factoryID</u>, name, manager, account)</li><li><em>employee</em>(<u>employeeID</u>, name, age, factoryID)</li><li><em>airconditioner</em>(<u>serialID</u>, date, model, price, factoryID)</li></ul><ol type="1"><li>Consider the following SQL query. In addition to the primary indices on the primary keys of the tables, on which attributes in the tables the indices can be further defined to speed up the query?</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> A.factoryID, <span class="hljs-built_in">AVG</span>(employeeID)<br><span class="hljs-keyword">FROM</span> factory <span class="hljs-keyword">AS</span> A, employee <span class="hljs-keyword">AS</span> B<br><span class="hljs-keyword">WHERE</span> A.factoryID <span class="hljs-operator">=</span> B.factoryID <span class="hljs-keyword">AND</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> account <span class="hljs-operator">&gt;</span> <span class="hljs-number">30000</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> B.factoryID;<br></code></pre></td></tr></table></figure><p>factoryID, age in <em>employee</em>, account in <em>factory</em>.</p><p>(2). For the following query, a non-clustered index is defined on the attribute model. Does this index speed up or slow down the operation, and why?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> airconditioner<br><span class="hljs-keyword">SET</span> price <span class="hljs-operator">=</span> price <span class="hljs-operator">+</span> <span class="hljs-number">100</span><br><span class="hljs-keyword">WHERE</span> model <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;GL2020&#x27;</span>;<br></code></pre></td></tr></table></figure><p>This index will speed up the operation. Because DBMS can seek tuples in <code>UPDATE</code> and modify <code>SET</code> based on this index. What’s more, there is no necessary to modify this index.</p><p>(3). For the following delete operation, a primary index has been defined on the primary key serialID. Does this index speed up or slow down the operation, and why?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">FROM</span> airconditioner<br><span class="hljs-keyword">WHERE</span> model <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;HX8302&#x27;</span> <span class="hljs-keyword">AND</span> price <span class="hljs-operator">&gt;</span> <span class="hljs-number">1500</span>;<br></code></pre></td></tr></table></figure><p>The delete operation will slow down.</p><p>This is because, when searching for the target tuples to be deleted based on the <code>WHERE</code> condition (involving the two attributes <code>model</code> and <code>price</code>), the primary index defined on the primary key <code>serialID</code> cannot be utilized. Moreover, after deleting the target tuples that satisfy the WHERE condition, the DBMS needs to spend additional time readjusting the primary index defined on <code>serialID</code>.</p><p>Therefore, overall, the primary index on <code>serialID</code> reduces the speed of the delete operation.</p><ol start="4" type="1"><li>If a multiple-attribute index is defined on <em>airconditioner</em> by <code>CREATE INDEX DMFIndex ON airconditioner(date, model, factoryID);</code>, can the index <em>DMFIndex</em> speed up the following queries? why?</li></ol><p>(i).</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> serialID<br><span class="hljs-keyword">FROM</span> airconditioner<br><span class="hljs-keyword">WHERE</span> <span class="hljs-type">date</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2021-11-30&#x27;</span> <span class="hljs-keyword">AND</span> model <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Haier&#x27;</span>;<br></code></pre></td></tr></table></figure><p>The <code>WHERE</code> condition uses two attributes of <em>DMFIndex</em> and satisfies the left-prefix principle, so the index takes effect and can speed up the query.</p><p>(ii).</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> serialID<br><span class="hljs-keyword">FROM</span> airconditioner<br><span class="hljs-keyword">WHERE</span> <span class="hljs-type">date</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2021-11-30&#x27;</span> <span class="hljs-keyword">AND</span> price <span class="hljs-operator">&gt;</span> <span class="hljs-number">2000</span>;<br></code></pre></td></tr></table></figure><p>The <code>WHERE</code> condition uses one attribute of <em>DMFIndex</em>, <code>date</code>, and satisfies the left-prefix principle, so the index takes effect and can speed up the query.</p><p>(iii).</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> serialID<br><span class="hljs-keyword">FROM</span> airconditioner<br><span class="hljs-keyword">WHERE</span> <span class="hljs-type">date</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2021-11-30&#x27;</span> <span class="hljs-keyword">AND</span> factoryID <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1040&#x27;</span>;<br></code></pre></td></tr></table></figure><p>The <code>WHERE</code> condition uses two attributes of the <em>DMFIndex</em>: <code>date</code> and <code>factoryID</code>. From the perspective of the left-prefix requirement, only the query condition <code>date = '2021-11-30'</code> can utilize the index, and the index can partially accelerate the query.</p><p>(iv).</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> serialID<br><span class="hljs-keyword">FROM</span> airconditioner<br><span class="hljs-keyword">WHERE</span> model <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Haier&#x27;</span> <span class="hljs-keyword">AND</span> factoryID <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1040&#x27;</span>;<br></code></pre></td></tr></table></figure><p>The <code>WHERE</code> condition uses two attributes of the <em>DMFIndex</em>: <code>model</code> and <code>factoryID</code>, but it does not satisfy the left-prefix rule. Therefore, the index is ineffective and cannot accelerate the query.</p><h2 id="appendix">Appendix</h2><p>访问方式</p><ol type="1"><li>聚集索引查找</li><li>聚集索引扫描</li></ol><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Indexing/seek%20and%20scan.png" alt="seek and scan"><figcaption aria-hidden="true">seek and scan</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 4: 聚集索引树的查找和扫描</div>]]></content>
    
    
    <categories>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Data Storage Structures</title>
    <link href="/2025/11/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Data%20Storage%20Structures/"/>
    <url>/2025/11/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Data%20Storage%20Structures/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="file-organization">File Organization</h2><p>DB is stored as a collection of <strong>DB files</strong>. Each file is a sequence of <strong>records</strong>. Each record is in s sequence of <strong>fields</strong>. Each a <strong>relation table</strong> is a set of <strong>tuples</strong>.</p><blockquote><p>The record size is <strong>fixed</strong>. Each file has records of <strong>one particular type</strong> only. <strong>Different</strong> files are used for <strong>different relations</strong>. A tuple is stored as a record in DB.</p></blockquote><h3 id="fixed-length-records">Fixed-Length Records</h3><p>“Fixed-Length Records”并不是指现实中每个字段的语义长度恒定不变，而是指“数据库在磁盘/页上为每条记录分配了一个固定的字节长度”。</p><p>当我们尝试删除某些 fixed-length records 时，可以使用 <strong>free lists</strong>。这个表在其 header 中存储第一个会被删除的 record 地址，然后我们再使用第一个会被删除的 record 存储第二个会被删除的 record 地址，以此类推（类似 pointers）。这也说明了，records can be stored in noncontiguous space。</p><h3 id="variable-length-records">Variable-Length Records</h3><p>Variable-length records arise in several ways:</p><ul><li><strong>Record types</strong> allow variable lengths, e.g. strings(varchar).</li><li><strong>Multiple record types</strong> in a file. e.g. Multitable Clustering File.</li></ul><p>So how to store variable-length records in block?</p><ol type="1"><li>Attributes in the record are stored in order (step 1: fixed-length attributes, step 2: variable-length attributes).</li><li><strong>Variable-length attributes</strong> represented by fixed size (offset, length), with actual data stored after all fixed length attributes.</li><li>Null values represented by null-value bitmap.</li></ol><h4 id="slotted-page-structure">Slotted Page Structure</h4><p>The storage space is divided into <strong>fixed-sized slotted pages</strong>, 4KB or 8KB records are allocated to slotted pages.</p><blockquote><p>分槽页结构：将 DB 文件存储空间在逻辑上为多个 page，每个 page 又多个 slot 组成。</p></blockquote><ol type="1"><li>Slotted page header contais<ul><li>Number of record entries.</li><li>End of free space in the block.</li><li>Location and size of each record.</li></ul></li><li>Records can be moved around within a page to keep contiguous.<ul><li><span class="math inline">\(r_{i}\)</span> is deleted, and <span class="math inline">\(r_{i + 3}\)</span>, <span class="math inline">\(r_{i + 2}\)</span>, <span class="math inline">\(r_{i + 1}\)</span> are moved to the free space created by deletion.</li><li><strong>Entry in the header must be updated</strong>, e.g. set to <span class="math inline">\(-1\)</span>.</li></ul></li><li>Pointers should not point directly to record, instead they should point to the <strong>entry</strong> for the record in header.</li></ol><h2 id="organization-of-records-in-files">Organization of Records in Files</h2><p>DB file can be viewed as a set of records at logical level. <strong>Logical organization</strong> of records determine how to access the records. These records are <strong>logically</strong> organized as <strong>heap</strong>, <strong>sequential</strong>, <strong>hash</strong> and <strong>clustering</strong>.</p><h3 id="heap-file-organization">Heap File Organization</h3><p>Any record can be placed anywhere in the file where there is space for the record.</p><ul><li>There is <strong>no ordering</strong> of records.</li><li>Records usually do not move once allocated.</li><li>There is <strong>a single file for a relation</strong>.</li></ul><h3 id="sequential-file-organization">Sequential File Organization</h3><p>Records are logically ordered by <strong>search-keys</strong>. Records are stored in sequential order, based on the search key.</p><ol type="1"><li>Records are physically stored in search-key order.</li><li>As close to search-key order as possible to minimize the number of block accesses in sequential processing.</li></ol><p>Chain together records by pointers.</p><ul><li>The pointer in each record points to the next record in search-key order.</li><li>Sequential access to the file.</li></ul><h3 id="clustering-file-organization">Clustering File Organization</h3><p>Store several relations in one file using a <strong>mutitable clustering</strong> file organization. Records of several different relations are stored in the same file. This is because storing related records on the same block to minimize I/O.</p><h3 id="hashing-file-organization">Hashing File Organization</h3><p>The file records are stored in <strong>buckets</strong>, and the bucket is the address of the record. Hash function <strong>on some attributes</strong> (search key) determine the address of the records. The result of the function specifies <strong>in which</strong> block/bucket of the record should be placed.</p><h2 id="data-dictionary-storage">Data Dictionary Storage</h2><p>Data dictionary stores</p><ul><li>Metadata: Data about data, such as names of relations.</li><li>User and accounting information.<ul><li>passwords.</li></ul></li><li>Statistical and descriptive data.<ul><li>number of tuples in each relation.</li></ul></li><li>Physical file organization information.<ul><li>How relation is stored (sequential/hash/…).</li><li>Physical location of relation.</li></ul></li><li>Information about indices.</li></ul><h2 id="data-buffer">Data Buffer</h2><p>A DB file is partitioned into fixed-length storage units, called <strong>blocks</strong>. Blocks are units of both <strong>storage allocation</strong> and <strong>data transfer</strong>. DBS seeks to <strong>minimize</strong> the number of <strong>block transfers</strong> betweem the <strong>disk</strong> and <strong>main memory</strong>. We can reduce the number of disk accesses by keeping as many blocks as possible in <strong>main memory</strong>.</p><p><strong>Def</strong>. <strong>Buffer</strong> is a <strong>portion of main memory</strong> available to store <strong>copies</strong> of disk blocks.</p><p><strong>Def</strong>. <strong>Buffer manager</strong> allocates buffer space in main memory.</p><blockquote><p>The buffer size is an <strong>adjustable</strong> parameter. It has impact on the system performance, e.g. throughput.</p></blockquote><h3 id="buffer-management">Buffer Management</h3><p>Program (requester) calls on <strong>buffer manager</strong> when need block from disk.</p><ol type="1"><li>If the block is already in buffer, buffer manager returns the address of the block in mian memory.</li><li>If the block is <strong>not in buffer</strong>, buffer manager<ol type="1"><li>Allocates space in buffer for the block<ol type="1"><li>Replacing (throwing out) some other block, if required, to make space for the new block.</li><li>Replaced block written back to disk only if it was modified since the most recent time that it was written to/fetched from disk.</li></ol></li><li>Reads the block from disk to buffer returns the address of the block in mian memory to requester.</li></ol></li></ol><h4 id="buffer-replacement-strategy">Buffer Replacement Strategy</h4><ul><li>Pinned block: Memory block that is not allowed to be written back to disk.<ul><li>Pin done before reading/writing data from a block.</li><li>Unpin done when read/write is complete.</li></ul></li><li>Multiple concurrent pin/unpin operations.<ul><li>Shared and exclusive locks on buffer.</li></ul></li><li>Concurrent opearations for shared data.<ul><li>Reading require shared lock.</li><li>Updating require exclusive lock.</li><li>Locking rules:<ul><li>Only one process can get exclusive lock at a time.</li><li>Shared lock cannot be concurrently with exclusive lock.</li><li>Multiple processes may be given shared lock concurrently.</li></ul></li></ul></li></ul><h4 id="buffer-replacement-policies">Buffer Replacement Policies</h4><ul><li><p>Replace the block <strong>least recently used (LRU strategy)</strong></p><ul><li>Idea: Use <strong>past pattern</strong> of block references as predictor of future references.</li><li>Use information in user’s query to predict future references.</li></ul></li><li><p><strong>Toss-immediate strategy</strong>: Free the space occupied by block as soon as the final tuple of that block has been processed.</p></li><li><p><strong>Most recently used (MRU)</strong> strategy: Pin the block currently being processed. After the final tuple of that block has been processed, the block is unpinned, and it becomes the most recently used block.</p></li></ul><ol type="1"><li>Buffer manager can use <strong>statistical information</strong> regarding the probability that a request will reference a particular relation, e.g. data dictionary is frequently accessed.<ul><li>Heuristic: Keep data-dictionary blocks in main memory buffer.</li></ul></li><li>Buffer manager may reorder <strong>writes</strong><ul><li>Lead to corruption of data structures on disk.</li><li>Heuristic: Careful ordering of writes.</li></ul></li></ol><h2 id="column-oriented-storage">Column-Oriented Storage</h2><p>Column-Oriented Storage known as <strong>colunmar representation</strong>. It stores each attribute of a relation separately.</p><p>Benefits:</p><ul><li>Reduced IO if only some attributes are accessed.</li><li>Improved CPU cache performance.</li><li>Improved compression.</li></ul><p>Drawbacks:</p><ul><li>Cost of tuple reconstruction from columnar representation.</li><li>Cost of tuple deletion and update.</li></ul><blockquote><p>Columnar representation found to be more efficient for <strong>decision support</strong> than row-oriented representation. Row-oriented representation preferable <strong>for transaction processing</strong>.</p></blockquote><h2 id="data-organization-in-dbs">Data Organization in DBS</h2><p>DBS provides the services of <strong>data organization and access</strong>. From DBS users, data is organized as relational tables, tuples, and attributes (user-oriented logical organization of data); From operating systems, data is stored as <strong>OS file</strong>, known as DB file.</p><blockquote><p>DBS 数据的基本逻辑单位——<strong>元组/数据行</strong>与 OS 文件中数据的基本逻辑单位——<strong>文件记录</strong>的对应关系。</p><ul><li>1 个元组对应于文件系统的 1 个逻辑记录</li><li>1 个关系表对应于 1 个 OS 文件，或 1 个文件存储多个关系表的数据。</li></ul><p>在 DBS，1 个 block 包含多个文件逻辑记录。</p></blockquote><h2 id="data-access-in-dbs">Data Access in DBS</h2><p>小型关系数据库系统，关系表被存储在单独文件，DBMS 利用 OS 文件系统作为 DBMS 物理层实现基础，利用 OS 文件系统实现数据组织与访问</p><ul><li>操作系统为 DB 分配所需的磁盘 block，有可能将逻辑上相邻数据分配到磁盘上不同区域，导致连续访问效率下降。</li><li>用户对 DB 文件数据的访问需要借助于 OS 文件系统提供的文件结构和存取路径，这也说明 DBMS 对 OS 依赖太大，不利于数据库系统的移植。</li><li>DBS 数据访问过程，DBMS 的 storage management，OS 文件系统，I/O 子系统完成如下地址变换<ul><li>DB 关系表中元组/数据行到 DB 文件数据的逻辑地址（文件名，记录号）间的映射。</li><li>DB 文件记录号到外设上数据物理地址（记录所在的物理块号和具体地址）的映射。</li></ul></li></ul><p>现代大型关系数据库系统，SQL Server、Oracle，为适应数据动态变化、提供数据快速访问路径，DB 数据仍然以DB 文件的方式存在，但对 DB 文件管理并不直接依赖于 OS 文件系统。创建数据库时，DBMS 向 OS 一次申请所需外存空间（数据库文件），在此外存存储空间中，DBMS 独立地为数据库中的数据设计存储和访问结构，</p><ul><li>分配管理 DB 文件，提供数据访问机制。</li><li>根据需要，动态扩充、压缩数据库空间</li></ul><p>SQL Server 中，一个数据库由用于<strong>存储表</strong>和<strong>索引</strong>的磁盘/外存存储空间构成，这些空间被分配在一个或多个操作系统文件上（主文件，辅文件，日志文件）。数据库被划分为许多逻辑<strong>页</strong>，每个逻辑页大小为 8KB。</p><ul><li>每个数据库文件由多个从 0 开始连续编号的页组成。每个页逻辑上划分为许多从 1 开始连续编号的槽，每个<strong>槽用于存放一个数据库表中的数据行/元组/记录</strong>。</li></ul><p>数据库文件所在的页可以物理上存储在外存连续区域，如想连续的 disk blocks，也可以存储在非连续的 blocks 中。</p><p>对于 1 个 DB 表中的数据行/元组/记录，SQL Server 用该表所在的数据库文件 ID、数据行所在页 ID 和 槽 ID 来标识，数据行的逻辑地址：&lt;文件 ID，页 ID，槽 ID&gt;。</p><ul><li><p>SQL Server 以<strong>盘区</strong>为单位，为 DB 文件的页分配外存上的物理空间。盘区大小为 64KB，占用 8 个连续的页。DB 文件中数据行/元组/记录物理地址：数据行所在盘区的物理地址。</p></li><li><p>SQL Server 利用<strong>全局分配映象</strong> GAM 和共享全局分配映象 SGAM 数据结构记录每个盘区的使用情况。</p></li><li><p>SQL Server 利用<strong>索引分配映象</strong> IAM 数据结构记录每个数据库文件的页与该页所在物理盘区的对应关系</p></li><li><p>SQL Server 利用索引实现对关系表中的数据行/元组的访问</p><ul><li>Index：search key <span class="math inline">\(\to\)</span> &lt;文件 ID，页 ID，槽 ID&gt;</li><li>SQL Server 可对关系表的<strong>主键</strong>自动建立索引</li></ul></li><li><p>SQL Server 数据<strong>存储与访问</strong>机制</p><ul><li>二级地址映射<ul><li>基于<strong>索引</strong>的 search key <span class="math inline">\(\to\)</span> &lt;文件 ID，页 ID，槽 ID&gt;</li><li>基于<strong>IAM</strong>的<strong>数据行逻辑地址</strong> <span class="math inline">\(\to\)</span> <strong>数据行物理地址</strong>（盘区物理地址）</li></ul></li></ul></li></ul><h2 id="opengauss-段页式存储管理">openGauss 段页式存储管理</h2><blockquote><p>Segmentation with Paging.</p></blockquote><p>数据库<strong>表空间</strong>和<strong>数据文件</strong>以段-区-页/block的逻辑组织方式，进行存储分配和管理。</p><ul><li>1 个 database（在一个 tablespace 中）有且仅有一个段空间（segment space），段空间的实际物理存储可以是一个物理文件，也可以拆分存储在多个物理文件上。</li><li>1 个 database 中所有 table 都从该数据库的空间中分配数据，数据库中<strong>表的数目</strong>和实际物理文件个数无关。避免当数据库中的表比较多时，数据库存储所在的物理文件也比较多的问题。</li></ul><p>Database 中的每张 table 有一个逻辑上的 segment，该 table 所有的数据都存在该 segment 上。</p><ul><li>每个 segment 会挂载多个 extent，每个 extent 是外存上一块连续的物理页，但 1 个 segment 内的各个 extent 可以是不连续的。</li><li>extent 的大小可是根据业务需求调整，避免碎片带来的存储空间浪费。</li></ul><blockquote><p>段页式文件可以自动扩容，不需要用户手动指定，直到磁盘空间用满或者达到 tablespace 设置的限制。段页式存储不会自动回收磁盘空间。</p><p>当某些数据表被删除之后，其在段页式文件中占据的空间，会被保留，即段页式文件中会存在一些空洞，磁盘空间没有被释放，这些空洞会被面后新扩展或者创建出来的表重用。如果不需要重用这些空洞，手动调用系统函数，进行磁盘回收，释放磁盘空间。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lock and Condition Variables</title>
    <link href="/2025/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Lock%20and%20Condition%20Variables%20Implementation/"/>
    <url>/2025/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Lock%20and%20Condition%20Variables%20Implementation/</url>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>无监督表示学习</title>
    <link href="/2025/11/23/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/11/23/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>表示学习的动机</p><ul><li>直接使用原始特征，此时特征比较单一，需要进行非线性组合才能发挥其作用。</li><li>一些特征之间可能存在相关性。</li><li>并不是所有的特征都对预测有用。</li><li>特征中存在噪声。</li><li>特征纬度过高，会导致维度灾难。</li></ul></blockquote><h2 id="主成分分析回顾">主成分分析（回顾）</h2><p><strong>Def</strong>. 方差：描述一维变量偏离其均值的程度</p><p><span class="math display">\[\sigma^{2} = \frac{1}{N} \sum_{i = 1}^{N} (X_i - \overline{X})\]</span></p><p><strong>Def</strong>. 协方差：描述两个变量偏离各自均值的程度（描述两个变量之间相关程度）</p><p><span class="math display">\[\text{COV}(X, Y) = \frac{1}{N} \sum_{i = 1}^{N} (X_i - \overline{X})(Y_i - \overline{Y})\]</span></p><blockquote><p>只要 <span class="math inline">\(\text{COV}(X, Y) \neq 0\)</span>，则表明 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 之间存在相关性。</p></blockquote><p><strong>Def</strong>. 协方差矩阵：对于多维变量，例如：<span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>，<span class="math inline">\(z\)</span>，其协方差矩阵表示为</p><p><span class="math display">\[C =\begin{bmatrix}\text{COV}(X, X) &amp;\text{COV}(X, Y) &amp;\text{COV}(X, Z)\\\text{COV}(Y, X) &amp;\text{COV}(Y, Y) &amp;\text{COV}(Y, Z)\\\text{COV}(Z, X) &amp;\text{COV}(Y, Z) &amp;\text{COV}(Z, Z)\end{bmatrix}\]</span></p><p>主对角线上为 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>，<span class="math inline">\(z\)</span> 各自的方差；显然，协方差矩阵是一个对称矩阵。</p><blockquote><p>对于<strong>正交属性</strong>空间中的样本点，如何用一个超平面对所有样本进行恰当的表达？容易想到，若存在这样的超平面，那么它大概应具有这样的性质：</p><ul><li><strong>最近重构性</strong>：样本点到这个超平面的距离都足够近。</li><li><strong>最大可分性</strong>：样本点在这个超平面上的投影能尽可能分开。</li></ul><p>基于最近重构性和最大可分性，能分别得到主成分分析的两种等价推导。</p></blockquote><p>基于最近重构性的主成分分析.</p><ol type="1"><li><p>对样本进行<strong>中心化</strong>（<span class="math inline">\(\sum\limits_{i} x_i = 0\)</span>），再假定投影变换后得到的新坐标系为 <span class="math inline">\(\{w_1, w_2, \cdots, w_d\}\)</span>，其中 <span class="math inline">\(w_i\)</span> 是标准正交基向量，即</p><p><span class="math display">\[||w_i||_2 = 1, \quad w_i^Tw_j = 0 (i \neq j)\]</span></p></li><li><p>若丢弃新坐标系中的部分坐标，即将维度降到 <span class="math inline">\(d&#39; &lt; d\)</span>，则样本点在低维坐标系中的投影 <span class="math inline">\(z_i = (z_{i1}, z_{i2}, \cdots, z_{id&#39;})\)</span>，<span class="math inline">\(z_{ij} = w_{j}^{T} x_{i}\)</span>，则基于 <span class="math inline">\(z_{i}\)</span> 重构 <span class="math inline">\(x_{i}\)</span>：</p><p><span class="math display">\[\hat{x_i} = \sum_{j = 1}^{d&#39;} z_{ij} w_{j}\]</span></p></li><li><p>考虑整个训练集，原样本点 <span class="math inline">\(x_i\)</span> 与基于投影重构的样本点 <span class="math inline">\(\hat{x_i}\)</span> 之间的距离为</p><p><span class="math display">\[\sum_{i = 1}^{m} \biggl|\biggl| \sum_{j = 1}^{d&#39;} z_{ij}w_j - x_i \biggr|\biggr|_2^2 = \sum_{i = 1}^{m} z_{i}^{T}z_{i} - 2 \sum_{i = 1}^{m} z_{i}^{T} W^T x_{i} + \text{const}\\\propto -\text{tr}\bigg(W^T \bigg(\sum_{i = 1}^{m} x_{i}x_{i}^{T}\bigg)W\bigg)\]</span></p><blockquote><p><span class="math inline">\(m\)</span> 表示样本数；<span class="math inline">\(\text{tr}\)</span> 表示矩阵的迹。</p></blockquote></li><li><blockquote><p>根据最近重构性最小化上式。考虑到 <span class="math inline">\(w_{j}\)</span> 是标准正交基，<span class="math inline">\(\sum\limits_{i} x_{i} x_{i}^{T}\)</span> 是协方差矩阵，优化目标为：</p></blockquote><p><span class="math display">\[\begin{aligned}\min_{W} \quad &amp;-\text{tr}(W^TXX^TW)\\\text{s.t.} \quad &amp;W^TW = I\end{aligned}\]</span></p></li></ol><p>基于最大可分性的主成分分析.</p><ul><li>样本点 <span class="math inline">\(x_i\)</span> 在新空间中超平面上的投影是 <span class="math inline">\(w^{T}x_{i}\)</span>，若所有样本点的投影尽可能分卡，则应该使得投影后样本点的<strong>方差最大化</strong>。投影后样本点的方差是 <span class="math inline">\(\sum\limits_{i} w^{T}x_{i}x_{i}^{T}w\)</span>。于是，我们得到和基于最近重构性的主成分分析相同的最优化问题。</li></ul><p><strong>Algorithm - PCA</strong>.</p><ol type="1"><li>输入：样本集 <span class="math inline">\(D = \{x_1, x_2, \cdots, x_m\}\)</span>，低维空间维数 <span class="math inline">\(d&#39;\)</span>。</li><li>过程：<ol type="1"><li>对所有样本进行中心化：<span class="math inline">\(x_{i} \leftarrow x_{i} - \frac{1}{m} \sum\limits_{i = 1}^{m}x_{i}\)</span>；</li><li>计算样本的协方差矩阵 <span class="math inline">\(XX^{T}\)</span>；</li><li>对协方差矩阵 <span class="math inline">\(XX^{T}\)</span> 做特征值分解；</li><li>取最大的 <span class="math inline">\(d&#39;\)</span> 个特征值所对应的特征向量 <span class="math inline">\(w_1\)</span>，<span class="math inline">\(w_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(w_{d&#39;}\)</span>；</li></ol></li><li>输出：投影矩阵 <span class="math inline">\(W = (w_1, w_2, \cdots, w_{d&#39;})\)</span>。</li></ol><blockquote><p>从重构的角度设置重构阈值，例如 <span class="math inline">\(t = 95\%\)</span>，选取使下式成立的最小 <span class="math inline">\(d&#39;\)</span></p><p><span class="math display">\[\frac{\sum\limits_{i = 1}^{d&#39;} \lambda_{i}}{\sum\limits_{i = 1}^{d} \lambda_i} \geq t\]</span></p></blockquote><h2 id="自编码器">自编码器</h2><blockquote><p>自编码器是一种采用无监督方式进行特征学习的神经网络。基本思想：通过一个编码器对输入进行编码，令解码器解码得到的信号与输入信号尽可能一致，即：重构误差最小。</p></blockquote><ul><li>网络结构：可以是任意一种网络结构，只需要保证：输入形状等于输出形状。</li><li>误差函数：常用<strong>均方误差</strong>，有时也用交叉熵损失（此时输入 <span class="math inline">\(x_i \in (0, 1)\)</span>）。</li><li>优化方法：采用误差反向传播进行模型求解。</li></ul><blockquote><p>一般而言，隐藏层神经元数量小于输入层神经元数量。</p></blockquote><h3 id="稀疏自编码器">稀疏自编码器</h3><blockquote><p>基本思想：用尽可能少的神经元来表示原始数据 <span class="math inline">\(x\)</span>（也就是隐藏层神经元的激活值尽可能多的为 <span class="math inline">\(0\)</span>）。</p></blockquote><ul><li><p>令 <span class="math inline">\(a_j^{(2)}\)</span> 表示自动编码器中第 <span class="math inline">\(j\)</span> 个隐节点的激活函数，则 <span class="math inline">\(a_j^{(2)}(x)\)</span> 表示对于特定的输入 <span class="math inline">\(x\)</span>，第 <span class="math inline">\(j\)</span> 个隐节点的激活值。</p></li><li><p>第 <span class="math inline">\(j\)</span> 个隐节点的平均激活为</p><p><span class="math display">\[\hat{\rho}_{j} = \frac{1}{m} \sum_{i = 1}^{m} \big[a_{j}^{(2)}(x_i)\big]\]</span></p></li><li><p>增加约束：<span class="math inline">\(\hat{\rho}_j = \rho\)</span>，其中 <span class="math inline">\(\rho\)</span> 是一个<strong>稀疏参数</strong>，通常设为一个接近于 <span class="math inline">\(0\)</span> 的小数。</p><ul><li><p>等效于：加入一个<strong>惩罚项</strong>，使得 <span class="math inline">\(\hat{\rho}_j\)</span> 不至于偏离 <span class="math inline">\(\rho\)</span> 太远。</p><p><span class="math display">\[\sum_{j = 1}^{s_2} \rho \log \frac{\rho}{\hat{\rho}_j} + (1 - \rho) \log \frac{1 - \rho}{1 - \hat{\rho}_j} \quad \text{OR} \quad \sum_{j = 1}^{s_2} \text{KL}(\rho || \hat{\rho}_j)\]</span></p></li></ul></li><li><p>总体损失函数为：</p><p><span class="math display">\[J_{\text{sparse}}(W, b) = J(W, b) + \beta \sum_{j = 1}^{s_2} \text{KL}(\rho || \hat{\rho}_j)\]</span></p></li><li><p>在目标函数 <span class="math inline">\(J_{\text{sparse}}(W, b)\)</span> 上采用梯度下降法求解模型参数。</p></li></ul><blockquote><p>基于稀疏自编码器的 <strong>k-Sparse AutoEncoders</strong>。此编码器的稀疏策略是：找到 <span class="math inline">\(z\)</span> 中前 <span class="math inline">\(k\)</span> 个最大激活，而令其它的均为 <span class="math inline">\(0\)</span>。误差仅通过 <span class="math inline">\(z\)</span> 中的这 <span class="math inline">\(k\)</span> 个被激活的节点传播。</p><p>手写书字体识别任务中，不同 <span class="math inline">\(k\)</span> 值的可视化结果不同，随着 <span class="math inline">\(k\)</span> 的减小，网络趋于学习一个关于输入数字体的更完整的表示。</p></blockquote><h3 id="去噪自编码器">去噪自编码器</h3><p>基本思想：</p><ul><li>输入中加入<strong>扰动</strong>后，更高层的表示应该保持更好的<strong>稳定性和鲁棒性</strong>。</li><li>通过<strong>降噪表示</strong>可以抽出关于输入信号更有用的信息。</li></ul><blockquote><p>加噪方式：<strong>高斯噪声</strong>和<strong>二值掩码噪声</strong>（需要注意限制加噪后的数值范围）。</p></blockquote><h3 id="堆叠自编码器">堆叠自编码器</h3><blockquote><p>分阶段训练多个自编码器</p></blockquote><h3 id="深度自编码器">深度自编码器</h3><blockquote><p>整体训练</p></blockquote><h2 id="受限玻尔兹曼机">受限玻尔兹曼机</h2><p><strong>Def</strong>. 概率无向图模型</p><ul><li>输入层的神经元之间以及隐藏层的神经元之间均存在<strong>连接</strong>。</li><li>输入层和输出层神经元均为<strong>二值随机变量</strong>。</li></ul><blockquote><p>概率无向图模型是一种基于<strong>能量</strong>的模型，能量越小，模型越稳定。</p><p><span class="math display">\[E = - \bigg(\sum_{i &lt; j} w_{ij} s_{i} s_{j} + \sum_{i} \theta_{i} s_{i}\bigg)\]</span></p><p>其中 <span class="math inline">\(s\)</span> 表示节点，<span class="math inline">\(\theta\)</span> 表示偏置。</p></blockquote><p>而受限玻尔兹曼机（RBM）是只有两层的概率无向图模型，但与概率无向图的性质有些不同。RBM 只有可见层（visible layer）和隐藏层（hidden layer）之间有连接，同一层之间<strong>没有连接</strong>。</p><p>能量函数：</p><p><span class="math display">\[E(\mathbf{v}, \mathbf{h}) = - \sum_{i, j} v_i W_{ij} h_{j} - \sum_{i} c_i v_i - \sum_{j} b_{j} h_{j}\]</span></p><p>其中，<span class="math inline">\(c\)</span>，<span class="math inline">\(b\)</span> 表示偏置。</p><p>由概率分布和能量函数的定义</p><p><span class="math display">\[\begin{aligned}E(\mathbf{v}, \mathbf{h}) &amp;= - \sum_{i, j} v_i W_{ij} h_{j} - \sum_{i} c_i v_i - \sum_{j} b_{j} h_{j}\\p(\mathbf{v}, \mathbf{h}) &amp;= \frac{\exp (-E(\mathbf{v}, \mathbf{h}))}{Z}\\p(\mathbf{v}) &amp;= \frac{\sum_{\mathbf{h}} \exp (-E(\mathbf{v}, \mathbf{h}))}{Z}\\Z &amp;= \sum_{\mathbf{v}, \mathbf{h}} \exp (-E(\mathbf{v}, \mathbf{h}))\end{aligned}\]</span></p><p>从而可以推出条件概率公式：</p><p><span class="math display">\[\begin{aligned}p(h_{j} = 1 | \mathbf{v}) &amp;= \frac{\exp(-E(\mathbf{v}, h_{j} = 1))}{\exp(-E(\mathbf{v}, h_{j} = 0)) + \exp(-E(\mathbf{v}, h_{j} = 1))}\\&amp;= \frac{\exp(\sum_{i} v_{i} W_{ij} + \sum_{i} c_{i}v_{i} + b_{j})}{\exp(\sum_{i}c_{i} v_{i}) + \exp(\sum_{i} v_{i} W_{ij} + \sum_{i} c_{i}v_{i} + b_{j})}\\&amp;= \frac{\exp(\sum_{i} v_{i} W_{ij} + b_{j})}{1 + \exp(\sum_{i} v_{i} W_{ij} + b_{j})} = s\bigg(\sum_{i} v_{i} W_{ij} + b_{j}\bigg)\end{aligned}\]</span></p><p>其中 <span class="math inline">\(s\)</span> 是 <strong>sigmoid</strong> 函数。同理可得：</p><p><span class="math display">\[p(v_{i} = 1 | \mathbf{h}) = s\bigg(c_{i} + \sum_{j} W_{ij} h_{j}\bigg)\]</span></p><p>接下来，我们最大化训练集上的对数似然，即最大化 <span class="math inline">\(p(\mathbf{v})\)</span>。对 <span class="math inline">\(p(\mathbf{v})\)</span> 的对数关于参数的偏导数可以得到：</p><p><span class="math display">\[\begin{aligned}\frac{\partial \log p(\mathbf{v})}{\partial \theta} &amp;= \frac{\partial (\log \sum_{\mathbf{h}} \exp(-E(\mathbf{v}, \mathbf{h})) - \log Z)}{\partial \theta}\\&amp;= \frac{1}{\sum_{\mathbf{h}}\exp(-E(\mathbf{v}, \mathbf{h}))} \cdot -\exp(-E(\mathbf{v}, \mathbf{h})) \cdot \frac{\partial E(\mathbf{v}, \mathbf{h})}{\partial \theta} - \frac{1}{Z} \cdot -\exp(-E(\mathbf{v}, \mathbf{h})) \cdot \frac{\partial E(\mathbf{v}, \mathbf{h})}{\partial \theta}\\&amp;= - \langle \frac{\partial E(\mathbf{v}, \mathbf{h})}{\partial \theta} \rangle_{p(\mathbf{h} | \mathbf{v})} + \langle \frac{\partial E(\mathbf{v}, \mathbf{h})}{\partial \theta} \rangle_{p(\mathbf{v}, \mathbf{h})}\end{aligned}\]</span></p><p><span class="math inline">\(\langle \rangle_{p}\)</span> 表示对概率分布 <span class="math inline">\(p\)</span> 下的期望。</p><blockquote><p>其中第一项 <span class="math inline">\(p(\mathbf{h} | \mathbf{v})\)</span> 代表在输入数据条件下表示层的概率分布，比较容易计算，而第二项 <span class="math inline">\(p(\mathbf{v}, \mathbf{h})\)</span> 由于归一化因子的存在，无法有效的计算该分布。</p></blockquote><p><strong>Algorithm - CD-k</strong>. RBM 的对称结构和其中神经元节点状态的条件独立性，使得可以通过若干步<strong>吉布斯采样</strong>来计算第二项的期望。在完成k步抽样之后，就可以近似计算模型参数的梯度，具体如下：</p><p><span class="math display">\[\begin{aligned}\delta W_{ij} &amp;= v_{i}^0 h_{j}^0 - v_{i}^k h_{j}^k\\\delta c_{i} &amp;= v_{i}^0 - v_{i}^{k}\\\delta b_{j} &amp;= h_{j}^0 - h_{j}^k\end{aligned}\]</span></p><h3 id="gaussian-rbm">Gaussian RBM</h3><p>使用高斯分布来建模输入层</p><p><span class="math display">\[\begin{aligned}E(\mathbf{v}, \mathbf{h}) &amp;= \frac{1}{2} \sum_{i} \frac{(v_i - c_i)^2}{2\sigma_i^2} - \sum_{i, j} \frac{v_i}{\sigma_{i}} W_{ij} h_{j} - \sum_{i} c_{i} v_{i} - \sum_{j} b_{j} h_{j}\\p(h_{j} = 1 | \mathbf{v}) &amp;= s(b_{j} + \sum_{i} \frac{v_{i}}{\sigma_{i}} W_{ij})\\p(v_{i} = 1 | \mathbf{h}) &amp;= \mathcal{N}(c_{i} + \sigma_{i} \sum_{j} W_{ij} h_{j}, \sigma_{i}^{2})\end{aligned}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>神经网络与深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OS Interfaces and Syscalls</title>
    <link href="/2025/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS_Interfaces_and_Syscalls/"/>
    <url>/2025/11/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS_Interfaces_and_Syscalls/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="os-programming-interface">OS Programming Interface</h2><p>What are the <strong>system calls</strong>? They differ from different operating system. The follow table shows some system calls in <strong>Windows</strong> and <strong>Unix</strong>.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th></th><th>Windows</th><th>Unix</th></tr></thead><tbody><tr class="odd"><td>Process Control</td><td><code>CreateProcess()</code><br><code>ExitProcess()</code><br><code>WaitForSingleObject()</code></td><td><code>fork()</code><br><code>exit()</code><br><code>wait()</code></td></tr><tr class="even"><td>File Manipulation</td><td><code>CreateFile()</code> <br> <code>ReadFile()</code> <br> <code>WriteFile</code> <br> <code>CloseHandle()</code></td><td><code>open()</code> <br> <code>read()</code> <br> <code>write()</code> <br> <code>close()</code></td></tr><tr class="odd"><td>Device Manipulation</td><td><code>SetConsoleMode()</code> <br> <code>ReadConsole()</code> <br> <code>WriteConsole()</code></td><td><code>ioctl()</code> <br> <code>read()</code> <br> <code>write()</code></td></tr><tr class="even"><td>Information Maintenance</td><td><code>GetCurrentProcessID()</code> <br> <code>SetTimer()</code> <br> <code>Sleep()</code></td><td><code>getpid()</code> <br> <code>alarm()</code> <br> <code>sleep()</code></td></tr><tr class="odd"><td>Communication</td><td><code>CreatePipe()</code> <br> <code>CreateFileMapping()</code> <br> <code>MapViewOfFile()</code></td><td><code>pipe()</code> <br> <code>shm_open()</code> <br> <code>mmap()</code></td></tr><tr class="even"><td>Protection</td><td><code>SetFileSecurity()</code> <br> <code>InitlializeSecurityDescriptor()</code> <br> <code>SetSecurityDescriptorGroup()</code></td><td><code>chmod()</code> <br> <code>umask()</code> <br> <code>chown()</code></td></tr></tbody></table></div><h3 id="posix-and-libc">POSIX and LIBC</h3><p><strong>Portable Operating System Interface</strong> (POSXI) is a standard for <strong>UNIX OSes</strong>, especially its system calls.</p><p><strong>LIBC</strong>: Overview of standard <strong>C libraries</strong>.</p><ul><li>POSIX APIs like <code>getpid()</code> and standard C functions like <code>strcpy()</code>.</li><li>Apps do not directly invoke <strong>syscalls</strong>.</li><li><strong>GLIBC</strong>: GNU C library.</li></ul><blockquote><p><em>If a software is written with only dependency to libc, it has good <strong>portability</strong> across OSes/hardware</em>.</p></blockquote><h2 id="case-study-process-management">Case Study: Process Management</h2><blockquote><p>Why we need <strong>multi-process</strong>? Early motuvation: Allow developers to write their own <strong>shell command</strong> line interpreters.</p></blockquote><h3 id="process-in-windows">Process in Windows</h3><p><strong>Boolean</strong> <code>CreateProcess(char *prog, char *args)</code>.</p><ul><li>Create and initialize the <strong>process control block</strong> (PCB) in kernel.</li><li>Create and initialize a new <strong>memory address space</strong>.</li><li>Load the program <code>prog</code> into the address space.</li><li>Copy arguments <code>args</code> into memory in the address space.</li><li>Initialize the hardware context to start execution at “start”.</li><li>Inform the scheduler that the new process is ready to run.</li></ul><blockquote><p>In reality, it’s a bit more complex. The parent process may specify the child process’s privileges, where it sends its input and output, what it should store its files, what to use as a scheduling priority.</p></blockquote><h3 id="fork-in-unix"><code>fork()</code> in Unix</h3><p><code>fork()</code> and <code>exec()</code>: The Unix way to <strong>create new process</strong>.</p><blockquote><p>Perhaps one of the most controversial design in Unix.</p></blockquote><ul><li><code>fork()</code>: Create a complete copy of the parent process, except the return value:<ul><li>0 for child process.</li><li>The PID of child process for the parent process.</li></ul></li><li><code>exec()</code>: Load and execute a program from disk.<ul><li><em>Note</em>: <code>exec()</code> does not create a new process.</li></ul></li></ul><blockquote><p>What actually have <code>fork()</code> and <code>exec()</code> done?</p><p><code>fork()</code></p><ol type="1"><li>Create and initialize PCB.</li><li>Create a new address space.</li><li>Copy the entire memory contents from parent process to the child.</li><li>Inherit the execution content of the parent (e.g., open files)</li><li>Inform the scheduler that new process is ready to run.</li></ol><p><code>exec(char *prog, char *args)</code></p><ol type="1"><li>Load the program <code>prog</code> into the current address space.</li><li>Copy arguments <code>args</code> into memory in the address space.</li><li>Initialize the hardware context to start execution at “start”</li></ol></blockquote><p>A typical example of how <code>fork()</code> and <code>exec()</code> are used.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = fork();<br><span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>    exec(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    waitpid(pid. &amp;status, options);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>The memory contents of the child process are copied twice, would taht be a waste?</p><p><code>exec()</code> is not always necessary (open a new page in Google Chrome)</p><p><code>wait(pid)</code>: Wait for the child process to finish execution.</p><p>Signal: Terminate, stop, resume a process</p></blockquote><h2 id="case-study-inputoutput">Case Study: Input/Output</h2><blockquote><p>Computer systems have very diverse I/O devices. Having an interface for each device means the OS interface needs to expand whenever a new device is added. <strong>Unix</strong> has one interface for all of them! (“Everthing is a file” - open, read, write, clos)</p></blockquote><h3 id="file-descriptor-in-unix">File Descriptor in Unix</h3><p><strong>File Descriptor (fd)</strong>: a number (int) that uniquely identifies an open file in a computer’s operating system. It describes a data resource, and how that resource may be accessed.</p><blockquote><ul><li>Each process has its own file descriptor table.</li><li>A file can be opened multiple times and therefore associated with many file descriptor.</li><li>More in filesystem courses.</li></ul><p>Internally, it has everything about an opened file (where it resides; its status; how to access it; …)</p></blockquote><h3 id="inputoutput-in-unix">Input/Output in Unix</h3><h2 id="system-calls">System Calls</h2><ul><li>An illusion that kernel is simply a set of library routines.<ul><li>Actually, it’s not. They are not even in the same context!</li><li>Names, arguments, return values.</li></ul></li><li>A key challenge: Protection from user-space errors.<ul><li>What are to be checked?</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Chapter 3: Context Switch</title>
    <link href="/2025/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Context_Switch/"/>
    <url>/2025/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Context_Switch/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="user-to-kernel-mode-switch">*User to kernel Mode Switch</h2><p>There are three conditions will trigger switch.</p><ol type="1"><li><strong>Exceptions</strong>: When the <strong>processor</strong> encounters <strong>unexpected condition</strong> like <strong>illegal memory access</strong>, <strong>divide-by-zero (in C)</strong>, <strong>perform privileged instructions</strong>.</li><li><strong>Interrupts</strong>: <strong>Asynchronous signal</strong> to the processor that some external event has occurred that requires its attention, like <strong>timer interrupts</strong>, <strong>I/O requests</strong> such as mouse movement.</li><li><strong>System calls</strong>: User processes requests the kernel do som operation on the user’s behalf, like <strong>R/W files</strong>, <strong>creating new processes</strong>, <strong>network connections</strong>.</li></ol><blockquote><p>What types of these user-to-kernel switch are they?</p><ul><li>inter-processor interrupt(IPI)</li><li>invalid opcode</li><li>segmentation fault</li><li>network card interrupt</li><li>divide-by-zero in python/java<ul><li>exception from interpreter (<strong>not processor</strong>)</li></ul></li></ul></blockquote><h2 id="interrupt-vector-table">Interrupt Vector Table</h2><p>Interrupt vector table stores the <strong>entries</strong> of different handlers for <strong>exceptions</strong>, <strong>interrupts</strong>, and <strong>traps</strong> in real mode.</p><blockquote><p>There is <strong>a special register</strong> that point to the <strong>vector (array)</strong> in kernel memory, where each entry points to the <strong>first instruction</strong> of a different handler procedure in the kernel.</p><p>In x86, there are <span class="math inline">\(256\)</span> entries in total. Each takes <span class="math inline">\(4\)</span> bytes.</p><p><strong>Old</strong>.</p></blockquote><h2 id="interrupt-descriptor-table">Interrupt Descriptor Table</h2><p>Interrupt descriptor table tells CPU where the <strong>interrupt service routines</strong> are located.</p><blockquote><p>Location calls <strong>entry</strong>, also called <strong>gate</strong>. There are <span class="math inline">\(256\)</span> gates in total. Each gate is <span class="math inline">\(8\)</span>-bytes long on <span class="math inline">\(32\)</span>-bit processors; or <span class="math inline">\(16\)</span>-bytes long on <span class="math inline">\(64\)</span>-bit processors. Its location is kept in <strong>IDT register(IDTR)</strong>, loaded with <strong>LIDT</strong> assembly instruction.</p><p>用户态到内核态只能经过这 <span class="math inline">\(256\)</span> 个门</p></blockquote><p>The following table is <strong>gate descriptor(32-bit)</strong> structure:</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>bits</th><th>name</th></tr></thead><tbody><tr class="odd"><td>0 ~ 15</td><td>Offset</td></tr><tr class="even"><td>16 ~ 31</td><td>Segment Selector</td></tr><tr class="odd"><td>32 ~ 39</td><td>Reserved</td></tr><tr class="even"><td>40 ~ 43</td><td>Gate Type</td></tr><tr class="odd"><td>44</td><td>0</td></tr><tr class="even"><td>45 ~ 46</td><td>DPL</td></tr><tr class="odd"><td>47</td><td>P</td></tr><tr class="even"><td>48 ~ 63</td><td>Offset</td></tr></tbody></table></div><blockquote><ul><li><strong>Offset</strong>: A 32-bit value, split in two parts, represents the address of the <strong>interrupt service routine</strong>.</li><li><strong>Selector</strong>: A <strong>segment selector</strong> which must point to a valid code segment in your <strong>GDT (Global Descriptor Table)</strong>.</li><li><strong>Gate Type</strong>: A 4-bit value which defines the type of gate this interrupt descriptor represents.</li><li><strong>DPL</strong>: A 2-bit value which defines the CPU privilege levels which are allowed to access this interrupt via the <strong>INT (Interrupt Instruction)</strong>.</li><li><strong>P</strong>: Present bit. Must be set 1 for the descriptor to be valid.</li></ul><p>Why offset is split into two parts? For compatibility.</p></blockquote><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>特性</th><th>IVT</th><th>IDT</th></tr></thead><tbody><tr class="odd"><td><strong>用途</strong></td><td>实模式中断向量表</td><td>保护模式/长模式中断描述符表</td></tr><tr class="even"><td><strong>存储位置</strong></td><td>固定在 0x0000 到 0x03FF</td><td>动态位置，由 IDTR 指定</td></tr><tr class="odd"><td><strong>条目大小</strong></td><td><span class="math inline">\(4\)</span> 字节</td><td><span class="math inline">\(8\)</span> 字节（<span class="math inline">\(32\)</span> 位）或 <span class="math inline">\(16\)</span> 字节（<span class="math inline">\(64\)</span> 位）</td></tr><tr class="even"><td><strong>条目内容</strong></td><td>中断处理程序的入口地址</td><td>描述符（包含段选择器、偏移地址等）</td></tr><tr class="odd"><td><strong>支持的模式</strong></td><td>实模式</td><td>保护模式、长模式</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 1: Comparison between IVT and IDT</div><p>IVT 是早期的简单实现，而 IDT 是现代操作系统中更灵活和安全的中断处理机制。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Context_Switch/interrupt%20procedure.png" alt="interrupt procedure"><figcaption aria-hidden="true">interrupt procedure</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 1: Interrupt procedure</div><h2 id="interrupt-masking">Interrupt Masking</h2><p>There are two kinds of interrupts:</p><ul><li><strong>Maskable interrupts</strong>: all software interrupts, all system calls, and partial hardware exceptions.</li><li><strong>Non-Maskable interrupts</strong>: partial hardware exceptions.</li><li><strong>Specified by <em>eflags registers</em></strong>.</li></ul><blockquote><p><strong>Disable interrupts</strong> and <strong>enable interrupts</strong>. Both of them are privileged instructions.</p><p>Masked interrupts are deferred, but not ignored. Given the limited buffer for interrupts, hardware buffers one interrupt of each type.</p></blockquote><h2 id="interrupt-stack">*Interrupt Stack</h2><p><strong>Interrupt stack</strong> is a special stack in kernel memory that saves <strong>interrupt process status</strong>. Empty when there is no interrupt (running in user space).</p><blockquote><ol type="1"><li><p>Why not directly use the user-space stack?</p><p>For reliability and security</p></li><li><p>How many interrupt stack in kernel?</p><p>Kernel need to allocate each thread a interrupt stack</p></li></ol><ul><li><strong>First fault</strong>: trap from user-space program to kernel-space exception handler.</li><li><strong>Double fault</strong>: trap from exception handler to another handler.</li><li><strong>Triple fault</strong>: reboot.</li></ul></blockquote><h2 id="kernel-to-user-mode-switch">Kernel to User Mode Switch</h2><ul><li><p><strong>New process</strong></p><p>When a new process is created (e.g., via <code>fork</code> and <code>exec</code> in Unix-like systems), the kernel initializes its context and then switches to user mode to start executing the user program.</p></li><li><p><strong>Resume after an interrupt/exception/syscall</strong></p><p>After handling an interrupt, exception, or system call, the kernel restores the user process’s context and returns to user mode so the process can continue execution from where it was interrupted.</p></li><li><p><strong>Switch to a different process</strong></p><p>The kernel may decide to switch to another process (context switch), often triggered by a timer interrupt (preemptive multitasking) or when the current process is blocked (e.g., waiting for I/O). The kernel saves the current process’s state and restores the next process’s state before switching to user mode.</p></li><li><p><strong>User-level upcall</strong></p><p>Sometimes, the kernel needs to notify a user process of an event (such as asynchronous I/O completion or signals). This is done via a user-level upcall, where the kernel arranges for a specific user-mode handler to be invoked.</p></li></ul><blockquote><p><strong>Upcalls</strong> allow apps to implement OS-like functionality to be invoked by <strong>OS</strong>.</p><ol type="1"><li><p>Asynchronous I/O notification, like waiting for I/O completion.</p></li><li><p>Inter-process communication, such as debugger suspends a process.</p></li><li><p>User-level exception handling, like ensuring files saved before app shuts down.</p></li><li><p>User-level resource allocation, such as Java garbage collection.</p></li></ol></blockquote><h2 id="x86-example">*x86 Example</h2><h3 id="x86-background">x86 Background</h3><ul><li>Memory is segmented, so pointers come in two parts: a segment and an offset.<ul><li>program counter: <code>cs</code> register and <code>eip</code> register</li><li>stack pointer: <code>ss</code> register and <code>esp</code> register</li><li>CPL is stored as the <span class="math inline">\(2\)</span> lower-bit of <code>cs</code> register</li></ul></li><li>In Intel 8086: <code>cs:eip</code> = cs <span class="math inline">\(\times 16 +\)</span> <code>eip</code><ul><li>both <code>cs</code> and <code>eip</code> are <span class="math inline">\(16\)</span>-bits long, therefore CPU can access at most <span class="math inline">\(1\)</span> MB memory space</li></ul></li><li><code>eflags</code> register stores the processor status and controls its behavior. Whether interrupts are masked or not.</li><li>Only a small number of instructions can change the <code>cs</code> register value<ul><li><code>ljmp</code> (far jump)</li><li><code>lcall</code> (far call), which pushes <code>eip</code> and <code>cs</code> to the stack, and then far jumps</li><li><code>lref</code> (far return), which inverses the far call</li><li><code>INT</code>: an assembly languages instruction for x86 processors that generates a <strong>software interrupt</strong>. It takes the interrupt number formatted as a byte value. Which read <code>cs</code>/<code>eip</code> from the IVT</li><li><code>IRET</code>: returns program control from an exception or interrupt handler to a program or procedure that was interrupted previously</li></ul></li></ul><h3 id="x86-transfer">x86 transfer</h3><p>When an interrupt/exception/syscall occurs, the <strong>hardware</strong> will:</p><ol type="1"><li>mask interrupts</li><li>save the special register values to other temporary registers</li><li>switch onto the kernel interrupt stack</li><li>push the three key values onto the new stack</li><li>optionally save an error code</li><li><strong>invoke</strong> the interrupt handler (<strong>CPL changed</strong>!)</li></ol><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Context_Switch/before%20interrupt.png" alt="before interrupt"><figcaption aria-hidden="true">before interrupt</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 2: Before interrupt</div><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Context_Switch/at%20the%20beginning%20of%20handler.png" alt="at the beginning of handler"><figcaption aria-hidden="true">at the beginning of handler</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 3: At the beginning of handler</div><p>Then the <strong>OS</strong> will:</p><ol type="1"><li>save the rest of the interrupted process’s state<ul><li><code>pusha</code>/ <code>pushad</code></li></ul></li><li><strong>execute</strong> the handler</li><li>resume the interrupted process<ul><li><code>popa</code>/<code>popad</code> <span class="math inline">\(+\)</span> pop error cod</li></ul></li><li>resume the interrupted process<ul><li><code>iret</code> (kernel mode to user mode)</li></ul></li></ol><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Context_Switch/during%20interrupt%20handler.png" alt="during interrupt handler"><figcaption aria-hidden="true">during interrupt handler</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 4: During interrupt handler</div>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Coze智能体实战——以面试官为例的智能体实战</title>
    <link href="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/"/>
    <url>/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>此文章用于 Coze 平台智能体制作入门。</p><span id="more"></span><h2 id="引入">引入</h2><p>首先，登入 Coze 平台账号，<strong>创建</strong>并<strong>确认</strong>智能体。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/创建智能体.png" alt="创建智能体"><figcaption aria-hidden="true">创建智能体</figcaption></figure></div><div style="display: block; margin: 0 auto; width: 50%"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/确认智能体.png" alt="确认智能体"><figcaption aria-hidden="true">确认智能体</figcaption></figure></div><p>然后，我们会进入<strong>工作界面</strong>。工作界面明显地分为三个部分，从左至右分别用于<strong>提示词</strong>，<strong>功能</strong>，<strong>调试</strong>。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/工作界面.png" alt="工作界面"><figcaption aria-hidden="true">工作界面</figcaption></figure></div><h2 id="功能面板">功能面板</h2><h3 id="对话体验模块">对话体验模块</h3><p><strong>对话体验</strong>模块位于功能面板的最底下，包括如下内容：</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/对话体验.png" alt="对话体验"><figcaption aria-hidden="true">对话体验</figcaption></figure></div><p>其中有两个很重要的参数：<strong>开场白</strong>和<strong>用户问题建议</strong>（其余参数仅作了解）。开场白中输入的内容会同步<strong>映射</strong>到右边调试界面，你可以在其中填写问候语，本智能体的基本信息或基本使用方式；然后是<strong>用户问题建议</strong>，因为本智能体是模拟面试官，更多的是智能体问，用户回答的形式，故<strong>关闭</strong>。</p><h3 id="技能模块">技能模块</h3><p><strong>技能</strong>模块包括两个部分：<strong>插件</strong>和<strong>工作流</strong>。插件可以理解为工具，就像我们人可以用手机上网，笔写字一般，有了插件，你的智能体可以实现<strong>联网搜索</strong>，<strong>绘图</strong>等功能；工作流适用于复杂的任务，好比工厂生产一件产品时其流水线。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/技能.png" alt="技能"><figcaption aria-hidden="true">技能</figcaption></figure></div><h3 id="知识模块">知识模块</h3><p><strong>知识</strong>模块包含三个部分：<strong>文本</strong>，<strong>表格</strong>和<strong>照片</strong>。知识可以理解为补充的数据，此功能用于个性化智能体的知识库。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/知识.png" alt="知识"><figcaption aria-hidden="true">知识</figcaption></figure></div><p><strong>记忆</strong>模块包含两个重要的部分：<strong>变量</strong>和<strong>数据库</strong>。变量的用处如图片中所述，我们可以通过设置变量保存用户的重要信息；数据库为智能体和使用者所维护，二者都可以修改和查询数据库。</p><h3 id="记忆模块">记忆模块</h3><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/记忆.png" alt="记忆"><figcaption aria-hidden="true">记忆</figcaption></figure></div><h2 id="提示词面板">提示词面板</h2><div style="display: block; margin: 0 auto; width: 50%"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/提示词面板.png" alt="提示词面板"><figcaption aria-hidden="true">提示词面板</figcaption></figure></div><p>我们使用<strong>任务执行</strong>模板。你应该很好奇，为什么有些字处于紫色背景中。我们将整个提示词复制，粘贴后的结果如下，可以看到有紫色背景的字都处于类似 <code>环境中，我们可以直接在提示词界面中修改紫色背景上的内容；或者，修改下面类似</code> 环境中的内容，然后将修改后的所有内容粘贴回去。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 角色 </span><br>你是&#123;#InputSlot placeholder=&quot;角色设定，比如xx领域的专家&quot;#&#125;&#123;#/InputSlot#&#125;<br>你的目标是&#123;#InputSlot placeholder=&quot;希望模型执行什么任务，达成什么目标&quot;#&#125;&#123;#/InputSlot#&#125;<br><br>&#123;#以下可以采用先总括，再展开详细说明的方式，描述你希望智能体在每一个步骤如何进行工作，具体的工作步骤数量可以根据实际需求增删#&#125;<br><span class="hljs-section">## 工作步骤 </span><br><span class="hljs-bullet">1.</span> &#123;#InputSlot placeholder=&quot;工作流程1的一句话概括&quot;#&#125;&#123;#/InputSlot#&#125; <br><span class="hljs-bullet">2.</span> &#123;#InputSlot placeholder=&quot;工作流程2的一句话概括&quot;#&#125;&#123;#/InputSlot#&#125; <br><span class="hljs-bullet">3.</span> &#123;#InputSlot placeholder=&quot;工作流程3的一句话概括&quot;#&#125;&#123;#/InputSlot#&#125;<br><br><span class="hljs-section">### 第一步 &#123;#InputSlot placeholder=&quot;工作流程1标题&quot;#&#125;&#123;#/InputSlot#&#125; </span><br>&#123;#InputSlot placeholder=&quot;工作流程步骤1的具体工作要求和举例说明，可以分点列出希望在本步骤做哪些事情，需要完成什么阶段性的工作目标&quot;#&#125;&#123;#/InputSlot#&#125;<br><span class="hljs-section">### 第二步 &#123;#InputSlot placeholder=&quot;工作流程2标题&quot;#&#125;&#123;#/InputSlot#&#125; </span><br>&#123;#InputSlot placeholder=&quot;工作流程步骤2的具体工作要求和举例说明，可以分点列出希望在本步骤做哪些事情，需要完成什么阶段性的工作目标&quot;#&#125;&#123;#/InputSlot#&#125;<br><span class="hljs-section">### 第三步 &#123;#InputSlot placeholder=&quot;工作流程3标题&quot;#&#125;&#123;#/InputSlot#&#125;</span><br>&#123;#InputSlot placeholder=&quot;工作流程步骤3的具体工作要求和举例说明，可以分点列出希望在本步骤做哪些事情，需要完成什么阶段性的工作目标&quot;#&#125;&#123;#/InputSlot#&#125;<br><br>通过这样的对话，你可以&#123;#InputSlot placeholder=&quot;智能体工作目标再次强调&quot;#&#125;&#123;#/InputSlot#&#125;<br></code></pre></td></tr></table></figure><h3 id="提示词切入">提示词切入</h3><p>现在我们要完成整个智能体最核心的部分，在写提示此之前，我们可以从两方面——<strong>需求分析</strong>和<strong>任务流程</strong>。对于这个智能体，我们可能的需求如下：</p><ul><li>角色与语气<ul><li>角色：潜水社“面试官/招新负责人”，专业、礼貌。</li><li>语气：友好且结构化；必要时给出示例回答模板。</li></ul></li><li>目标与边界<ul><li>主要目标：评估用户，可以从用户的简历，用户之间的问答中评估，根据评估结果，判断用户是否适合加入潜水社（可以记录）</li></ul></li><li>输入与前置<ul><li>输入：（这里我们严格要求输入格式为以 markdown 语法书写的表格）简历。</li><li>关键信息字段：姓名/昵称、年龄段、联系方式、潜水证级别、潜水次数、近一年潜水/泳龄、健康申报、空闲时段、设备拥有情况、动机与期望。</li></ul></li><li>输出与记录<ul><li>面试结论：评估结果（百分制）</li><li>记录：将评估信息记录至数据库。</li></ul></li><li>对话策略<ul><li>询问简历内容</li><li>从题库中选择若干题目考研用户</li><li>轮换至用户询问潜水相关事项。</li></ul></li><li>知识与数据<ul><li>内置知识：社团介绍、活动类型与费用区间、装备清单、训练大纲、报名流程与时间表、常见问答和应试题目。</li><li>可配置项：报名链接、负责人联系方式、当期名额与日程。</li></ul></li><li>工具与插件（可选）<ul><li>搜索/日程查询：用于返回最近活动安排。</li><li>表单/表格写入：将面试结果落库（如 Coze 数据库或外部表格）。</li></ul></li><li>变量与记忆设计（示例）<ul><li>user_name, contact, cert_level, dive_count, swim_years, health_flags, available_slots, gear_owned, motivation, decision, next_step_deadline。</li></ul></li><li>安全与合规<ul><li>健康申报触发提示词保护：出现“心血管/耳鼻/手术/妊娠”等关键词时，统一给出风险提示与线下复核流程。</li></ul></li><li>评价指标<ul><li>信息完整度（关键字段覆盖率）、澄清轮次、对话时长、用户满意度、转化率（完成报名/加群）。</li></ul></li><li>失败与回退<ul><li>长篇无结构简历：先摘要后提取字段再逐项核对。</li><li>用户拒答敏感项：记录“未提供”并给出继续面试的影响说明与替代材料。</li></ul></li></ul><p>在制作任务流程前，我们先规范用户简历内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 字段         | 内容示例           | 说明                         |<br>|--------------|--------------------|------------------------------|<br>| 姓名    | 张三               | 必填                         |<br>| 年龄      | 18              | 必填     |<br>| 潜水证级别   | OW                 | 如无/OW/AOW/Rescue/DM等         |<br>| 潜水次数     | 20                 | 累计持证潜水次数             |<br>| 近一年潜水   | 5                  | 近一年内潜水次数             |<br>| 泳龄         | 3                  | 游泳年数                     |<br>| 健康申报     | 无重大疾病         | 如有特殊情况请注明           |<br>| 空闲时段     | 周末/寒暑假        | 可参与活动的主要时间         |<br>| 设备拥有情况 | 自有面镜、脚蹼     | 可多项填写                   |<br>| 动机与期望   | 结识同好，提升技能 | 简述加入社团的原因与期望     |<br></code></pre></td></tr></table></figure><p>示例潜水新手简历：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 字段         | 内容                         |<br>|--------------|----------------------------------|<br>| 姓名         | 李华                             |<br>| 年龄         | 19                               |<br>| 潜水证级别   | 无（参加过泳池体验）              |<br>| 潜水次数     | 2                                |<br>| 近一年潜水   | 1                                |<br>| 泳龄         | 4                                |<br>| 健康申报     | 无重大疾病（无心血管/癫痫/近期手术/妊娠等） |<br>| 空闲时段     | 周末上午、暑期可全日参与          |<br>| 设备拥有情况 | 面镜、脚蹼（无BCD/自备潜水服）     |<br>| 动机与期望   | 想学习基础潜水技能、结识潜水伙伴并参与周末开放水域活动 |<br></code></pre></td></tr></table></figure><p>然后，给出一个可能的任务流程</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/任务流程.png" alt="任务流程"><figcaption aria-hidden="true">任务流程</figcaption></figure></div><blockquote><p>上述流程图中的评估函数最终的结果需要 <span class="math inline">\(\in [0, 100]\)</span></p></blockquote><h2 id="初步制作">初步制作</h2><h3 id="添加文本知识">添加文本知识</h3><p>这里提供十道有关潜水的选择题</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 有关潜水的选择题</span><br><br><span class="hljs-bullet">1.</span> 下列哪项最能解释“中性浮力”的含义？  <br>   A. 身体自然下沉到海底  <br>   B. 不上浮也不下沉，保持所处深度  <br>   C. 只能缓慢上升  <br>   D. 只能缓慢下沉  <br>   答案：B<br><br><span class="hljs-bullet">2.</span> 水肺潜水中最主要的上升原则是：  <br>   A. 快速上升缩短潜水时间  <br>   B. 屏住呼吸加速上升  <br>   C. 缓慢、持续呼吸并控制上升速率  <br>   D. 关闭气源节省空气  <br>   答案：C<br><br><span class="hljs-bullet">3.</span> 为减少氮气减压病风险的常见做法是：  <br>   A. 深潜后立即乘飞机离开  <br>   B. 严格遵守潜水表或潜水电脑指示  <br>   C. 不做安全停留  <br>   D. 只靠主观感觉判断时间  <br>   答案：B<br><br><span class="hljs-bullet">4.</span> 下列哪种症状最可能与“耳压平衡不充分”相关？  <br>   A. 皮肤瘙痒  <br>   B. 耳朵疼痛或闷胀  <br>   C. 视力暂时模糊  <br>   D. 手指麻木  <br>   答案：B<br><br><span class="hljs-bullet">5.</span> 呼吸调节器一阶段的主要作用是：  <br>   A. 直接供气到口腔  <br>   B. 将高压瓶内气体降为中间压力  <br>   C. 过滤海水  <br>   D. 加热气体  <br>   答案：B<br><br><span class="hljs-bullet">6.</span> 下列哪项最可能导致“快速失温”？  <br>   A. 水温与体温接近  <br>   B. 穿着合适厚度的湿式或干式潜水服  <br>   C. 长时间静止在冷水中  <br>   D. 缓慢移动以减小阻力  <br>   答案：C<br><br><span class="hljs-bullet">7.</span> 使用富氧空气（Nitrox）的一个主要好处是：  <br>   A. 完全避免减压病  <br>   B. 延长无减压极限时间  <br>   C. 不需分析氧浓度  <br>   D. 可以无限制深潜  <br>   答案：B<br><br><span class="hljs-bullet">8.</span> 若同伴出现“气源耗尽”信号，应首先：  <br>   A. 把自己的第二头（备用二级头）递给对方  <br>   B. 迅速单独上升  <br>   C. 拍照留证  <br>   D. 关闭对方气瓶  <br>   答案：A<br><br><span class="hljs-bullet">9.</span> 潜水结束后建议避免立即乘飞机的主要原因是：  <br>   A. 机舱温度过低  <br>   B. 氧气浓度过高  <br>   C. 气压变化可能加剧体内残余氮扩散  <br>   D. 防止器材损坏  <br>   答案：C<br><br><span class="hljs-bullet">10.</span> 下列哪项不是良好“伙伴制度”行为？  <br><span class="hljs-code">    A. 共同进行潜水计划与检查  </span><br><span class="hljs-code">    B. 入水后互相确认状态  </span><br><span class="hljs-code">    C. 独自脱离队伍加速前行  </span><br><span class="hljs-code">    D. 及时共享位置与剩余气量  </span><br><span class="hljs-code">    答案：C</span><br></code></pre></td></tr></table></figure><p>然后，在<strong>功能面板</strong>中的<strong>知识</strong>模块，选择添加<strong>文本</strong>。接着按下图的顺序点击。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/创建知识.png" alt="创建知识"><figcaption aria-hidden="true">创建知识</figcaption></figure></div><p>然后我们会进入到如下界面，将上面的有关潜水知识的选择题复制，然后在桌面创建一个名字叫 <code>潜水选择题.md</code> 的文件，打开后粘贴进去，退出，再将这个文件上传即可。接着一直点下一步就行。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/上传文本知识.png" alt="上传文本知识"><figcaption aria-hidden="true">上传文本知识</figcaption></figure></div><p>按照上面流程，再创建 <code>潜水知识简答题</code> 和 <code>潜水社社团信息</code> 的<strong>文本知识</strong>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 潜水知识简答题</span><br><br><span class="hljs-bullet">1.</span> 请解释什么是“安全停留”，通常在什么深度与时长进行？其主要目的是什么？<br><br><span class="hljs-bullet">2.</span> 简述在下潜过程中进行耳压平衡的常用方法（至少两种），并说明为何需要频繁执行。<br><br><span class="hljs-bullet">3.</span> 说明导致减压病（DCS）的主要生理机制，并列出至少三条预防措施。<br><br><span class="hljs-bullet">4.</span> 在计划使用富氧空气（Nitrox）潜水时，需要进行哪三项关键检查或计算？简述其目的。<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 关于潜水社社团</span><br><br><span class="hljs-section">## 社团概述</span><br>潜水社致力于推广安全、规范、环保的休闲与技术潜水活动，构建学习交流与团队协作社区。核心价值：安全第一 / 持续学习 / 伙伴制度 / 海洋保护。<br><br><span class="hljs-section">## 主要活动</span><br><span class="hljs-bullet">-</span> 基础培训：浮力控制、装备认知、入门环境适应。<br><span class="hljs-bullet">-</span> 开放水域活动：近岸潜点、淡水水库、离岸船潜。<br><span class="hljs-bullet">-</span> 进阶工作坊：导航、夜潜、富氧、救援情景模拟。<br><span class="hljs-bullet">-</span> 学术交流：水下摄影、海洋生态、减压理论分享。<br><span class="hljs-bullet">-</span> 公益与环保：清洁行动、海洋生物记录、科普传播。<br><br><span class="hljs-section">## 参加条件</span><br><span class="hljs-bullet">-</span> 年龄：16周岁以上（未成年人需监护授权）。<br><span class="hljs-bullet">-</span> 证书：无证可参与体验池/浅水教学；开放水域需 OW 或同等级。<br><span class="hljs-bullet">-</span> 健康：无严重心血管/呼吸/耳鼻/癫痫等潜水禁忌；近期手术需恢复评估。<br><span class="hljs-bullet">-</span> 行为规范：遵守潜水计划、气量报告制度、拒绝单独脱离。<br><br><span class="hljs-section">## 装备策略</span><br><span class="hljs-bullet">-</span> 社团公用：气瓶、配重、部分调节器/BC、基础灯具。<br><span class="hljs-bullet">-</span> 个人建议：面镜、脚蹼、防寒服、电脑（进阶后）。<br><span class="hljs-bullet">-</span> 维护：每季度统一检修；发现故障及时标记停用。<br><br><span class="hljs-section">## 安全规则</span><br><span class="hljs-bullet">1.</span> 伙伴制度：入水前双人检查（气源、阀门、电脑、释放带）。<br><span class="hljs-bullet">2.</span> 上升控制：最大上升速率不超过 9–10 m/min；常规安全停留 3–5 min @ 5 m。<br><span class="hljs-bullet">3.</span> 气量下限：回收时主气瓶剩余不低于 50 bar（或按计划阈值）。<br><span class="hljs-bullet">4.</span> 失联处理：60 秒搜索后浮标标记并按预案返回。<br><span class="hljs-bullet">5.</span> 高风险触发：反复耳痛、异常疲劳、皮疹、关节痛 → 终止并建议医疗评估。<br><br><span class="hljs-section">## 培训路径示例</span><br>体验 → OW → AOW → Rescue → Nitrox / Navigation / Deep → 进阶：技术潜水（需额外体系评估）。<br><br><span class="hljs-section">## 常见问答</span><br><span class="hljs-bullet">-</span> Q: 没有证可以直接海边下水吗？  <br>  A: 需完成体验/入门课程并在教练监护下进行。<br><span class="hljs-bullet">-</span> Q: 富氧是否更安全？  <br>  A: 可延长无减压时间，但需分析氧分压与最大使用深度，防止氧毒性。<br><span class="hljs-bullet">-</span> Q: 何时可申请进阶船潜？  <br>  A: 通常完成 ≥6 次受控开放水域潜水且浮力表现稳定。<br><br><span class="hljs-section">## 环保倡议</span><br><span class="hljs-bullet">-</span> 不触碰/采集生物。<br><span class="hljs-bullet">-</span> 控制配重与踢蹼避免搅底。<br><span class="hljs-bullet">-</span> 参与年度海底垃圾清理与数据记录。<br><br><span class="hljs-section">## 行为与退出</span><br><span class="hljs-bullet">-</span> 违反安全条款两次 → 暂停参与高级活动。<br><span class="hljs-bullet">-</span> 恶意隐瞒健康风险 → 评估小组复核，必要时永久禁止。<br><br></code></pre></td></tr></table></figure><h3 id="添加用户变量">添加用户变量</h3><p>此外，根据我们要求的<strong>简历模版</strong>，添加几个<strong>用户变量</strong>。在<strong>记忆</strong>模块添加<strong>变量</strong>。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/添加变量.png" alt="添加变量"><figcaption aria-hidden="true">添加变量</figcaption></figure></div><h3 id="编写提示词">编写提示词</h3><p>根据我们的<strong>需求分析</strong>和<strong>任务流程</strong>，给出如下提示词。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 角色 </span><br>你是&#123;#InputSlot placeholder=&quot;角色设定，比如xx领域的专家&quot;#&#125;学校潜水社社团的智能面试官，你专业且礼貌&#123;#/InputSlot#&#125;<br>你的目标是&#123;#InputSlot placeholder=&quot;希望模型执行什么任务，达成什么目标&quot;#&#125;评估用户是否能加入潜水社&#123;#/InputSlot#&#125;<br><br>&#123;#以下可以采用先总括，再展开详细说明的方式，描述你希望智能体在每一个步骤如何进行工作，具体的工作步骤数量可以根据实际需求增删#&#125;<br><span class="hljs-section">## 工作步骤 </span><br><span class="hljs-bullet">1.</span> &#123;#InputSlot placeholder=&quot;工作流程1的一句话概括&quot;#&#125;评估用户简历，并打分（满分50）&#123;#/InputSlot#&#125; <br><span class="hljs-bullet">2.</span> &#123;#InputSlot placeholder=&quot;工作流程2的一句话概括&quot;#&#125;从潜水知识选择题知识库中随机挑选5道选择题提问用户，并评估，（一道题4分答错不得分）&#123;#/InputSlot#&#125; <br><span class="hljs-bullet">3.</span> &#123;#InputSlot placeholder=&quot;工作流程3的一句话概括&quot;#&#125;从潜水知识简答题知识库中随机挑选2道简答题提问用户，并评估，（一道题10分，主要评估内容合理性）&#123;#/InputSlot#&#125;<br><span class="hljs-bullet">4.</span> &#123;#InputSlot placeholder=&quot;工作流程3的一句话概括&quot;#&#125;允许用户询问关于潜水社事项，根据潜水社社团信息知识库回答&#123;#/InputSlot#&#125;<br><br><span class="hljs-section">### 第一步 &#123;#InputSlot placeholder=&quot;工作流程1标题&quot;#&#125;阅读用户简历&#123;#/InputSlot#&#125; </span><br><span class="hljs-bullet">1.</span> &#123;#InputSlot placeholder=&quot;工作流程步骤1的具体工作要求和举例说明，可以分点列出希望在本步骤做哪些事情，需要完成什么阶段性的工作目标&quot;#&#125;阅读用户简历信息，添加关于姓名、年龄、潜水证级别、潜水次数、近一年潜水、泳龄、健康申报、空闲时段、设备拥有情况、动机与期望的用户变量。&#123;#/InputSlot#&#125;<br><span class="hljs-bullet">2.</span> &#123;#InputSlot placeholder=&quot;工作流程步骤2的具体工作要求和举例说明，可以分点列出希望在本步骤做哪些事情，需要完成什么阶段性的工作目标&quot;#&#125;根据用户变量信息，满分50分的标准，评估用户并打分，其中如果“健康申报”变量，若用户此变量中存在重大疾病，则评估0分。&#123;#/InputSlot#&#125;<br><span class="hljs-section">### 第二步 &#123;#InputSlot placeholder=&quot;工作流程2标题&quot;#&#125;选择题考题&#123;#/InputSlot#&#125; </span><br>&#123;#InputSlot placeholder=&quot;工作流程步骤2的具体工作要求和举例说明，可以分点列出希望在本步骤做哪些事情，需要完成什么阶段性的工作目标&quot;#&#125;从潜水知识选择题知识库中随机挑选5道选择题提问用户，并评估，（一道题4分答错不得分）&#123;#/InputSlot#&#125;<br><span class="hljs-section">### 第三步 &#123;#InputSlot placeholder=&quot;工作流程3标题&quot;#&#125;简答题考题&#123;#/InputSlot#&#125;</span><br>&#123;#InputSlot placeholder=&quot;工作流程3的一句话概括&quot;#&#125;从潜水知识简答题知识库中随机挑选2道简答题提问用户，并评估，（一道题10分，此类型题目无标准答案，评估标准在于内容合理性）&#123;#/InputSlot#&#125;<br><span class="hljs-section">### 第四步 &#123;#InputSlot placeholder=&quot;工作流程3标题&quot;#&#125;用户询问潜水社社团信息&#123;#/InputSlot#&#125;</span><br>&#123;#InputSlot placeholder=&quot;工作流程3的一句话概括&quot;#&#125;允许用户询问关于潜水社事项，根据潜水社社团信息知识库回答&#123;#/InputSlot#&#125;<br>通过这样的对话，你可以&#123;#InputSlot placeholder=&quot;智能体工作目标再次强调&quot;#&#125;初步判断是否能够加入潜水社（需要用户的总评估分数大于60）&#123;#/InputSlot#&#125;<br></code></pre></td></tr></table></figure><blockquote><p>然后，我们调试。假设用户使用我们智能体时的工作流程就是我们的任务流程，也就是说，他严格地按<strong>提交简历</strong>、<strong>先后回答选择题和填空题</strong>、<strong>询问潜水社社团信息</strong>的顺序使用我们的智能体。</p></blockquote><h2 id="提示词优化评估函数">提示词优化——评估函数</h2><p>我们在提示词中定义了<strong>任务流程图</strong>中三个评估函数，但这些评估函数过于简单，不能够反映真实的评判标准，下面我们从提高评估函数的复杂度从而使我们的智能体更真实低评估。</p><p>重新分配评分指标：</p><ul><li><p>简历质量与匹配 — 60</p><ul><li>完整度（必填字段覆盖率）： 0–10</li><li>证书与潜水次数（经验）： 0–10</li><li>近一年活跃度/泳龄：0–5</li><li>装备/空闲时段匹配：0–5</li><li>动机与期望：25-30</li></ul></li><li><p>选择题（知识） — 20（5题，每题4分）</p></li><li><p>简答题（理解与表达） — 20（2题，每题0–10）</p><ol type="1"><li>正确性与核心要点 — 5 分<ul><li>回答是否包含题目要求的关键概念或结论，事实性错误扣分。</li></ul></li><li>完整性与结构 — 2 分<ul><li>是否覆盖了必要子项，逻辑清晰，有条理地展开。</li></ul></li><li>深度与举例 — 1.5 分<ul><li>有无合理解释、推理或恰当举例来支撑观点。</li></ul></li><li>表达与可读性 — 1.5 分<ul><li>语言简洁、术语使用恰当，避免歧义。</li></ul></li></ol></li></ul><p>仍然保留健康与安全规则：若健康申报含“心血管/癫痫/近期重大手术/妊娠/严重耳鼻疾患”等关键词：我们直接通知用户由于健康原因面试不通过，但仍允许用户询问关于潜水社信息。</p><p>根据我们最新的评估指标，同时我们优化提示词其它部分。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">## 角色  </span><br>你是学校潜水社的智能面试官，专业且礼貌。你的目标是评估用户是否能加入潜水社、给出分数和决定，并将评估结果记录到数据库。<br><br><span class="hljs-section">## 输入要求  </span><br>要求用户以&quot;简历模板&quot;形式提交简历，必须包含字段：姓名、年龄段、联系方式、潜水证级别、潜水次数、近一年潜水、泳龄、健康申报、空闲时段、设备拥有情况、动机与期望。若缺项，应标注为“未提供”，并由你提示用户补充。<br><br><span class="hljs-section">## 工作步骤  </span><br><span class="hljs-bullet">1.</span> 阅读并解析用户简历，抽取并保存变量。若信息不完整，先标注并提示用户按需补充。  <br><span class="hljs-bullet">2.</span> 简历评估（满分60）：按照子项加权评分并给出理由与子项得分。子项与评分范围：  <br><span class="hljs-bullet">   -</span> 完整度（必填字段覆盖率）： 0–10 <br><span class="hljs-bullet">   -</span> 证书与潜水次数（经验）： 0–10<br><span class="hljs-bullet">   -</span> 近一年活跃度/泳龄：0–5<br><span class="hljs-bullet">   -</span> 装备/空闲时段匹配：0–5<br><span class="hljs-bullet">   -</span> 动机与期望：25-30  <br>   若健康申报包含“心血管/癫痫/近期重大手术/妊娠/严重耳鼻疾患”等关键词，立即触发健康门控：面试不通过，简历得分视为0，但仍允许用户询问社团信息并记录原因。说明必须明确、礼貌并建议线下复核流程。<br><br><span class="hljs-bullet">3.</span> 选择题考核（满分20）：从知识库随机挑5题（不包含答案），每题4分，答错不得分。记录每题答对/答错及得分。告知用户回答格式为：1. [答案]；2. [答案]；3. [答案]；4. [答案]；5. [答案]。<br><br><span class="hljs-bullet">4.</span> 简答题考核（满分20）：从简答题知识库随机挑2题，每题0–10，按下列子评分项评价并给出每题详细评分与反馈：  <br><span class="hljs-bullet">   -</span> 正确性与核心要点 — 5 分  <br><span class="hljs-bullet">     -</span> 回答是否包含题目要求的关键概念或结论，事实性错误扣分。<br><span class="hljs-bullet">   -</span> 完整性与结构 — 2 分  <br><span class="hljs-bullet">     -</span> 是否覆盖了必要子项，逻辑清晰，有条理地展开。  <br><span class="hljs-bullet">   -</span> 深度与举例 — 1.5 分  <br><span class="hljs-bullet">     -</span> 有无合理解释、推理或恰当举例来支撑观点。<br><span class="hljs-bullet">   -</span> 表达与可读性 — 1.5 分  <br><span class="hljs-bullet">     -</span> 语言简洁、术语使用恰当，避免歧义。<br><br><span class="hljs-section">## 总分与决策  </span><br>将三部分分数相加得到总评分 ∈ [0,100]。阈值：总分 &gt; 60 判定为“初步通过”；≤ 60 判定为“不通过”。在健康门控触发时，直接判定“不通过”（总分记为0）并说明原因。<br><br><span class="hljs-section">## 输出格式（必须包含）  </span><br><span class="hljs-bullet">-</span> 当前已评估评分（百分制）  <br><span class="hljs-bullet">-</span> 已评估分项分数与简短评分理由（每项一句话）  <br><span class="hljs-bullet">-</span> 简答题详细反馈（每题给出各子项得分与改进建议）  <br><span class="hljs-bullet">-</span> 若未通过，给出改进建议与下一步（例如补充资料、参加培训、线下复核等）  <br><span class="hljs-bullet">-</span> 将评估记录（所有变量、答题记录、总分、结论、时间戳）写入数据库<br><br><span class="hljs-section">## 对话策略与边界  </span><br><span class="hljs-bullet">-</span> 若用户未按要求提交简历，先给出示例模板并要求按表格格式重新提交。  <br><span class="hljs-bullet">-</span> 对敏感健康信息如有疑义，建议线下医疗评估并标注“需复核”。  <br><span class="hljs-bullet">-</span> 允许用户在任一阶段询问社团信息，并基于知识库回答。  <br><span class="hljs-bullet">-</span> 不允许用户要求复议评分。<br><br><span class="hljs-section">## 交互风格  </span><br><span class="hljs-bullet">-</span> 专业、礼貌、结构化、简明。对评语给出具体改进点而非笼统评价。  <br><span class="hljs-bullet">-</span> 对所有评分动作均记录理由，便于复核与存档。<br></code></pre></td></tr></table></figure><h2 id="提示词优化应用工作流">提示词优化——应用工作流</h2><blockquote><p>工作流的调用由<strong>智能体</strong>完成，包括输入和查看输出。</p></blockquote><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/添加工作流.png" alt="添加工作流"><figcaption aria-hidden="true">添加工作流</figcaption></figure></div><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/创建工作流.png" alt="创建工作流"><figcaption aria-hidden="true">创建工作流</figcaption></figure></div><h3 id="process_resume">process_resume</h3><p>创建名字叫 process_resume，描述为：处理简历。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/添加节点并设置接口.png" alt="添加节点并设置接口"><figcaption aria-hidden="true">添加节点并设置接口</figcaption></figure></div><p>双击<strong>大模型</strong>节点。<strong>大模型</strong>节点有两个地方需要更改，第一处位于<strong>输入中的变量值</strong>，将这个变量值选择为<strong>开始</strong>节点的 <strong>input</strong>。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/简介处理的大模型节点.png" alt="简介处理的大模型节点"><figcaption aria-hidden="true">简介处理的大模型节点</figcaption></figure></div><p>第二处位于<strong>系统提示词</strong>，将下面 markdown 内容复制后粘贴到系统提示词中。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">## 内容</span><br><br>&#123;&#123;input&#125;&#125;<br><br><span class="hljs-section">## 你的任务</span><br><br>你的任务是处理用户发的简历，简历的形式不唯一，但一定会有关键字和内容，你需要将关键字和内容处理出来。<br><br><span class="hljs-section">## 你的回答格式</span><br><br>你的回答格式为列表，格式为，关键字：内容。<br></code></pre></td></tr></table></figure><p>然后，双击<strong>结束</strong>节点，右边<strong>输出变量中的变量值</strong>设置为<strong>大模型</strong>节点的输出 <strong>output</strong>。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/简介处理的结束节点.png" alt="简介处理的结束节点"><figcaption aria-hidden="true">简介处理的结束节点</figcaption></figure></div><p>最终，此工作流完成，点击<strong>右上角的发布</strong>，并添加到我们的智能体中。</p><h3 id="resume_evaluate">resume_evaluate</h3><blockquote><p>结构和第一个个工作流一致，唯一的不同在于<strong>大模型</strong>节点内的提示词。所以，你只需要<strong>重复</strong>第一个工作流的制作流程，然后把<strong>大模型</strong>节点中的<strong>系统提示词</strong>内容换成下面提示词即可。</p></blockquote><p>创建名字叫 resume_evaluate，描述为：简历评估，返回简历的评估分数。然后重复第一个个工作流的流程，新的<strong>系统提示词</strong>如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">## 内容</span><br><br>&#123;&#123;input&#125;&#125;<br><br><span class="hljs-section">## 评估细则</span><br><br>简历评估（满分60）：按照子项加权评分并给出理由与子项得分。子项与评分范围：  <br><span class="hljs-bullet">   -</span> 完整度（必填字段覆盖率）： 0–10 <br><span class="hljs-bullet">   -</span> 证书与潜水次数（经验）： 0–10<br><span class="hljs-bullet">   -</span> 近一年活跃度/泳龄：0–5<br><span class="hljs-bullet">   -</span> 装备/空闲时段匹配：0–5<br><span class="hljs-bullet">   -</span> 动机与期望：25-30  <br>   若健康申报包含“心血管/癫痫/近期重大手术/妊娠/严重耳鼻疾患”等关键词，立即触发健康门控：面试不通过，简历得分视为0，但仍允许用户询问社团信息并记录原因。说明必须明确、礼貌并建议线下复核流程。<br><br><span class="hljs-section">## 回答格式</span><br><br>评估细则+得分<br></code></pre></td></tr></table></figure><h3 id="essay_evaluate">essay_evaluate</h3><blockquote><p>结构和第一个个工作流一致，唯一的不同在于<strong>大模型</strong>节点内的提示词。所以，你只需要<strong>重复</strong>第一个工作流的制作流程，然后把<strong>大模型</strong>节点中的<strong>系统提示词</strong>内容换成下面提示词即可。</p></blockquote><p>创建名字叫 essay_evaluate，描述为：简单题评估，返回每道题目的评估分数。然后重复第一个个工作流的流程，新的<strong>系统提示词</strong>如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">## 内容</span><br><br>&#123;&#123;input&#125;&#125;<br><br><span class="hljs-section">## 考核标准</span><br><br>简答题考核（满分20）：每题0–10，按下列子评分项评价并给出每题详细评分与反馈：  <br><span class="hljs-bullet">   -</span> 正确性与核心要点 — 5 分  <br><span class="hljs-bullet">     -</span> 回答是否包含题目要求的关键概念或结论，事实性错误扣分。<br><span class="hljs-bullet">   -</span> 完整性与结构 — 2 分  <br><span class="hljs-bullet">     -</span> 是否覆盖了必要子项，逻辑清晰，有条理地展开。  <br><span class="hljs-bullet">   -</span> 深度与举例 — 1.5 分  <br><span class="hljs-bullet">     -</span> 有无合理解释、推理或恰当举例来支撑观点。<br><span class="hljs-bullet">   -</span> 表达与可读性 — 1.5 分  <br><span class="hljs-bullet">     -</span> 语言简洁、术语使用恰当，避免歧义。<br><br><span class="hljs-section">## 回答风格</span><br><br>[1]. 得分：XX，其中正确性与核心要点得分：XX，完整性与结构得分：XX，深度与举例得分：XX，表达与可读性得分：XX。<br>[2]. 得分：XX，其中正确性与核心要点得分：XX，完整性与结构得分：XX，深度与举例得分：XX，表达与可读性得分：XX。<br></code></pre></td></tr></table></figure><h3 id="最新提示词">最新提示词</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">## 角色  </span><br>你是学校潜水社的智能面试官，专业且礼貌。你的目标是评估用户是否能加入潜水社、给出分数和决定，并将评估结果记录到数据库。<br><br><span class="hljs-section">## 输入要求  </span><br>要求用户以&quot;简历模板&quot;形式提交简历，必须包含字段：姓名、年龄段、联系方式、潜水证级别、潜水次数、近一年潜水、泳龄、健康申报、空闲时段、设备拥有情况、动机与期望。若缺项，应标注为“未提供”，并由你提示用户补充。<br><br><span class="hljs-section">## 工作步骤  </span><br><span class="hljs-bullet">1.</span> 阅读并解析用户简历，先 &#123;&#123;process<span class="hljs-emphasis">_resume&#125;&#125;， 将分析结果展示出来，抽取并保存变量。若信息不完整，先标注并提示用户按需补充。  </span><br><span class="hljs-emphasis">2. 简历评估（满分60）：按照子项加权评分并给出理由与子项得分。再 &#123;&#123;resume_</span>evaluate&#125;&#125;<br><br><span class="hljs-bullet">3.</span> 选择题考核（满分20）：告知用户回答格式为：“选择题解答：1. [答案]；2. [答案]；3. [答案]；4. [答案]；5. [答案]。”从知识库随机挑5题（包括选项，不包含答案），每题4分，答错不得分。记录每题答对/答错及得分。<br><br><span class="hljs-bullet">4.</span> 简答题考核（满分20）：先从从简答题知识库随机挑2题，等用户回复后，再将题目以及用户的回答输入到 &#123;&#123;essay<span class="hljs-emphasis">_evaluate&#125;&#125;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">## 总分与决策  </span><br><span class="hljs-emphasis">将三部分分数相加得到总评分 ∈ [0,100]。阈值：总分 &gt; 60 判定为“初步通过”；≤ 60 判定为“不通过”。在健康门控触发时，直接判定“不通过”（总分记为0）并说明原因。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">## 输出格式（必须包含）  </span><br><span class="hljs-emphasis">- 当前已评估评分（百分制）  </span><br><span class="hljs-emphasis">- 已评估分项分数与简短评分理由（每项一句话）  </span><br><span class="hljs-emphasis">- 简答题详细反馈（每题给出各子项得分与改进建议）  </span><br><span class="hljs-emphasis">- 若未通过，给出改进建议与下一步（例如补充资料、参加培训、线下复核等）  </span><br><span class="hljs-emphasis">- 将评估记录（所有变量、答题记录、总分、结论、时间戳）写入数据库</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">## 对话策略与边界  </span><br><span class="hljs-emphasis">- 若用户未按要求提交简历，先给出示例模板并要求按表格格式重新提交。  </span><br><span class="hljs-emphasis">- 对敏感健康信息如有疑义，建议线下医疗评估并标注“需复核”。  </span><br><span class="hljs-emphasis">- 允许用户在任一阶段询问社团信息，并基于知识库回答。如果知识库中没有，则回答不知道  </span><br><span class="hljs-emphasis">- 不允许用户要求复议评分。</span><br><span class="hljs-emphasis">- 严格按照评估简历——选择题考核——简答题考核的顺序执行，每一阶段完成后才进入下一阶段的任务。</span><br><span class="hljs-emphasis">- 各个阶段调用各个阶段内的工作流，不允许乱调用工作流。</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">## 交互风格  </span><br><span class="hljs-emphasis">- 专业、礼貌、结构化、简明。对评语给出具体改进点而非笼统评价。  </span><br><span class="hljs-emphasis">- 对所有评分动作均记录理由，便于复核与存档。</span><br></code></pre></td></tr></table></figure><p>如何在提示词中添加工作流？在指定位置输入 <code>&#123;&#125;</code> 后，即可添加。最终提示词中的 <code>&#123;&#123;process_resume&#125;&#125;</code> 等不是规范的添加写法，如果你直接复制我的最终提示词，智能体不会调用工作流，你的做法应该是：粘贴后，手动将三个位置的 <code>&#123;&#123;&#125;&#125;</code> 内容全部删除，然后重新添加工作流。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/18/%E6%9D%82/Coze%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E4%BB%A5%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E6%88%98/在提示词中添加工作流.png" alt="在提示词中添加工作流"><figcaption aria-hidden="true">在提示词中添加工作流</figcaption></figure></div><h2 id="添加数据库可选">添加数据库（可选）</h2><p>补充内容：</p><p>添加面试记录数据库，字段名称如下：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>名称</th></tr></thead><tbody><tr class="odd"><td>user_name</td></tr><tr class="even"><td>age</td></tr><tr class="odd"><td>cert_level</td></tr><tr class="even"><td>dive_count</td></tr><tr class="odd"><td>last_year_dives</td></tr><tr class="even"><td>swim_years</td></tr><tr class="odd"><td>health_declaration</td></tr><tr class="even"><td>available_slots</td></tr><tr class="odd"><td>gear_owned</td></tr><tr class="even"><td>motivation</td></tr><tr class="odd"><td>total_rsume_score</td></tr><tr class="even"><td>completeness_score</td></tr><tr class="odd"><td>experience_score</td></tr><tr class="even"><td>recently_activity_score</td></tr><tr class="odd"><td>gear_schedule_score</td></tr><tr class="even"><td>motivation_score</td></tr><tr class="odd"><td>total_mcq_score</td></tr><tr class="even"><td>total_essay_score</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>假设检验</title>
    <link href="/2025/11/16/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"/>
    <url>/2025/11/16/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="假设">假设</h2><p>检验问题通常叙述成：在显著水平 <span class="math inline">\(\alpha\)</span> 下，检验假设</p><p><span class="math display">\[H_0: \mu = \mu_0, \quad H_1: \mu \neq \mu_0\]</span></p><p>也常说成“在显著性水平 <span class="math inline">\(\alpha\)</span> 下，针对 <span class="math inline">\(H_1\)</span> 检验 <span class="math inline">\(H_0\)</span>“，<span class="math inline">\(H_0\)</span> 称为<strong>原假设</strong>或<strong>零假设</strong>，<span class="math inline">\(H_1\)</span> 称为<strong>备择假设</strong>，我们要进行的工作是，根据样本，按上述检验方法做出决策在 <span class="math inline">\(H_0\)</span> 与 <span class="math inline">\(H_1\)</span> 两者之间接受其一。</p><p>当检验统计量取某个区域 <span class="math inline">\(C\)</span> 中的值时，我们拒绝原假设 <span class="math inline">\(H_0\)</span>，则称区域 <span class="math inline">\(C\)</span> 为<strong>拒绝域</strong>，拒绝域的边界点称为<strong>临界点</strong>。</p><p>由于检验法则是根据样本作出的，总有可能做出错误的决策，在假设 <span class="math inline">\(H_0\)</span> 实际上为真时，我们可能犯拒绝 <span class="math inline">\(H_0\)</span> 的错误，称这类“弃真”的错误为第 I 类错误，又当 <span class="math inline">\(H_0\)</span> 实际上不真时，我们也有可能接受 <span class="math inline">\(H_0\)</span>，称这类“取伪”的错误为第 II 类错误，犯第 II 类错误的概率记为</p><p><span class="math display">\[P\{当 H_0 不真时接受 H_0\} \quad 或 \quad P_{p \in H_1}\{接受 H_0\}\]</span></p><h2 id="显著性检验">显著性检验</h2><p>为此，在确定检验法则时，我们应尽可能使犯两类错误的概率都较小，但是，进一步讨论可知，一般来说，当样本容量固定，若减小犯一类错误的概率，则犯另一类错的概率往往增大；若要使犯两类错误的概率都减小，除非增加样本容量。在给定样本容量的情况下，一般来说，我们总是控制犯第 I 类错误的概率，使它不大于 <span class="math inline">\(\alpha\)</span>，<span class="math inline">\(\alpha\)</span> 的大小视具体情况而定，这种只对犯第 I 类错误的概率加以控制，而不考虑犯第 II 类错误的概率的检验，称为<strong>显著性检验</strong>。</p><h2 id="正态总体均值的假设检验">正态总体均值的假设检验</h2><h3 id="单个总体均值">单个总体均值</h3><ol type="1"><li><blockquote><p><span class="math inline">\(\sigma^2\)</span> 已知，关于 <span class="math inline">\(\mu\)</span> 的检验</p></blockquote><p>利用统计量 <span class="math inline">\(Z = \frac{\overline{X} - \mu_0}{\sigma / \sqrt{n}}\)</span></p></li><li><blockquote><p><span class="math inline">\(\sigma^2\)</span> 未知，关于 <span class="math inline">\(\mu\)</span> 的检验</p></blockquote><p><span class="math display">\[|t| = \bigg|\frac{\bar{x} - \mu_0}{s / \sqrt{n}}\bigg| \geq t_{\alpha / 2}(n - 1)\]</span></p></li></ol><h3 id="两个总体均值差">两个总体均值差</h3><ol type="1"><li><blockquote><p>两总体方差相同，两样本独立</p></blockquote><span class="math display">\[|t| = \frac{|(\bar{x} - \bar{y}) - \delta|}{s_w\sqrt{\frac{1}{n_1} + \frac{1}{n_2}}} \geq t_{\alpha / 2}(n_1 + n_2 - 2)\]</span></li></ol><h3 id="基于成对数据的检验">基于成对数据的检验</h3><p>一般，设有 <span class="math inline">\(n\)</span> 对相互独立的观察结果：<span class="math inline">\((X_1,Y_1),(X_2,Y_2),\dots,(X_n,Y_n)\)</span>。令</p><p><span class="math display">\[D_i = X_i - Y_i, \quad i=1,2,\dots,n.\]</span></p><p>由成对样本的构造，<span class="math inline">\(D_1, D_2, \dots, D_n\)</span> 相互独立；又由于它们由同一因素引起，通常可认为服从同一分布。今假设</p><p><span class="math display">\[D_i \sim N(\mu_D,\, \sigma_D^2), \quad i=1,2,\dots,n,\]</span></p><p>其中 <span class="math inline">\(\mu_D,\sigma_D^2\)</span> 未知。我们需要基于这一样本检验以下假设：</p><ol type="1"><li><span class="math inline">\(H_0: \mu_D = 0,\; H_1: \mu_D \neq 0\)</span>；</li><li><span class="math inline">\(H_0: \mu_D \le 0,\; H_1: \mu_D &gt; 0\)</span>；</li><li><span class="math inline">\(H_0: \mu_D \ge 0,\; H_1: \mu_D &lt; 0\)</span>。</li></ol><p>分别记 <span class="math inline">\(D_1, D_2, \dots, D_n\)</span> 的样本均值与样本方差的观察值为 <span class="math inline">\(\bar d,\ s_d^2\)</span>。按“单个正态总体均值的 <span class="math inline">\(t\)</span> 检验”（方差未知）可得下列统计量与拒绝域（显著性水平为 <span class="math inline">\(\alpha\)</span>）：</p><p><span class="math display">\[t = \frac{\bar d}{s_d/\sqrt{n}}, \qquad \text{在 } H_0 \text{ 下，} t \sim t(n-1).\]</span></p><p>对应三种备择假设，其拒绝域分别为：</p><p><span class="math display">\[\left|t\right| = \left|\frac{\bar d}{s_d/\sqrt{n}}\right| \ge t_{\alpha/2}(n-1) \quad (\text{双侧});\]</span></p><p><span class="math display">\[t = \frac{\bar d}{s_d/\sqrt{n}} \ge t_{\alpha}(n-1) \quad (\text{右侧});\]</span></p><p><span class="math display">\[t = \frac{\bar d}{s_d/\sqrt{n}} \le -\, t_{\alpha}(n-1) \quad (\text{左侧}).\]</span></p><h2 id="正态总体方差的假设检验">正态总体方差的假设检验</h2><h3 id="单个总体方差">单个总体方差</h3><p>设总体 <span class="math inline">\(X \sim N(\mu, \sigma^2)\)</span>，其中 <span class="math inline">\(\mu, \sigma^2\)</span> 均未知，<span class="math inline">\(X_1, X_2, \dots, X_n\)</span> 是来自 <span class="math inline">\(X\)</span> 的样本。要求在显著性水平 <span class="math inline">\(\alpha\)</span> 下检验假设：</p><p><span class="math display">\[H_0: \sigma^2 = \sigma_0^2, \quad H_1: \sigma^2 \neq \sigma_0^2,\]</span></p><p>其中 <span class="math inline">\(\sigma_0^2\)</span> 为已知常数。</p><p>由于 <span class="math inline">\(S^2\)</span> 是 <span class="math inline">\(\sigma^2\)</span> 的无偏估计，当 <span class="math inline">\(H_0\)</span> 为真时，观察值 <span class="math inline">\(s^2\)</span> 与 <span class="math inline">\(\sigma_0^2\)</span> 的比值 <span class="math inline">\(\frac{s^2}{\sigma_0^2}\)</span> 一般来说应在 1 附近摆动，而不应过分大于 1 或过分小于 1。根据抽样分布理论，当 <span class="math inline">\(H_0\)</span> 为真时，有</p><p><span class="math display">\[\frac{(n-1)S^2}{\sigma_0^2} \sim \chi^2(n-1).\]</span></p><p>我们取</p><p><span class="math display">\[\chi^2 = \frac{(n-1)S^2}{\sigma_0^2}\]</span></p><p>作为检验统计量。对于双侧检验问题，其拒绝域具有以下形式：</p><p><span class="math display">\[\frac{(n-1)s^2}{\sigma_0^2} \le k_1 \quad \text{或} \quad \frac{(n-1)s^2}{\sigma_0^2} \ge k_2.\]</span></p><p>此处 <span class="math inline">\(k_1, k_2\)</span> 的值由下式确定：</p><p><span class="math display">\[P\{\text{当 } H_0 \text{ 为真时拒绝 } H_0\} = P_{\sigma_0^2}\left\{ \left(\frac{(n-1)S^2}{\sigma_0^2} \le k_1\right) \cup \left(\frac{(n-1)S^2}{\sigma_0^2} \ge k_2\right) \right\} = \alpha.\]</span></p><p>为计算方便起见，习惯上取</p><p><span class="math display">\[P_{\sigma_0^2}\left\{ \frac{(n-1)S^2}{\sigma_0^2} \le k_1 \right\} = \frac{\alpha}{2}, \quad P_{\sigma_0^2}\left\{ \frac{(n-1)S^2}{\sigma_0^2} \ge k_2 \right\} = \frac{\alpha}{2}.\]</span></p><p>故得 <span class="math inline">\(k_1 = \chi_{1-\alpha/2}^2(n-1), k_2 = \chi_{\alpha/2}^2(n-1)\)</span>。于是得到拒绝域为</p><p><span class="math display">\[\frac{(n-1)s^2}{\sigma_0^2} \le \chi_{1-\alpha/2}^2(n-1) \quad \text{或} \quad \frac{(n-1)s^2}{\sigma_0^2} \ge \chi_{\alpha/2}^2(n-1).\]</span></p><p>下面来求单边检验问题（显著性水平为 <span class="math inline">\(\alpha\)</span>）</p><p><span class="math display">\[H_0: \sigma^2 \le \sigma_0^2, \quad H_1: \sigma^2 &gt; \sigma_0^2\]</span></p><p>的拒绝域。因 <span class="math inline">\(H_0\)</span> 中的全部 <span class="math inline">\(\sigma^2\)</span> 都比 <span class="math inline">\(H_1\)</span> 中的 <span class="math inline">\(\sigma^2\)</span> 要小，当 <span class="math inline">\(H_1\)</span> 为真时，<span class="math inline">\(S^2\)</span> 的观察值 <span class="math inline">\(s^2\)</span> 往往偏大，因此拒绝域的形式为 <span class="math inline">\(s^2 \ge k\)</span>。要控制 <span class="math inline">\(P\{\text{当 } H_0 \text{ 为真时拒绝 } H_0\} \le \alpha\)</span>，只需令</p><p><span class="math display">\[P_{\sigma^2 \le \sigma_0^2}\{S^2 \ge k\} = P_{\sigma^2 \le \sigma_0^2}\left\{ \frac{(n-1)S^2}{\sigma^2} \ge \frac{(n-1)k}{\sigma^2} \right\} \le P_{\sigma^2 \le \sigma_0^2}\left\{ \frac{(n-1)S^2}{\sigma^2} \ge \frac{(n-1)k}{\sigma_0^2} \right\} = \alpha.\]</span></p><p>因 <span class="math inline">\(\frac{(n-1)S^2}{\sigma^2} \sim \chi^2(n-1)\)</span>，可得</p><p><span class="math display">\[\frac{(n-1)k}{\sigma_0^2} = \chi_\alpha^2(n-1).\]</span></p><p>于是 <span class="math inline">\(k = \frac{\sigma_0^2}{n-1}\chi_\alpha^2(n-1)\)</span>，得检验问题的拒绝域为</p><p><span class="math display">\[s^2 \ge \frac{\sigma_0^2}{n-1}\chi_\alpha^2(n-1),\]</span></p><p>即</p><p><span class="math display">\[\chi^2 = \frac{(n-1)s^2}{\sigma_0^2} \ge \chi_\alpha^2(n-1).\]</span></p><p>类似地，可得左边检验问题</p><p><span class="math display">\[H_0: \sigma^2 \ge \sigma_0^2, \quad H_1: \sigma^2 &lt; \sigma_0^2\]</span></p><p>的拒绝域为</p><p><span class="math display">\[\chi^2 = \frac{(n-1)s^2}{\sigma_0^2} \le \chi_{1-\alpha}^2(n-1).\]</span></p><p>以上检验法称为 <span class="math inline">\(\chi^2\)</span> <strong>检验法</strong>。</p><h3 id="两个总体的方差差">两个总体的方差差</h3><p>设 <span class="math inline">\(X_1, X_2, \dots, X_{n_1}\)</span> 来自正态总体 <span class="math inline">\(N(\mu_1, \sigma_1^2)\)</span>，<span class="math inline">\(Y_1, Y_2, \dots, Y_{n_2}\)</span> 来自正态总体 <span class="math inline">\(N(\mu_2, \sigma_2^2)\)</span>，且两样本独立。记两样本的样本方差分别为 <span class="math inline">\(S_1^2, S_2^2\)</span>，并设 <span class="math inline">\(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2\)</span> 均未知。现需在显著性水平 <span class="math inline">\(\alpha\)</span> 下检验：</p><p><span class="math display">\[H_0: \sigma_1^2 \le \sigma_2^2, \qquad H_1: \sigma_1^2 &gt; \sigma_2^2.\]</span></p><p>当 <span class="math inline">\(H_0\)</span> 为真时，有 <span class="math inline">\(E(S_1^2) = \sigma_1^2 \le \sigma_2^2 = E(S_2^2)\)</span>；当 <span class="math inline">\(H_1\)</span> 为真时，<span class="math inline">\(\displaystyle \frac{S_1^2}{S_2^2}\)</span> 往往偏大，故可取拒绝域形如</p><p><span class="math display">\[\frac{S_1^2}{S_2^2} \ge k.\]</span></p><p>常数 <span class="math inline">\(k\)</span> 的确定：要求 <span class="math inline">\(P\{\text{当 } H_0 \text{ 为真时拒绝 } H_0\} \le \alpha\)</span>，只需令</p><p><span class="math display">\[P_{\sigma_1^2 \le \sigma_2^2}\!\left\{ \frac{S_1^2}{S_2^2} \ge k \right\}\;\le\; P_{\sigma_1^2/\sigma_2^2 \le 1}\!\left\{ \frac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2} \ge k \right\} = \alpha.\]</span></p><p>由抽样分布定理知</p><p><span class="math display">\[\frac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2} \sim F(n_1-1,\, n_2-1),\]</span></p><p>故取 <span class="math inline">\(k = F_{\alpha}(n_1-1,\, n_2-1)\)</span>（<span class="math inline">\(F_{\alpha}(\nu_1,\nu_2)\)</span> 表示自由度 <span class="math inline">\(\nu_1,\nu_2\)</span> 的 <span class="math inline">\(F\)</span> 分布上侧 <span class="math inline">\(\alpha\)</span> 分位数）。于是检验的拒绝域为</p><p><span class="math display">\[F = \frac{s_1^2}{s_2^2} \ge F_{\alpha}(n_1-1,\, n_2-1).\]</span></p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>参数估计</title>
    <link href="/2025/11/15/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"/>
    <url>/2025/11/15/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="点估计">点估计</h2><p>点估计问题一般提法如下：设总体 <span class="math inline">\(X\)</span> 的分布函数 <span class="math inline">\(F(x; \theta)\)</span> 的形式为已知；<span class="math inline">\(\theta\)</span> 是待估参数，<span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是 <span class="math inline">\(X\)</span> 的一个样本，<span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 是相应的一个样本值，<strong>点估计问题就是要构造一个适当的统计量</strong> <span class="math inline">\(\hat{\theta}(X_1, X_2, \cdots, X_n)\)</span>，用它的观察值 <span class="math inline">\(\hat{\theta}(x_1, x_2, \cdots, x_n)\)</span> 作为未知参数 <span class="math inline">\(\theta\)</span> 的近似值，我们称 <span class="math inline">\(\hat{\theta}(X_1, X_2, \cdots, X_n)\)</span> 为 <span class="math inline">\(\theta\)</span> 的<strong>估计量</strong>，称 <span class="math inline">\(\hat{\theta}(x_1, x_2, \cdots, x_n)\)</span> 为 <span class="math inline">\(\theta\)</span> 的估计值。在不混淆的情况下统称估计量和估计值为<strong>估计</strong>，并都简记为 <span class="math inline">\(\hat{\theta}\)</span>。</p><h2 id="矩估计">矩估计</h2><p>设 <span class="math inline">\(X\)</span> 为连续型随机变量，其概率密度为 <span class="math inline">\(f(x; \theta_1, \theta_2, \cdots, \theta_k)\)</span>，或 <span class="math inline">\(X\)</span> 为离散型随机变量。其分布律为 <span class="math inline">\(P\{X = x\} = p(x; \theta_1, \theta_2, \cdots, \theta_k)\)</span>，其中 <span class="math inline">\(\theta_1\)</span>，<span class="math inline">\(\theta_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(\theta_{k}\)</span> 为待估参数 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是来自 <span class="math inline">\(X\)</span> 的样本，假设总体 <span class="math inline">\(X\)</span> 的前 <span class="math inline">\(k\)</span> 阶矩</p><p><span class="math display">\[\begin{aligned}\mu_l &amp;= E(X^l) = \int_{-\infty}^{\infty} x^l f(x; \theta_1, \theta_2, \cdots, \theta_k) \text{d}x\\&amp;= \sum_{x \in R_X} x^l p(x; \theta_1, \theta_2, \cdots, \theta_k)\end{aligned}\]</span></p><p>存在，其中，<span class="math inline">\(R_X\)</span> 是 <span class="math inline">\(X\)</span> 可能取汁的范围，<span class="math inline">\(l = 1, 2, \cdots, k\)</span>，一般来说，它们是 <span class="math inline">\(\theta_1\)</span>，<span class="math inline">\(\theta_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(\theta_{k}\)</span> 的函数，基于样本矩</p><p><span class="math display">\[A_l = \frac{1}{n} \sum_{i = 1}^{n} X_{i}^{l}\]</span></p><p>依概率收敛于相应的总体矩 <span class="math inline">\(\mu_{l}(l = 1, 2, \cdots, k)\)</span>，样本矩的连续函数依概率收敛于相应的总体矩的连续函数，我们就用样本矩作为相应的总体矩的估计量，而以样本矩的连续函数作为相应的总体矩的连续函数的估计量，这种估计方法称为<strong>矩估计</strong>，矩估计的具体做法如下：设</p><p><span class="math display">\[\begin{cases}\mu_1 &amp;= \mu_1(\theta_1, \theta_2, \cdots, \theta_k)\\\mu_2 &amp;= \mu_2(\theta_1, \theta_2, \cdots, \theta_k)\\\cdots\\\mu_k &amp;= \mu_k(\theta_1, \theta_2, \cdots, \theta_k)\end{cases}\]</span></p><p>解方程得出 <span class="math inline">\(\theta_1\)</span>，<span class="math inline">\(\theta_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(\theta_{k}\)</span> 的表达式，即 <span class="math inline">\(\theta_i = \theta_i (\mu_1, \mu_2, \cdots, \mu_k)\)</span>，再以 <span class="math inline">\(A_i\)</span> 分别代替 <span class="math inline">\(\mu_i\)</span>，得 <span class="math inline">\(\hat{\theta_i} = \theta_i(A_1, A_2, \cdots, A_k), i = 1, 2, \cdots, k\)</span> 分别作为 <span class="math inline">\(\theta_i\)</span> 的估计量。</p><h2 id="最大似然估计">最大似然估计</h2><p>若总体 <span class="math inline">\(X\)</span> 属离散型，其分布律 <span class="math inline">\(P\{X = x\} = p(x; \theta), \theta \in \Theta\)</span> 的形式为已知，<span class="math inline">\(\theta\)</span> 为待估参数，<span class="math inline">\(\Theta\)</span> 是 <span class="math inline">\(\theta\)</span> 可能取值的范围，设 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是来自 <span class="math inline">\(X\)</span> 的样本，则 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 的联合分布律为</p><p><span class="math display">\[\prod_{i = 1}^{n} p(x_i; \theta)\]</span></p><p>又设 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 是相应于样本 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 的一个样本值，易知样本 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 取到观察值 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 的概率，亦即事件 <span class="math inline">\(\{X_1 = x_1, X_2 = x_2, \cdots, X_n = x_n\}\)</span> 发生的概率为</p><p><span class="math display">\[L(\theta) = L(x_1, x_2, \cdots, x_n; \theta) = \prod_{i = 1}^{n} p(x_i; \theta), \quad \theta \in \Theta\]</span></p><p>这一概率随 <span class="math inline">\(\theta\)</span> 的取值而变化，它是 <span class="math inline">\(\theta\)</span> 的函数，<span class="math inline">\(L(\theta)\)</span> 称为样本的<strong>似然函数</strong>。</p><p>接下来，我们固定样本观察值 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span>，在 <span class="math inline">\(\Theta\)</span> 内挑选使似然函数达到最大的参数值 <span class="math inline">\(\hat{\theta}\)</span>，作为参数 <span class="math inline">\(\theta\)</span> 的估计值，即取 <span class="math inline">\(\hat{\theta}\)</span> 使</p><p><span class="math display">\[L(x_1, x_2, \cdots, x_n; \hat{\theta}) = \max_{\theta \in \Theta} L(x_1, x_2, \cdots, x_n; \theta)\]</span></p><p>这样得到的 <span class="math inline">\(\hat{\theta}\)</span> 与样本值 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 有关，常记为 <span class="math inline">\(\hat{\theta}(x_1, x_2, \cdots, x_n)\)</span>，称为参数 <span class="math inline">\(\theta\)</span> 的<strong>最大似然估计值</strong>，而相应的统计量 <span class="math inline">\(\hat{\theta}(X_1, X_2, \cdots, X_n)\)</span> 称为参数 <span class="math inline">\(\theta\)</span> 的<strong>最大似然估计量</strong>。</p><p>若总体 <span class="math inline">\(X\)</span> 属连续型，其概率密度 <span class="math inline">\(f(x; \theta), \theta \in \Theta\)</span> 的形式已知，<span class="math inline">\(\theta\)</span> 为待估参数，<span class="math inline">\(\Theta\)</span> 是 <span class="math inline">\(\theta\)</span> 可能取值的范围，设 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是来自 <span class="math inline">\(X\)</span> 的样本，则 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 的联合概率密度为</p><p><span class="math display">\[\prod_{i = 1}^{n} f(x_i; \theta)\]</span></p><p>设 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 是相应于样本 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 的一个样本值，则随机点 <span class="math inline">\((X_1, X_2, \cdots, X_n)\)</span> 落在点 <span class="math inline">\((x_1, x_2, \cdots, x_n)\)</span> 的领域（边长分别为 <span class="math inline">\(\text{d}x_1\)</span>，<span class="math inline">\(\text{d}x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(\text{d}x_n\)</span> 的 <span class="math inline">\(n\)</span> 维立方体）内的概率近似地为</p><p><span class="math display">\[\prod_{i = 1}^{n} f(x_i; \theta) \text{d}x_i\]</span></p><p>其值随 <span class="math inline">\(\theta\)</span> 的取值而变化，与离散型情况一样，我们取 <span class="math inline">\(\theta\)</span> 的估计值 <span class="math inline">\(\hat{\theta}\)</span> 使概率式取到最大值，但因子 <span class="math inline">\(\prod\limits_{i = 1}^{n} \text{d}x_i\)</span> 不随 <span class="math inline">\(\theta\)</span> 而变，故只需要考虑函数</p><p><span class="math display">\[L(\theta) = L(x_1, x_2, \cdots, x_n; \theta) = \prod_{i = 1}^{n} f(x_i; \theta)\]</span></p><p>的最大值。这里 <span class="math inline">\(L(\theta)\)</span> 称为样本的<strong>似然函数</strong>，若</p><p><span class="math display">\[L(x_1, x_2, \cdots, x_n; \hat{\theta}) = \max_{\theta \in \Theta} L(x_1, x_2, \cdots, x_n; \theta)\]</span></p><p>则称 <span class="math inline">\(\hat{\theta}(x_1, x_2, \cdots, x_n)\)</span> 为 <span class="math inline">\(\theta\)</span> 的<strong>最大似然估计值</strong>，称 <span class="math inline">\(\hat{\theta}(X_1, X_2, \cdots, X_n)\)</span> 为 <span class="math inline">\(\theta\)</span> 的<strong>最大似然估计量</strong>。</p><blockquote><p>我们得到了两种类型：离散型和连续性，的似然函数，接下来，将 <span class="math inline">\(\theta\)</span> 视为自变量，求其最大值点 <span class="math inline">\(\hat{\theta}\)</span>。</p></blockquote><h2 id="估计量的评选标准">估计量的评选标准</h2><h3 id="无偏性">无偏性</h3><p>若估计量 <span class="math inline">\(\theta = \theta(X_1, X_2, \cdots, X_n)\)</span> 的数学期望 <span class="math inline">\(E(\theta)\)</span> 存在，且对于任意 <span class="math inline">\(\theta \in \Theta\)</span> 有</p><p><span class="math display">\[E(\hat{\theta}) = \theta\]</span></p><p>则称 <span class="math inline">\(\hat{\theta}\)</span> 是 <span class="math inline">\(\theta\)</span> 的<strong>无偏估计量</strong>。</p><h3 id="有效性">有效性</h3><p>设 <span class="math inline">\(\hat{\theta_1} = \hat{\theta_1}(X_1, X_2, \cdots, X_n)\)</span> 与 <span class="math inline">\(\hat{\theta_2} = \hat{\theta_2} (X_1, X_2, \cdots, X_n)\)</span> 都是 <span class="math inline">\(\theta\)</span> 的无偏估计量，若对于任意 <span class="math inline">\(\theta \in \Theta\)</span>，有</p><p><span class="math display">\[D(\hat{\theta_1}) \leq D(\hat{\theta_2})\]</span></p><p>且至少对于某一个 <span class="math inline">\(\theta \in \Theta\)</span> 上式中的不等号成立，则称 <span class="math inline">\(\hat{\theta_1}\)</span> 较 <span class="math inline">\(\hat{\theta_2}\)</span> <strong>有效</strong>。</p><h3 id="相合性">相合性</h3><p>设 <span class="math inline">\(\hat{\theta}(X_1, X_2, \cdots, X_n)\)</span> 为参数 <span class="math inline">\(\theta\)</span> 的估计量，若对于任意 <span class="math inline">\(\theta \in \Theta\)</span>，当 <span class="math inline">\(n \to \infty\)</span> 时 <span class="math inline">\(\hat{\theta}(X_1, X_2, \cdots, X_n)\)</span> 依概率收敛于 <span class="math inline">\(\theta\)</span>，则称 <span class="math inline">\(\hat{\theta}\)</span> 为 <span class="math inline">\(\theta\)</span> 的<strong>相合估计量</strong>。</p><p>即，若对于任意 <span class="math inline">\(\theta \in \Theta\)</span> 都满足：对于任意 <span class="math inline">\(\varepsilon &gt; 0\)</span>，有</p><p><span class="math display">\[\lim_{n \to \infty} P\{|\hat{\theta} - \theta| &lt; \varepsilon\} = 1\]</span></p><p>则称 <span class="math inline">\(\hat{\theta}\)</span> 是 <span class="math inline">\(\theta\)</span> 的<strong>相合估计量</strong>。</p><h2 id="区间估计">区间估计</h2><h3 id="置信区间">置信区间</h3><p>设总体 <span class="math inline">\(X\)</span> 的分布函数 <span class="math inline">\(F(x; \theta)\)</span> 含有一个未知参数 <span class="math inline">\(\theta\)</span>，<span class="math inline">\(\theta \in \Theta\)</span>，对于给定值 <span class="math inline">\(0 &lt; \alpha &lt; 1\)</span>，若由来自 <span class="math inline">\(X\)</span> 的样本 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 确定的两个统计量 <span class="math inline">\(\utilde{\theta} = \utilde{\theta}(X_1, X_2, \cdots, X_n)\)</span> 和 <span class="math inline">\(\bar{\theta} = \bar{\theta}(X_1, X_2, \cdots, X_n)(\utilde{\theta} &lt; \bar{\theta})\)</span>，对于任意 <span class="math inline">\(\theta \in \Theta\)</span> 满足</p><p><span class="math display">\[P\{\utilde{\theta}(X_1, X_2, \cdots, X_n) &lt; \theta &lt; \bar{\theta}(X_1, X_2, \cdots, X_n)\} \geq 1 - \alpha\]</span></p><p>则称随机区间 <span class="math inline">\((\utilde{\theta}, \bar{\theta})\)</span> 是 <span class="math inline">\(\theta\)</span> 的置信水平为 <span class="math inline">\(\utilde{\theta}\)</span> 和 <span class="math inline">\(\bar{\theta}\)</span> 分别称为置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的双侧置信区间的<strong>置信下限</strong>和<strong>置信上限</strong>，<span class="math inline">\(1 - \alpha\)</span> 称为<strong>置信水平</strong>。</p><h3 id="枢轴量">枢轴量</h3><p>设总体参数为 <span class="math inline">\(\theta\)</span>，样本统计量为 <span class="math inline">\((X_1, X_2, \cdots, X_n)\)</span>，如果一个函数 <span class="math inline">\(Q(X_1, X_2, \cdots, X_n; \theta)\)</span> 满足以下条件：</p><ol type="1"><li>它是样本数据和参数 <span class="math inline">\(\theta\)</span> 的函数；</li><li>在样本分布已知的情况下，其分布不依赖于未知参数 <span class="math inline">\(\theta\)</span>。</li></ol><p>那么，<span class="math inline">\(Q\)</span> 就成为一个<strong>枢轴量</strong>。</p><h2 id="正态总体均值与方差的区间估计">正态总体均值与方差的区间估计</h2><h3 id="单个总体的情况">单个总体的情况</h3><p>设已给定置信水平为 <span class="math inline">\(1 - \alpha\)</span>，并设 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 为总体 <span class="math inline">\(N(\mu, \sigma^2)\)</span> 的样本，<span class="math inline">\(\overline{X}\)</span>，<span class="math inline">\(S^2\)</span> 分别是样本均值和样本方差。</p><ol type="1"><li><blockquote><p>均值 <span class="math inline">\(\mu\)</span> 的置信区间</p></blockquote><p>若 <span class="math inline">\(\sigma^2\)</span> 已知，一个置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的置信区间为</p><p><span class="math display">\[\bigg(\overline{X} \pm \frac{\sigma}{\sqrt{n}} z_{\alpha / 2}\bigg)\]</span></p><p>若 <span class="math inline">\(\sigma^2\)</span> 未知，一个置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的置信区间为</p><p><span class="math display">\[\bigg(\overline{X} \pm \frac{S}{\sqrt{n}} t_{\alpha / 2}(n - 1)\bigg)\]</span></p></li><li><blockquote><p>方差 <span class="math inline">\(\sigma^2\)</span> 的置信区间</p></blockquote><p>一个置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的置信区间</p><p><span class="math display">\[\bigg(\frac{(n - 1)S^2}{\chi_{\alpha / 2}^2 (n - 1)}, \frac{(n - 1)S^2}{\chi_{1 - \alpha / 2}^2(n - 1)}\bigg)\]</span></p></li></ol><h3 id="两个总体的情况">两个总体的情况</h3><ol type="1"><li><blockquote><p>两个总体均值差 <span class="math inline">\(\mu_1 - \mu_2\)</span> 的置信区间</p></blockquote><p><span class="math inline">\(\sigma_1^2\)</span>，<span class="math inline">\(\sigma_2^2\)</span> 均为已知，一个置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的置信区间为</p><p><span class="math display">\[\bigg(\overline{X} - \overline{Y} \pm z_{\alpha / 2} \sqrt{\frac{\sigma_1^2}{n_1} + \frac{\sigma_2^2}{n_2}}\bigg)\]</span></p><p><span class="math inline">\(\sigma_1^2 = \sigma_2^2 = \sigma^2\)</span>，但 <span class="math inline">\(\sigma^2\)</span> 未知，一个置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的置信区间为</p><p><span class="math display">\[\bigg(\overline{X} - \overline{Y} \pm t_{\alpha / 2} (n_1 + n_2 - 2) \frac{(n_1 - 1)S_1^2 + (n_2 - 1)S_2^2}{n_1 + n_2 - 2}\sqrt{\frac{1}{n_1} + \frac{1}{n_2}}\bigg)\]</span></p></li><li><blockquote><p>两个总体方差比 <span class="math inline">\(\sigma_1^2 / \sigma_2^2\)</span> 的置信区间</p></blockquote><p>假设总体均值未知，则一个置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的置信区间为</p><p><span class="math display">\[\bigg(\frac{S_1^2}{S_2^2}\frac{1}{F_{\alpha / 2}(n_1 - 1, n_2 - 1)}, \frac{S_1^2}{S_2^2}\frac{1}{F_{1 - \alpha / 2}(n_1 - 1, n_2 - 1)}\bigg)\]</span></p></li></ol><h2 id="分布参数的区间估计">(0-1) 分布参数的区间估计</h2><p>设有一容量为 <span class="math inline">\(n &gt; 50\)</span> 的大样本，它来自 (0-1) 分布的总体 <span class="math inline">\(X\)</span>，<span class="math inline">\(X\)</span> 的分布律为</p><p><span class="math display">\[f(x; p) = p^x(1 - p)^{1 - x}, \quad x = 0, 1\]</span></p><p>其中 <span class="math inline">\(p\)</span> 为未知参数，求 <span class="math inline">\(p\)</span> 的置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的置信区间。</p><p>已知 (0-1) 分布的均值和方差分别为</p><p><span class="math display">\[u = p, \quad \sigma^2 = p(1 - p)\]</span></p><p>设 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是一个样本，由中心极限定理知</p><p><span class="math display">\[\frac{\sum_{i = 1}^{n} X_i - np}{\sqrt{np(1 - p)}} = \frac{n\overline{X} - np}{\sqrt{np(1 - p)}} \sim N(0, 1)\]</span></p><p>于是有</p><p><span class="math display">\[P\bigg\{-z_{\alpha / 2} &lt; \frac{n\overline{X} - np}{\sqrt{np(1 - p)}} &lt; z_{alpha / 2}\bigg\} \approx 1 - \alpha\]</span></p><p>而中间不等式等价于</p><p><span class="math display">\[(n + z_{\alpha / 2}^2 p^2 - (2n \overline{X} + z_{\alpha / 2}^2)p + n\overline{X}^2) &lt; 0\]</span></p><p>记</p><p><span class="math display">\[\begin{aligned}p_1 &amp;= \frac{1}{2a} (-b - \sqrt{b^2 - 4ac})\\p_2 &amp;= \frac{1}{2a} (-b + \sqrt{b^2 - 4ac})\end{aligned}\]</span></p><p>即置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的置信区间为 <span class="math inline">\((p_1, p_2)\)</span>。</p><h2 id="单侧置信区间">单侧置信区间</h2><p>对于给定值 <span class="math inline">\(0 &lt; \alpha &lt; 1\)</span>，若由样本 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 确定的统计量 <span class="math inline">\(\utilde{\theta} = \utilde{\theta}(X_1, X_2, \cdots, X_n)\)</span>，对于任意 <span class="math inline">\(\theta \in \Theta\)</span> 满足</p><p><span class="math display">\[P\{\theta &gt; \utilde{\theta}\} \geq 1 - \alpha\]</span></p><p>称随机区间 <span class="math inline">\((\utilde{\theta}, \infty)\)</span> 是 <span class="math inline">\(\theta\)</span> 的置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的<strong>单侧置信区间</strong>，<span class="math inline">\(\utilde{\theta}\)</span> 称为 <span class="math inline">\(\theta\)</span> 的置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的<strong>单侧置信下线</strong>。</p><p>又若统计量 <span class="math inline">\(\bar{\theta} = \bar{\theta}(X_1, X_2, \cdots, X_n)\)</span>，对于任意 <span class="math inline">\(\theta \in \Theta\)</span> 满足</p><p><span class="math display">\[P\{\theta &lt; \bar{\theta}\} \geq 1 - \alpha\]</span></p><p>称随机区间 <span class="math inline">\((-\infty, \bar{\theta})\)</span> 是 <span class="math inline">\(\theta\)</span> 置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的<strong>单侧置信区间</strong>，<span class="math inline">\(\bar{\theta}\)</span> 称为 <span class="math inline">\(\theta\)</span> 的置信水平为 <span class="math inline">\(1 - \alpha\)</span> 的<strong>单侧置信上限</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>样本及抽样分布</title>
    <link href="/2025/11/14/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"/>
    <url>/2025/11/14/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="总体个体容量">总体个体容量</h2><p>在数理统计中，我们往往研究有关对象的某一项数量指标，为此，考虑与这一数量指标相联系的随机试验，对这一数量指标进行试验或观察，我们将试验的<strong>全部可能的观察值</strong>称为<strong>总体</strong>，这些值不一定都不相同，数目上也不一定是有限的，每一个可能观察值称为<strong>个体</strong>，总体中所包含的个体的个数称为总体的<strong>容量</strong>。</p><h2 id="样本和样本值">样本和样本值</h2><p>设 <span class="math inline">\(X\)</span> 是具有分布函数 <span class="math inline">\(F\)</span> 的随机变量，若 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是具有同一分布函数 <span class="math inline">\(F\)</span> 的、相互独立的随机变量，则称 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 为从分布函数 <span class="math inline">\(F\)</span>（或总体 <span class="math inline">\(F\)</span>、或总体 <span class="math inline">\(X\)</span>）得到的容量为 <span class="math inline">\(n\)</span> 的<strong>简单随机样本</strong>，简称<strong>样本</strong>，它们的观察值 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 称为样本值，又称为 <span class="math inline">\(X\)</span> 的 <span class="math inline">\(n\)</span> 个独立的观察值</p><p>有定义得：若 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 为 <span class="math inline">\(F\)</span> 的一个样本，则 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 相互独立，其它们的分布函数都是 <span class="math inline">\(F\)</span>，所以 <span class="math inline">\((X_1, X_2, \cdots, X_n)\)</span> 的分布函数为</p><p><span class="math display">\[F^{\ast} (x_1, x_2, \cdots, x_n) = \prod_{i = 1}^{n} F(x_i)\]</span></p><p>又若 <span class="math inline">\(X\)</span> 具有概率密度 <span class="math inline">\(f\)</span>，则 <span class="math inline">\((X_1, X_2, \cdots, X_n)\)</span> 的概率密度为</p><p><span class="math display">\[f^{\ast}(x_1, x_2, \cdots, x_n) = \prod_{i = 1}^{n} f(x_i)\]</span></p><h2 id="样本分位数">样本分位数</h2><p>设有容量为 <span class="math inline">\(n\)</span> 的样本观察值 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span>，样本 <span class="math inline">\(p(1 &gt; p &gt; 0)\)</span> 分位数记为 <span class="math inline">\(x_p\)</span>，它具有以下性质：</p><ol type="1"><li>至少有 <span class="math inline">\(np\)</span> 个观察值小于等于 <span class="math inline">\(x_p\)</span>；</li><li>至少有 <span class="math inline">\(n(1 - p)\)</span> 个观察值大于或等于 <span class="math inline">\(x_p\)</span>。</li></ol><blockquote><p>样本 <span class="math inline">\(p\)</span> 分位数可按以下法则求得，将 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 按自小到大的次序排序。若 <span class="math inline">\(np\)</span> 不是整数，则取 <span class="math inline">\(\lceil np \rceil\)</span>；若 <span class="math inline">\(np\)</span> 是整数，则取 <span class="math inline">\(\overline{np + np + 1}\)</span></p></blockquote><h2 id="统计量">统计量</h2><p>设 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是来自总体 <span class="math inline">\(X\)</span> 的一个样本，<span class="math inline">\(g(X_1, X_2, \cdots, X_n)\)</span> 是 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 的函数，若 <span class="math inline">\(g\)</span> 中不含未知参数，则称 <span class="math inline">\(g(X_1, X_2, \cdots, X_n)\)</span> 是一统计量。</p><p>因为 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 都是随机变量，而统计量 <span class="math inline">\(g(X_1, X_2, \cdots, X_n)\)</span> 是随机变量的函数，因此统计量是一个随机变量。设 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 是相应于样本 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 的样本值，则称 <span class="math inline">\(g(x_1, x_2, \cdots, x_n)\)</span> 是 <span class="math inline">\(g(X_1, X_2, \cdots, X_n)\)</span> 的观察值。</p><h3 id="常用的统计量">常用的统计量</h3><ol type="1"><li><p>样本均值</p><p><span class="math display">\[\overline{X} = \frac{1}{n} \sum_{i = 1}^{n} X_i\]</span></p></li><li><p>样本方差</p><p><span class="math display">\[S^2 = \frac{1}{n - 1} \sum_{i = 1}^{n} (X_i - \overline{X})^2 = \frac{1}{n - 1} \bigg(\sum_{i = 1}^{n} X_{i}^2 - n\overline{X}^2\bigg)\]</span></p></li><li><p>样本标准差</p><p><span class="math display">\[S = \sqrt{\frac{1}{n - 1} \sum_{i = 1}^{n}(X_i - \overline{X}^2)}\]</span></p></li><li><p>样本 <span class="math inline">\(k\)</span> 阶原点矩</p><p><span class="math display">\[A_n = \frac{1}{n} \sum_{i = 1}^{n} X_i^k, \quad k = 1, 2, \cdots\]</span></p></li><li><p>样本 <span class="math inline">\(k\)</span> 阶中心矩</p><p><span class="math display">\[B_k = \frac{1}{n} \sum_{i = 1}^{n} (X_i - \overline{X})^k, \quad k = 2, 3, \cdots\]</span></p></li></ol><h2 id="经验分布函数">经验分布函数</h2><p>设 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 是来自分布函数为 <span class="math inline">\(F(x)\)</span> 的总体 <span class="math inline">\(X\)</span> 的样本观察值。<span class="math inline">\(X\)</span> 的经验分布函数，记为 <span class="math inline">\(F_n(x)\)</span>，定义为样本观察值 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 中小于或等于指定值 <span class="math inline">\(x\)</span> 所占的比率，即</p><p><span class="math display">\[F_n(x) = \frac{\# (x_i \leq x)}{n}, \quad -\infty &lt; x &lt; \infty\]</span></p><p>其中 <span class="math inline">\(\# (x_i \leq x)\)</span> 表示 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 中小于或等于 <span class="math inline">\(x\)</span> 的个数。</p><blockquote><p>按定义，当给定样本观察值 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 时，<span class="math inline">\(F_n(x)\)</span> 是自变量 <span class="math inline">\(x\)</span> 的函数，它具有分布函数的三个条件：(1). <span class="math inline">\(F_n(x)\)</span> 是 <span class="math inline">\(x\)</span> 的不减函数；(2). <span class="math inline">\(0 \leq F_n(x) \leq 1\)</span>，且 <span class="math inline">\(F(-\infty) = 0\)</span>，且 <span class="math inline">\(F(\infty) = 1\)</span>；(3). <span class="math inline">\(F(x)\)</span> 是一个右连续函数。由此知 <span class="math inline">\(F_n(x)\)</span> 是一个分布函数，当 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 各不相同时，<span class="math inline">\(F_n(x)\)</span> 是以等概率 <span class="math inline">\(1/n\)</span> 取 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span> 的离散型随机变量的分布函数。</p></blockquote><h3 id="格里汶科定理">格里汶科定理</h3><p>设 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是来自以 <span class="math inline">\(F(x)\)</span> 为分布函数的总体 <span class="math inline">\(X\)</span> 的样本，<span class="math inline">\(F(x)\)</span> 是经验分布函数，则有</p><p><span class="math display">\[P\bigg\{\lim_{n \to \infty} \sup_{-\infty &lt; x &lt; \infty} |F_n(x) - F(x)| = 0\bigg\} = 1\]</span></p><blockquote><p>此定理的含义是 <span class="math inline">\(F_n(x)\)</span> 在整个实轴上以概率 1 均匀收敛于 <span class="math inline">\(F(x)\)</span>，于是当样本容量 <span class="math inline">\(n\)</span> 充分大时，<span class="math inline">\(F_n(x)\)</span> 能够良好地逼近总体分布函数 <span class="math inline">\(F(x)\)</span>，这是在概率统计学中以样本推断总体的依据。</p></blockquote><h2 id="集中统计量">集中统计量</h2><h3 id="卡方分布">卡方分布</h3><p>设 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是来自总体 <span class="math inline">\(N(0, 1)\)</span> 的样本，则称统计量</p><p><span class="math display">\[\chi^2 = X_1^2 + X_2^2 + \cdots + X_n^2\]</span></p><p>服从自由度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(\chi^2\)</span> 分布，记为 <span class="math inline">\(\chi^2 \sim \chi^2(n)\)</span>。</p><p><span class="math inline">\(\chi^2(n)\)</span> 分布的概率密度为</p><p><span class="math display">\[f(y) =\begin{cases}\frac{1}{2^{n/2} \Gamma(n/2)} y^{n/2 - 1} \text{e}^{-y/2}, &amp;y &gt; 0\\0, &amp;\text{otherwise}\end{cases}\]</span></p><p>根据 <span class="math inline">\(\Gamma\)</span> 分布的可加性得：</p><ol type="1"><li><p>设 <span class="math inline">\(\chi_{1}^2 \sim \chi^2(n_1)\)</span>，<span class="math inline">\(\chi_{2}^2 \sim \chi^2(n_2)\)</span>，并且 <span class="math inline">\(\chi_1^2\)</span>，<span class="math inline">\(\chi_2^2\)</span> 相互独立，则有</p><p><span class="math display">\[\chi_1^2 + \chi_2^2 \sim \chi^2(n_1 + n_2)\]</span>。</p></li><li><p>若 <span class="math inline">\(\chi^2 \sim \chi^2(n)\)</span>，则有</p><p><span class="math display">\[E(\chi^2) = n, \quad D(\chi^2) = 2n\]</span></p></li><li><p>对于给定的正数 <span class="math inline">\(\alpha\)</span>，<span class="math inline">\(0 &lt; \alpha &lt; 1\)</span>，满足条件</p><p><span class="math display">\[P\{\chi^2 &gt; \chi_\alpha^2(n)\} = \int_{\chi_\alpha^2(n)}^{\infty} f(y) \text{d}y = \alpha\]</span></p><p>的 <span class="math inline">\(\chi_\alpha^2(n)\)</span> 就是 <span class="math inline">\(\chi^2(n)\)</span> 分布上的 <span class="math inline">\(\alpha\)</span> 分位数。</p><blockquote><p>当 <span class="math inline">\(n\)</span> 充分大时，近似地有</p><p><span class="math display">\[\chi_\alpha^2(n) \approx \frac{1}{2} (z_\alpha + \sqrt{2n - 1})^2\]</span></p><p>其中，<span class="math inline">\(z_\alpha\)</span> 是标准正态分布的上 <span class="math inline">\(\alpha\)</span> 分位数。</p></blockquote></li></ol><h3 id="学生氏分布">学生氏分布</h3><p>设 <span class="math inline">\(X \sim N(0, 1)\)</span>，<span class="math inline">\(Y \sim \chi^2(n)\)</span>，且 <span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span> 相互独立，则称随机变量</p><p><span class="math display">\[t = \frac{X}{\sqrt{Y/n}}\]</span></p><p>服从自由度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(t\)</span> 分布，记为 <span class="math inline">\(t \sim t(n)\)</span>。</p><p><span class="math inline">\(t\)</span> 分布又称为学生氏分布，<span class="math inline">\(t(n)\)</span> 分布的概率密度函数为</p><p><span class="math display">\[h(t) = \frac{\Gamma[(n + 1)/2]}{\sqrt{n\pi}\Gamma(n/2)} \bigg(1 + \frac{t^2}{n}\bigg)^{-(n + 1)/2}, \quad -\infty &lt; t &lt; \infty\]</span></p><p>实际上，由 <span class="math inline">\(\Gamma\)</span> 函数的性质可得</p><p><span class="math display">\[\lim_{n \to \infty} h(t) = \frac{1}{\sqrt{2\pi}} \text{e}^{-t^2/2}\]</span></p><p>同样，给出 <span class="math inline">\(t\)</span> 分布上分位数，对于给定的 <span class="math inline">\(0 &lt; \alpha &lt; 1\)</span>，满足条件</p><p><span class="math display">\[P\{t &gt; t_{\alpha}(n)\} = \int_{t_{\alpha}(n)}^{\infty} h(t) \text{d}t = \alpha\]</span></p><p>的 <span class="math inline">\(t_{\alpha}(n)\)</span> 就是 <span class="math inline">\(t(n)\)</span> 分布的上 <span class="math inline">\(\alpha\)</span> 分位数。</p><blockquote><p>由概率密度函数的对称性知</p><p><span class="math display">\[t_{1 - \alpha}(n) = -t_{\alpha}\]</span></p><p>此外，当 <span class="math inline">\(n &gt; 45\)</span> 时，对于常用的 <span class="math inline">\(\alpha\)</span>，可以用正态近似 <span class="math inline">\(t_{\alpha}(n) \approx z_{\alpha}\)</span>。</p></blockquote><h3 id="f-分布">F 分布</h3><p>设 <span class="math inline">\(U \sim \chi^2(n_1)\)</span>，<span class="math inline">\(V \sim \chi^2(n_2)\)</span>，且 <span class="math inline">\(U\)</span>，<span class="math inline">\(V\)</span> 相互独立，则称随机变量</p><p><span class="math display">\[F = \frac{U/n_1}{V/n_2}\]</span></p><p>服从自由度为 <span class="math inline">\((n_1, n_2)\)</span> 的 <span class="math inline">\(F\)</span> 分布，记为 <span class="math inline">\(F \sim F(n_1, n_2)\)</span>，其概率密度函数为：</p><p><span class="math display">\[\phi(y) =\begin{cases}\frac{\Gamma[(n_1 + n_2)/2](n_1 / n_2)^{n_1/2}y^{(n_1/2) - 1}}{\Gamma(n_1 / 2) \Gamma(n_2 / 2) [1 + (n_1 y / n_2)]^{(n_1 + n_2) / 2}}, &amp; y &gt; 0\\0, &amp; \text{otherwise}\end{cases}\]</span></p><p>由定义可得 <span class="math inline">\(\frac{1}{F} \sim F(n_2, n_1)\)</span>。</p><p>同样，给出 <span class="math inline">\(F\)</span> 分布的上 <span class="math inline">\(\alpha\)</span> 分位数，对于给定的 <span class="math inline">\(0 &lt; \alpha &lt; 1\)</span>，满足条件</p><p><span class="math display">\[P\{F &gt; F_{\alpha}(n_1, n_2)\} = \int_{F_{\alpha}(n_1, n_2)}^{\infty} \phi(y) \text{d}y = \alpha\]</span></p><blockquote><p><span class="math display">\[F_{1 - \alpha} (n_1, n_2) = \frac{1}{F_{\alpha}(n_2, n_1)}\]</span></p></blockquote><h3 id="正态总体的样本均值与样本方差分布">正态总体的样本均值与样本方差分布</h3><p>设总体 <span class="math inline">\(X\)</span>（不管服从什么分布，只要均值和方差存在）的均值为 <span class="math inline">\(\mu\)</span>，方差为 <span class="math inline">\(\sigma^2\)</span>，<span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是来自 <span class="math inline">\(X\)</span> 的一个样本，<span class="math inline">\(\overline{X}\)</span>，<span class="math inline">\(S^2\)</span> 分别是样本均值和样本方差，则有</p><p><span class="math display">\[E(\overline{X}) = \mu, \quad D(\overline{X}) = \sigma^2 / n\]</span></p><p>而</p><p><span class="math display">\[E(S^2) = E\bigg[\frac{1}{n - 1} \bigg(\sum_{i = 1}^{n} X_i^2 - n\overline{X}^2\bigg)\bigg] = \frac{1}{n - 1} \bigg[\sum_{i = 1}^{n} E(X_i^2) - nE(\overline{X}^2)\bigg]\\= \frac{1}{n - 1}\bigg[\sum_{i = 1}^{n}(\sigma^2 + \mu^2) - n(\sigma^2 / n + \mu^2)\bigg] = \sigma^2\]</span></p><p>进而，设总体 <span class="math inline">\(X \sim N(\mu, \sigma^2)\)</span>，知 <span class="math inline">\(\overline{X} = \frac{1}{n} \sum\limits_{i = 1}^{n} X_i\)</span>，也服从正态分布，于是得到下述结论：</p><ol type="1"><li><p>设 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是来自正态总体 <span class="math inline">\(N(\mu, \sigma^2)\)</span> 的样本，<span class="math inline">\(\overline{X}\)</span> 是样本均值，则有</p><p><span class="math display">\[\overline{X} \sim N(\mu, \sigma^2 / n)\]</span></p></li><li><p>设 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是来自正态总体 <span class="math inline">\(N(\mu, \sigma^2)\)</span> 的样本，<span class="math inline">\(\overline{X}\)</span>，<span class="math inline">\(S^2\)</span> 分别是样本均值和样本方差，则有</p><ol type="1"><li><span class="math inline">\(\frac{(n - 1) S^2}{\sigma^2} \sim \chi^2(n - 1)\)</span></li><li><span class="math inline">\(\overline{X}\)</span> 与 <span class="math inline">\(S^2\)</span> 相互独立</li></ol></li><li><p>设 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 是来自正态总体 <span class="math inline">\(N(\mu, \sigma^2)\)</span> 的样本，<span class="math inline">\(\overline{X}\)</span>，<span class="math inline">\(S^2\)</span> 分别是样本均值和样本方差，则有</p><p><span class="math display">\[\frac{\overline{X} - \mu}{S / \sqrt{n}} \sim t(n - 1)\]</span></p></li><li><p>设 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 和 <span class="math inline">\(Y_1\)</span>，<span class="math inline">\(Y_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(Y_n\)</span> 分别是来自正态总体 <span class="math inline">\(N(\mu_1, \sigma_1^2)\)</span> 和 <span class="math inline">\(N(\mu_2, \sigma_2^2)\)</span> 的样本，且这两个样本相互独立，设 <span class="math inline">\(\overline{X} = \frac{1}{n_1} \sum\limits_{i = 1}^{n_1} X_{i}\)</span>，<span class="math inline">\(\overline{Y} = \frac{1}{n_2} \sum\limits_{i = 1}^{n_2} Y_{i}\)</span> 分别是这两个样本的样本均值；<span class="math inline">\(S_1^2 = \frac{1}{n_{1} - 1} \sum\limits_{i = 1}^{n_1} (X_i - \overline{X})^2\)</span>，<span class="math inline">\(S_2^2 = \frac{1}{n_2 - 1} \sum\limits_{i = 1}^{n_2} (Y_i - \overline{Y})^2\)</span> 分别是这两个样本的样本方差，则有</p><ol type="1"><li><p><span class="math inline">\(\frac{S_1^2 / S_2^2}{\sigma_1^2 / \sigma_2^2} \sim F(n_1 - 1, n_2 - 1)\)</span></p></li><li><p>当 <span class="math inline">\(\sigma_1^2 = \sigma_2^2 = \sigma^2\)</span> 时</p><p><span class="math display">\[\frac{(\overline{X} - \overline{Y}) - (\mu_1 - \mu_2)}{S_W \sqrt{\frac{1}{n_1} + \frac{1}{n_2}}} \sim t(n_1 + n_2 - 2)\]</span></p><p>其中，</p><p><span class="math display">\[S_W^2 = \frac{(n_1 - 1)S_1^2 + (n_2 - 1)S_2^2}{n_1 + n_2 - 2}\]</span></p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统原理期中试题解答</title>
    <link href="/2025/11/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%9C%9F%E4%B8%AD%E4%BD%9C%E4%B8%9A/"/>
    <url>/2025/11/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%9C%9F%E4%B8%AD%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="一">一</h2><p>给出下列关系代数操作对应的 SQL 语句</p><ol type="1"><li><p><span class="math inline">\(\sigma_{p = 233}(r)\)</span></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> r <span class="hljs-keyword">WHERE</span> p <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;233&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p><span class="math inline">\(\Pi_{A_1, A_2, \cdots, A_m}(r)\)</span></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> A_1, A_2, \cdots, A_m <span class="hljs-keyword">FROM</span> r;<br></code></pre></td></tr></table></figure></li><li><p><span class="math inline">\(\Pi_{A_1, A_2}(\sigma_{p = 114}(r))\)</span></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> A_1, A_2 <span class="hljs-keyword">FROM</span> r <span class="hljs-keyword">WHERE</span> p <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;114&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p><span class="math inline">\(\Pi_{A, B}(\sigma_{B = 114}(r \Join S))\)</span>，假设 <span class="math inline">\(r(A, B, C)\)</span>，<span class="math inline">\(s(C, E, F)\)</span>。</p><p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> r.A, r.B <span class="hljs-keyword">FROM</span> r <span class="hljs-keyword">JOIN</span> s <span class="hljs-keyword">USING</span> (C) <span class="hljs-keyword">WHERE</span> r.B <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;114&#x27;</span>;<br></code></pre></td></tr></table></figure></p></li></ol><h2 id="二">二</h2><p>给出下列 SQL 语句对应的关系代数表达式</p><ol type="1"><li><p><code>SELECT * FROM student WHERE SNO = '10086';</code></p><p><span class="math display">\[\sigma_{\text{SNO} = 10086}(\text{Student})\]</span></p></li><li><p><code>SELECT Name, Class FROM Student WHERE SNO = '10086';</code></p><p><span class="math display">\[\Pi_{\text{Name}, \text{Class}}(\sigma_{\text{SNO} = 10086}(\text{Student}))\]</span></p></li><li><p><code>SELECT Name FROM Student, SC WHERE SC.SNO = Student.SNO AND SC.CNO = '1';</code></p><p><span class="math display">\[\Pi_{\text{Name}}(\sigma_{\text{Student.SNO} = \text{SC.SNO} \land \text{SC.CNO = 1}}(\text{Student} \times \text{SC}))\]</span></p></li><li><p><code>SELECT R.*, S.C FROM R , S WHERE R.A = S.A;</code>，假设 <span class="math inline">\(R(A, B)\)</span>，<span class="math inline">\(S(A, C)\)</span></p><p><span class="math display">\[\Pi_{R.A, R.B, S.C}(\sigma_{R.A = S.A}(R \times S))\]</span></p></li></ol><h2 id="三">三</h2><p>某银行企业数据库关系如下，划线部分为主键</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>表</th><th>属性</th></tr></thead><tbody><tr class="odd"><td><em>branch</em></td><td><span class="math inline">\(\underline{\text{branch-name}}\)</span>, branch-city, assets</td></tr><tr class="even"><td><em>loan</em></td><td><span class="math inline">\(\underline{\text{loan-number}}\)</span>, branch-name, amount</td></tr><tr class="odd"><td><em>borrower</em></td><td><span class="math inline">\(\underline{\text{customer-name}}\)</span>, <span class="math inline">\(\underline{\text{loan-number}}\)</span></td></tr><tr class="even"><td><em>customer</em></td><td><span class="math inline">\(\underline{\text{customer-name}}\)</span>, customer-street, customer-city</td></tr><tr class="odd"><td><em>account</em></td><td><span class="math inline">\(\underline{\text{account-number}}\)</span>, branch-name, balance</td></tr><tr class="even"><td><em>depositor</em></td><td><span class="math inline">\(\underline{\text{customer-name}}\)</span>, account-number</td></tr><tr class="odd"><td><em>employee</em></td><td><span class="math inline">\(\underline{\text{employee-ID}}\)</span>, employee-name, branch-name, job-title</td></tr></tbody></table></div><ol type="1"><li><p>使用 SQL 语句定义关系表 <em>employee</em>，其中 <em>employee-ID</em> 是主键，<em>employee-name</em> 是候选键并且不为空；表 <em>employee</em> 和 <em>branch</em> 之间存在参照完整性；员工的职位必须是 manager，teller，officer，secretary 之一。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> employee (<br>  employee_ID <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  employee_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  branch_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  job_title <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">9</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (employee_ID),<br>  <span class="hljs-keyword">UNIQUE</span> (employee_name),<br>  <span class="hljs-keyword">CHECK</span> (job_title <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;manager&#x27;</span>, <span class="hljs-string">&#x27;teller&#x27;</span>, <span class="hljs-string">&#x27;officer&#x27;</span>, <span class="hljs-string">&#x27;secretary&#x27;</span>)),<br>  <span class="hljs-keyword">FOREIGN KEY</span> (branch_name) <span class="hljs-keyword">REFERENCES</span> branch(branch_name)<br>);<br></code></pre></td></tr></table></figure></li><li><p>使用 SQL 语句查找在 Raccoon 市有一个或多个账户，并且这些账户的余额总额超过 10000 元的客户信息。列出客户的姓名和他在 Raccoon 市分支机构的账户总余额，客户姓名的字母降序排列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> d.customer_name, <span class="hljs-built_in">SUM</span>(a.balance) <span class="hljs-keyword">AS</span> balance_in_Raccoon<br><span class="hljs-keyword">FROM</span> depositor d<br><span class="hljs-keyword">JOIN</span> account a <span class="hljs-keyword">on</span> d.account_number <span class="hljs-operator">=</span> a.account_number<br><span class="hljs-keyword">JOIN</span> branch b <span class="hljs-keyword">on</span> a.branch_name <span class="hljs-operator">=</span> b.branch_name<br><span class="hljs-keyword">WHERE</span> b.branch_city <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Raccoon&#x27;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> d.customer_name<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">SUM</span>(a.balance) <span class="hljs-operator">&gt;</span> <span class="hljs-number">10000</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> d.customer_name <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="四">四</h2><ol type="1"><li>每位老师有教师代码（唯一）、教师姓名、办公地址、职级、部门。</li><li>每门课程有课程名称、课程编号（唯一）、课程学分。课程包含章节，每个章节有一个编号（唯一）和章节名，同一门课程可能有多个章节。</li><li>每个学生有学生编号（唯一）、姓名、专业、出生日期。</li><li>一位老师最多可以教四门课程，每门课程由两位老师教授。</li><li>一个学生可以选择多门课程，每门课程可以由多个学生选择。</li></ol><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%9C%9F%E4%B8%AD%E4%BD%9C%E4%B8%9A/E-R%20Diagram%20in%20Question%204.png" alt="E-R Diagram in Question 4"><figcaption aria-hidden="true">E-R Diagram in Question 4</figcaption></figure></div><h2 id="五">五</h2><p>将下面的 E-R 图转换为相应的关系模型。对于每个模型，用 R(<span class="math inline">\(\underline{\text{A1, A2}}\)</span>, <span class="math inline">\(\cdots\)</span>, An) 的形式写出来，用下划线标出主键，并用 R.A1(FK) References S.A2(PK) 的形式说明外键。</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%9C%9F%E4%B8%AD%E4%BD%9C%E4%B8%9A/E-R%20Diagram%20in%20Question%205.png" alt="E-R Diagram in Question 5"><figcaption aria-hidden="true">E-R Diagram in Question 5</figcaption></figure></div><p>Customer(<span class="math inline">\(\underline{\text{Customer-no}}\)</span>, name, e-mail), Order(<span class="math inline">\(\underline{\text{order-no}}\)</span>, date, cost, Customer-no), Product(<span class="math inline">\(\underline{\text{product-no}}\)</span>, name, price) includes(<span class="math inline">\(\underline{\text{order-no}}\)</span>, <span class="math inline">\(\underline{\text{product-no}}\)</span>, quantity), Order.Customer-no(FK) References Customer.Customer-no(PK), includes.order-no(FK) References Order.order-no(PK), includes.product-no(FK) References Product.product-no(PK).</p><h2 id="六">六·</h2><p>A university student database needs to store information about <span class="math inline">\(\underline{\mathit{students}}\)</span>, <span class="math inline">\(\underline{\mathit{professors}}\)</span>, <span class="math inline">\(\underline{\mathit{projects}}\)</span>, and <span class="math inline">\(\underline{\pmb{departments}}\)</span>. Consider the following information:</p><ul><li>Each student has an SNo, a name, an age, and a degree program (e.g. M.S. or Ph.D.).</li><li>Each professor has a PNo, a name, an age, and a research specialty.</li><li>Each project has a project number, a starting date, an ending date, and a budget.</li><li>Each department has a department number, a department name, and a main office.</li><li>integrity constraints:<ol type="1"><li>A student studies in one (and only one) department.</li><li>A Professor works in one (and only one) department.</li><li>Each project must be managed by one and only one professor, and each professor must manage at least one project.</li><li>Each project is worked on by some students, more than one student can participate(or work on) the same project, and some students may work on no projects.</li><li>When a student work on a project, the professor managing this project must supervise the student’s work. One student may work on several projects, so he may have several supervisors.</li></ol></li></ul><ol type="1"><li><p>Design and draw an E/R diagram for this database that captures the information above. &gt; <em>Note</em>: mapping cardinality of each relationship and participation of each entity to the relationship should be described in the diagram.</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%9C%9F%E4%B8%AD%E4%BD%9C%E4%B8%9A/E-R%20Diagram%20in%20Question%206(1).png" alt="E-R Diagram in Question 6(1)"><figcaption aria-hidden="true">E-R Diagram in Question 6(1)</figcaption></figure></div></li><li><p>Convert the E-R diagram to the proper relational schema, and give the primary key of each relation schema by underlines.</p><p>student(<span class="math inline">\(\underline{\text{SNo}}\)</span>, stu_name, stu_age, stu_degree, dept_number), professor(<span class="math inline">\(\underline{\text{PNo}}\)</span>, pro_name, pro_age, research_specialty, dept_number), project(<span class="math inline">\(\underline{\text{project\_number}}\)</span>, start_date, end_date, budget, PNo), department(<span class="math inline">\(\underline{\text{dept\_number}}\)</span>, dept_name, main_office), works_on(<span class="math inline">\(\underline{\text{student.SNo}}\)</span>, <span class="math inline">\(\underline{\text{project.project\_number}}\)</span>), supervise(<span class="math inline">\(\underline{\text{student.SNo}}\)</span>, <span class="math inline">\(\underline{\text{professor.PNo}}\)</span>, project_number).</p></li></ol><h2 id="七">七</h2><p>Consider the following relation schema <span class="math inline">\(R\)</span> and the functional dependency <span class="math inline">\(F\)</span> hold on <span class="math inline">\(R = \{X, Y, Z, W, Q\}\)</span>, <span class="math inline">\(F = \{XY \to ZQ, Q \to XY, Z \to W, Q \to Z\}\)</span></p><ol type="1"><li><p>Compute <span class="math inline">\((XZ)+\)</span>.</p><p>由 <span class="math inline">\(Z\to W\)</span> 可得 <span class="math inline">\(W\)</span>；无法由 <span class="math inline">\(XZ\)</span> 推出 <span class="math inline">\(Q\)</span> 或 <span class="math inline">\(Y\)</span>（需要 <span class="math inline">\(Q\)</span> 或 <span class="math inline">\(XY\)</span> 才能触发 <span class="math inline">\(Q\to XY\)</span> 或 <span class="math inline">\(XY\to ZQ\)</span>），因此闭包为 <span class="math inline">\(\{X,Z,W\}\)</span>。</p></li><li><p>Is the decomposition <span class="math inline">\(\rho = \{R1(X, Y, Z), R2(Z, W, Q)\}\)</span> on <span class="math inline">\(R\)</span> lossless-join? Why?</p><p>交集为 <span class="math inline">\(R_1\cap R_2=\{Z\}\)</span>。检查 <span class="math inline">\(Z^+=\{Z,W\}\)</span>，既不是 <span class="math inline">\(R_1(X,Y,Z)\)</span> 的超码，也不是 <span class="math inline">\(R_2(Z,W,Q)\)</span> 的超码；不满足二元分解无损充要条件“交集函数决定其中一个模式”，故分解有损。</p></li></ol><h2 id="八">八</h2><p>The functional dependency set <span class="math inline">\(F = \{A \to C, C \to A, B \to A, D \to AC, B \to E\}\)</span> holds on the relation schema <span class="math inline">\(R = (A, B, C, D, E)\)</span>.</p><ol type="1"><li><p>Compute <span class="math inline">\((AB)+\)</span>.</p><p>由 <span class="math inline">\(B\to A\)</span>、<span class="math inline">\(A\to C\)</span>、<span class="math inline">\(B\to E\)</span> 依次可得 <span class="math inline">\(A,C,E\)</span>；无规则推出 <span class="math inline">\(D\)</span>。</p></li><li><p>List all the candidate keys of <span class="math inline">\(R\)</span>.</p><p><span class="math inline">\(D\to AC\)</span>，配合 <span class="math inline">\(B\to A, B\to E\)</span> 得 <span class="math inline">\(BD\to ABCDE\)</span>，且 <span class="math inline">\(B\)</span> 与 <span class="math inline">\(D\)</span> 分别不能由其它属性函数确定（右部无 <span class="math inline">\(B\)</span>、<span class="math inline">\(D\)</span>），因此 <span class="math inline">\(BD\)</span> 最小且为唯一候选键。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大数定理及中心极限定理</title>
    <link href="/2025/11/13/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86%E5%8F%8A%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/"/>
    <url>/2025/11/13/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86%E5%8F%8A%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="大数定理">大数定理</h2><h3 id="依概率收敛">依概率收敛</h3><p>设 <span class="math inline">\(Y_1\)</span>，<span class="math inline">\(Y_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(Y_n\)</span>，<span class="math inline">\(\cdots\)</span> 是一个随机变量序列，<span class="math inline">\(a\)</span> 是一个常数，若对于任意正数 <span class="math inline">\(\varepsilon\)</span>，有</p><p><span class="math display">\[\lim_{n \to \infty} P\{|Y_n - a| &lt; \varepsilon\} = 1\]</span></p><p>则称序列 <span class="math inline">\(Y_1\)</span>，<span class="math inline">\(Y_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(Y_n\)</span>，<span class="math inline">\(\cdots\)</span> 依概率收敛于 <span class="math inline">\(a\)</span>，记为</p><p><span class="math display">\[Y_n \xrightarrow{P} a\]</span></p><blockquote><p>设 <span class="math inline">\(X_n \xrightarrow{P} a\)</span>，<span class="math inline">\(Y_n \xrightarrow{P} b\)</span>，又设函数 <span class="math inline">\(g(x, y)\)</span> 在点 <span class="math inline">\((a, b)\)</span> 连续，则</p><p><span class="math display">\[g(X_n, Y_n) \xrightarrow{P} g(a, b)\]</span></p></blockquote><h3 id="弱大数定理">弱大数定理</h3><p>设 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span> 是相互独立，服从同一分布的随机变量序列，且具有数学期望 <span class="math inline">\(E(X_k) = \mu (k = 1, 2, \cdots)\)</span>，作前 <span class="math inline">\(n\)</span> 个变量的算术平均 <span class="math inline">\(\frac{1}{n} \sum\limits_{k = 1}^{n} X_{k}\)</span>，则对于任意 <span class="math inline">\(\varepsilon &gt; 0\)</span>，有</p><p><span class="math display">\[\lim_{n \to \infty} P\bigg\{\bigg|\frac{1}{n} \sum_{k = 1}^{n} X_{k} - \mu\bigg| &lt; \varepsilon\bigg\} = 1\]</span></p><p>设随机变量 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span>，<span class="math inline">\(\cdots\)</span> 相互独立，服从同一分布且具有数学期望 <span class="math inline">\(E(X_k) = \mu(k = 1, 2, \cdots)\)</span>，则序列 <span class="math inline">\(\bar{X} = \frac{1}{n} \sum\limits_{k = 1}^{n} X_{k}\)</span>，依概率收敛于 <span class="math inline">\(\mu\)</span>，即 <span class="math inline">\(\bar{X} \xrightarrow{P} \mu\)</span>。</p><h3 id="伯努利大数定理">伯努利大数定理</h3><p>设 <span class="math inline">\(f_A\)</span> 是 <span class="math inline">\(n\)</span> 次独立重复试验中事件 <span class="math inline">\(A\)</span> 发生的次数，<span class="math inline">\(p\)</span> 是事件 <span class="math inline">\(A\)</span> 在每次试验中发生的概率，则对于任意 <span class="math inline">\(\varepsilon &gt; 0\)</span>，有</p><p><span class="math display">\[\lim_{n \to \infty} P\bigg\{\bigg|\frac{f_A}{n} - p\bigg| &lt; \varepsilon\bigg\} = 1\]</span></p><h2 id="中心极限定理">中心极限定理</h2><h3 id="独立同分布的中心极限定理">独立同分布的中心极限定理</h3><p>设随机变量 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span>，<span class="math inline">\(\cdots\)</span> 相互独立，服从同一分布，且具有数学期望和方差：<span class="math inline">\(E(X_k) = \mu\)</span>，<span class="math inline">\(D(X_k) = \sigma^2 &gt; 0(k = 1, 2, \cdots)\)</span>，则随机变量之和 <span class="math inline">\(\sum\limits_{k = 1}^{n} X_{k}\)</span> 的标准化变量</p><p><span class="math display">\[Y_n = \frac{\sum\limits_{k = 1}^{n} X_{k} - E\bigg(\sum\limits_{k = 1}^{n} X_{k}\bigg)}{\sqrt{D(\sum\limits_{k = 1}^{n} X_k)}} = \frac{\sum\limits_{k = 1}^{n} X_{k} - n\mu}{\sqrt{n}\delta}\]</span></p><p>的分布函数 <span class="math inline">\(F_n(x)\)</span> 对于任意 <span class="math inline">\(x\)</span> 满足</p><p><span class="math display">\[\begin{aligned}\lim_{n \to \infty} F_n(x) &amp;= \lim_{n \to \infty} P\bigg\{\frac{\sum\limits_{k = 1}^{n} X_{k} - n\mu}{\sqrt{n}\delta} \leq x\bigg\}\\&amp;= \int_{-\infty}^{x} \frac{1}{\sqrt{2}\pi} \text{e}^{-t^2/2} \text{d}t = \Phi(x)\end{aligned}\]</span></p><h3 id="李雅普诺夫定理">李雅普诺夫定理</h3><p>设随机变量 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span>，<span class="math inline">\(\cdots\)</span> 相互独立，它们具有数学期望和方差</p><p><span class="math display">\[E(X_k) = \mu_{k}, \quad D(X_{k}) = \sigma^{2}_{k} &gt; 0, \quad k = 1, 2, \cdots\]</span></p><p>记 <span class="math inline">\(B_n^2 = \sum\limits_{k = 1}^{n} \sigma_{k}^2\)</span>，若存在正数 <span class="math inline">\(\delta\)</span>，使得当 <span class="math inline">\(n \to \infty\)</span> 时，</p><p><span class="math display">\[\frac{1}{B_{n}^{2 + \delta}} \sum_{k = 1}^{n} E\{|X_k - \mu_k|^{2 + \delta}\} \to 0\]</span></p><p>则随机变量之和 <span class="math inline">\(\sum\limits_{k = 1}^{n} X_{k}\)</span> 的标准化变量</p><p><span class="math display">\[Z_n = \frac{\sum\limits_{k = 1}^{n} X_{k} - E\bigg(\sum\limits_{k = 1}^{n} X_{k}\bigg)}{\sqrt{D\bigg(\sum\limits_{k = 1}^{n} X_{k}\bigg)}} = \frac{\sum\limits_{k = 1}^{n} X_{k} - \sum\limits_{k = 1}^{n} \mu_{k}}{B_n}\]</span></p><p>的分布函数 <span class="math inline">\(F_n(x)\)</span> 对于任意 <span class="math inline">\(x\)</span>，满足</p><p><span class="math display">\[\begin{aligned}\lim_{n \to \infty} F_n(x) &amp;= \lim_{n \to \infty} P\bigg\{\frac{\sum\limits_{k = 1}^{n} X_{k} - \sum\limits_{k = 1}^{n} \mu_{k}}{B_n} \leq x\bigg\}\\&amp;= \int_{-\infty}^{x} \frac{1}{\sqrt{2}\pi} \text{e}^{-t^2/2} \text{d}t = \Phi(x)\end{aligned}\]</span></p><h3 id="棣莫弗-拉普拉斯定理">棣莫弗-拉普拉斯定理</h3><p>设随机变量 <span class="math inline">\(\eta_{n}(n = 1, 2, \cdots)\)</span> 服从参数为 <span class="math inline">\(n\)</span>，<span class="math inline">\(p(0 &lt; p &lt; 1)\)</span> 的二项分布，则对于任意 <span class="math inline">\(x\)</span>，有</p><p><span class="math display">\[\lim_{n \to \infty} P\bigg\{\frac{\eta_n - np}{\sqrt{np(1 - p)}} \leq x\bigg\} = \int_{-\infty}^{x} \frac{1}{\sqrt{2\pi}} \text{e}^{-t^2/2} \text{d}t = \Phi(x)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>随机变量的数字特征</title>
    <link href="/2025/11/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"/>
    <url>/2025/11/12/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="期望">期望</h2><p>若级数</p><p><span class="math display">\[\sum_{k = 1}^{\infty} x_{k} p_{k}\]</span></p><p>绝对收敛，则称级数的和为随机变量 <span class="math inline">\(X\)</span> 的<strong>数学期望</strong>，记为 <span class="math inline">\(E(X)\)</span>。</p><p>设连续型随机变量 <span class="math inline">\(X\)</span> 的概率密度为 <span class="math inline">\(f(x)\)</span>，若积分</p><p><span class="math display">\[\int_{-\infty}^{\infty} xf(x) \text{d}x\]</span></p><p>绝对收敛，则称积分的值为随机变量 <span class="math inline">\(X\)</span> 的<strong>数学期望</strong>，记为 <span class="math inline">\(E(X)\)</span>。</p><h3 id="求期望的定理">求期望的定理</h3><p>设 <span class="math inline">\(Y\)</span> 是随机变量 <span class="math inline">\(X\)</span> 的函数；<span class="math inline">\(Y = g(X)\)</span>，其中 <span class="math inline">\(g\)</span> 是连续函数</p><ol type="1"><li><p>如果 <span class="math inline">\(X\)</span> 是离散型随机变量，它的分布律为 <span class="math inline">\(P\{X = x_{k}\} = p_{k}, k = 1, 2, \cdots\)</span>，若 <span class="math inline">\(\sum\limits_{k = 1}^{\infty} g(x_{k}) p_{k}\)</span> 绝对收敛，则有</p><p><span class="math display">\[E(Y) = E[g(X)] = \sum\limits_{k = 1}^{\infty} g(x_{k}) p_{k}\]</span></p></li><li><p>如果 <span class="math inline">\(X\)</span> 是连续型随机变量，它的概率密度为 <span class="math inline">\(f(x)\)</span>，若 <span class="math inline">\(\int_{-\infty}^{\infty} g(x) f(x) \text{d}x\)</span> 绝对收敛，则有</p><p><span class="math display">\[E(Y) = E[g(X)] = \int_{-\infty}^{\infty} g(x) f(x) \text{d}x\]</span></p></li></ol><blockquote><p>上述 2. 可以推广到两个或两个以上随机变量的函数情况，例如，设 <span class="math inline">\(Z\)</span> 是随机变量 <span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span> 的函数 <span class="math inline">\(Z = g(X, Y)\)</span>，<span class="math inline">\(g\)</span> 是连续函数，若二维随机变量 <span class="math inline">\((X, Y)\)</span> 的概率密度为 <span class="math inline">\(f(x, y)\)</span>，则有</p><p><span class="math display">\[E(Z) = E[g(X, Y)] = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} g(x, y) f(x, y) \text{d}x \text{d}y\]</span></p><p>这里设上式右边的积分绝对收敛，又若 <span class="math inline">\((X, Y)\)</span> 为离散型随机变量，其分布律为 <span class="math inline">\(P\{X = x_{i}, Y = y_{i}\} = p_{ij}, i, j = 1, 2, \cdots\)</span>，则有</p><p><span class="math display">\[E(Z) = E[g(X, Y)] = \sum_{j = 1}^{\infty} \sum_{i = 1}^{\infty} g(x_{i}, y_{j}) p_{ij}\]</span></p><p>这里同样设上式右边的级数绝对收敛。</p></blockquote><h2 id="方差">方差</h2><p><span class="math display">\[D(X) = \text{Var}(X) = E\{[X - E(X)]^2\} = E(X^2) - [E(X)]^2\]</span></p><p>记 <span class="math inline">\(\sigma(X) = \sqrt{D(X)}\)</span></p><h3 id="方差的性质">方差的性质</h3><ol type="1"><li><p>设 <span class="math inline">\(C\)</span> 是常数，则 <span class="math inline">\(D(C) = 0\)</span>；</p></li><li><p>设 <span class="math inline">\(X\)</span> 是随机变量，<span class="math inline">\(C\)</span> 是常数，则有</p><p><span class="math display">\[D(CX) = C^2 D(X), \quad D(X + C) = D(X)\]</span></p></li><li><p>设 <span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span> 是两个随机变量，则有</p><p><span class="math display">\[D(X + Y) = D(X) + D(Y) + 2E\{[X - E(X)][Y - E(Y)]\}\]</span></p><p>特别地，若 <span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span> 相互独立，则有</p><p><span class="math display">\[D(X + Y) = D(X) + D(Y)\]</span></p></li><li><p><span class="math inline">\(D(X) = 0\)</span> 的充要条件是 <span class="math inline">\(X\)</span> 以概率 1 取常数 <span class="math inline">\(E(X)\)</span>，即 <span class="math inline">\(P\{X = E(X)\} = 1\)</span></p></li></ol><h2 id="切比雪夫不等式">切比雪夫不等式</h2><p>谁随机变量 <span class="math inline">\(X\)</span> 具有数学期望 <span class="math inline">\(E(X) = \mu\)</span>，方差 <span class="math inline">\(D(X) = \sigma^2\)</span>，则对于任意正数 <span class="math inline">\(\varepsilon\)</span>，不等式</p><p><span class="math display">\[P\{|X - \mu| \geq \varepsilon\} \leq \frac{\sigma^2}{\varepsilon^2}\]</span></p><p>成立</p><h2 id="协方差和相关系数">协方差和相关系数</h2><p>量 <span class="math inline">\(E\{[X - E(X)][Y - E(Y)]\}\)</span> 称为随机变量 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的协方差，记为 <span class="math inline">\(\text{Cov}(X, Y)\)</span>，即</p><p><span class="math display">\[\text{Cov}(X, Y) = E\{[X - E(X)][Y - E(Y)]\}\]</span></p><p>而</p><p><span class="math display">\[\rho_{XY} = \frac{\text{Cov}(X, Y)}{\sqrt{D(X) D(Y)}}\]</span></p><p>称为随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的相关系数。</p><h3 id="协方差和相关系数的性质">协方差和相关系数的性质</h3><ol type="1"><li><p><span class="math inline">\(\text{Cov}(aX, bY) = ab\text{Cov}(X, Y)，\)</span>a<span class="math inline">\(，\)</span>b$ 是常数。</p></li><li><p><span class="math inline">\(\text{Cov}(X_1 + X_2, Y) = \text{Cov}(X_1, Y) + \text{Cov}(X_2, Y)\)</span></p></li><li><p><span class="math inline">\(|\rho_{XY}| \leq 1\)</span></p></li><li><p>若 <span class="math inline">\(|\rho_{XY}| = 1\)</span>，从而</p><p><span class="math display">\[\begin{aligned}E\{[Y - (a_0 + b_0 X)]^2\} &amp;= 0\\D[Y - (a_0 + b_0 X)] &amp;= 0\\E[Y - (a_0 + b_0 X)] &amp;= 0\end{aligned}\]</span></p></li></ol><h2 id="矩协方差矩阵">矩、协方差矩阵</h2><h3 id="原点矩中心矩混合矩">原点矩、中心矩、混合矩</h3><p>设 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是随机变量，若 <span class="math inline">\(E(X^k), k = 1, 2, \cdots\)</span> 存在，称它为 <span class="math inline">\(X\)</span> 的 <span class="math inline">\(k\)</span> 阶<strong>原点矩</strong>，简称 <span class="math inline">\(k\)</span> 阶矩。；若 <span class="math inline">\(E\{[X - E(X)]^k\}, k = 1, 2, \cdots\)</span> 存在，称它为 <span class="math inline">\(X\)</span> 的 <span class="math inline">\(k\)</span> 阶<strong>中心矩</strong>；若 <span class="math inline">\(E(X^k Y^l), k, l = 1, 2, \cdots\)</span> 存在，称它为 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的 <span class="math inline">\(k + l\)</span> 阶<strong>混合矩</strong>；若 <span class="math inline">\(E\{[X - E(X)]^k [Y - E(Y)]^l\}, k, l = 1, 2, \cdots\)</span> 存在，称它为 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的 <span class="math inline">\(k + l\)</span> 阶<strong>混合中心矩</strong>。</p><h3 id="协方差矩阵">协方差矩阵</h3><p>设 <span class="math inline">\(n\)</span> 维随机变量 <span class="math inline">\((X_1, X_2, \cdots, X_n)\)</span> 的二阶混合中心矩，<span class="math inline">\(c_{ij} = \text{Cov}(X_i, X_j) = E\{[X_i - E(X_i)][X_j - E(X_j)]\}, i, j = 1, 2, \cdots, n\)</span> 都存在，则称矩阵</p><p><span class="math display">\[\mathbf{C} =\begin{bmatrix}c_{11} &amp;c_{12} &amp;\cdots &amp;c_{1n}\\c_{21} &amp;c_{22} &amp;\cdots &amp;c_{2n}\\\vdots &amp;\vdots &amp;\quad &amp;\vdots\\c_{n1} &amp;c_{n2} &amp;\cdots &amp;c_{nn}\end{bmatrix}\]</span></p><p>为 <span class="math inline">\(n\)</span> 为随机变量 <span class="math inline">\((X_1, X_2, \cdots, X_n)\)</span> 的<strong>协方差矩阵</strong>，显然是一个对称矩阵。</p><h3 id="多维正态分布的随机变量的概率密度">多维正态分布的随机变量的概率密度</h3><p><span class="math display">\[f(x_1, x_2, \cdots, x_n) = \frac{1}{(2\pi)^{\pi/2} (\det(C))^{1/2}} \exp \bigg\{-\frac{1}{2}(\mathbf{X} - \mathbf{\mu})^{\text{T}} \mathbf{C}^{-1} (\mathbf{X} - \mathbf{\mu})\bigg\}\]</span></p><p>其中，<span class="math inline">\(\mathbf{C}\)</span> 是协方差矩阵。</p><blockquote><ol type="1"><li><span class="math inline">\(n\)</span> 维正态随机变量 <span class="math inline">\((X_1, X_2, \cdots, X_n)\)</span> 的每一个分量 <span class="math inline">\(X_i, i = 1, 2, \cdots, n\)</span> 都是正态随机变量；反之，若 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 都是正态随机变量，且相互独立，则 <span class="math inline">\((X_1, X_2, \cdots, X_n)\)</span> 是 <span class="math inline">\(n\)</span> 维正态随机变量。</li><li><span class="math inline">\(n\)</span> 维随机变量 <span class="math inline">\((X_1, X_2, \cdots, X_n)\)</span> 服从 <span class="math inline">\(n\)</span> 维正态分布的充要条件是 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 的任意线性组合服从一维正态分布。</li><li>若 <span class="math inline">\((X_1, X_2, \cdots, X_n)\)</span> 服从 <span class="math inline">\(n\)</span> 维正态分布，设 <span class="math inline">\(Y_1\)</span>，<span class="math inline">\(Y_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(Y_k\)</span> 是 <span class="math inline">\(X_j(j = 1, 2, \cdots, n)\)</span> 的线性函数，则 <span class="math inline">\((Y_1, Y_2, \cdots, Y_k)\)</span> 也服从多维正态分布。</li><li>设 <span class="math inline">\((X_1, X_2, \cdots, X_n)\)</span> 服从 <span class="math inline">\(n\)</span> 维正态分布，则 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 相互独立与 <span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(X_n\)</span> 两两不相关是等价的。</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多维随机变量及其分布</title>
    <link href="/2025/11/11/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"/>
    <url>/2025/11/11/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="二维随机变量">二维随机变量</h2><p><strong>分布函数</strong>的定义 设 <span class="math inline">\((X, Y)\)</span> 是二维随机变量，对于任意实数 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>，二元函数：</p><p><span class="math display">\[F(x, y) = P\{(X \leq x) \cap (Y \leq y)\} = P\{X \leq x, Y \leq y\}\]</span></p><p>称为二维随机变量 <span class="math inline">\((X, Y)\)</span> 的分布函数，或称为随机变量 <span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span> 的<strong>联合分布函数</strong>。</p><blockquote><p>我们称 <span class="math inline">\(P\{X = x_i, Y = y_i\} = p_{ij}, i, j = 1, 2, \cdots\)</span> 为二维离散型随机变量 <span class="math inline">\((X, Y)\)</span> 的分布律，或称为随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的联合分布律。 同样我们可以定义连续型随机变量的分布函数：对于二维变量 <span class="math inline">\((X, Y)\)</span> 的分布函数 <span class="math inline">\(F(x, y)\)</span>，如果存在非负可积函数 <span class="math inline">\(f(x, y)\)</span> 使对于任意 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span> 有</p><p><span class="math display">\[F(x, y) = \int_{-\infty}^{y} \int_{-\infty}^{x} f(u, v) \text{d}u \text{d}v\]</span></p><p>则称 <span class="math inline">\((X, Y)\)</span> 是二维连续型随机变量，函数 <span class="math inline">\(f(x, y)\)</span> 称为二维连续型随机变量 <span class="math inline">\((X, Y)\)</span> 的概率密度函数，或称为随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的联合概率密度。</p></blockquote><h2 id="边缘分布">边缘分布</h2><p>二维随机变量 <span class="math inline">\((X, Y)\)</span> 作为一个整体，具有分布函数 <span class="math inline">\(F(x, y)\)</span>，而 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 都是随机变量，各自也有分布函数，将它们分别记为 <span class="math inline">\(F_{X}(x)\)</span>，<span class="math inline">\(F_{Y}(y)\)</span>，依次称为二维随机变量 <span class="math inline">\((X, Y)\)</span> 关于 <span class="math inline">\(X\)</span> 和关于 <span class="math inline">\(Y\)</span> 的<strong>边缘分布函数</strong>。边缘分布函数可以由 <span class="math inline">\((X, Y)\)</span> 的分布函数 <span class="math inline">\(F(x, y)\)</span> 所确定，事实上，</p><p><span class="math display">\[F_{X}(x) = P\{X \leq x\} = P\{X \leq x, Y &lt; \infty\} = F(x, \infty)\]</span></p><p>也就是说，只要在函数 <span class="math inline">\(F(x, y)\)</span> 中令 <span class="math inline">\(y \to \infty\)</span> 就能得到 <span class="math inline">\(F_{X}(x)\)</span>。</p><blockquote><p>对于离散型随机变量，已知 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的分布律为，则称</p><p><span class="math display">\[\begin{aligned}P\{X = x_{i}\} &amp;= \sum_{j = i}^{\infty} p_{ij}, \quad i = 1, 2, \cdots\\P\{Y = y_{j}\} &amp;= \sum_{i = i}^{\infty} p_{ij}, \quad j = 1, 2, \cdots\end{aligned}\]</span></p><p>分别为关于 <span class="math inline">\(X\)</span> 和关于 <span class="math inline">\(Y\)</span> 的边缘概率密度。</p><p>对于连续型随机变量，设它的概率密度为 <span class="math inline">\(f(x, y)\)</span>，称</p><p><span class="math display">\[\begin{aligned}f_{X}(x) &amp;= \int_{-\infty}^{\infty} f(x, y) \text{d}y\\f_{Y}(y) &amp;= \int_{-\infty}^{\infty} f(x, y) \text{d}x\end{aligned}\]</span></p><p>分别为关于 <span class="math inline">\(X\)</span> 和关于 <span class="math inline">\(Y\)</span> 的边缘概率密度。</p></blockquote><h2 id="条件分布">条件分布</h2><p>设 <span class="math inline">\((X, Y)\)</span> 是二维离散型随机变量，对于固定的 <span class="math inline">\(j\)</span>，若 <span class="math inline">\(P\{Y = y_{j}\} &gt; 0\)</span>，则称</p><p><span class="math display">\[P\{X = x_{i} | Y = y_{j}\} = \frac{P\{X = x_{i}. Y = y_{j}\}}{P\{Y = y_{j}\}}, \quad i = 1, 2, \cdots\]</span></p><p>为在 <span class="math inline">\(Y = y_{j}\)</span> 条件下随机变量 <span class="math inline">\(X\)</span> 的条件分布律。</p><p>同样可以定义连续型随机变量的条件分布律。设二维随机变量 <span class="math inline">\((X, Y)\)</span> 的概率密度为 <span class="math inline">\(f(x, y)\)</span>，<span class="math inline">\((X, Y)\)</span> 关于 <span class="math inline">\(Y\)</span> 的边缘概率密度为 <span class="math inline">\(f_{Y}(y)\)</span>。若对于固定的 <span class="math inline">\(y\)</span>，<span class="math inline">\(f_{Y}(y) &gt; 0\)</span>，则称 <span class="math inline">\(\frac{f(x, y)}{f_{Y}(y)}\)</span> 为在 <span class="math inline">\(Y = y\)</span> 的条件下的<strong>条件概率密度</strong>，记为</p><p><span class="math display">\[f_{X | Y}(x \mid y) = \frac{f(x, y)}{f_{Y}(y)}\]</span></p><p>称 <span class="math inline">\(\int_{-\infty}^{x} f_{X | Y}(x \mid y) \text{d}x = \int_{-\infty}^{x} \frac{f(x, y)}{f_{Y}(y)} \text{d}x\)</span> 为在 <span class="math inline">\(Y = y\)</span> 的条件下 <span class="math inline">\(X\)</span> 的条件分布函数，记为 <span class="math inline">\(P\{X \leq x | Y = y\}\)</span> 或 <span class="math inline">\(F_{X | Y}(x \mid y)\)</span>，即</p><p><span class="math display">\[F_{X | Y}(x \mid y) = P\{X \leq x | Y = y\} = \int_{-\infty}^{x} \frac{f(x, y)}{f_{Y}(y)} \text{d}x\]</span></p><h2 id="相互独立的随机变量">相互独立的随机变量</h2><p>设 <span class="math inline">\(F(x, y)\)</span> 及 <span class="math inline">\(F_{X}(x)\)</span>，<span class="math inline">\(F_{Y}(y)\)</span> 分别是二维随机变量 <span class="math inline">\((X, Y)\)</span> 的分布函数及边缘分布函数，若对于所有 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span> 有</p><p><span class="math display">\[P\{X \leq x, Y \leq y\} = P\{X \leq x\} P\{Y \leq y\}\]</span></p><p>即</p><p><span class="math display">\[F(x, y) = F_{X}(x) F_{Y}(y)\]</span></p><p>则称随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是相互独立的。</p><p>设 <span class="math inline">\((X, Y)\)</span> 是连续型随机变量，<span class="math inline">\(f(x, y)\)</span>，<span class="math inline">\(f_{X}(x)\)</span>，<span class="math inline">\(f_{Y}(y)\)</span> 分别为 <span class="math inline">\((X, Y)\)</span> 的概率密度和边缘概率密度，则 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立的条件等价于下式</p><p><span class="math display">\[f(x, y) = f_{X}(x) f_{Y}(y)\]</span></p><p>在平面上几乎处处成立。</p><p>当 <span class="math inline">\((X, Y)\)</span> 是离散型随机变量时，<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立的条件等价于：对于 <span class="math inline">\((X, Y)\)</span> 的所有可能取的值 <span class="math inline">\((x_{i}, y_{j})\)</span> 有</p><p><span class="math display">\[P\{X = x_{i}, Y = y_{j}\} = P\{X = x_{i}\} P\{Y = y_{j}\}\]</span></p><h3 id="z-x-y">Z = X + Y</h3><p>若随机变量 <span class="math inline">\(Z = X + Y\)</span>，一般情况下，该随机变量的概率密度为</p><p><span class="math display">\[\begin{aligned}f_{X + Y}(z) &amp;= \int_{-\infty}^{\infty} f(z - y, y) \text{d}y\\f_{X + Y}(z) &amp;= \int_{-\infty}^{\infty} f(x, z - x) \text{d}x\end{aligned}\]</span></p><p>若 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立，则概率密度可以写为</p><p><span class="math display">\[\begin{aligned}f_{X + Y}(z) &amp;= \int_{-\infty}^{\infty} f_{X}(z - y) f_{Y}(y) \text{d}y\\f_{X + Y}(z) &amp;= \int_{-\infty}^{\infty} f_{X}(x) f_{Y}(z - x) \text{d}x\end{aligned}\]</span></p><p>上面两个公式称为 <span class="math inline">\(f_{X}\)</span> 和 <span class="math inline">\(f_{Y}\)</span> 的卷积公式，记为 <span class="math inline">\(f_{X} * f_{Y}\)</span>。</p><blockquote><p>若 <span class="math inline">\(X_{i} \sim N(\mu_i, \sigma_{i}^2)(i = 1, 2, \cdots, n)\)</span>，且 <span class="math inline">\(X_{i}\)</span> 之间相互独立，则 <span class="math inline">\(Z \sim N(\mu_{1} + \mu_{2} + \cdots + \mu_{n}, \sigma_{1}^2 + \sigma_{2}^2 + \cdots + \sigma_{n}^2)(Z = X_{1} + X_{2} + \cdots + X_{n})\)</span>，一般地，可以证明<strong>有限个相互独立的正态随机变量的线性组合仍然服从正态分布</strong>。 上述结论还能推广到 <span class="math inline">\(n\)</span> 个相互独立的 <span class="math inline">\(\Gamma\)</span> 分布变量之和的情况，即若 <span class="math inline">\(X_{i}\)</span> 服从参数为 <span class="math inline">\(\alpha_{i}\)</span>，<span class="math inline">\(\beta(i = 1, 2, \cdots, n)\)</span> 的 <span class="math inline">\(\Gamma\)</span> 分布，则 <span class="math inline">\(\sum\limits_{i = 1}^{n} X_{i}\)</span> 服从参数为 <span class="math inline">\(\sum\limits_{i = 1}^{n} \alpha_{i}\)</span>，<span class="math inline">\(\beta\)</span> 的 <span class="math inline">\(\Gamma\)</span> 分布。</p><p><span class="math display">\[\int_{0}^{+\infty} x^{\alpha-1} e^{-x/\beta}\,dx = \Gamma(\alpha)\,\beta^{\alpha}.\]</span></p></blockquote><h3 id="z-y-xz-xy">Z = Y / X，Z = XY</h3><p>一般概率密度</p><p><span class="math display">\[\begin{aligned}f_{Y|X}(z) &amp;= \int_{-\infty}^{\infty} |x| f(x, xz) \text{d}x\\f_{XY}(z) &amp;= \int_{-\infty}^{\infty} \frac{1}{|x|} f\bigg(x, \frac{z}{x}\bigg) \text{d}x\end{aligned}\]</span></p><p>同样地，若 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立，则概率密度可以写为</p><p><span class="math display">\[\begin{aligned}f_{Y|X}(z) &amp;= \int_{-\infty}^{\infty} |x| f_{X}(x) f_{Y}(xz) \text{d}x\\f_{XY}(z) &amp;= \int_{-\infty}^{\infty} \frac{1}{|x|} f_{X}(x) f_{Y}\bigg(\frac{z}{x}\bigg) \text{d}x\end{aligned}\]</span></p><h3 id="maxmin">MAX，MIN</h3><p>若 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立，由于 <span class="math inline">\(M = \max \{X, Y\}\)</span> 不大于 <span class="math inline">\(z\)</span> 等价于 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 都不大于 <span class="math inline">\(z\)</span>，故有</p><p><span class="math display">\[\begin{aligned}P\{M \leq z\} &amp;= P\{X \leq z, Y \leq z\} = P\{X \leq z\} P\{Y \leq z\}\end{aligned}\]</span></p><p>即</p><p><span class="math display">\[F_{\max}(z) = F_{X}(z) F_{Y}(z)\]</span></p><p>类似地，可以得到</p><p><span class="math display">\[\begin{aligned}F_{\min}(z) &amp;= P\{N \leq z\} = 1 - P\{N &gt; z\}\\&amp;= 1 - P\{X &gt; z, Y &gt; z\} = 1 - P\{X &gt; z\} P\{Y &gt; z\}\end{aligned}\]</span></p><p>即</p><p><span class="math display">\[F_{\min}(z) = 1 - [1 - F_{X}(z)][1 - P_{Y}(z)]\]</span></p><blockquote><p>以上结果容易推广到 <span class="math inline">\(n\)</span> 个相互独立的随机变量的情况。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>随机变量及其分布</title>
    <link href="/2025/11/11/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"/>
    <url>/2025/11/11/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="随机变量">随机变量</h2><p>设随机试验的样本空间为 <span class="math inline">\(S = \{e\}\)</span>，<span class="math inline">\(X = X(e)\)</span> 是定义在样本空间 <span class="math inline">\(S\)</span> 上的实值单值函数，称 <span class="math inline">\(X = X(e)\)</span> 为随机变量。</p><h2 id="分布律">分布律</h2><p>设离散型随机变量 <span class="math inline">\(X\)</span> 所有可能的取值为 <span class="math inline">\(x_{k}(k = 1, 2, 3, \cdots)\)</span>，<span class="math inline">\(X\)</span> 取各个可能值的概率，即事件 <span class="math inline">\(\{X = x_{k}\}\)</span> 的概率为</p><p><span class="math display">\[P \{X = x_{k}\} = p_{k}, \quad k = 1, 2 \cdots\]</span></p><h2 id="三种重要的离散型随机变量">三种重要的离散型随机变量</h2><h3 id="分布">0-1 分布</h3><p>设随机变量 <span class="math inline">\(X\)</span> 只可能取 0 与 1 两个值，它的分布律是</p><p><span class="math display">\[P \{X = k\} = p^{k} (1 - p)^{1 - k}, \quad k = 0, 1 \quad (0 &lt; p &lt; 1)\]</span></p><h3 id="伯努利试验">伯努利试验</h3><p>设试验 <span class="math inline">\(E\)</span> 只有两个可能结果：<span class="math inline">\(A\)</span> 及 <span class="math inline">\(\bar{A}\)</span>，则称 <span class="math inline">\(E\)</span> 为伯努利试验。设 <span class="math inline">\(P(A) = p (0 &lt; p &lt; 1)\)</span>，此时 <span class="math inline">\(P(\bar{A}) = 1 - p\)</span>。将 <span class="math inline">\(E\)</span> 独立重复地进行 <span class="math inline">\(n\)</span> 次，则称这一串重复的独立试验为 <span class="math inline">\(n\)</span> 重伯努利试验。其分布律如下：</p><p><span class="math display">\[P\{X = k\} = \binom{n}{k} p^{k} (1 - p)^{n - k}，\quad k = 0, 1, 2, \cdots, n\]</span></p><p>记作 <span class="math inline">\(X \sim b(n, p)\)</span>。</p><h3 id="泊松分布">泊松分布</h3><p>设随机变量 <span class="math inline">\(X\)</span> 所有可能取值为 <span class="math inline">\(0, 1, 2, \cdots\)</span>，而取各个可能值的概率为</p><p><span class="math display">\[P\{X = k\} = \frac{\lambda^{k} \text{e}^{-\lambda}}{k!}, \quad k = 0, 1, 2, \cdots\]</span></p><p>其中，<span class="math inline">\(\lambda &gt; 0\)</span> 是常数，则称 <span class="math inline">\(X\)</span> 服从参数为 <span class="math inline">\(\lambda\)</span> 的泊松分布，记为 <span class="math inline">\(X \sim \pi(\lambda)\)</span>。</p><h4 id="泊松定理">泊松定理</h4><p>设 <span class="math inline">\(\lambda &gt; 0\)</span> 是一个常数，<span class="math inline">\(n\)</span> 是任意正整数，设 <span class="math inline">\(np_n = \lambda\)</span>，则对于任一固定的的非负整数 <span class="math inline">\(k\)</span>，有</p><p><span class="math display">\[\lim_{n \ to \infty} \binom{n}{k} p_n^k (1 - p_n)^{n - k} = \frac{\lambda^{k} \text{e}^{-\lambda}}{k!}\]</span></p><p>因为 <span class="math inline">\(\lambda\)</span> 是一常数，所以若 <span class="math inline">\(n\)</span> 很大，则 <span class="math inline">\(p\)</span> 会很小，在这种情况下有</p><p><span class="math display">\[\binom{n}{k} p_n^k (1 - p_n)^{n - k} \approx \frac{\lambda^{k} \text{e}^{-\lambda}}{k!}, \quad \lambda = np\]</span></p><h2 id="随机变量的分布函数">随机变量的分布函数</h2><p><strong>分布函数</strong>的定义 设 <span class="math inline">\(X\)</span> 是一个随机变量，<span class="math inline">\(x\)</span> 是任意实数，函数</p><p><span class="math display">\[F(x) = P\{X \leq x\}, \quad -\infty &lt; x &lt; \infty\]</span></p><p>称为 <span class="math inline">\(X\)</span> 的分布函数。</p><h2 id="连续型随机变量及其概率密度">连续型随机变量及其概率密度</h2><p>如果对于随机变量 <span class="math inline">\(X\)</span> 的分布函数 <span class="math inline">\(F(x)\)</span>，存在非负可积函数 <span class="math inline">\(f(x)\)</span>，是对于任意实数 <span class="math inline">\(x\)</span> 有</p><p><span class="math display">\[F(x) = \int_{-\infty}^{x} f(t) \text{d} t\]</span></p><p>则称 <span class="math inline">\(X\)</span> 为<strong>连续型随机变量</strong>，<span class="math inline">\(f(x)\)</span> 称为 <span class="math inline">\(X\)</span> 的<strong>概率密度函数</strong>，简称为<strong>概率密度</strong>。</p><h2 id="三种重要的连续型随机变量">三种重要的连续型随机变量</h2><h3 id="均匀分布">均匀分布</h3><p>若连续型随机变量 <span class="math inline">\(X\)</span> 具有概率密度</p><p><span class="math display">\[f(x) =\begin{cases}\frac{1}{b - a}, &amp;a &lt; x &lt; b\\0, &amp;\text{otherwise}\end{cases}\]</span></p><p>则称 <span class="math inline">\(X\)</span> 在区间 <span class="math inline">\((a, b)\)</span> 上服从<strong>均匀分布</strong>，记为 <span class="math inline">\(X \sim U(a, b)\)</span>。</p><h3 id="指数分布">指数分布</h3><p>若连续型随机变量 <span class="math inline">\(X\)</span> 具有概率密度</p><p><span class="math display">\[f(x) =\begin{cases}\frac{1}{\theta} \text{e}^{-x/\theta}, &amp;x &gt; 0\\0, &amp;\text{otherwise}\end{cases}\]</span></p><p>其中 <span class="math inline">\(\theta &gt; 0\)</span> 为常数，则称 <span class="math inline">\(X\)</span> 服从参数为 <span class="math inline">\(\theta\)</span> 的指数分布。</p><blockquote><p>指数分布具有无记忆性，具体如下</p><p><span class="math display">\[\begin{aligned}P\{X &gt; s + t | X &gt; s\} &amp;= \frac{P\{(X &gt; s + t) \cap (X &gt; s)\}}{P\{X &gt; s\}}\\&amp;= \frac{P\{X &gt; s + t\}}{P\{X &gt; s\}} = \frac{1 - F(s + t)}{1 - F(s)}\\&amp;= \text{e}^{-t/\theta} = P\{X &gt; t\}\end{aligned}\]</span></p></blockquote><h3 id="正态分布">正态分布</h3><p>若连续型随机变量 <span class="math inline">\(X\)</span> 的概率密度为</p><p><span class="math display">\[f(t) = \frac{1}{\sqrt{2\pi}\sigma} \exp\bigg\{-\frac{(x - \mu)^{2}}{2\sigma^2}\bigg\}, \quad -\infty &lt; x &lt; \infty\]</span></p><p>其中，<span class="math inline">\(\mu\)</span>，<span class="math inline">\(\sigma &gt; 0\)</span> 为常数，则称 <span class="math inline">\(X\)</span> 服从参数为 <span class="math inline">\(\mu\)</span>，<span class="math inline">\(\sigma\)</span> 的<strong>正态分布</strong>或<strong>高斯分布</strong>，记为 <span class="math inline">\(X \sim N(\mu, \sigma^2)\)</span></p><blockquote><p>为了便于今后在数理统计中的应用，对于标准正态随机变量，我们引入上 <span class="math inline">\(\alpha\)</span> 分位数的定义 设 <span class="math inline">\(X \sim N(0, 1)\)</span>，若 <span class="math inline">\(z_{\alpha}\)</span> 满足条件</p><p><span class="math display">\[P\{X &gt; z_{\alpha}\} = \alpha, \quad 0&lt; \alpha &lt; 1\]</span></p><p>则称 <span class="math inline">\(z_{\alpha}\)</span> 为标准正态分布上的上 <span class="math inline">\(\alpha\)</span> 分位数。</p></blockquote><h2 id="随机变量的函数的分布">随机变量的函数的分布</h2><p>设随机变量 <span class="math inline">\(X\)</span> 具有概率密度 <span class="math inline">\(f_{X}(x)\)</span>，<span class="math inline">\(-\infty &lt; x &lt; \infty\)</span>，又设函数 <span class="math inline">\(g(x)\)</span> 处处可导且恒有 <span class="math inline">\(g&#39;(x) &gt; 0\)</span> 或 <span class="math inline">\(&lt; 0\)</span>，则 <span class="math inline">\(Y = g(X)\)</span> 是连续型随机变量，其概率密度为</p><p><span class="math display">\[f_{Y}(y) =\begin{cases}f_{X} [h_(y)] |h&#39;(y)|, &amp;\alpha &lt; y &lt; \beta\\0, &amp;\text{otherwise}\end{cases}\]</span></p><p>其中，<span class="math inline">\(\alpha = \min \{g(-\infty), g(\infty)\}\)</span>，<span class="math inline">\(\beta = \max \{g(-\infty), g(\infty)\}\)</span>，<span class="math inline">\(h(y)\)</span> 是 <span class="math inline">\(g(x)\)</span> 的反函数。</p><h2 id="补充">补充</h2><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/11/11/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/标准正态分布的上分位数.png" alt="标准正态分布的上分位数"><figcaption aria-hidden="true">标准正态分布的上分位数</figcaption></figure></div>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>概率论的基本概念</title>
    <link href="/2025/11/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2025/11/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="随机试验">随机试验</h2><ol type="1"><li>可以在相同条件下重复地进行；</li><li>每次试验的可能结果不止一个，并且能事先明确试验的所有可能结果；</li><li>进行一次试验前不能确定哪一个结果会出现。</li></ol><h2 id="样本空间随机事件">样本空间、随机事件</h2><p>随机试验 <span class="math inline">\(E\)</span> 的所有可能结果组成的集合称为 <span class="math inline">\(E\)</span> 的<strong>样本空间</strong>，记为 <span class="math inline">\(S\)</span>。样本空间中的元素，即 <span class="math inline">\(E\)</span> 的每一个结果，称为<strong>样本点</strong>。</p><p>称试验 <span class="math inline">\(E\)</span> 的样本空间 <span class="math inline">\(S\)</span> 的子集为 <span class="math inline">\(E\)</span> 的<strong>随机事件</strong>，简称为事件。在每次试验中，并且仅当这个子集中的一个样本点出现时，称这一<strong>事件发生</strong>。特别的由一个样本点组成的单点集称为<strong>基本事件</strong>。</p><h2 id="等可能事件古典概型">等可能事件（古典概型）</h2><ol type="1"><li>试验中的样本空间只包含有限个元素；</li><li>试验中的每个基本事件发生的可能性相同。</li></ol><h2 id="条件概率">条件概率</h2><p><strong>条件概率</strong>定义 设 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 是两个事件，且 <span class="math inline">\(P(A) &gt; 0\)</span>，称</p><p><span class="math display">\[P(B | A) = \frac{P(AB)}{P(A)}\]</span></p><p>为在事件 <span class="math inline">\(A\)</span> 发生的条件下事件 <span class="math inline">\(B\)</span> 发生的条件概率。</p><p><strong>乘法定理</strong>定义 设 <span class="math inline">\(P(A) &gt; 0\)</span>，则有</p><p><span class="math display">\[P(AB) = P(B | A) P (A)\]</span></p><p>上式称为乘法公式。</p><blockquote><p>可以将乘法公式推广到多项。设 <span class="math inline">\(A_1\)</span>，<span class="math inline">\(A_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(A_n\)</span> 为 <span class="math inline">\(n\)</span> 个事件，且 <span class="math inline">\(P(A_1 A_2 \cdots A_{n - 1}) &gt; 0\)</span>，则有</p><p><span class="math display">\[P(A_1 A_2 \cdots A_n) = P(A_n | A_1 A_2 \cdots A_{n - 1}) \cdots P(A_2 | A_1) P(A_1)\]</span></p></blockquote><h2 id="全概率公式与贝叶斯公式">全概率公式与贝叶斯公式</h2><p><strong>划分</strong>定义 设 <span class="math inline">\(S\)</span> 为试验 <span class="math inline">\(E\)</span> 的样本空间，<span class="math inline">\(B_1\)</span>，<span class="math inline">\(B_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(B_n\)</span> 为 <span class="math inline">\(E\)</span> 的一组事件，若</p><ol type="1"><li><span class="math inline">\(B_i B_j = \phi\)</span>，<span class="math inline">\(i \neq j\)</span>，<span class="math inline">\(j = 1, 2, \cdots, n\)</span>；</li><li><span class="math inline">\(B_1 \cup B_2 \cup \cdots B_n = S\)</span>。</li></ol><h3 id="全概率公式">全概率公式</h3><p>设试验 <span class="math inline">\(E\)</span> 的样本空间为 <span class="math inline">\(S\)</span>，<span class="math inline">\(A\)</span> 为 <span class="math inline">\(E\)</span> 的事件，<span class="math inline">\(B_1\)</span>，<span class="math inline">\(B_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(B_n\)</span> 为 <span class="math inline">\(S\)</span> 的一个划分，且 <span class="math inline">\(P(B_i) &gt; 0(i = 1, 2, \cdots, n)\)</span>，则</p><p><span class="math display">\[P(A) = P(A | B_1) P(B_1) + P(A | B_2) P(B_2) + \cdots + P(A | B_n) P(B_n)\]</span></p><h3 id="贝叶斯公式">贝叶斯公式</h3><p>设试验 <span class="math inline">\(E\)</span> 的样本空间为 <span class="math inline">\(S\)</span>，<span class="math inline">\(A\)</span> 为 <span class="math inline">\(E\)</span> 的事件，<span class="math inline">\(B_1\)</span>，<span class="math inline">\(B_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(B_n\)</span> 为 <span class="math inline">\(S\)</span> 的一个划分，且 <span class="math inline">\(P(A) &gt; 0\)</span>，<span class="math inline">\(P(B_i) &gt; 0(i = 1, 2, \cdots, n)\)</span>，则</p><p><span class="math display">\[P(B_i | A) = \frac{P(A | B_i) P(B_i)}{\sum\limits_{j = 1}^{n} P(A | B_j) P(B_j)}, \quad i = 1, 2, \cdots, n\]</span></p><h2 id="独立性">独立性</h2><p><strong>独立</strong>定义 设 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 是两事件，如果满足等式</p><p><span class="math display">\[P(AB) = P(A) P(B)\]</span></p><p>则称事件 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 相互独立，简称 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 独立。</p><ol type="1"><li>设 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 是两事件，且 <span class="math inline">\(P(A) &gt; 0\)</span>。若 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 相互独立，则 <span class="math inline">\(P(B | A) = P(B)\)</span>，反之亦然。</li><li>若事件 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 相互独立，则 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(\bar{B}\)</span>，<span class="math inline">\(\bar{A}\)</span> 和 <span class="math inline">\(B\)</span>，<span class="math inline">\(\bar{A}\)</span> 和 <span class="math inline">\(\bar{B}\)</span> 各对事件也相互独立。</li></ol><p><strong>相互独立</strong>的定义 设 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span>，<span class="math inline">\(C\)</span> 是三个事件，如果满足等式</p><p><span class="math display">\[\begin{cases}&amp;P(AB) = P(A) P(B)\\&amp;P(BC) = P(B) P(C)\\&amp;P(AC) = P(A) P(C)\\&amp;P(ABC) = P(A) P(B) P(C) \end{cases}\]</span></p><p>则称事件 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span>，<span class="math inline">\(C\)</span> 相互独立</p><blockquote><p>扩展到 <span class="math inline">\(n\)</span> 个事件，一般地，设 <span class="math inline">\(A_1\)</span>，<span class="math inline">\(A_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(A_n\)</span> 是 <span class="math inline">\(n(n \geq 2)\)</span> 个事件，如果对于其中任意 <span class="math inline">\(2\)</span> 个，任意 <span class="math inline">\(3\)</span> 个，<span class="math inline">\(\cdots\)</span>，任意 <span class="math inline">\(n\)</span> 个事件的积事件的概率，都等于个事件概率之积，则称事件 <span class="math inline">\(A_1\)</span>，<span class="math inline">\(A_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(A_n\)</span> 相互独立。</p><p>此外，相互独立又有如下性质</p><ol type="1"><li>若事件 <span class="math inline">\(A_1\)</span>，<span class="math inline">\(A_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(A_n\)</span> 相互独立，则其中任意 <span class="math inline">\(k\)</span> 个事件也是相互独立的；</li><li>若 <span class="math inline">\(n\)</span> 个事件 <span class="math inline">\(A_1\)</span>，<span class="math inline">\(A_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(A_n\)</span> 相互独立，则将 <span class="math inline">\(A_1\)</span>，<span class="math inline">\(A_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(A_n\)</span> 中任意多个事件换成它们各自的对立事件，所得的 <span class="math inline">\(n\)</span> 个事件仍然相互独立。</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>全连接网络</title>
    <link href="/2025/10/25/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/"/>
    <url>/2025/10/25/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>神经网络与深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Address Translation</title>
    <link href="/2025/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Address_Translation/"/>
    <url>/2025/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Address_Translation/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="address-translation-concept">Address Translation Concept</h2><blockquote><p>From virtual address to physical address.</p></blockquote><ol type="1"><li><p><strong>Memory protection（内存保护）</strong><br>地址转换允许操作系统为每个进程分配独立的虚拟地址空间。这样，一个进程无法访问或修改其他进程的内存区域，从而防止恶意或错误的访问，提升系统安全性。</p></li><li><p><strong>Memory sharing（内存共享）</strong><br>通过地址转换，多个进程可以安全地共享某些物理内存区域（如共享库或数据），而不会影响各自的私有数据。操作系统可灵活地将同一物理页映射到不同进程的虚拟地址空间。</p></li><li><p><strong>Flexible memory placement（灵活的内存放置）</strong><br>地址转换使得虚拟地址与物理地址解耦，操作系统可以将进程的内存分散地放置在物理内存的任意位置，而不要求连续分配，提高了内存利用率和碎片管理能力。</p></li><li><p><strong>Sparse addresses（稀疏地址空间）</strong><br>虚拟地址空间可以远大于实际物理内存，允许进程分配大但稀疏的地址空间。只有实际用到的部分才会分配物理内存，节省资源并支持大数据集或内存映射文件。</p></li><li><p><strong>Runtime lookup efficiency（运行时查找效率）</strong><br>地址转换机制（如页表和 TLB）设计为高效，能在每次内存访问时快速完成虚拟地址到物理地址的映射，保证程序运行速度不会因转换过程显著降低。</p></li><li><p><strong>Compact translation tables（紧凑的转换表）</strong><br>地址转换表（如多级页表）结构设计紧凑，既能支持大地址空间，又能节省内存开销，避免为未使用的虚拟地址分配过多资源。</p></li><li><p><strong>Portability（可移植性）</strong><br>虚拟地址空间让程序无需关心物理内存布局，提升了软件的可移植性。程序可以在不同硬件或操作系统上运行，而无需修改内存访问逻辑。</p></li></ol><h2 id="segmentation">Segmentation</h2><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Address_Translation/Segmented%20Memory.png" alt="Segmented Memory"><figcaption aria-hidden="true">Segmented Memory</figcaption></figure></div><p>在这一页的分段存储（Segmented Memory）图示中，virtual address（虚拟地址）的结构由两部分组成：</p><ul><li><strong>Segment（段寄存器）</strong>：用于选择当前访问的是哪一个段（segment），即在分段表中查找对应的条目。</li><li><strong>Offset（偏移寄存器）</strong>：表示在该段内的偏移量，即访问该段内的具体位置。</li></ul><p>虚拟地址结构可以用如下形式表示： <span class="math display">\[\text{Virtual Address} = (\text{Segment},\ \text{Offset})\]</span></p><p>图中的 “+” 和 “&gt;” 的意义如下：</p><ul><li><strong>“+”</strong>：表示将分段表中查到的该段的 Base（基址）与 Offset（偏移量）相加，得到物理地址。 <span class="math display">\[\text{Physical Address} = \text{Base} + \text{Offset}\]</span></li><li><strong>“&gt;”</strong>：表示将 Offset 与 Bound（界限）进行比较。如果 Offset 超过 Bound，说明访问越界，触发 Exception（异常）。</li></ul><p>简要流程：</p><ol type="1"><li>处理器根据虚拟地址中的 Segment 字段查找分段表，获得该段的 Base、Bound 和权限。</li><li>检查 Offset 是否小于 Bound（“&gt;”比较），否则异常。</li><li>用 Base + Offset（“+”运算）得到物理地址，完成地址转换。</li></ol><p>这样设计既实现了内存保护，也支持灵活的内存分布和访问控制。</p><blockquote><p>可以看到那张图最右边的 physical memory 中有许多 holes，为什么会形成这些 holes？如果一个 process branches into these holes 会发生什么？</p></blockquote><ul><li>为什么物理内存会有 holes（空洞）<ul><li>动态分配/释放：进程创建、退出或调整段/页大小后，物理上被释放的区域会留下不连续的空闲区（外部碎片）。<br></li><li>不同大小/对齐：段大小各异且要求对齐，会产生不能被当前需求填满的空闲间隙。<br></li><li>内核/设备保留：内核空间、设备映射等也占用物理地址区间，形成不可用的间隔。<br></li><li>若只用段式分配（不做压缩/搬迁），这些空洞会累积。</li></ul></li><li>如果进程“branch into these holes”（跳转或访问到这些空洞）会发生什么<ul><li>若虚拟地址没有被映射到有效段/页：MMU/段表检测到无效映射或权限不符，CPU 产生异常（segmentation fault / protection fault）。操作系统通常终止该进程或发信号（如 Unix 的 SIGSEGV）。<br></li><li>在按需分页系统中：若虚拟地址在合法的地址空间但对应页面尚未驻留，首次访问会触发 page fault，操作系统可以分配物理页并完成映射（例如分配零页或从磁盘加载），然后继续执行。<br></li><li>在分段模型中：若 offset &gt;= bound，会立即触发段越界异常；若 offset &lt; bound 但权限不够（如试图写入只读段），会触发保护异常。<br></li><li>简言之：未映射或越界访问不会“读到随机数据”，而是由硬件/OS 捕获并处理（异常、分配页面或终止进程）。</li></ul></li><li>操作系统的应对<ul><li>使用分页或段页结合以减轻外部碎片；采用内存压缩/搬迁（compaction）或交换（swap）来回收连续空间。<br></li><li>在允许情况下使用按需分配，首次访问时由 OS 分配并初始化物理页面。</li></ul></li></ul><p>结论：holes 是物理上未分配的空闲区，直接跳到这些区域通常会引起硬件异常或页面缺失，需由 OS 通过映射/分配或强制终止来处理。</p><blockquote><p>分段存储（Segmented Memory）在实际操作系统中的实现方式存在较大差异：</p><ul><li>某些操作系统（如 Multics）会为每个数据结构分配一个段，以实现细粒度的保护和进程间共享。</li><li>而大多数现代系统只用分段机制来管理粗粒度的内存区域（如代码段、数据段等），不再为每个小对象单独分段。</li></ul></blockquote><h2 id="paging">Paging</h2><h3 id="single-level-paging">Single-level Paging</h3><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Address_Translation/One-level%20page%20table.png" alt="One-level page table"><figcaption aria-hidden="true">One-level page table</figcaption></figure></div><p>单级页表虽然解决了很多问题（如支持页面共享），但<strong>页表本身可能非常大</strong>，甚至<strong>超过进程实际使用的内存</strong>。</p><ul><li>对于大地址空间，每个进程都需要分配完整的页表，即使实际只用到很少的页面。</li><li>这会导致大量内存浪费，尤其是进程数量多或每个进程实际用到的页面很少时。</li></ul><h3 id="multi-level-paging">Multi-level Paging</h3><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Address_Translation/Multi-level%20Paging.png" alt="Multi-level Paging"><figcaption aria-hidden="true">Multi-level Paging</figcaption></figure></div><h4 id="page-directory-entry">Page Directory Entry</h4><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Address_Translation/page%20directory%20entry.png" alt="page directory entry"><figcaption aria-hidden="true">page directory entry</figcaption></figure></div><h4 id="page-table-entry">Page Table Entry</h4><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Address_Translation/page%20table%20entry.png" alt="page table entry"><figcaption aria-hidden="true">page table entry</figcaption></figure></div><h3 id="memory-management-unit">Memory Management Unit</h3><blockquote><p>The hardware that actually does the translation, usually located in CPU.</p></blockquote><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Address_Translation/Memory%20management%20unit.png" alt="Memory management unit"><figcaption aria-hidden="true">Memory management unit</figcaption></figure></div><h3 id="page-fault">Page Fault</h3><ul><li><strong>Page Fault（缺页中断）</strong>：当 CPU/MMU 访问的虚拟地址没有被映射到物理内存时发生。<ul><li><strong>软缺页（Pure/Soft）</strong>：如页面被换出或共享页未驻留，操作系统处理后可继续访问。</li><li><strong>硬缺页（Invalid/Hard）</strong>：如写入只读页、访问未分配页等，通常导致段错误（Segmentation fault）。</li></ul></li><li><strong>现代操作系统中的 malloc 行为</strong>：<ul><li>malloc 只分配虚拟地址空间，<strong>不会立即分配物理内存</strong>。</li><li>只有当程序真正访问这块内存时，才通过缺页中断分配物理页。</li><li>这样做可以节省物理内存，提高资源利用率。</li></ul></li></ul><h3 id="copy-on-write">Copy-on-Write</h3>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Introduction to SQL</title>
    <link href="/2025/10/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Introduction_to_SQL/"/>
    <url>/2025/10/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Introduction_to_SQL/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="structured-query-language-sql">Structured Query Language (SQL)</h2><h3 id="sql-parts">SQL Parts</h3><ol type="1"><li>Data Manipulation Language (DML)<ul><li>The ability to <strong>query/retrieve</strong> information</li><li>The ability to <strong>select, insert, delete, update</strong> tuples</li></ul></li><li>Data Definition Language (DDL)<ul><li>The ability to <strong>define, drop, modify</strong> on <strong>schemas, views</strong> and <strong>index</strong></li><li><strong>Integrity</strong>: commands for <strong>specifying integrity constraints</strong></li><li><strong>View definition</strong>: commands for <strong>defining views</strong></li></ul></li><li>Transaction control<ul><li>Commands for specifying the <strong>beginning</strong> and <strong>ending</strong> of transactions</li></ul></li><li>Embedded SQL and dynamic SQL<ul><li>Statements embedded within <strong>programming languages</strong></li></ul></li><li>Authorization<ul><li>Commands for specifying <strong>access rights</strong> to relations and views</li></ul></li></ol><h3 id="sql-data-definition">SQL Data Definition</h3><p><strong>Def</strong>. DDL allows <strong>specification</strong> about relations:</p><ul><li>The <strong>schema</strong> for each relation</li><li>The <strong>type of values</strong> associated with each attribute</li><li>The <strong>integrity constraints</strong></li><li>The <strong>indices</strong> to be maintained for each relation</li><li>The <strong>security and authorization</strong> information for each relation</li><li>The <strong>physical storage structure</strong> of each relation on disk</li></ul><h3 id="domain-types-in-sql">Domain Types in SQL</h3><ul><li><code>char(n)</code>. Fixed length character string, user-specified length <span class="math inline">\(n\)</span></li><li><code>varchar(n)</code>. Variable length character string, user-specified length <span class="math inline">\(n\)</span></li><li><code>int</code>. Integer (the integers that is machine-dependent)</li><li><code>smallint</code>. Small integer (machine-dependent subset of the integer)</li><li><code>numeric(p, d)</code>. <strong>Fixed point number</strong>, user-specified precision of <span class="math inline">\(p\)</span> digits, with <span class="math inline">\(d\)</span> digits to the right of decimal point</li><li><code>data</code>. <strong>Dates</strong>, containing a (<span class="math inline">\(4\)</span> digit) year, month and date</li><li><code>time</code>. <strong>Time</strong> of day, in hours, minutes and seconds</li><li><code>timestamp</code>. <strong>Date plus time of day</strong>, e.g. <code>2001-7-27 09:00:30.75</code></li><li><code>Interval</code>. Period of time<ul><li>Subtracting a <strong>date/time/timestamp</strong> value from another gives an interval value</li></ul></li><li><code>Null</code>. Values allowed in all domain types. Declaring an attribute to be <strong>not null</strong> prohibits. null values for that attribute</li><li><code>create domain</code>. Construct creates <strong>user-defined domain</strong> types</li></ul><h3 id="basic-schema-definition-create-table">Basic Schema Definition: Create Table</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create table</span> takes (<br>  ID <span class="hljs-type">varchar</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">not null</span>,<br>  course_id <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">not null</span>,<br>  <span class="hljs-keyword">year</span> <span class="hljs-type">numeric</span>(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">not null</span>,<br>  grade <span class="hljs-type">varchar</span>(<span class="hljs-number">2</span>),<br>  <span class="hljs-keyword">primary key</span> (ID, course_id, <span class="hljs-keyword">year</span>),<br>  <span class="hljs-keyword">foreign key</span> (ID) <span class="hljs-keyword">references</span> student(ID),<br>  <span class="hljs-keyword">foreign key</span> (course_id, <span class="hljs-keyword">year</span>) <span class="hljs-keyword">references</span> section(course_id, <span class="hljs-keyword">year</span>)<br>);<br></code></pre></td></tr></table></figure><h4 id="updates-to-schemas">Updates to Schemas</h4><ul><li>Drop table: <code>DROP TABLE r</code></li><li>Alter:<ul><li><code>ALTER TABLE r ADD A D</code><ul><li>Where <span class="math inline">\(A\)</span> is the name of attribute added to <span class="math inline">\(r\)</span> and <span class="math inline">\(D\)</span> is the domain of <span class="math inline">\(A\)</span></li><li>All existing tuples are assigned <strong>null</strong> as the value for the added attribute</li></ul></li><li><code>ALTER TABLE r DROP A</code><ul><li>Not supported by many database</li></ul></li></ul></li></ul><p>The tuples/rows in <strong>table</strong> are stored <strong>row by row</strong>. Adding attributes or dropping the table leads to <strong>costly modifying</strong> the records and then moving these records</p><h2 id="basic-structure-of-sql-queries">Basic Structure of SQL Queries</h2><p>A typical SQL query has the form:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> A1, A2, ..., An<br><span class="hljs-keyword">FROM</span> r1, r2, ..., rm<br><span class="hljs-keyword">WHERE</span> P;<br></code></pre></td></tr></table></figure><p>This query is <strong>equivalent</strong> to the relational algebra expression:</p><p><span class="math display">\[\Pi_{A_1, A_2, \cdots, A_n} (\sigma_{P} (r_1 \times r_2 \times \cdots \times r_m))\]</span></p><h3 id="the-select-clause">The Select Clause</h3><p>The select clause lists the <strong>attributes</strong>. For example, find the names of all instructors:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> instructor;<br></code></pre></td></tr></table></figure><blockquote><p><em>Note</em>: names are case insensitive (Name, NAME, name).</p></blockquote><p>SQL allows <strong>duplicates</strong> in relations. To force elimination of duplicates, <strong>insert</strong> the keyword <strong>distinct</strong>. For example, find the department names of all instructors, and remove duplicates:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> dept_name<br><span class="hljs-keyword">FROM</span> instructor;<br></code></pre></td></tr></table></figure><blockquote><p>We also insert the keyword <strong>all</strong> to specify that duplicates should not be removed.</p></blockquote><ul><li>An <strong>asterisk</strong> in the select clause denotes <strong>all attributes</strong></li><li>An attribute can be a literal with <strong>no from</strong> clause, e.g. <code>SELECT '437';</code><ul><li>Results is a table with <strong>one column</strong> and <strong>a single row</strong> with value 437</li><li>Can give the column a <strong>name</strong> using: <code>SELECT '437;</code> AS FOO`</li></ul></li><li>An attribute can be a literal with <strong>from</strong> clause, e.g. <code>SELECT 'A' FROM instructor;</code><ul><li>Result is a table with <strong>one column</strong> and <span class="math inline">\(N\)</span> <strong>rows</strong>, each row with vale A.</li></ul></li></ul><p>The select clause can contain <strong>arithmetic expressions</strong> involving operation <span class="math inline">\(+\)</span>, <span class="math inline">\(-\)</span>, <span class="math inline">\(*\)</span>, and <span class="math inline">\(/\)</span>. The query:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> ID, name <span class="hljs-keyword">and</span> salary<span class="hljs-operator">/</span><span class="hljs-number">12</span> <span class="hljs-keyword">AS</span> monthly_salary<br><span class="hljs-keyword">FROM</span> instructor;<br></code></pre></td></tr></table></figure><p>would return a relation that is the same as <em>instructor</em>, except that the value of salary is divided by <span class="math inline">\(12\)</span>.</p><h3 id="the-where-clause">The Where Clause</h3><p>The where clause specifies <strong>conditions</strong> that the result must satisfy</p><ul><li>Corresponds to <strong>selection predicate</strong> of relational algebra</li><li>Allows the <strong>logical connectives</strong></li><li><strong>Between comparison operator</strong><ul><li>Find names of all instructors with salary between <span class="math inline">\(90000\)</span> and <span class="math inline">\(100000\)</span></li><li><code>SELECT name FROM instructor WHERE salary BETWEEN 90000 AND 100000;</code></li></ul></li><li><strong>Tuple comparison operator</strong><ul><li><code>SELECT name, course_id FROM instructors, teaches WHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology);</code></li></ul></li></ul><h3 id="the-from-clause">The From Clause</h3><p>The form clause lists relations corresponding to <strong>Cartesian product</strong> operation of relational algebra. For example, fin Cartesian product <em>instructor</em> and <em>teaches</em>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> instructor, teaches;<br></code></pre></td></tr></table></figure><p>For <strong>common</strong> attributes, like ID, attributes in resulting table are <strong>renamed</strong> using the relation name, like instructor.ID.</p><blockquote><p>Cartesian product not very useful directly, but useful with <strong>where clause</strong> condition.</p></blockquote><h3 id="natural-join">Natural Join</h3><p>Natural Join in <strong>from</strong> subclause. For example, find names of all instructors in Art who have taught some course and course_id.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> name, course_id<br><span class="hljs-keyword">FROM</span> instructor <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> teaches<br><span class="hljs-keyword">WHERE</span> instructor.dept_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Art&#x27;</span>;<br></code></pre></td></tr></table></figure><p>What’s difference compared with:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> name, course_id<br><span class="hljs-keyword">FROM</span> instructor, teaches<br><span class="hljs-keyword">WHERE</span> instructor.ID <span class="hljs-operator">=</span> teaches.ID <span class="hljs-keyword">AND</span> instructor.dept_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Art&#x27;</span>;<br></code></pre></td></tr></table></figure><p>SQL queries run in this order: <code>FROM + JOIN</code> <span class="math inline">\(\to\)</span> <code>WHERE</code> <span class="math inline">\(\to\)</span> <code>GROUP BY</code> <span class="math inline">\(\to\)</span> <code>HAVING</code> <span class="math inline">\(\to\)</span> <code>SELECT</code> <span class="math inline">\(\to\)</span> <code>ORDER BY</code> <span class="math inline">\(\to\)</span> <code>LIMIT</code>.</p><h2 id="the-rename-operation">The Rename Operation</h2><p>Renaming <strong>relations</strong> and <strong>attributes</strong> using the <strong>as</strong> clause. For example, find names of all instructors who have a higher salary than instructor in Comp.Sci.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> T.name <span class="hljs-keyword">AS</span> TeacherName<br><span class="hljs-keyword">FROM</span> instructor <span class="hljs-keyword">AS</span> T, instructors <span class="hljs-keyword">AS</span> S <span class="hljs-comment">/*tuple variables*/</span><br><span class="hljs-keyword">WHERE</span> T.salary <span class="hljs-operator">&gt;</span> S.salary <span class="hljs-keyword">and</span> S.dept_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Comp.Sci&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="string-operations">String Operations</h2><p><strong>String matching operator</strong> for comparison on <strong>character strings</strong>. The operator <strong>like</strong> uses patterns two special characters:</p><ul><li>Percent (<code>%</code>). The <code>%</code> character matches any <strong>substring</strong>.</li><li>Underscore (<code>_</code>). The <code>_</code> character matches any <strong>character</strong>.</li></ul><p>For example, find the names of all instructors whose name includes the substring “dar”.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> instructor<br><span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%dar%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>Or match the string “100%”, <code>LIKE '100\%' ESCAPE '\';</code>. We use backslash (<code>\</code>) as escape character.</p><p>Patterns are case sensitive. Examples:</p><ul><li><code>Intro%</code> matches any string beginning with “Intro”</li><li><code>%Comp%</code> matches any string containing “Comp” as a substring</li><li><code>_ _ _</code> matches any string of exactly <strong>three characters</strong></li><li><code>_ _ _%</code> matches any string of at <strong>least</strong> three characters.</li></ul><h2 id="ordering-the-display-of-tuples">Ordering the Display of Tuples</h2><ul><li>List in <strong>alphabetic order</strong> the names of all instructors. <code>ORDER BY name</code></li><li>Specify <strong>desc</strong> for descending order or <strong>asc</strong> for ascending order (ascending order is the default), e.g. <code>ORDER BY name DESC, dept_name DESC</code></li></ul><h2 id="set-operation">Set Operation</h2><p><strong>Def</strong>. <strong>Set operations</strong> include <strong>union</strong>, <strong>intersect</strong>, and <strong>except</strong> (<span class="math inline">\(\cup\)</span>, <span class="math inline">\(\cap\)</span>, <span class="math inline">\(-\)</span>) operate on relations.</p><ul><li><strong>Automatically eliminates duplicates</strong></li><li><strong>Union all</strong>, <strong>Intersect all</strong> and <strong>except all</strong>, to retain duplicates</li></ul><h2 id="null-values">Null Values</h2><p><strong>Null</strong> signifies an unknown value or a values does not exist. The <strong>result</strong> of any <strong>arithmetic expression</strong> involving <strong>null</strong> is <strong>null</strong>. The <strong>predicate is null</strong> can be used to check for null values. For example, find all instructors whose salary is null:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> instructor<br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><p>SQL treats as <strong>unknown</strong> the result of any comparison involving a <strong>nul</strong> value.</p><p>The predicate in a <strong>where</strong> clause can involve Boolean operations (and, or, not); thus Boolean operations need to be extended to deal with <strong>unknown</strong>.</p><ul><li><code>True AND UNKNOWN = UNKNOWN</code></li><li><code>FALSE AND UNKNOWN = UNKNOWN</code></li><li><code>UNKNOWN AND UNKNOWN = UNKNOWN</code></li><li><code>UNKNOWN OR TRUE = TRUE</code></li><li><code>UNKNOWN OR FALSE = UNKNOWN</code></li><li><code>UNKNOWN OR UNKNOWN = UNKNOWN</code></li></ul><blockquote><p>Results of <strong>where</strong> clause predicate is treated as <strong>false</strong> if it evaluates to <strong>unknown</strong>.</p></blockquote><h2 id="aggregate-functions">Aggregate Functions</h2><p><strong>Aggregate functions</strong> operate on values of <strong>column</strong>, but return a <strong>value</strong>.</p><ul><li><code>AVG</code>; average value</li><li><code>MIN</code>: minimum value</li><li><code>MAX</code>: maximum value</li><li><code>SUM</code>: sum of values</li><li><code>COUNT</code>: number of values</li></ul><p>Examples:</p><ol type="1"><li><p>Find average salary of instructors in Computer Science department</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span> instructor<br><span class="hljs-keyword">WHERE</span> dept_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Comp.Sci&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>Find <strong>total number of instructors</strong> who teach a course in Spring 2018</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> ID)<br><span class="hljs-keyword">FROM</span> teaches<br><span class="hljs-keyword">WHERE</span> dept_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Comp.Sci&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>Find <strong>the number of tuples</strong> in the <em>course</em> relation</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> course;<br></code></pre></td></tr></table></figure></li></ol><h3 id="group-by">Group By</h3><p>Find the average salary of instructors in <strong>each department</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> dept_name, <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">AS</span> avg_salary<br><span class="hljs-keyword">FROM</span> instructor<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_name;<br></code></pre></td></tr></table></figure><blockquote><p>Attributes in <strong>select</strong> clause outside of aggregate functions <strong>must appear in group by</strong> list (dept_name).</p><p>All aggregate operations <strong>except</strong> <code>COUNT(*)</code> <strong>ignore</strong> tuples with <strong>null</strong> values on the aggregated attributes.</p></blockquote><h3 id="having-clause">Having Clause</h3><p>Find the names and average salaries of all departments whose average salary is more than <span class="math inline">\(42000\)</span>.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> dept_name, <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">AS</span> avg_salary<br><span class="hljs-keyword">FROM</span> instructor<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_name<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-operator">&gt;</span> <span class="hljs-number">42000</span>;<br></code></pre></td></tr></table></figure><blockquote><p><em>Note</em>: predicates in <strong>having</strong> clause are applied after the formation of groups whereas predicates in <strong>where</strong> clause are applied before forming groups.</p></blockquote><h2 id="nested-subqueries">Nested Subqueries</h2><p><strong>Subquery</strong> is a <strong>select-from-where</strong> expression nested within <strong>another</strong> query. For example, find courses offered in Fall 2009 and in Spring 2010:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> course_id<br><span class="hljs-keyword">FROM</span> section<br><span class="hljs-keyword">WHERE</span> semester <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Fall&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2009</span> <span class="hljs-keyword">AND</span> course_id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> course_id <span class="hljs-keyword">FROM</span> section <span class="hljs-keyword">WHERE</span> semester <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Sprint&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2010</span>);<br></code></pre></td></tr></table></figure><blockquote><p>Don’t recommend!</p></blockquote><h2 id="some-and-all-clause">Some and All Clause</h2><ul><li>Some: <code>F &lt;comp&gt; SOME r</code> <span class="math inline">\(\Leftrightarrow \exist t \in r\)</span> such that (<code>F &lt;comp&gt; t</code>)</li><li>All: <code>F &lt;comp&gt; ALL r</code> <span class="math inline">\(\Leftrightarrow \forall t \in r\)</span> (<code>F &lt;comp&gt; t</code>)</li></ul><h2 id="exists-and-not-exists-clause">Exists and Not Exists Clause</h2><ul><li><p>Exists: find all courses taught in both Fall 2017 and Spring 2018</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> course_id<br><span class="hljs-keyword">FROM</span> section <span class="hljs-keyword">AS</span> S<br><span class="hljs-keyword">WHERE</span> semester <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Fall&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2017</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> section <span class="hljs-keyword">AS</span> T <span class="hljs-keyword">WHERE</span> semester <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Spring&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2018</span> <span class="hljs-keyword">AND</span> S.course_id <span class="hljs-operator">=</span> T.course_id);<br></code></pre></td></tr></table></figure></li><li><p>Not exists: find all students who have taken all courses offered in Biology department</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.ID, S.name<br><span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> S<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> ((<span class="hljs-keyword">SELECT</span> course_id <span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">WHERE</span> dept_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Biology&#x27;</span>) <span class="hljs-keyword">EXCEPT</span> (<span class="hljs-keyword">SELECT</span> T.course_id <span class="hljs-keyword">FROM</span> takes <span class="hljs-keyword">AS</span> T <span class="hljs-keyword">WHERE</span> S.ID <span class="hljs-operator">=</span> T.ID));<br></code></pre></td></tr></table></figure></li></ul><h2 id="unique-clause">Unique Clause</h2><p>The <strong>unique</strong> tests whether a subquery has any <strong>duplicate</strong> tuples in result. For example, find all courses that were offered at most once in 2017:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> T.course_id<br><span class="hljs-keyword">FROM</span> course <span class="hljs-keyword">AS</span> T<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">UNIQUE</span> (<span class="hljs-keyword">SELECT</span> R.course_id <span class="hljs-keyword">FROM</span> section <span class="hljs-keyword">AS</span> R <span class="hljs-keyword">WHERE</span> T.course_id <span class="hljs-operator">=</span> R.course_id <span class="hljs-keyword">AND</span> R.year <span class="hljs-operator">=</span> <span class="hljs-number">2017</span>);<br></code></pre></td></tr></table></figure><h2 id="subqueries-in-from-clause">Subqueries in From Clause</h2><p>Find <strong>the average instructors’ salaries</strong> of those departments where the average salary is greater than 42000:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> dept_name, avg_salary<br><span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> dept_name, <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> instructor <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_name) <span class="hljs-keyword">AS</span> dept_avg(dept_name, avg_salary)<br><span class="hljs-keyword">WHERE</span> avg_salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">42000</span>;<br></code></pre></td></tr></table></figure><h2 id="with-clause">With Clause</h2><p>The <strong>with clause</strong> provides a way of defining a <strong>temporary relation</strong> available only to the query in which the <strong>with clause occurs</strong>. For example, find all departments with the maximum budget:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">WITH</span> max_budget(<span class="hljs-keyword">values</span>) <span class="hljs-keyword">AS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(budget) <span class="hljs-keyword">FROM</span> department)<br><span class="hljs-keyword">SELECT</span> department.name<br><span class="hljs-keyword">FROM</span> department, max_budget<br><span class="hljs-keyword">WHERE</span> department.budget <span class="hljs-operator">=</span> max_budget.value;<br></code></pre></td></tr></table></figure><h2 id="scalar-subquery">Scalar Subquery</h2><p><strong>Scalar subquery</strong> is for one where <strong>a single value</strong> is expected. For example, list all departments along with the number of instructors in each department:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> dept_name, (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> instructor <span class="hljs-keyword">WHERE</span> department.dept_name <span class="hljs-operator">=</span> instructor.dept_name) <span class="hljs-keyword">AS</span> num_instructors<br><span class="hljs-keyword">FROM</span> department;<br></code></pre></td></tr></table></figure><h2 id="modification-of-database">Modification of Database</h2><h3 id="deletion">Deletion</h3><ul><li>Delete all instructors: <code>DELETE FROM instructor;</code></li><li>Delete all instructors from Finance department: <code>DELETE FROM instructor WHERE dept_name = 'Finance';</code></li><li>Delete all tuples in instructor for those instructors associated with department located in Watson building: <code>DELETE FROM instructor WHERE dept_name IN (SELECT dept_name FROM department WHERE building = 'Watson');</code></li><li>Delete all instructors whose salary is less than the average salary of instructors: <code>DELETE FROM instructor WHERE salary &lt; (SELECT AVG(salary) FROM instructor);</code><ul><li><strong>Problem</strong>: as deleting tuples from instructor, the average salary changes. Solutions:<ul><li>Firstly, compute average salary and find all tuples to delete</li><li>Subsequently, delete all tuples found above (without recomputing)</li></ul></li></ul></li></ul><h3 id="insertion">Insertion</h3><ul><li><p>Add a new tuple to <em>course</em>: <code>INSERT INTO course VALUES ('CS-437', 'Database Systems', 'Comp.Sci', 4);</code></p></li><li><p>Add a new tuple to <em>student</em> with total_creds set to null: <code>INSERT INTO student VALUES('3003', 'Green', 'Finance', null);</code></p></li><li><p>Make <strong>each student</strong> in Music department who has earned more than <span class="math inline">\(144\)</span> credits hours an instructor in the Music department <strong>with salary of</strong> <span class="math inline">\(18000\)</span></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">INSERT INTO</span> instructor<br><span class="hljs-keyword">SELECT</span> ID, name, dept_name, <span class="hljs-number">18000</span><br><span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> dept_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Music&#x27;</span> <span class="hljs-keyword">AND</span> total_cred <span class="hljs-operator">&gt;</span> <span class="hljs-number">144</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="updates">Updates</h3><ul><li><p>Give a <span class="math inline">\(5\%\)</span> salary raise to all instructors:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> instructor<br><span class="hljs-keyword">SET</span> salary <span class="hljs-operator">=</span> salary <span class="hljs-operator">*</span> <span class="hljs-number">1.05</span>;<br></code></pre></td></tr></table></figure></li><li><p>Give a <span class="math inline">\(5\%\)</span> salary raise to those instructors who earn less than <span class="math inline">\(70000\)</span>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> instructor<br><span class="hljs-keyword">SET</span> salary <span class="hljs-operator">=</span> salary <span class="hljs-operator">*</span> <span class="hljs-number">1.05</span><br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&lt;</span> <span class="hljs-number">70000</span>;<br></code></pre></td></tr></table></figure></li><li><p>Give a <span class="math inline">\(5\%\)</span> salary raise to instructors whose salary is less than average:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> instructor<br><span class="hljs-keyword">SET</span> salary <span class="hljs-operator">=</span> salary <span class="hljs-operator">*</span> <span class="hljs-number">1.05</span><br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&lt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> instructor);<br></code></pre></td></tr></table></figure></li><li><p>Increase salaries of instructors whose salary is over <span class="math inline">\(100000\)</span> by <span class="math inline">\(3\%\)</span>, and all others by a <span class="math inline">\(5\%\)</span>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> instructor<br><span class="hljs-keyword">SET</span> salary <span class="hljs-operator">=</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> salary <span class="hljs-operator">&lt;=</span> <span class="hljs-number">100000</span> <span class="hljs-keyword">THEN</span> salary <span class="hljs-operator">*</span> <span class="hljs-number">1.05</span> <span class="hljs-keyword">ELSE</span> salary <span class="hljs-operator">*</span> <span class="hljs-number">1.03</span> <span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure></li><li><p>Recompute and update total_creds value for all students</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> student S<br><span class="hljs-keyword">SET</span> total_creds <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(credits) <span class="hljs-keyword">FROM</span> takes, course <span class="hljs-keyword">WHERE</span> takes.course_id <span class="hljs-operator">=</span> course.course_id <span class="hljs-keyword">AND</span> S.ID <span class="hljs-operator">=</span> takes.ID <span class="hljs-keyword">AND</span> takes.grade <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;F&#x27;</span> <span class="hljs-keyword">AND</span> takes.grade <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span>);<br></code></pre></td></tr></table></figure></li><li><p>Sets total_creds to null for students who have not taken any course:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> student<br><span class="hljs-keyword">SET</span> total_creds <span class="hljs-operator">=</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-built_in">SUM</span>(credits) <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">THEN</span> <span class="hljs-built_in">SUM</span>(credits) <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TLB and Cache</title>
    <link href="/2025/10/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/TLB_and_Cache/"/>
    <url>/2025/10/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/TLB_and_Cache/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="cache">Cache</h2><h3 id="concept">Concept</h3><ul><li>Cache（缓存）：存放数据的副本，使常用数据比原始位置更快被访问。</li><li>目的：加速频繁访问，提升系统性能（适用于架构、操作系统、分布式系统等）。</li><li>前提：只有在较高的“缓存命中率”下才有效。</li><li>关键公式：<span class="math inline">\(平均访问时间 = 命中率 \times 命中时间 + 未命中率 \times 未命中时间\)</span></li></ul><blockquote><p>Processing is often faster than I/O access</p></blockquote><h3 id="locality">Locality</h3><blockquote><p>the Key to Cache Success</p></blockquote><ul><li>时间局部性（Temporal locality）：若某地址被访问，则短期内很可能再次被访问，于是把最近访问的数据保留在靠近处理器的缓存中。</li><li>空间局部性（Spatial locality）：若某地址被访问，附近地址很可能随后被访问，于是将连续的数据块一起提升到上层缓存。</li><li>要点：利用时间与空间局部性可以提高缓存命中率，从而显著降低平均访问时间。</li></ul><h3 id="memory-hierarchy">Memory Hierarchy</h3><ul><li>内存层次（Memory Hierarchy）：通过多级存储（从寄存器到磁带）在速度、容量和成本之间权衡，常用数据放在更快但更小/更贵的层次以提升性能。</li><li>关键收益来自局部性：时间局部性和空间局部性。</li><li>关键公式：<span class="math inline">\(平均访问时间 = 命中率 \times 命中时间 + 未命中率 \times 未命中时间\)</span>。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table style="width:100%;"><thead><tr class="header"><th>层级</th><th style="text-align: right;">典型组件</th><th style="text-align: right;">典型访问延迟（量级）</th><th style="text-align: right;">典型容量</th><th>主要作用</th></tr></thead><tbody><tr class="odd"><td>寄存器</td><td style="text-align: right;">CPU registers</td><td style="text-align: right;">≈ 1 ns（最短）</td><td style="text-align: right;">数十–百字节</td><td>存放当前运算操作数，最快速访问</td></tr><tr class="even"><td>On-chip cache (L1)</td><td style="text-align: right;">L1/L0 缓存</td><td style="text-align: right;">~1–10 ns</td><td style="text-align: right;">KB–十几KB</td><td>利用时间局部性，快速命中CPU近操作数据</td></tr><tr class="odd"><td>二级/片上缓存 (L2/L3, SRAM)</td><td style="text-align: right;">On-chip / Second level cache</td><td style="text-align: right;">~10–100 ns</td><td style="text-align: right;">KBs–MBs</td><td>扩展缓存容量，降低对主存访问</td></tr><tr class="even"><td>主存 (DRAM)</td><td style="text-align: right;">Main Memory</td><td style="text-align: right;">~100 ns</td><td style="text-align: right;">MBs–GBs</td><td>存放程序数据/指令，容量较大但延迟更高</td></tr><tr class="odd"><td>二级存储 (Disk)</td><td style="text-align: right;">磁盘/SSD</td><td style="text-align: right;">~10 ms（磁盘） / 更低（SSD）</td><td style="text-align: right;">GBs–TBs</td><td>持久存储，容量大但延迟高</td></tr><tr class="even"><td>三级/更慢存储 (Tape)</td><td style="text-align: right;">磁带等</td><td style="text-align: right;">~10 s（量级）</td><td style="text-align: right;">TBs–PBs</td><td>归档、离线存储，极低成本高容量但访问慢</td></tr></tbody></table></div><ul><li>要点：通过速度、容量和成本的权衡构建内存层次（Memory Hierarchy），在不同层次用缓存技术提高访问效率。</li><li>直接利用的缓存技术示例：TLB（页表项缓存）、多级缓存（Cache）、分页虚拟内存（内存作为磁盘缓存）、文件系统缓存、DNS 缓存、Web 代理缓存等。</li><li>原理：利用时间局部性与空间局部性提升命中率，从而降低平均访问时间。</li><li>本课程关注的路径：CPU → TLB → Cache → Memory（重点讲解 TLB 与 Cache 的作用与交互）。</li></ul><h2 id="tlb">TLB</h2><h3 id="address-translation-problem">Address Translation Problem</h3><ul><li>问题：虚拟地址到物理地址的多级页表翻译会显著拖慢内存访问。</li><li>原因：每次内存访问可能需要多次（至少两次）额外的内存访问来查页表；而内存速度通常远慢于CPU，层级越多开销越大。</li><li>图示：把虚拟地址分成若干索引字段，逐级查页表得到页框，再加上页内偏移形成物理地址，说明多次访存的过程。</li><li>隐含结论：需要用TLB等缓存页表项的机制来避免频繁的多次内存访问，从而提高性能。</li></ul><h3 id="tlb-as-a-cache">TLB as a Cache</h3><ul><li>TLB（Translation Lookaside Buffer，转换检测缓冲区）：MMU 内的一个特殊高速缓存，用来缓存页表项以加速地址转换。</li><li>作用：把虚拟页号直接映射到物理页框，避免每次访问都进行多级页表查找，从而降低地址翻译的延迟。</li><li>依赖局部性：利用时间局部性（近期访问页）和空间局部性（相邻地址位于同一页）提高命中率。</li><li>关键点：内存映射按页对齐，TLB 缓存的是页级别的映射条目；TLB 命中能显著减少对主存的额外访存。</li></ul><h3 id="tlb-lookup">TLB Lookup</h3><ul><li>关键流程：MMU 在每次访问时查找 TLB；若任一条目匹配则为命中，直接得到物理页并完成访问；若全部不匹配则为未命中，需做完整的页表翻译并将得到的映射替换进 TLB。</li><li>TLB 条目包含：虚拟页号、物理页框号、访问权限。</li><li>目的与要点：通过缓存页级映射避免多级页表的多次内存访问，利用时间/空间局部性提高地址转换速度并降低延迟。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/TLB_and_Cache/A%20TLB%20lookup%20goes%20through%20each%20TLB%20entry.png" alt="A TLB lookup goes through each TLB entry"><figcaption aria-hidden="true">A TLB lookup goes through each TLB entry</figcaption></figure></div><blockquote><p>TLBs are often set-associative to reduce the comparison.</p></blockquote><h3 id="tlb-miss">TLB Miss</h3><p>TLB 未命中的主要来源概括：</p><ul><li>该虚拟页此前未被访问（冷启动缺失）。</li><li>因 TLB 容量有限而被驱逐（替换导致未命中）。</li><li>由于相联性引发页映射冲突（不同页争用同组）。</li><li>其它进程或内核修改了页表条目，导致原有 TLB 条目失效。</li></ul><p>TLB 未命中（TLB miss）有两种处理方式——硬件遍历页表和软件遍历页表（如 MIPS），两者的流程和结果不同。</p><ul><li>硬件遍历：MMU 在 TLB miss 时自动走当前多级页表以填充 TLB。若 PTE 有效，硬件填入 TLB，处理器无感知；若 PTE 标记为无效，则产生页错误（page fault），由内核决定后续处理。</li><li>软件遍历：处理器在 TLB miss 时产生 TLB fault，内核收到异常后遍历页表查找 PTE。若 PTE 有效，内核填充 TLB 并从异常返回；若无效，则调用页错误处理例程。</li></ul><h3 id="tlb-performance">TLB Performance</h3><ul><li><p>关键指标：TLB 命中率（hit ratio）。</p></li><li><p>提高命中率的两种常用手段：超级页（superpage）和预取（prefetching）。</p></li><li><p>典型参数量级：</p><ul><li>大小：12 位索引 → ≈ 4096 条目；</li><li>命中时间：约 <span class="math inline">\(0.5\text{–}1\)</span> 个时钟周期；</li><li>未命中惩罚：约 <span class="math inline">\(10\text{–}100\)</span> 个时钟周期；</li><li>未命中率：约 <span class="math inline">\(0.01\%\text{–}1\%\)</span>（稀疏/图结构应用可达 <span class="math inline">\(20\%\text{–}40\%\)</span>）。</li></ul></li><li><p>成本公式：</p><p><span class="math display">\[\text{Cost(address translation)} = \text{Cost(TLB lookup)} + \text{Cost(full translation)}\times P(\text{miss})\]</span></p></li><li><p>要点：TLB 小而快，命中率对地址转换总体开销决定性；通过增加页粒度或预取能有效提升性能。</p></li></ul><blockquote><p>If a TLB hit takes 1 clock cycle, a miss takes 30 clock cycles, a memory read takes 30 clock cycles, and the miss rate is 1%, what’s the average memory access time?</p></blockquote><h4 id="superpage">Superpage</h4><ul><li><strong>超级页（Superpage）</strong>：物理内存中一组连续页，映射到虚拟内存的连续区域，且页对齐，使它们共享同一个高位（超级页地址）。<ul><li>这样可以用一个 TLB 条目缓存整个超级页，显著提升 TLB 命中率。</li><li>但会牺牲内存分配的灵活性（需要大块连续空间）。</li></ul></li><li><strong>匹配方式</strong>：只比较地址的高位（超级页地址），忽略超级页内的偏移。<ul><li>2MB 超级页：偏移为虚拟地址最低 21 位。</li><li>1GB 超级页：偏移为最低 30 位。</li><li>x86 架构对超级页会跳过页表的一级或两级。</li></ul></li><li><strong>要点</strong>：同一超级页内所有页只需一个 TLB 条目即可命中，减少 TLB 未命中次数，提高性能。</li></ul><h4 id="tlb-prefetching">TLB Prefetching</h4><ul><li>TLB 预取是指在实际使用前，将页表项提前加载到 TLB 中，以减少未命中带来的延迟。</li><li>预取方式包括：<ol type="1"><li>顺序预取（Sequential）：利用空间局部性，适合线性访问。</li><li>跨步预取（Strided）：适用于数组等规律访问。</li><li>相关预取（Correlated）：根据历史访问模式预测下一步访问。</li></ol><ul><li>预取可由软件或硬件实现。</li></ul></li><li>CPU 预取的效果与流水线结构密切相关，类似于指令预取。</li></ul><h4 id="memory-performance">Memory Performance</h4><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>缓存类型</th><th>缓存内容</th><th>缓存位置</th><th>延迟（周期）</th><th>管理者</th></tr></thead><tbody><tr class="odd"><td>Registers（寄存器）</td><td>4-8 字节字</td><td>CPU 内核</td><td>0</td><td>编译器</td></tr><tr class="even"><td>TLB</td><td>地址转换</td><td>芯片上的 TLB</td><td>0</td><td>硬件 MMU</td></tr><tr class="odd"><td>L1 cache</td><td>64 字节块</td><td>芯片上的 L1</td><td>4</td><td>硬件</td></tr><tr class="even"><td>L2 cache</td><td>64 字节块</td><td>芯片上的 L2</td><td>10</td><td>硬件</td></tr><tr class="odd"><td>虚拟内存</td><td>4KB 页</td><td>主存</td><td>100</td><td>硬件 + 操作系统</td></tr><tr class="even"><td>Buffer cache</td><td>文件部分</td><td>主存</td><td>100</td><td>操作系统</td></tr><tr class="odd"><td>Disk cache</td><td>磁盘扇区</td><td>磁盘控制器</td><td>100,000</td><td>磁盘固件</td></tr><tr class="even"><td>网络缓冲缓存</td><td>文件部分</td><td>本地磁盘</td><td>10,000,000</td><td>NFS 客户端</td></tr><tr class="odd"><td>浏览器缓存</td><td>网页</td><td>本地磁盘</td><td>10,000,000</td><td>浏览器</td></tr><tr class="even"><td>Web 缓存</td><td>网页</td><td>远程服务器磁盘</td><td>1,000,000,000</td><td>Web 代理服务器</td></tr></tbody></table></div><h3 id="tlb-consistency">TLB Consistency</h3><p>TLB 一致性（Consistency）是所有缓存系统都面临的核心问题：缓存中的内容必须与原始数据保持一致，尤其在条目被修改时。主要涉及以下场景：</p><ul><li>进程上下文切换（Process context switch）：切换进程时需保证 TLB 不泄漏或错误映射其他进程的数据。</li><li>权限降低（Permission reduction）：当页表权限被收紧时，TLB 中的旧权限条目必须失效。</li><li>TLB 失效（TLB shootdown）：多核系统中，某核修改页表后需通知其他核使相关 TLB 条目失效，确保一致性。</li></ul><p>要点：TLB 必须及时同步页表的变更，避免访问到过期或错误的地址映射。</p><h4 id="permission-reduction">Permission Reduction</h4><ul><li>当映射被丢弃或访问权限降低（如从读写变为只读）时，需保证 TLB 条目失效以防止非法访问。<ul><li>早期计算机直接清空整个 TLB；现代系统支持逐条失效（如 x86 的 <code>invlpg</code> 指令）。</li><li>如果页被多个进程共享，处理更复杂。</li></ul></li><li>权限提升（如只读变为读写）无需特殊处理，因为旧条目不会导致安全问题。</li><li>探讨是否能用硬件自动处理 TLB 失效：<ul><li>处理器无法追踪映射来源，难以判断内存写入是否影响 TLB 条目。</li><li>即使能做到，频繁检查所有写入也没有必要。</li></ul></li></ul><p>结论：权限降低时需主动失效相关 TLB 条目，通常由软件（操作系统）完成。</p><h4 id="tlb-shootdown">TLB Shootdown</h4><ul><li>多处理器系统中，任一处理器修改页表（及其 TLB）时，需让其他处理器的 TLB 也失效（flush），称为 TLB shootdown。</li><li>具体流程：<ol type="1"><li>操作系统先修改页表；</li><li>向所有处理器发送 TLB flush 请求；</li><li>完成 TLB 更新的处理器可恢复运行；</li><li>原始处理器需等待所有处理器确认移除旧条目后才能继续。</li></ol></li><li>TLB shootdown 的代价随核心数线性增长，可通过批量处理（batch）优化。</li></ul><p>要点：多核系统中，页表变更需同步所有核的 TLB，代价高，需优化。</p><blockquote><p>如果初始 CPU 没有等待其他 CPU 的 TLB 失效确认，可能导致同一页被多次读取但数据不一致</p></blockquote><h2 id="memory-cache">Memory Cache</h2><blockquote><p>Fill the speed gap of CPU and DRAM memory.</p></blockquote><ul><li><strong>块</strong>（block）是缓存的最小单位，通常大于一个字/字节，以利用空间局部性。块大小不能太大也不能太小，现代 Intel 处理器常用 64 字节。</li><li>地址查找时，地址被分为三部分：Tag（标记）、Index（索引）、Block offset（块内偏移）。<ul><li>Index 用于选择缓存集合（Set Select）。</li><li>Block offset 用于选择块内具体数据（Data Select）。</li></ul></li></ul><h3 id="cache-lookup">Cache Lookup</h3><p>缓存（Cache）的查找方式（Cache Lookup）及其三种典型结构：</p><ul><li><strong>全关联</strong>（Fully associative，完全关联）：每个地址可以存储在缓存表的任意位置，灵活但查找速度慢。</li><li><strong>直接映射</strong>（Direct mapped）：每个地址只能存储在缓存表的一个固定位置，查找速度快但容易冲突。</li><li><strong>N 路组关联</strong>（N-way set associative）：每个地址可以存储在 N 个缓存集合中的一个，兼顾查找速度和命中率。</li></ul><h4 id="fully-associative">Fully Associative</h4><ul><li><strong>查找方式</strong>：每条缓存线都需要比较其 Cache Tag（缓存标记），以判断是否命中。</li><li><strong>示例参数</strong>：块大小为 32 字节（Block Size = 32B）。</li><li><strong>硬件需求</strong>：需要 <span class="math inline">\(N\)</span> 个 27 位比较器（假设地址高 27 位为 Tag），以并行比较所有缓存行的 Tag。</li><li><strong>地址分解</strong>：地址高位为 Cache Tag（27 位），低 5 位为 Byte Select（块内偏移）。</li><li><strong>结构说明</strong>：每条缓存线包含 Cache Tag、Cache Data（数据块）、Valid Bit（有效位）。</li><li><strong>查找流程</strong>：输入地址后，所有缓存行的 Tag 并行比较，若有命中则通过 Byte Select 选取块内具体字节。</li></ul><blockquote><p>全关联缓存灵活但硬件复杂度高，适合容量较小的高速缓存。</p></blockquote><h4 id="direct-mapped">Direct Mapped</h4><blockquote><p>Map to one specific cache line through a Hash function.</p></blockquote><p>举个例子：1 KB Direct Mapped Cache with 32 B Blocks</p><ul><li>Index chooses potential block.</li><li>Tag checked to ver ify block.</li><li>Byte select chooses byte within block.</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/TLB_and_Cache/Direct%20Mapped.png" alt="Direct Mapped"><figcaption aria-hidden="true">Direct Mapped</figcaption></figure></div><blockquote><p>Drawback: frequently using two addresses that map to the same cache entry leads to thrash.</p></blockquote><h3 id="set-associative">Set Associative</h3><p>对于每个 Cache Index（缓存索引），组关联允许有 <span class="math inline">\(N\)</span> 条缓存线（entries）并行参与查找。</p><blockquote><p>一个地址查找时，组内有 <span class="math inline">\(N\)</span> 个 tag 并行比较。</p></blockquote><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/TLB_and_Cache/Set%20Associative.png" alt="Set Associative"><figcaption aria-hidden="true">Set Associative</figcaption></figure></div><blockquote><p>Why use the lower bits for index, higher bits for tag?</p></blockquote><ol type="1"><li><strong>空间局部性原理</strong><ul><li>地址的低比特变化快，代表相邻的数据块（如连续字节、连续数组元素）。</li><li>把低比特作为 Index，可以让相邻地址映射到相邻或同一组缓存线，充分利用空间局部性，提高命中率。</li></ul></li><li><strong>高比特唯一性</strong><ul><li>高比特变化慢，代表远距离的数据（如不同数组、不同函数变量）。</li><li>用高比特作为 Tag，可以区分那些映射到同一组但实际属于不同内存区域的数据，防止冲突。</li></ul></li></ol><h3 id="cache-replacement">Cache Replacement</h3><ul><li><p><strong>Direct mapped（直接映射）</strong><br>只有一种可能：每个地址只能映射到一个固定的缓存位置，不需要替换策略。</p></li><li><p><strong>Set associative 或 fully associative（组关联或全关联）</strong><br>一个数据块可以放在多个位置，需要替换策略来决定驱逐哪一个缓存块。常见策略有：</p><ul><li>Random（随机）：简单，无额外开销。</li><li>FIFO（先进先出）：某些场景下效果很差。</li><li>LRU（最近最少使用）：根据历史访问预测未来，优先替换最久未被访问的块。</li></ul></li></ul><h3 id="cache-write-policies">Cache Write Policies</h3><ul><li><strong>Write through（直写）</strong>：数据同时写入缓存和主存。<ul><li>优点：读未命中不会导致写操作。</li><li>缺点：处理器写入时会被阻塞，除非有写缓冲。</li></ul></li><li><strong>Write back（回写）</strong>：数据只写入缓存，只有缓存块被替换时才写回主存。<ul><li>需判断缓存块是否被修改（干净/脏块，dirty bit）。</li><li>优点：重复写操作不会频繁写入主存，处理器写入时不被阻塞。</li><li>缺点：实现更复杂，读未命中时可能需要先回写脏数据。</li></ul></li></ul><blockquote><p>虚拟地址还是物理地址寻址？</p></blockquote><ul><li>缓存（Cache）可以通过虚拟地址或物理地址进行寻址，但实际有多个层级的缓存。</li><li>所有经过 MMU（内存管理单元）后的地址访问都是物理地址。</li><li>TLB 未命中的代价非常高，因此通常会让 TLB 和一级缓存（L1 Cache）在 CPU 内部重叠，以提升性能。</li><li>图示流程：CPU 先用虚拟地址经 MMU &amp; TLB 翻译为物理地址，再访问各级缓存和主存。</li></ul><h3 id="overlapping-tlb-and-cache">Overlapping TLB and Cache</h3><ul><li>虚拟地址中的 Offset（页内偏移）<strong>正好覆盖了 Cache 的 index（索引）和 byte select（字节选择）字段</strong>。</li><li>这样，CPU 可以在地址转换（TLB 查找虚拟页号 <span class="math inline">\(\to\)</span> 物理页号）的同时，<strong>并行选中缓存中的字节</strong>，提升访问效率。</li></ul><p>实际上，虚拟地址和物理地址的结构为：</p><ul><li>虚拟地址结构：<code>[Virtual Page # | Offset]</code><ul><li>Virtual Page #：虚拟页号，用于TLB查找。</li><li>Offset：页内偏移，用于定位页内具体字节。</li></ul></li><li>物理地址结构：<code>[tag/page # | index | byte]</code><ul><li>tag/page #：物理页号或缓存标记。</li><li>index：缓存索引（决定落在哪个cache组）。</li><li>byte：块内字节选择。</li></ul></li></ul><p><strong>对应关系：</strong></p><ul><li>虚拟地址的 Offset 部分，经过TLB转换后，直接作为物理地址的 index 和 byte 字段。</li><li>这样，<strong>TLB查找和Cache查找可以并行进行</strong>，不必等TLB完成后再查Cache，减少延迟。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/TLB_and_Cache/Overlapping%20TLB%20and%20Cache.png" alt="Overlapping TLB and Cache"><figcaption aria-hidden="true">Overlapping TLB and Cache</figcaption></figure></div><ul><li>虚拟地址结构被分为三部分：虚拟页号（virtual page #，20位）、页内偏移（disp，10位）、块内字节选择（00，2位）。</li><li>TLB 用虚拟页号查找物理页号，判断是否命中（Hit/Miss）。</li><li>Cache 用偏移（disp）作为 index，块内字节选择（00）定位具体字节。</li><li>两者可以<strong>并行查找</strong>，因为虚拟地址的 offset 部分直接决定了 cache 的 index 和 byte select。</li><li>最终，TLB 和 Cache 都命中时，直接返回数据；否则需要进一步处理。</li></ul><p>总结：</p><ul><li><strong>核心思想</strong>：虚拟地址中的 offset（页内偏移）正好覆盖了 cache 的 index（索引）和 byte select（字节选择），因此可以在地址转换（TLB 查找）和缓存查找时并行选中缓存字节，加速访问。</li><li><strong>VIPT（Virtually Indexed, Physically Tagged）</strong>：缓存用虚拟地址索引、物理地址做 tag，常用于 L1 cache。</li><li><strong>另一方案 VIVT（Virtually Indexed, Virtually Tagged）</strong>：缓存 tag 也是虚拟地址，只有缓存未命中时才做地址转换，但会带来一致性等问题。</li><li><strong>实际应用</strong>：L1 cache 多为 VIPT，L2/L3 cache 多为 PIPT（Physically Indexed, Physically Tagged）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图像描述生成</title>
    <link href="/2025/10/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/House%20Prices%20-%20Advanced%20Regression%20Techniques/"/>
    <url>/2025/10/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/House%20Prices%20-%20Advanced%20Regression%20Techniques/</url>
    
    <content type="html"><![CDATA[<p>Searching “House Prices - Advanced Regression Techniques” on Kaggle for more details.</p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>神经网络与深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kaggle Competition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像描述生成</title>
    <link href="/2025/10/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0%E7%94%9F%E6%88%90/"/>
    <url>/2025/10/19/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BF%B0%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>本文章关于神经网络课程设计选题——图像描述生成。</p><span id="more"></span><h2 id="评测指标">评测指标</h2><h3 id="bleubilingual-evaluation-understudy指标">BLEU（BiLingual Evaluation Understudy）指标</h3><blockquote><p>n-gram 层面指把文本看作连续的词，考察长度为 <span class="math inline">\(n\)</span> 的连续片段。</p></blockquote><p>在 n-gram 层面的<strong>准确率</strong>计算公式为：</p><p><span class="math display">\[\text{BLEU}_{n}(a, b) = \frac{\sum\limits_{w_n \in a} \min \biggl(c_a(w_n), \max\limits_{j = 1, \cdots, |b|} c_{b_{j} (w_n)}\biggr)}{\sum\limits_{w_n \in a} c_a(w_n)}\]</span></p><p>其中，<span class="math inline">\(a\)</span>：候选句子（生成句子）；<span class="math inline">\(b\)</span>：参考句子集（真实句子集、标注句子集）；<span class="math inline">\(w_n\)</span>：n-gram；<span class="math inline">\(c_x(y_n)\)</span>：n-gram <span class="math inline">\(y_n\)</span> 在句子 <span class="math inline">\(x\)</span> 中出现的次数。</p><blockquote><p>n-gram 通常用滑动窗口（overlapping）切分连续的 token 序列。</p></blockquote><p>然后简单计算<strong>召回率</strong></p><p><span class="math display">\[\text{BLEU} = \text{BP} \cdot \exp \biggl(\sum_{n = 1}^{N} w_n \log \text{BLEU}_n\biggr)\]</span></p><p>其中，<span class="math inline">\(\text{BP}\)</span> 是短句惩罚项，根据候选句子的长度 <span class="math inline">\(c\)</span>，选择一个最相近的参考句子的长度 <span class="math inline">\(r\)</span>。</p><p><span class="math display">\[\text{BP} =\begin{cases}1, &amp;c &gt; r\\\text{e}^{1 - r/c}, &amp; c \leq r\end{cases}\]</span></p><blockquote><p>衡量的是句子之间的流畅性而非语义相似度</p></blockquote><h3 id="meteor-metric-for-evaluation-of-translation-with-explicit-ordering-指标">METEOR (Metric for Evaluation of Translation with Explicit ORdering) 指标</h3><p>考虑同义词的F值，鼓励连续词匹配，其计算过程如下：</p><ol type="1"><li><p>在候选句子和参考句子之间做词到词的映射（根据匹配原则列出所有可能的匹配，然后在所有可能的匹配中选择一个匹配成功词最多的，如果两个匹配成功的词一样多，就选择其中交叉最少的那个）</p></li><li><p>计算 METEOR 值，对于多个参考句子，取得分最高的作为最终结果。</p><p><span class="math display">\[\text{METEOR} = \max_{j = 1, 2, \cdots, |b|} \biggl(\frac{10PR}{R + 9P} \biggr) \biggl(1 - \frac{1}{2} \biggl(\frac{\text{chunks}}{\text{matched unigrams}}\biggr)^3 \biggr)\]</span></p><p>其中，<span class="math inline">\(P\)</span> 表示精确率：候选句子（生成句子）中被匹配上的 unigram（单词）数除以候选句子中的总 unigram 数。</p><p><span class="math display">\[P=\frac{\text{matched\_unigrams}}{\text{候选句子总 unigram}}\]</span></p><p><span class="math inline">\(R\)</span>（Recall，召回率）：候选句子中被匹配上的 unigram 数除以参考句子 <span class="math inline">\(b_j\)</span> 中的总 unigram 数。</p><p><span class="math display">\[R=\frac{\text{matched\_unigrams}}{\text{参考句子 }b_j\text{ 的总 unigram}}\]</span></p><p><span class="math inline">\(\text{matched unigrams}\)</span>：依据第 1 步建立的词到词映射后实际匹配上的 unigram 数目（在所有可能匹配中选择匹配词数最多且交叉最少的映射得到的匹配数）。</p><p><span class="math inline">\(\text{chunks}\)</span>：在候选句子与参考句子之间按匹配顺序形成的连续匹配段（contiguous matched segments）的数量。若匹配项在序列中是分散的，<span class="math inline">\(\text{chunks}\)</span> 会较大。</p></li></ol><h3 id="rouge-recall-oriented-understudy-of-gisting-evaluation">ROUGE (Recall Oriented Understudy of Gisting Evaluation)</h3><p>在 n-gram 层面的召回率：</p><p><span class="math display">\[\text{ROUGE}_n(a, b) = \frac{\sum\limits_{j = 1}^{|b|} \sum\limits_{w_n \in b_j} c_{b_{j}} \min(c_{a} (w_n), c_{b_{j}} (w_n))}{\sum\limits_{j = 1}^{|b|} \sum\limits_{w_n \in b_j} c_{b_{j}} (w_n)}\]</span></p><p>F 值：</p><p><span class="math display">\[\begin{aligned}\text{ROUGE-L} &amp;= \frac{(1 + \beta^2) R_{lcs} P_{lcs}}{R_{lcs} + \beta^2 P_{lcs}}\\R_{lcs} &amp;= \frac{\text{LCS}(X, Y)}{m}\\P_{lcs} &amp;= \frac{\text{LCS}(X, Y)}{n}\\\beta &amp;= \frac{P_{lcs}}{R_{lcs}}\end{aligned}\]</span></p><p>其中，LCS 为最长公共子序列。</p><blockquote><p>多个参考句子时，单独计算所有的参考句子的 ROUGE-L 值，取最大的一个作为最终的结果。</p></blockquote><h3 id="cider">CIDEr</h3><blockquote><p>BLEU + 向量空间模型</p></blockquote><p><span class="math display">\[\text{CIDEr}_n (a, b) = \frac{1}{|b|} \sum_{j = 1}^{|b|} \frac{g^n(a) \cdot g^n(b_j)}{||g^n(a)|| \cdot ||g^n(b_j)||}\]</span></p><p>其中，<span class="math inline">\(g^n(x)\)</span> 为句子 <span class="math inline">\(x\)</span> 的 n-gram 形式的 TF-IDF 表示，对所有词预先执行 stem 操作，变成词根形式。CIDEr 最终是 1 到 4 gram 的结果的平均值。</p><blockquote><p>CIDEr 取词根的操作会让一些动词的原型和名词匹配成功；高置信度的词重复出现的长句的CIDEr得分也很高。</p></blockquote><h3 id="cider-d">CIDEr-D</h3><p><span class="math display">\[\text{CIDEr-D}_n (c_i, S_i) = \frac{10}{m} \sum_{j} \exp \biggl(\frac{-(l(c_i) - l(s_{ij}))^2}{2 \sigma^2} \biggr) \times \frac{\min(g^n(c_i), g^n(s_{ij})) \cdot g^n(s_{ij})}{||g^n(c_i)|| \cdot ||g^n(s_{ij})||}\]</span></p><p>CIDEr-D 也是计算 1 到 4 gram的结果的平均值。</p><blockquote><p>对于动词原形和名词匹配成功的问题，CIDEr-D 不再取词根；对于包括高置信度的词的长句，CIDEr-D 增加了惩罚生成句子和参考句子的长度差别的权重，并且通过对 n-gram 计数的截断操作不再计算生成句子中出现次数超过参考句子的 n-gram。</p></blockquote><h3 id="spicesemantic-propositional-image-caption-evaluation">SPICE（Semantic Propositional Image Caption Evaluation）</h3><p>计算步骤：</p><ol type="1"><li><p>利用 Stanford Scene Graph Parser 将候选句子和参考句子集转化为场景图。</p></li><li><p>比较候选句子和参考句子集中元组的 precision、recall，最终计算出 F1 score。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>神经网络与深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Relation Model</title>
    <link href="/2025/10/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Relation_Model/"/>
    <url>/2025/10/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Relation_Model/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="structure-of-relational-databases">Structure of Relational Databases</h2><p><strong>Def</strong>. <strong>A relational database</strong> consists of <strong>a collection of tables</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>ID</th><th>name</th><th>dept_name</th><th>salary</th></tr></thead><tbody><tr class="odd"><td>10101</td><td>Srinivasan</td><td>Comp. Sci.</td><td>65000</td></tr><tr class="even"><td>12121</td><td>Wu</td><td>Finance</td><td>90000</td></tr><tr class="odd"><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 1: An example table</div><p><strong>Def</strong>.</p><ul><li><span class="math inline">\(R = (A_1, A_2, \cdots, A_n)\)</span> is a <strong>relation schema</strong>, <span class="math inline">\(A_i\)</span> is <strong>attribute</strong>, <span class="math inline">\(D_i\)</span> is <strong>domain</strong> of <span class="math inline">\(A_i\)</span>.</li><li>The <strong>domain</strong> of the attribute is the <strong>set</strong> of allowed values<ul><li>Attribute values are (normally) required to be <strong>atomic</strong>, <strong>indivisible</strong>.</li><li>The special vale <strong>null</strong> is a member of every domain, indicating that the value is unknown.<ul><li>The null values causes complications in definition of operations, e.g. <strong>index failure</strong>.</li></ul></li></ul></li><li>A <strong>relation instance</strong> <span class="math inline">\(r\)</span> is defined over schema <span class="math inline">\(R\)</span>, denoted by <span class="math inline">\(r(R)\)</span><ul><li>The current values <span class="math inline">\(r(R)\)</span> are specified by a <strong>table</strong>.</li><li>An element <span class="math inline">\(t\)</span> of relation <span class="math inline">\(r\)</span> is called a <strong>tuple</strong>, denoted by a <strong>row</strong> in table.</li></ul></li></ul><blockquote><p>Relations are unordered. Ordered of tuples is <strong>irrelevant</strong>. Tuples may be stored in an <strong>arbitrary</strong> order. <strong>Attributes</strong> orders are also irrelevant.</p></blockquote><h2 id="database-schema">Database Schema</h2><p><strong>Def</strong>. <strong>Database schema</strong> is the <strong>logical structure</strong> of database.</p><p><strong>Def</strong>. <strong>Database instance</strong> is a <strong>snapshot</strong> of data in database at a given instant in time.</p><p>Example:</p><ul><li>Schema: <em>instructor</em> (ID, name, dept_name, salary)</li><li>Instance:</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>ID</th><th>name</th><th>dept_name</th><th>salary</th></tr></thead><tbody><tr class="odd"><td>22222</td><td>Einstein</td><td>Physics</td><td>95000</td></tr><tr class="even"><td>12121</td><td>Wu</td><td>Finance</td><td>90000</td></tr><tr class="odd"><td>32343</td><td>El Said</td><td>History</td><td>60000</td></tr><tr class="even"><td>45565</td><td>Katz</td><td>Comp. Sci.</td><td>75000</td></tr><tr class="odd"><td>98345</td><td>Kim</td><td>Elec. Eng.</td><td>80000</td></tr><tr class="even"><td>76766</td><td>Crick</td><td>Biology</td><td>72000</td></tr><tr class="odd"><td>10101</td><td>Srinivasan</td><td>Comp. Sci.</td><td>65000</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 2: An example database instance</div><h2 id="keys">Keys</h2><p><strong>Def</strong>. <strong>Super key</strong> is a set of <strong>one or more</strong> attributes that can be used to <strong>identify uniquely</strong> a tuple in the relation.</p><p><strong>Def</strong>. Given relation schema <span class="math inline">\(R = (A_1, A_2, \cdots, A_n)\)</span>, a subset <span class="math inline">\(K\)</span> is <strong>super key</strong> if no two distinct tuples have the <strong>same values</strong> on all attributes in <span class="math inline">\(K\)</span>.</p><blockquote><p>The super key may contain <strong>redundant</strong> attributes, e.g. {ID} and {ID, name, dept_name}.</p></blockquote><p><strong>Def</strong>. <span class="math inline">\(K\)</span> is a <strong>candidate key</strong> if <span class="math inline">\(K\)</span> is <strong>minimal</strong> super key, e.g. {ID}.</p><p><strong>Def</strong>. <strong>Primary key</strong> is a <strong>candidate key</strong> as <strong>principal means</strong> to identify tuples.</p><p><strong>Def</strong>. <strong>Integrity</strong> of primary key requires values on the primary key are not permitted to be <strong>null</strong>.</p><p><strong>Def</strong>. <strong>Primary attributes</strong> are the attributes in the <strong>candidate keys</strong>, i.e. the element of the primary key.</p><blockquote><p><em>Note</em>: It is recommended to select numeric (int, float) candidate keys as the primary key to improve query performance based on the primary key. Avoid selecting string-type attributes, such as varchar or datetime (e.g. student_name).</p></blockquote><p><strong>Def</strong>. <strong>Foreign key</strong></p><p>If <span class="math inline">\(X\)</span> is one or more attributes in schema <span class="math inline">\(r_1\)</span>, e.g. <em>instructor</em>, and <span class="math inline">\(X\)</span> is also the <strong>primary key</strong> of another schema <span class="math inline">\(r_2\)</span>, e.g. <em>department</em>.</p><ul><li><span class="math inline">\(X\)</span> is called a <strong>foreign key</strong> from <span class="math inline">\(r_1\)</span> referencing <span class="math inline">\(r_2\)</span>.</li><li><span class="math inline">\(r_1\)</span> is called the <strong>referencing relation</strong> of the foreign key dependency.</li><li><span class="math inline">\(r_2\)</span> is called the <strong>referenced relation</strong> of the foreign key</li></ul><blockquote><p><em>Note</em>: There are foreign key relationships between database tables. When importing data, first import the data of the referenced relation <span class="math inline">\(r_2\)</span> (e.g., <em>department</em>), and then import the data of the referencing relation <span class="math inline">\(r_1\)</span> (e.g., <em>instructor</em>).</p></blockquote><p><strong>Def</strong>. <strong>Referential integrity</strong></p><p>Values appearing in <strong>foreign key</strong> attributes (dept_name) of any tuples in the <strong>referencing</strong> relation <span class="math inline">\(r_1\)</span> (<em>instructor</em>) must appear in attributes of at least <strong>one tuples</strong> in the <strong>referenced</strong> relation <span class="math inline">\(r_2\)</span> (<em>department</em>).</p><h2 id="schema-diagram-for-university-database">Schema Diagram for University Database</h2><p><strong>A database schema</strong>, with <strong>primary key</strong> and <strong>foreign key</strong> dependency, can be depicted as <strong>schema diagram</strong>.</p><ul><li>Nodes: schema, attributes, primary key</li><li>Arcs: foreign key dependency, from referencing relation <span class="math inline">\(r_1\)</span> to referenced relation <span class="math inline">\(r_2\)</span></li></ul><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Relation_Model/Schema%20Diagram.png" alt="Schema Diagram"><figcaption aria-hidden="true">Schema Diagram</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 1: Schema diagram</div><h2 id="relational-algebra-expression">Relational Algebra Expression</h2><p><strong>Def</strong>. <strong>Relation algebra expression</strong> is defined as follows</p><ul><li>A <strong>basic</strong> expression is a relation <span class="math inline">\(r\)</span> in DB, or a constant relation <span class="math inline">\(C = \{r_1, r_2, \cdots, r_n\}\)</span>, written by listing its tuples.</li><li>A <strong>general</strong> expression is defined: if <span class="math inline">\(E_1\)</span> and <span class="math inline">\(E_2\)</span> are relational algebra expressions, we have<ul><li><span class="math inline">\(E_1 \cup E_2\)</span></li><li><span class="math inline">\(E_1 - E_2\)</span></li><li><span class="math inline">\(E_1 \times E_2\)</span></li><li><span class="math inline">\(\sigma_{p} (E_1)\)</span></li><li><span class="math inline">\(\Pi_{s} (E_1)\)</span></li><li><span class="math inline">\(\rho_{X} (E_1)\)</span></li></ul></li></ul><h3 id="select-operation">Select Operation</h3><p><strong>Def</strong>. The <strong>select</strong> operation selects <strong>tuples</strong> that satisfy a given <strong>predicate</strong>.</p><ul><li>Notation: <span class="math inline">\(\sigma_{p} (r)\)</span>. <span class="math inline">\(p\)</span> is called the <strong>selection predicate</strong></li><li>Example: select those <strong>tuples</strong> of the <em>instructor</em> relation where the instructor is in Physics <em>department</em><ul><li>Query: <span class="math inline">\(\sigma_{\text{dept\_name} = \text{&quot;Physics&quot;}} (\text{instructor})\)</span></li></ul></li></ul><p>What’s more, we allow <strong>comparisons</strong> (<span class="math inline">\(=\)</span>, <span class="math inline">\(\neq\)</span>, <span class="math inline">\(&gt;\)</span>, <span class="math inline">\(\geq\)</span>, <span class="math inline">\(&lt;\)</span>, <span class="math inline">\(\leq\)</span>) in the selection predicate and can <strong>combine</strong> several predicates into a larger predicate by using connectives: <span class="math inline">\(\land\)</span>, <span class="math inline">\(\lor\)</span>, <span class="math inline">\(\lnot\)</span>. For example, find the instructors in Physics with salary greater <span class="math inline">\(90000\)</span>: <span class="math inline">\(\sigma_{\text{dept\_name} = \text{&quot;Physics&quot;} \land \text{salary} &gt; 90000} (\text{instructor})\)</span>.</p><p>The select predicate may include comparisons between two attributes. For example, find all departments whose name is the same as their building name: <span class="math inline">\(\sigma_{\text{dept\_name} = \text{building}} (\text{department})\)</span>.</p><h3 id="project-operation">Project Operation</h3><p><strong>Def</strong>. <strong>Operation</strong> that returns its argument relation, with certain attributes <strong>left out</strong>.</p><ul><li>Notation: <span class="math inline">\(\Pi_{A_1, A_2, \cdots, A_{k}} (r)\)</span></li><li>The result defined as <span class="math inline">\(k\)</span> columns by <strong>erasing</strong> the columns that are not listed.</li><li>Example: eliminate the dept_name attribute of <em>instructor</em><ul><li>Query: <span class="math inline">\(\Pi_{\text{attributes except dept\_name}} (\text{instructor})\)</span></li></ul></li></ul><blockquote><p>Composition of relational operations. For example, find the names of all instructors in Physics department: <span class="math inline">\(\Pi_{\text{name}} (\sigma_{\text{dept\_name} = \text{&quot;Physics&quot;}} (\text{instructor}))\)</span></p></blockquote><h3 id="join-operation">Join Operation</h3><p><strong>Def</strong>. <strong>Cartesian product operation</strong> (denoted by <span class="math inline">\(\times\)</span>) allows to <strong>combine</strong> information from two relations. For example, Cartesian product of <em>instructor</em> and <em>teaches</em> is written as: <span class="math inline">\(\text{instructor} \times \text{teaches}\)</span>.</p><blockquote><p>Cartesian product, we suppose <span class="math inline">\(A = \{a, b, c\}\)</span>, <span class="math inline">\(B = \{d, e, f\}\)</span>, <span class="math inline">\(A \times B = \{ad, ae, af, bd, be, bf, cd, ce, cd\}\)</span>.</p></blockquote><p><strong>Def</strong>. The <strong>join operation</strong> combine <strong>select operation</strong> and <strong>Cartesian product operation</strong> into a single operation.</p><p>Consider relation instance <span class="math inline">\(r(R)\)</span> and <span class="math inline">\(s(S)\)</span>. Let <span class="math inline">\(\theta\)</span> be a <strong>predicate</strong> on attributes in schema <span class="math inline">\(R\)</span> union <span class="math inline">\(S\)</span>. The join operation is defined as follows: <span class="math inline">\(r \Join_{\theta} s = \sigma_{\theta} (r \times s)\)</span>.</p><h3 id="union-operation">Union Operation</h3><p>The union operation allows us to combine two relations. Notation: <span class="math inline">\(r \cup s\)</span>. For <span class="math inline">\(r \cup s\)</span> to be valid.</p><ol type="1"><li><span class="math inline">\(r\)</span>, <span class="math inline">\(s\)</span> must have the <strong>same arity</strong> (same number of attributes)</li><li>The attribute <strong>domains</strong> must be <strong>compatible</strong></li></ol><p>For example, find all courses taught in the Fall 2017 semester, or in the Spring 2018 semester, or in both: <span class="math inline">\(\Pi_{\text{course\_id}}(\sigma_{\text{semester} = \text{&quot;Fall&quot;} \land \text{year} = 2017}(\text{section})) \cup \Pi_{\text{course\_id}}(\sigma_{\text{semester} = \text{&quot;Spring&quot;} \land \text{year} = 2018}(\text{section}))\)</span></p><h3 id="set-intersection-operation">Set Intersection Operation</h3><p><strong>Def</strong>. The <strong>set intersection operation</strong> allows us to find tuples that are in both input relations. Notation: <span class="math inline">\(r \cap s\)</span>. Similar to union operation.</p><h3 id="set-difference-operation">Set Difference Operation</h3><p><strong>Def</strong>. The <strong>set difference operation</strong> allows find tuples that are in one relation but are not in another. Notation: <span class="math inline">\(r - s\)</span>.</p><h3 id="the-assignment-operation">The Assignment Operation</h3><p><strong>Def</strong>. The <strong>assignment operation</strong> is denoted by <span class="math inline">\(\leftarrow\)</span>. Working like assignment in <strong>programming language</strong>. For example, find all instructor in Physics and Music department.</p><p><span class="math display">\[\begin{aligned}\text{Physics} &amp;\leftarrow \sigma_{\text{dept\_name} = \text{&quot;Physics&quot;}} (\text{instructor})\\\text{Music} &amp;\leftarrow \sigma_{\text{dept\_name} = \text{&quot;Music&quot;}} (\text{instructor})\\\text{Physic} &amp;\cup \text{Music}\end{aligned}\]</span></p><h3 id="the-rename-operation">The Rename Operation</h3><p><strong>Def</strong>. The results of relational algebra expression do not have a name. The <strong>rename operation</strong> <span class="math inline">\(\rho\)</span> is provided for a name. The expression <span class="math inline">\(\rho_{X}(E)\)</span> returns the result of express <span class="math inline">\(E\)</span> under the name <span class="math inline">\(X\)</span>.</p><h3 id="equivalent-queries">Equivalent Queries</h3><p>The two queries are not identical, however they give the same result on any database.</p><blockquote><p>We can use different queries to improve querying.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>全连接网络</title>
    <link href="/2025/10/17/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C/"/>
    <url>/2025/10/17/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>在本篇文章中，我们将通过代码实现与数学推导，系统讲解全连接神经网络（Fully Connected Neural Network, FCNN）在手写数字识别任务中的应用。文章不仅涵盖了数据预处理、模型搭建、前向与反向传播的详细过程，还对梯度计算的数学原理进行了推导说明。通过对不同批次大小的训练结果进行对比分析，展示了 mini-batch 梯度下降在实际深度学习任务中的优势，并进一步探讨了 L1/L2 正则化对模型泛化能力的影响。本文适合希望深入理解神经网络原理与实践的读者。</p><span id="more"></span><h2 id="代码实现与数学原理">代码实现与数学原理</h2><p>首先下载手写数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> random<br><br>mnist_train = torchvision.datasets.MNIST(root=<span class="hljs-string">&#x27;~/Datasets/MNIST&#x27;</span>, train=<span class="hljs-literal">True</span>, <br>                                                download=<span class="hljs-literal">True</span>, transform=<span class="hljs-literal">None</span>)<br>mnist_test = torchvision.datasets.MNIST(root=<span class="hljs-string">&#x27;~/Datasets/MNIST&#x27;</span>, train=<span class="hljs-literal">False</span>, <br>                                               download=<span class="hljs-literal">True</span>, transform=<span class="hljs-literal">None</span>)<br><span class="hljs-built_in">print</span>(mnist_train[<span class="hljs-number">0</span>])                                               <br></code></pre></td></tr></table></figure><p>运行后显示的结果是 <code>(&lt;PIL.Image.Image image mode=L size=28x28 at 0x1397411D0&gt;, 5)</code>，这说明这个数据集中的每个数据的 data 部分是一张 <span class="math inline">\(28 \times 28\)</span> 大小的张量，targets 是一个整数，据此进行整理与归一化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">X_train = np.array(mnist_train.data) / <span class="hljs-number">255.0</span><br>y_train = np.array(mnist_train.targets)<br>X_test = np.array(mnist_test.data) / <span class="hljs-number">255.0</span><br>y_test = np.array(mnist_test.targets)<br><br>X_train = X_train.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">28</span> * <span class="hljs-number">28</span>)<br>X_test = X_test.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">28</span> * <span class="hljs-number">28</span>)<br></code></pre></td></tr></table></figure><p>考虑使用 batch GD 算法，分批代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter</span>(<span class="hljs-params">batch_size, features, labels</span>):<br>    num_examples = <span class="hljs-built_in">len</span>(features)<br>    indices = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(num_examples))<br>    random.shuffle(indices)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_examples, batch_size):<br>        j = np.array(indices[i: <span class="hljs-built_in">min</span>(i + batch_size, num_examples)])<br>        <span class="hljs-keyword">yield</span> features[j], labels[j]<br></code></pre></td></tr></table></figure><p>定义激活函数与其导数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">relu</span>(<span class="hljs-params">x</span>): <br>    <span class="hljs-keyword">return</span> np.maximum(<span class="hljs-number">0</span>, x)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">relu_grad</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &gt; <span class="hljs-number">0</span>).astype(<span class="hljs-built_in">float</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">softmax</span>(<span class="hljs-params">x</span>):<br>    exp_x = np.exp(x - np.<span class="hljs-built_in">max</span>(x, axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>))<br>    <span class="hljs-keyword">return</span> exp_x / np.<span class="hljs-built_in">sum</span>(exp_x, axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>定义损失函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cross_entropy</span>(<span class="hljs-params">y, y_hat</span>):<br>    <span class="hljs-keyword">return</span> - np.<span class="hljs-built_in">sum</span>(y * np.log(y_hat)) / <span class="hljs-built_in">len</span>(y)<br></code></pre></td></tr></table></figure><p>定义独热编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">one_hot</span>(<span class="hljs-params">y, num_classes</span>):<br>    y_onehot = np.zeros((y.size, num_classes))<br>    y_onehot[np.arange(y.size), y] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> y_onehot<br></code></pre></td></tr></table></figure><blockquote><p>5 变换为 (0, 0, 0, 0, 0, 1, 0, 0, 0, 0)</p></blockquote><p>设计神经网络大小与初始化权重：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">input_size = <span class="hljs-number">784</span><br>hidden_size = <span class="hljs-number">128</span><br>output_size = <span class="hljs-number">10</span><br><br>w_1 = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (input_size, hidden_size))<br>b_1 = np.zeros((<span class="hljs-number">1</span>, hidden_size))<br>w_2 = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (hidden_size, output_size))<br>b_2 = np.zeros((<span class="hljs-number">1</span>, output_size))<br></code></pre></td></tr></table></figure><p>从输入层到隐藏层用 <span class="math inline">\(\text{relu}\)</span>，从隐藏层到输出层用 <span class="math inline">\(\text{softmax}\)</span>。故定义前向传播：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">X</span>):<br>    Z_1 = np.dot(X, w_1) + b_1<br>    A_1 = relu(Z_1)<br>    Z_2 = np.dot(A_1, w_2) + b_2<br>    A_2 = softmax(Z_2)<br>    <span class="hljs-keyword">return</span> Z_1, A_1, Z_2, A_2<br></code></pre></td></tr></table></figure><p>先使用交叉熵损失函数，推导反向传播的数学公式。反向传播的核心就是计算损失函数对每一层权重和偏置的导数（梯度），可以给予链式法则求梯度。在输出层，输出记为 <span class="math inline">\(Y\)</span>，除了输出层，<span class="math inline">\(Z\)</span> 代表线性变换结果，<span class="math inline">\(A\)</span> 代表激活值，在输入层记输入为 <span class="math inline">\(X\)</span>。</p><p><span class="math display">\[\begin{aligned}Z_1 &amp;= w_1 X + b_1\\A_1 &amp;= \text{relu}(Z_1)\\Z_2 &amp;= w_2 A_1 + b_2\\A_{2, j} &amp;= \text{softmax}(Z_{2, j}) = \frac{\text{e}^{Z_{2, j}}}{\sum\limits_{k} \text{e}^{Z_{2, k}}}\end{aligned}\]</span></p><p>在输出层，损失的计算公式为：</p><p><span class="math display">\[L = - \sum_{i = 1}^{C} (Y_i \times \ln A_{2,i})\]</span></p><p>其中，<span class="math inline">\(C\)</span> 是类别。对 <span class="math inline">\(A_2\)</span> 求导：</p><p><span class="math display">\[\frac{\partial L}{\partial A_2} = - \sum_{i = 1}^{C} (Y_i \times \frac{1}{A_{2,i}})\]</span></p><p>由 <span class="math inline">\(A_2 = \text{softmax}(Z_2)\)</span> 得：</p><p><span class="math display">\[\begin{aligned}\frac{\partial L}{\partial Z_{2}} &amp;= \sum_{j} \sum_{i} \frac{\partial L}{\partial A_{2, i}} \cdot \frac{\partial A_{2, i}}{\partial Z_{2, j}}\\\frac{\partial L}{\partial Z_{2}} &amp;= \biggl(- \frac{Y_i}{A_{2, i}}\biggr) \cdot A_{2, i} (1 - A_{2, i}) + \sum_{i \neq j} \biggl(- \frac{Y_j}{A_{2, j}}\biggr) \cdot (-A_{2, i} A_{2, j})\\&amp;= -Y_i + A_{2, i} \sum_{j} Y_j\\&amp;= A_2 - Y\end{aligned}\]</span></p><p>由 <span class="math inline">\(Z_2 = w_2 A_1 + b_2\)</span> 得：</p><p><span class="math display">\[\begin{aligned}\frac{\partial L}{\partial w_2} &amp;= \frac{\partial L}{\partial Z_2} \cdot \frac{\partial Z_2}{\partial w_2} = (A_2 - Y) \cdot A_1\\\frac{\partial L}{\partial b_2} &amp;= \frac{\partial L}{\partial Z_2} \cdot \frac{\partial Z_2}{\partial b_2} = (A_2 - Y)\\\frac{\partial L}{\partial A_1} &amp;= \frac{\partial L}{\partial Z_2} \cdot \frac{\partial Z_2}{\partial A_1} = (A_2 - Y) \cdot w_2\end{aligned}\]</span></p><p>由 <span class="math inline">\(A_1 = \text{relu}(Z_1)\)</span> 得：</p><p><span class="math display">\[\frac{\partial L}{\partial Z_1} = \frac{\partial L}{\partial A_1} \cdot \frac{\partial A_1}{\partial Z_1} = (A_2 - Y) \cdot w_2 \cdot \frac{\partial A_1}{\partial Z_1}\]</span></p><p>其中，<span class="math inline">\(\frac{\partial A_1}{\partial Z_1}\)</span> 根据 <span class="math inline">\(\text{relu}\)</span> 函数的定义易得，见代码部分。</p><p>由 <span class="math inline">\(Z_1 = w_1 X + b_1\)</span> 得类似结果。</p><blockquote><p>推导过程中没有考虑真实的矩阵形状。</p></blockquote><h2 id="结果分析">结果分析</h2><p>上述提供了一个 batch GD 算法，可以用其分析小批量与大批量之间的优劣。具体结果如下表所示，从中可以看到小批量 mini-batch GD 思路可以得到较好的结果。</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">批次大小 (Batch size)</th><th style="text-align: center;">最大训练准确率 (Max Acc)</th><th style="text-align: center;">测试准确率 (Test Accuracy)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;">0.9696</td><td style="text-align: center;">0.9455</td></tr><tr class="even"><td style="text-align: center;">20</td><td style="text-align: center;">0.9615</td><td style="text-align: center;">0.9421</td></tr><tr class="odd"><td style="text-align: center;">30</td><td style="text-align: center;">0.9543</td><td style="text-align: center;">0.9354</td></tr><tr class="even"><td style="text-align: center;">40</td><td style="text-align: center;">0.9506</td><td style="text-align: center;">0.9368</td></tr><tr class="odd"><td style="text-align: center;">50</td><td style="text-align: center;">0.9423</td><td style="text-align: center;">0.9300</td></tr><tr class="even"><td style="text-align: center;">60</td><td style="text-align: center;">0.9376</td><td style="text-align: center;">0.9195</td></tr><tr class="odd"><td style="text-align: center;">70</td><td style="text-align: center;">0.9385</td><td style="text-align: center;">0.9242</td></tr><tr class="even"><td style="text-align: center;">80</td><td style="text-align: center;">0.9382</td><td style="text-align: center;">0.9240</td></tr><tr class="odd"><td style="text-align: center;">90</td><td style="text-align: center;">0.9301</td><td style="text-align: center;">0.9191</td></tr><tr class="even"><td style="text-align: center;">500</td><td style="text-align: center;">0.8982</td><td style="text-align: center;">0.8908</td></tr><tr class="odd"><td style="text-align: center;">600</td><td style="text-align: center;">0.8913</td><td style="text-align: center;">0.8855</td></tr><tr class="even"><td style="text-align: center;">700</td><td style="text-align: center;">0.8877</td><td style="text-align: center;">0.8896</td></tr><tr class="odd"><td style="text-align: center;">800</td><td style="text-align: center;">0.8912</td><td style="text-align: center;">0.8891</td></tr><tr class="even"><td style="text-align: center;">900</td><td style="text-align: center;">0.8872</td><td style="text-align: center;">0.8830</td></tr></tbody></table></div><h2 id="改进">改进</h2><p>当前代码没有尝试正则化，下面尝试用 L2 正则化防止机器学习模型过拟合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">...existing code...<br>lr = <span class="hljs-number">0.1</span><br>num_epochs = <span class="hljs-number">10</span><br>batch_size = <span class="hljs-number">64</span><br>l2_lambda = <span class="hljs-number">0.01</span><br><br>...existing code...<br>        dZ_2 = A_2 - y_onehot <span class="hljs-comment"># (batch_size, 10)</span><br>        dw_2 = np.dot(A_1.T, dZ_2) / batch_size + l2_lambda * w_2 <span class="hljs-comment"># (784, 10)</span><br>        db_2 = np.<span class="hljs-built_in">sum</span>(dZ_2, axis=<span class="hljs-number">0</span>, keepdims=<span class="hljs-literal">True</span>) / batch_size <span class="hljs-comment"># (1, 10)</span><br><br>        dA_1 = np.dot(dZ_2, w_2.T) <span class="hljs-comment"># (batch_size, 128)</span><br>        dZ_1 = dA_1 * relu_grad(Z_1) <span class="hljs-comment"># (batch_size, 128)</span><br>        dw_1 = np.dot(X_batch.T, dZ_1) / batch_size + l2_lambda * w_1<span class="hljs-comment"># (784, 128)</span><br>        db_1 = np.<span class="hljs-built_in">sum</span>(dZ_1, axis=<span class="hljs-number">0</span>, keepdims=<span class="hljs-literal">True</span>) / batch_size <span class="hljs-comment"># (1, 784)</span><br>...existing code...<br></code></pre></td></tr></table></figure><p>相比于没有正则化，二者模型比对结果如下表所示，可以发现，二者最大训练准确率几乎一致，但测试准确率相差近 <span class="math inline">\(1\%\)</span>。</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">正则化 (Regularization)</th><th style="text-align: center;">最大训练准确率 (Max Acc)</th><th style="text-align: center;">测试准确率 (Test Accuracy)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">有</td><td style="text-align: center;">0.9363</td><td style="text-align: center;">0.9370</td></tr><tr class="even"><td style="text-align: center;">无</td><td style="text-align: center;">0.9364</td><td style="text-align: center;">0.9264</td></tr></tbody></table></div><p>接着尝试用 L1 正则化防止机器学习模型过拟合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">...existing code...<br>lr = <span class="hljs-number">0.1</span><br>num_epochs = <span class="hljs-number">10</span><br>batch_size = <span class="hljs-number">64</span><br>l1_lambda = <span class="hljs-number">0.01</span><br><br>...existing code...<br>        dZ_2 = A_2 - y_onehot <span class="hljs-comment"># (batch_size, 10)</span><br>        dw_2 = np.dot(A_1.T, dZ_2) / batch_size + l1_lambda * np.sign(w_2) <span class="hljs-comment"># (784, 10)</span><br>        db_2 = np.<span class="hljs-built_in">sum</span>(dZ_2, axis=<span class="hljs-number">0</span>, keepdims=<span class="hljs-literal">True</span>) / batch_size <span class="hljs-comment"># (1, 10)</span><br><br>        dA_1 = np.dot(dZ_2, w_2.T) <span class="hljs-comment"># (batch_size, 128)</span><br>        dZ_1 = dA_1 * relu_grad(Z_1) <span class="hljs-comment"># (batch_size, 128)</span><br>        dw_1 = np.dot(X_batch.T, dZ_1) / batch_size + l1_lambda * np.sign(w_1)<span class="hljs-comment"># (784, 128)</span><br>        db_1 = np.<span class="hljs-built_in">sum</span>(dZ_1, axis=<span class="hljs-number">0</span>, keepdims=<span class="hljs-literal">True</span>) / batch_size <span class="hljs-comment"># (1, 784)</span><br>...existing code...<br></code></pre></td></tr></table></figure><p>L1 正则化与 L2 正则化在相同参数下结果如下表所示，可见此时 L1 正则化的效果远不及 L2 正则化。</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">正则化 (Regularization)</th><th style="text-align: center;">最大训练准确率 (Max Acc)</th><th style="text-align: center;">测试准确率 (Test Accuracy)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">L2</td><td style="text-align: center;">0.9363</td><td style="text-align: center;">0.9370</td></tr><tr class="even"><td style="text-align: center;">L1</td><td style="text-align: center;">0.8463</td><td style="text-align: center;">0.8373</td></tr></tbody></table></div><p>将学习率设置为 0.001，此时 L1 的性能有所增长，以极小的差距超越无正则化的结果。</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">正则化 (Regularization)</th><th style="text-align: center;">最大训练准确率 (Max Acc)</th><th style="text-align: center;">测试准确率 (Test Accuracy)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">L1</td><td style="text-align: center;">0.9341</td><td style="text-align: center;">0.9294</td></tr></tbody></table></div><h2 id="参考代码">参考代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> random<br><br>mnist_train = torchvision.datasets.MNIST(root=<span class="hljs-string">&#x27;~/Datasets/MNIST&#x27;</span>, train=<span class="hljs-literal">True</span>, <br>                                                download=<span class="hljs-literal">True</span>, transform=<span class="hljs-literal">None</span>)<br>mnist_test = torchvision.datasets.MNIST(root=<span class="hljs-string">&#x27;~/Datasets/MNIST&#x27;</span>, train=<span class="hljs-literal">False</span>, <br>                                               download=<span class="hljs-literal">True</span>, transform=<span class="hljs-literal">None</span>)<br><br><span class="hljs-built_in">print</span>(mnist_train[<span class="hljs-number">0</span>]) <span class="hljs-comment"># (&lt;PIL.Image.Image image mode=L size=28x28 at 0x1397411D0&gt;, 5)</span><br><br>X_train = np.array(mnist_train.data) / <span class="hljs-number">255.0</span><br>y_train = np.array(mnist_train.targets)<br>X_test = np.array(mnist_test.data) / <span class="hljs-number">255.0</span><br>y_test = np.array(mnist_test.targets)<br><br>X_train = X_train.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">28</span> * <span class="hljs-number">28</span>)<br>X_test = X_test.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">28</span> * <span class="hljs-number">28</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter</span>(<span class="hljs-params">batch_size, features, labels</span>):<br>    num_examples = <span class="hljs-built_in">len</span>(features)<br>    indices = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(num_examples))<br>    random.shuffle(indices)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_examples, batch_size):<br>        j = np.array(indices[i: <span class="hljs-built_in">min</span>(i + batch_size, num_examples)])<br>        <span class="hljs-keyword">yield</span> features[j], labels[j]<br><br>input_size = <span class="hljs-number">784</span><br>hidden_size = <span class="hljs-number">128</span><br>output_size = <span class="hljs-number">10</span><br><br>w_1 = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (input_size, hidden_size))<br>b_1 = np.zeros((<span class="hljs-number">1</span>, hidden_size))<br>w_2 = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (hidden_size, output_size))<br>b_2 = np.zeros((<span class="hljs-number">1</span>, output_size))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">relu</span>(<span class="hljs-params">x</span>): <br>    <span class="hljs-keyword">return</span> np.maximum(<span class="hljs-number">0</span>, x)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">relu_grad</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (x &gt; <span class="hljs-number">0</span>).astype(<span class="hljs-built_in">float</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">softmax</span>(<span class="hljs-params">x</span>):<br>    exp_x = np.exp(x - np.<span class="hljs-built_in">max</span>(x, axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>))<br>    <span class="hljs-keyword">return</span> exp_x / np.<span class="hljs-built_in">sum</span>(exp_x, axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cross_entropy</span>(<span class="hljs-params">y, y_hat</span>):<br>    <span class="hljs-keyword">return</span> - np.<span class="hljs-built_in">sum</span>(y * np.log(y_hat)) / <span class="hljs-built_in">len</span>(y)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">one_hot</span>(<span class="hljs-params">y, num_classes</span>):<br>    y_onehot = np.zeros((y.size, num_classes))<br>    y_onehot[np.arange(y.size), y] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> y_onehot<br><br>lr = <span class="hljs-number">0.1</span><br>num_epochs = <span class="hljs-number">10</span><br>batch_size = <span class="hljs-number">64</span><br>l1_lambda = <span class="hljs-number">0.001</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">X</span>):<br>    Z_1 = np.dot(X, w_1) + b_1 <span class="hljs-comment"># (batch_size, 128)</span><br>    A_1 = relu(Z_1)<br>    Z_2 = np.dot(A_1, w_2) + b_2<br>    A_2 = softmax(Z_2)<br>    <span class="hljs-keyword">return</span> Z_1, A_1, Z_2, A_2<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num_epochs + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> X_batch, y_batch <span class="hljs-keyword">in</span> data_iter(batch_size, X_train, y_train):<br>        Z_1, A_1, Z_2, A_2 = forward(X_batch)<br><br>        y_onehot = one_hot(y_batch, output_size)<br><br>        dZ_2 = A_2 - y_onehot <span class="hljs-comment"># (batch_size, 10)</span><br>        dw_2 = np.dot(A_1.T, dZ_2) / batch_size+ l1_lambda * np.sign(w_2) <span class="hljs-comment"># (784, 10)</span><br>        db_2 = np.<span class="hljs-built_in">sum</span>(dZ_2, axis=<span class="hljs-number">0</span>, keepdims=<span class="hljs-literal">True</span>) / batch_size <span class="hljs-comment"># (1, 10)</span><br><br>        dA_1 = np.dot(dZ_2, w_2.T) <span class="hljs-comment"># (batch_size, 128)</span><br>        dZ_1 = dA_1 * relu_grad(Z_1) <span class="hljs-comment"># (batch_size, 128)</span><br>        dw_1 = np.dot(X_batch.T, dZ_1) / batch_size + l1_lambda * np.sign(w_1) <span class="hljs-comment"># (784, 128)</span><br>        db_1 = np.<span class="hljs-built_in">sum</span>(dZ_1, axis=<span class="hljs-number">0</span>, keepdims=<span class="hljs-literal">True</span>) / batch_size <span class="hljs-comment"># (1, 784)</span><br><br>        w_1 -= lr * dw_1<br>        b_1 -= lr * db_1<br>        w_2 -= lr * dw_2<br>        b_2 -= lr * db_2<br><br>    _, _, _, train_pred = forward(X_train) <span class="hljs-comment"># 概率分布</span><br>    train_loss = cross_entropy(one_hot(y_train, output_size), train_pred)<br>    train_acc = np.mean(np.argmax(train_pred, axis=<span class="hljs-number">1</span>) == y_train)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>, Loss: <span class="hljs-subst">&#123;train_loss:<span class="hljs-number">.4</span>f&#125;</span>, Acc: <span class="hljs-subst">&#123;train_acc:<span class="hljs-number">.4</span>f&#125;</span>&quot;</span>)<br><br>_, _, _, test_pred = forward(X_test)<br>test_acc = np.mean(np.argmax(test_pred, axis=<span class="hljs-number">1</span>) == y_test)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test Accuracy: <span class="hljs-subst">&#123;test_acc:<span class="hljs-number">.4</span>f&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>神经网络与深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Syllabi and Basics</title>
    <link href="/2025/10/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Syllabi_and_Basics/"/>
    <url>/2025/10/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Syllabi_and_Basics/</url>
    
    <content type="html"><![CDATA[<p>OS is a special software layer that provides and manages the access from apps/users to hardware resources (CPU, memory, disk, etc).</p><span id="more"></span><h2 id="the-role-of-os">The Role of OS</h2><h3 id="os-as-referee">OS as referee</h3><ul><li><p>Resource Allocation: multitasks on constrained resources.</p></li><li><p>Isolation: fault in one app shall not disrupt others.</p></li><li><p>Communication: realiable, safe and fast.</p></li></ul><h3 id="os-as-illusionist">OS as illusionist</h3><p>Illusion of resources not physically present.</p><h3 id="os-as-glue">OS as glue</h3><ul><li><p>Providing common services to facilitate resource sharing, like reading/writing files, sharing memory, and passing messages.</p></li><li><p>Decouple hardware and app development: most applications can evolve independently with OS, unless those require very low-level programming such as databases.</p></li></ul><h2 id="the-goal-of-os">The Goal of OS</h2><ul><li>Managing hardware resources<ul><li>Allocating resources to concurrent tasks, who gets more?</li><li>Determining hardware status: CPU frequency, I/O device on/off, etc.</li></ul></li><li>Facilitate app developers<ul><li>Illusion of resources not physically present</li><li>Isolation of apps</li><li>Cross-apps communication</li></ul></li><li>Facilitate users<ul><li>UI components and rendering</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Boot, Process, Kernel</title>
    <link href="/2025/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Boot_Process_Kernel/"/>
    <url>/2025/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Boot_Process_Kernel/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="basic-input-output-system">Basic Input Output System</h2><blockquote><p><strong>BIOS</strong> is a firmware, stored on <strong>ROM</strong> (read only memory) on motherboard.</p></blockquote><ol type="1"><li><strong>Power-on self-test</strong> diagnostic</li><li>Identify <strong>attached hardware</strong> and initialize their states</li><li>Build HW description for <strong>advanced configuration and power interface</strong> (ACPI)</li><li>Load a <strong>bootloader</strong> from disk to memory (usually the first disk sector <span class="math inline">\(512\)</span> bytes)</li><li>Transfer the <strong>control</strong> to the bootloader (setting <code>%cs%</code> and <code>%ip</code>)</li></ol><h2 id="bootloader">Bootloader</h2><blockquote><p><strong>Bootloader</strong> is a software, and a part of OS.</p></blockquote><ol type="1"><li>Switch from <strong>real mode</strong> to <strong>protected mode</strong></li><li>Check if kernel <strong>image</strong> is ok.</li><li>Loading kernel from disk to <strong>memory</strong>.</li><li>Transfer the control to <strong>real</strong> OS.</li></ol><blockquote><p>Kernel image is the core of OS.</p><p>Real model and protected mode are different <strong>status</strong> the CPU works at</p></blockquote><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Boot_Process_Kernel/A%20summary%20of%20booting%20process.png" alt="A summary of booting process"><figcaption aria-hidden="true">A summary of booting process</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 1: A summary of booting process</div><h2 id="case-study-booting-of-jos">Case Study: Booting of JOS</h2><ul><li><code>[f000:fff0] 0xffff0</code>: <code>ljmp $0xf000, $0xe05b</code><ul><li>The <strong>first</strong> instruction run by CPU</li><li>Observed through <strong>GDB</strong></li><li>What we learned from it?<ul><li>The IMB PC starts executing at physical address <code>0x000ffff0</code>, which is at the very top of the <span class="math inline">\(64\)</span> KB area reserved for the ROM BIOS.</li><li>The PC starts executing with <code>CS = 0xf000</code> and <code>IP = 0xfff0</code></li><li>The first instruction to be executed is a <code>jmp</code> instruction, which jumps to the segmented address <code>CS = 0xf000</code> and <code>IP = 0xe05b</code></li></ul></li></ul></li></ul><blockquote><ul><li><p>在 x86 架构中，CPU 在启动时会从固定地址（通常是 <code>0xffff0</code>）开始执行代码。这个地址位于 BIOS 的内存区域，通常包含一条 <code>ljmp</code> 指令，用于跳转到实际的 BIOS 初始化代码位置。</p></li><li><p><strong>Instruction</strong> 是指 <strong>CPU</strong> 执行的机器语言命令，它是计算机程序的最基本组成部分。指令告诉 CPU 应该执行什么操作，比如数据传输、算术运算、逻辑运算或控制程序流程。每条指令通常由两部分组成</p><ul><li>Opcode（操作码）：指定要执行的操作类型，例如加法、跳转等。</li><li>Operands（操作数）：提供操作所需的数据或地址。</li></ul></li></ul></blockquote><h2 id="unified-extensible-firmware-interface-uefi">Unified Extensible Firmware Interface (UEFI)</h2><p>A successor of BIOS</p><ul><li>It’s faster</li><li>It has filesystem support</li><li>It can be stored in various places: flash memory on motherboard, hard drive, or even network share</li><li>It supports more input such as mouse</li><li>It has secure boot</li><li>It has better UI</li><li>Somehow it’s more like a ”mini OS”</li></ul><h2 id="process">Process</h2><p><strong>Def</strong>. <strong>Process</strong>: the execution of an application program with <strong>restricted rights</strong>.</p><ul><li>Protection from each other; <strong>OS protected</strong> from processes</li><li>Owns dedicated <strong>address space</strong></li><li><strong>Contexts</strong> of file descriptor, filesystem, etc..</li><li><strong>One or many threads</strong></li></ul><blockquote><p>在操作系统中，Contexts（上下文）指的是与进程相关的所有状态信息，这些信息使得操作系统能够正确地管理和调度进程。具体到 file descriptor、filesystem 等，指的是进程在文件操作和文件系统方面的上下文信息。</p><p>How process differs from program?</p><ul><li>Process is an <strong>instance</strong> of program, like an object is an instance of a class in OOP</li><li>A program can have zero, one, or many processes executing it</li></ul></blockquote><h2 id="process-control-block">Process Control Block</h2><p><strong>Def</strong>. <strong>Process control block</strong>: a data structure used by <strong>Linux</strong> to keep <strong>track</strong> of a process execution. It includes</p><ul><li>Process ID (PID)</li><li>Process state (running, waiting, ready..)</li><li>Process priority</li><li>Program counter</li><li>Memory related information</li><li>Register information</li><li>I/O status information (file descriptor, I/O devices..)</li><li>Accounting information</li></ul><h3 id="process-in-memory">Process in Memory</h3><p>There are <span class="math inline">\(5\)</span> parts of a process in memory. <strong>From high address to low address</strong> (this address is virtual), they are <strong>stack</strong>, <strong>heap</strong>, <strong>uninitialized data (.bss)</strong>, <strong>initialized data (.data)</strong>, <strong>code (.text)</strong>.</p><p>For example, the following code initialize a process.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-comment">// .data</span><br><span class="hljs-type">int</span> b; <span class="hljs-comment">// .bss</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">static</span> c = a + b; <span class="hljs-comment">// .data</span><br>  <span class="hljs-type">int</span> d; <span class="hljs-comment">// stack</span><br>  <span class="hljs-type">int</span> *e = <span class="hljs-built_in">malloc</span>(..); <span class="hljs-comment">// heap</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>In Linux, we use <code>readelf</code> command to checkout what’s in an executable</p></blockquote><h2 id="how-to-virtual">How to virtual</h2><p>The basic <strong>model</strong> of CPU virtualization: run one process for a little while, then run another one, and so forth. But this model has two significant challenges.</p><ul><li>Performance. How to virtualize without adding <strong>excessive overhead</strong> to the system</li><li>Control (isolation)<ul><li>OS must take control whenever it wants; otherwise a process can run forever</li><li>OS must control how certain resources can be accessed by processes (<strong>evil</strong> processes)</li><li>A straightforward way to address this; let OS <strong>take charge of</strong> each instruction of process</li></ul></li></ul><blockquote><p>Above contents mean we allow most instructions direct run on CPU, but for sensitive instructions, we let them go through OS. This means we need to <strong>limit direct execution</strong>.</p></blockquote><h3 id="limited-direct-execution">Limited Direct Execution</h3><p>So, how to limit direct execution? Here are two ways.</p><ul><li><strong>Restricted operations</strong><ul><li>Sensitive operations must go to OS, so the latter can guarantee its legality (reject, accept, schedule, etc..)</li></ul></li><li><strong>Inter-process switching</strong><ul><li>Voluntary switching: <strong>system calls</strong>, <code>wait()</code>, etc..</li><li>Involuntary switching: <strong>timer interrupt</strong></li></ul></li></ul><h2 id="dual-mode">Dual Mode</h2><p>But, how to implement <strong>restricted operations</strong> or <strong>inter-process switching</strong>? Is software alone enough? We need hardware-assisted (<strong>user mode</strong> and <strong>kernel mode</strong>)isolation and protection.</p><p>What hardware needs to provide?</p><ul><li><strong>Privileged instructions</strong></li><li><strong>Memory protection</strong></li><li>Timer interrupts</li><li>Safe mode transfer</li></ul><h3 id="privileged-instructions">Privileged Instructions</h3><p><strong>Def</strong>. <strong>Privileged instructions</strong> are available in kernel mode but not user mode. Any instructions that could affect other processors are likely to be privileged.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">Privileged Instructions</th><th style="text-align: center;">Non-privileged Instructions</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">I/O read/write</td><td style="text-align: center;">Performing arithmetic operation</td></tr><tr class="even"><td style="text-align: center;">Context switch</td><td style="text-align: center;">Call a function</td></tr><tr class="odd"><td style="text-align: center;">Changing privilege level</td><td style="text-align: center;">Reading status of processor</td></tr><tr class="even"><td style="text-align: center;">Set system time</td><td style="text-align: center;">Read system time</td></tr></tbody></table></div><div style="text-align: center; font-style: italic;">Table 1: Some privileged instructions and non-privileged instructions</div><p>What if apps need those privileged instructions?</p><p>What if apps executes a privileged instruction <strong>without</strong> permission?</p><ul><li>Processor detects it in its hardware logic, and throws an <strong>exception</strong></li><li>Process halted, <strong>OS takes over</strong></li></ul><h3 id="memory-protection">Memory Protection</h3><ul><li><strong>Segmentation</strong><ul><li>Base and bounds registers</li><li>Every memory access is checked on those registers</li><li>A block copy needs to check each of the data address</li><li>Kernel mode bypass this check</li></ul></li></ul><blockquote><p>The disadvantages of this approach</p><ul><li>No <strong>expandable heap and stack</strong></li><li>No memory <strong>sharing</strong></li><li>Memory fragmentation</li></ul></blockquote><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Boot_Process_Kernel/Base%20and%20Bounds.png" alt="Base and bounds in segmentation"><figcaption aria-hidden="true">Base and bounds in segmentation</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 2: Base and bounds in segmentation</div><ul><li><strong>Paging</strong><ul><li>Every memory address a process see is <strong>discontinuously</strong> mapped to a physical address in memory</li><li>Involves extensive software-hardware cooperation</li></ul></li></ul><blockquote><p><strong>How</strong> to translate virtual address to physical address is determined by <strong>OS in kernel mode</strong></p><p>The <strong>actual</strong> translation process and permission check in done by <strong>CPU</strong></p></blockquote><h3 id="time-interrupts">Time Interrupts</h3><p><strong>Def</strong>. <strong>Time interrupts</strong> is a way for OS to regain the control to the CPU</p><ul><li>An illusion: the program has the full control of CPU</li><li>Otherwise, it can execute an infinite loop</li><li>Hardware timer can <strong>only</strong> be reset in kernel mode</li></ul><p>After timer interrupts, the OS <strong>schedule</strong> another process (could be the same one being interrupted) to run</p><h3 id="current-privilege-level-cpl">Current Privilege Level (CPL)</h3><p>x86 architecture uses <strong>lower</strong> <span class="math inline">\(2\)</span>-bits in the CS (<code>CS</code>) Segment register (referred to as the <strong>current privilege level bits</strong>). Yet most OSes only use level <span class="math inline">\(0\)</span> (<strong>kernel mode</strong>) and level <span class="math inline">\(3\)</span> (<strong>user mode</strong>)</p><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Boot_Process_Kernel/Protection%20Rings.png" alt="Protection rings"><figcaption aria-hidden="true">Protection rings</figcaption></figure></div><div style="text-align: center; font-style: italic;">Figure 3: Protection rings</div><p>How to <strong>switch</strong> between user and kernel modes?</p><ol type="1"><li><code>CPL &amp;= 0x0</code></li><li><code>CPL &amp;= 0x3</code></li><li><code>CPL |= 0x0</code></li><li><code>CPL |= 0x3</code></li><li><code>CPL &amp;= 0xfffffffc</code></li><li><code>CPL |= 0xfffffffc</code></li></ol><h2 id="some-questions">Some Questions</h2><ol type="1"><li><p>Does user code always run in user process?</p></li><li><p>Does user code always run in user mode?</p></li><li><p>Does OS code always run in system process?</p></li><li><p>Does OS code always run in kernel mode?</p></li><li><p>How does code/CPU know if it’s in user or kernel mode?</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thread</title>
    <link href="/2025/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Thread/"/>
    <url>/2025/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Thread/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="concurrency">Concurrency</h2><p><strong>Def</strong>. <strong>Concurrency</strong> means multiple activities at the sam time (network service handles many client requests at the same time).</p><h2 id="thread">Thread</h2><p><strong>Def</strong>. <strong>Thread</strong>: A single execution <strong>sequence</strong> that represents a separately schedulable task. Also known as the <strong>minimal</strong> scheduling unit in OS.</p><blockquote><p><strong>Execution sequence</strong>: Each thread executes <strong>a sequence of instructions</strong> (assignments, conditionals, loops, procedures, etc) just as in the sequential programming model.</p><p><strong>Separately schedulable task</strong>: The OS can run, suspend, or resume a thread at any time.</p></blockquote><p>Thread<strong>s</strong> in the same process share memory space, but not execution context.</p><blockquote><p>There will be thread context switch.</p></blockquote><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Thread/Thread%20vs.%20Process.png" alt="Thread vs. Process"><figcaption aria-hidden="true">Thread vs. Process</figcaption></figure></div><h2 id="thread-implementation">Thread implementation</h2><h3 id="thread-data-structures">Thread Data Structures</h3><h4 id="tcb">TCB</h4><p><strong>Def</strong>. <strong>TCB</strong> (Thread Control Block)</p><ul><li><strong>Stack pointer</strong>: each thread needs their own <strong>stack</strong>.</li><li><strong>Copy of processor registers</strong><ul><li>General-purpose registers for storing intermediate values</li><li>Special-purpose registers for storing instruction pointer and stack pointer</li></ul></li><li><strong>Metadata</strong><ul><li>Thread ID</li><li>Scheduling priority</li><li>Status</li></ul></li></ul><blockquote><p>How large is the stack?</p><ul><li>In kernel, it’s usually small: 8KB in Linux on Intel x86.</li><li>In user space, it’s library-dependent (<code>pthread.h</code>).<ul><li>Most libraries check if there is a stack <strong>overflow</strong>.</li><li>Few PL/libs such as Google Go will automatically extend the stack when needed.</li></ul></li></ul></blockquote><p>TCB（线程控制块）是操作系统为每个线程维护的核心数据结构，记录了线程的状态、寄存器、栈指针等关键信息。每个线程都有自己的 TCB，用于区分和管理线程。</p><h4 id="shared-state">Shared state</h4><p>线程之间可以共享某些状态（如全局变量、堆内存），但每个线程也有自己的私有状态（如栈、寄存器等）。TCB 记录的就是这些私有状态。</p><p>OS does not enforce physical division on threads’ own separated states.</p><p>操作系统不会对线程的私有状态（如栈）做物理隔离。也就是说，虽然每个线程有自己的栈空间，但这些空间在同一个进程的虚拟地址空间内，理论上线程 A 可以通过指针访问线程 B 的栈。</p><blockquote><p>If thread A has a pointer to the stack location of thread B, can A access/modify the variables on the stack of thread B? 答案是<strong>可以</strong>。因为所有线程共享同一个进程的虚拟地址空间，只要线程 A 拿到了线程 B 栈上变量的地址，就可以直接读写。操作系统不会阻止这种行为。</p></blockquote><h3 id="kernel-thread-context-switch">Kernel Thread Context Switch</h3><ul><li>Voluntary kernel thread context switch<ul><li><strong>Turn off interrupts.</strong></li><li>Get a next ready thread.</li><li>Mark the old thread as ready.</li><li>Add the old thread to <strong>readyList</strong>.</li><li>Save all registers and stack point.</li><li>Set stack point to the new thread.</li><li>Restores all the register values.</li></ul></li><li>Involuntary kernel thread context switch<ul><li>Save the states.</li><li>Run the <strong>kernel’s handler</strong>.</li><li>Restore the states.</li></ul></li></ul><blockquote><p>Almost identical to user-mode transfer, except:</p><ul><li>There is no need to switch modes (or stack).</li><li>The handler can resume <strong>any</strong> thread on the ready list rather than always resuming the thread/process that was just suspended.</li></ul></blockquote><h3 id="implementing-multi-threaded-processes">Implementing Multi-threaded Processes</h3><ul><li>Implementing user-level muti-threaded processes through<ul><li>Kernel threads (each thread op traps into kernel).</li><li>User-level libraries (no kernel support)</li><li>Hybrid mode.</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Kernel Abstraction</title>
    <link href="/2025/09/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/The_Kernel_Abstraction/"/>
    <url>/2025/09/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/The_Kernel_Abstraction/</url>
    
    <content type="html"><![CDATA[<p>A central role of operating systems is protection — the isolation of potentially misbehaving applications and users so that they do not corrupt other applications or the operating system itself.</p><p>This chapter focuses on how the operating system protects the kernel from untrusted applications, but the principles also apply at the application level. <span id="more"></span></p><h2 id="the-process-abstraction">The Process Abstraction</h2><p>Some Defintiions:</p><ol type="1"><li><p>A compiler converts that code into a sequence of machine instructions and stores those instructions in a file, called the program’s <strong>executable image</strong>, what’s more, the compiler also defines any static data the program needs, along with its initial values, and includes them in the executable image.</p></li><li><p>To run the program, the operating system copies the instructions and data from the executable image into physical memory. The operating system sets aside a memory region, the <strong>execution stack</strong>, to hold the state of local variables during procedure calls. The operating system also sets aside a memory region, called the <strong>heap</strong>, for any dynamically allocated data structures the program might need.</p></li><li><p>The operating system keeps track of the various processes on the computer using a data structure called the <strong>process control block</strong>, or PCB. The PCB stores all the information the operating system needs about a particular process: where it is stored in memory, where its executable image resides on disk, which user asked it to execute, what privileges the process has, and so forth.</p></li></ol><h2 id="dual-mode-operation">Dual-Mode Operation</h2><h2 id="memory-protection">Memory Protection</h2><h3 id="base-and-bound">Base and Bound</h3><div style="display: block; margin: 0 auto; width: fit-content"><figure><img src="/2025/09/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/The_Kernel_Abstraction/Base%20and%20bound%20memory%20protection.png" alt="Base and bound memory protection"><figcaption aria-hidden="true">Base and bound memory protection</figcaption></figure></div><blockquote><p>Base and bound memory protection using physical addresses. Every code and data address generated by the program is first checked to verify that its address lies within the memory region of the process.</p></blockquote><p>With this approach, a processor has two extra registers, called <strong>base and bound</strong>. The base specifies the start of the process’s memory region in physical memory, while the bound gives its endpoint. These registers can be changed only by privileged instructions, that is, by the operating system executing in kernel mode. User-level code cannot change their values.</p><p>Using physically addressed base and bound registers can provide protection, but this does not provide some important features:</p><ol type="1"><li><p><strong>Expandable heap and stack</strong>.With a single pair of base and bound registers per process, the amount of memory allocated to a program is fixed when the program starts. Although the operating system can change the bound, most programs have two (or more) memory regions that need to independently expand depending on program behavior. The execution stack holds procedure local variables and grows with the depth of the procedure call graph; the heap holds dynamically allocated objects. Most systems today grow the heap and the stack from opposite sides of program memory; this is difficult to accommodate with a pair of base and bound registers.</p></li><li><p><strong>Memory sharing</strong>. Base and bound registers do not allow memory to be shared between different processes, as would be useful for sharing code between multiple processes running the same program or using the same library.</p></li><li><p><strong>Physical memory addresses</strong>. When a program is compiled and linked, the addresses of its procedures and global variables are set relative to the beginning of the executable file, that is, starting at zero. With the mechanism we have just described using base and bound registers, each program is loaded into physical memory at runtime and must use those physical memory addresses. Since a program may be loaded at different locations depending on what other programs are running at the same time, the kernel must change every instruction and data location that refers to a global address, each time the program is loaded into memory.</p></li><li><p><strong>Memory fragmentation</strong>. Once a program starts, it is nearly impossible to relocate it. The program might store pointers in registers or on the execution stack (for example, the program counter to use when returning from a procedure), and these pointers need to be changed to move the program to a different region of physical memory. Over time, as applications start and finish at irregular times, memory will become increasingly fragmented. Potentially, memory fragmentation may reach a point where there is not enough contiguous space to start a new process, despite sufficient free memory in aggregate.</p></li></ol><p>这段内容主要讨论了基于物理地址的基址和界限寄存器实现内存保护的方式及其局限性，具体包括以下几点：</p><ul><li><p><strong>可扩展的堆和栈</strong>：仅依靠一对基址和界限寄存器，程序启动时的内存区域是固定的，无法满足堆和栈需要独立扩展的需求。</p></li><li><p><strong>内存共享问题</strong>：基址和界限寄存器方法不能实现多个进程之间的内存共享，比如共享代码或库，这在多进程环境下是一个重要功能。</p></li><li><p><strong>物理内存地址问题</strong>：程序在编译时所有地址均相对于可执行文件的起始位置（即从零开始），而加载到物理内存时，必须调整所有全局地址指令，使得加载过程极为复杂且低效。</p></li><li><p><strong>内存碎片问题</strong>：一旦程序加载，就难以迁移，因为内部的数据结构（例如寄存器中的指针）需要重新调整，这会导致内存碎片问题，最终可能无法分配足够连续的内存空间启动新进程。</p></li></ul><p>整体来说，文章在说明虽然基于基址和界限寄存器的内存保护机制可以提供基本的保护，但它在现代操作系统中存在诸多限制，不适应现代应用程序对内存灵活性和共享能力的需求。</p>]]></content>
    
    
    <categories>
      
      <category>The Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微分方程</title>
    <link href="/2025/09/11/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    <url>/2025/09/11/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="常见的一阶微分方程的解法">常见的一阶微分方程的解法</h2><ol type="1"><li><p>最简单的一阶微分方程形式为 <span class="math inline">\(f(x) \text{d}x = g(y) \text{d}y\)</span>，此时等式两端积分即可。</p></li><li><p>齐次方程标准形式如下：<span class="math inline">\(y&#39; = f(\frac{y}{x})\)</span>，其中 <span class="math inline">\(f\)</span> 有连续的导数，此时只需要令 <span class="math inline">\(u = \frac{y}{x}\)</span>。</p></li><li><p>伯努利方程的标准形式为 <span class="math inline">\(\frac{\text{d}y}{\text{d}x} + P(x)y = Q(x) y^\alpha\)</span>，其中 <span class="math inline">\(P(x)\)</span> 和 <span class="math inline">\(Q(x)\)</span> 均为连续函数，且 <span class="math inline">\(\alpha \neq 0, 1\)</span>，两端同时除以 <span class="math inline">\(y^\alpha\)</span>，再令 <span class="math inline">\(z = y^{1 - \alpha}\)</span></p></li><li><p>一阶线性方程的标准形式为 <span class="math inline">\(\frac{\text{d}y}{\text{d}x} + P(x)y = Q(x)\)</span>，其中 <span class="math inline">\(P(x)\)</span> 和 <span class="math inline">\(Q(x)\)</span> 均为连续函数，该方程的通解为 <span class="math inline">\(y = \text{e}^{-\int P(x) \text{d}x} \bigl(\int Q(x) \text{e}^{\int P(x) \text{d}x}\text{d}x + C\bigr)\)</span></p></li><li><p>凑全微分需要技巧</p></li></ol><h2 id="高阶微分方程">高阶微分方程</h2><ol type="1"><li>有些高阶微分方程可以降阶，比如 <span class="math inline">\(F(x, y&#39;, y&#39;&#39;)\)</span> 和 <span class="math inline">\(F(y ,y&#39;, y&#39;&#39;)\)</span></li></ol><h2 id="常系数高阶线性微分方程">常系数高阶线性微分方程</h2><h3 id="齐次线性微分方程">齐次线性微分方程</h3><p>标准形式：<span class="math inline">\(y^{(n)} + a_1 y^{(n-1)} + \cdots + a_{n-1} y&#39; + a_n y = 0\)</span></p><ol type="1"><li><p><strong>特征方程法</strong>：令 <span class="math inline">\(I(\lambda) = \lambda^n + a_1 \lambda^{n - 1} + \cdots + a_{n - 1} \lambda + a_n = 0\)</span>，解出所有特征根</p></li><li><p><strong>根据特征根类型构造通解</strong>：</p><ul><li><p><strong>单实根</strong> <span class="math inline">\(\lambda\)</span>：对应解为 <span class="math inline">\(C e^{\lambda x}\)</span></p></li><li><p><strong><span class="math inline">\(k\)</span> 重实根</strong> <span class="math inline">\(\lambda\)</span>：对应解为 <span class="math inline">\((C_1 + C_2 x + \cdots + C_k x^{k-1}) e^{\lambda x}\)</span></p></li><li><p><strong>单复根</strong> <span class="math inline">\(\alpha \pm \beta i\)</span>：对应解为 <span class="math inline">\(e^{\alpha x}(C_1 \cos \beta x + C_2 \sin \beta x)\)</span></p></li><li><p><strong><span class="math inline">\(k\)</span> 重复根</strong> <span class="math inline">\(\alpha \pm \beta i\)</span>：对应解为 <span class="math inline">\(e^{\alpha x}[(C_1 + C_2 x + \cdots + C_k x^{k-1}) \cos \beta x + (D_1 + D_2 x + \cdots + D_k x^{k-1}) \sin \beta x]\)</span></p></li></ul></li></ol><h2 id="例题讲解">例题讲解</h2><ol type="1"><li><blockquote><p>解微分方程 <span class="math inline">\(y(y + 1) \text{d} x + [x(y + 1) + x^2 y^2] \text{d} y = 0\)</span>。</p></blockquote><p>变形如下</p><p><span class="math display">\[\begin{aligned}(y + 1)(y\text{d} x + x\text{d} y) + x^2 y^2 \text{d} y &amp;= 0\\\frac{\text{d} (xy)}{x^2 y^2} + \frac{\text{d} y}{1 + y} &amp;= 0\\\frac{-1}{xy} + \ln |y + 1| &amp;= C, C \in \mathbb{R}\end{aligned}\]</span></p></li><li><blockquote><p>求微分方程 <span class="math inline">\((1 + y^2) \text{d} x + (x - \arctan y) \text{d} y = 0\)</span> 的通解。</p></blockquote><p><span class="math display">\[\begin{aligned}\frac{\text{d} x}{\text{d} y} + \frac{x - \arctan y}{1 + y^2} &amp;= 0\\\end{aligned}\]</span></p></li><li><blockquote><p>求微分方程 <span class="math inline">\(y y&#39;&#39; - 2(y&#39;)^2 = 0\)</span> 的通解</p></blockquote><p>设 <span class="math inline">\(y&#39; = p(y)\)</span>，则 <span class="math inline">\(y&#39;&#39; = \frac{\text{d} p}{\text{d} y} \frac{\text{d} y}{\text{d} x} = p \frac{\text{d} p}{\text{d} y}\)</span>，则原微分方程变为 <span class="math inline">\(y p \frac{\text{d} p}{\text{d} y} - 2 p^2 = 0\)</span>，如果 <span class="math inline">\(p \neq 0\)</span>，则 <span class="math inline">\(y \frac{\text{d} p}{\text{d} y} = 2p\)</span></p></li><li><blockquote><p>求二阶非齐次线性方程 <span class="math inline">\(y&#39;&#39; - 3y&#39; + 2y = 2\text{e}^{-x} \cos x + \text{e}^{2x}(4x + 5)\)</span> 的通解</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>无穷级数</title>
    <link href="/2025/09/11/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/"/>
    <url>/2025/09/11/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>数项级数</strong>与<strong>函数项级数</strong></p><!--- more --><h2 id="内容要点">内容要点</h2><ol type="1"><li><p>常数项级数收敛等价于余项极限为 0。</p></li><li><p>在级数中去掉、增加或改变有限项不改变敛散性。</p></li><li><p>两个及以上的发散级数加减结果的敛散性不定。</p></li><li><p>级数收敛的必要条件是其通项极限为 0。</p></li><li><p>p-级数：<span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{1}{n^p} = \begin{cases}收敛, &amp;p &gt; 1 \\ 发散, &amp;p \leq 1\end{cases}\)</span></p></li><li><p>交错级数收敛的莱布尼茨判别法：<span class="math inline">\(\sum\limits_{n = 1}^{\infty} (-1)^{n - 1} u_n\)</span>，如果数列 <span class="math inline">\(\{u_n\}\)</span>单调减少且 <span class="math inline">\(\lim\limits_{n \to \infty} u_n = 0\)</span>，则收敛。</p></li><li><p>若正项级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} u_n\)</span> 满足 <span class="math inline">\(\lim\limits_{n \to \infty} \frac{u_{n + 1}}{u_n} = \rho\)</span> 或 <span class="math inline">\(\lim\limits_{n \to \infty} \sqrt[n]{u_n} = \rho\)</span>，则当 <span class="math inline">\(\rho &lt; 1\)</span> 时收敛，<span class="math inline">\(&gt; 1\)</span> 时发散。</p></li><li><p>给出两个正项级数的通项 <span class="math inline">\(u_n\)</span> 和 <span class="math inline">\(v_n\)</span>，记极限结果为 <span class="math inline">\(\lim\limits_{n \to \infty} \frac{u_n}{v_n} = l_n\)</span>。<span class="math inline">\(0 &lt; l_n &lt; +\infty\)</span>，则两个正项级数同敛散性；如果 <span class="math inline">\(l_n = 0\)</span>，则若 <span class="math inline">\(\sum\limits_{n = 1}^{\infty}v_n\)</span> 收敛，<span class="math inline">\(\sum\limits_{n = 1}^{\infty}u_n\)</span> 收敛；若 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} u_n\)</span> 发散，<span class="math inline">\(\sum\limits_{n = 1}^{\infty} v_n\)</span> 发散。</p></li><li><p>如果级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} |u_n|\)</span> 收敛，则称级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} u_n\)</span> 绝对收敛。绝对收敛的级数必收敛。</p></li><li><p>如果 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} u_n\)</span> 收敛，而 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} |u_n|\)</span> 发散，则称级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} u_n\)</span> 条件收敛。</p></li><li><p>绝对收敛的级数改变任意个项次序所得新级数仍收敛，且和结果不变；条件收敛的级数可以通过改变次序使得新级数收敛于任何实数。</p></li><li><p>设在 <span class="math inline">\([1, +\infty]\)</span> 上 <span class="math inline">\(f(x) \geq 0\)</span> 且单调递减，<span class="math inline">\(a_n = f(n)\)</span>，则 <span class="math inline">\(\sum\limits_{n = 1}^{\infty}\)</span> 与 <span class="math inline">\(\int_{1}^{+\infty} f(x) \text{d}x\)</span> 同敛散性。</p></li><li><p>设 <span class="math inline">\(p\)</span>，<span class="math inline">\(q\)</span> 是正数，证明级数 <span class="math inline">\(\sum\limits_{n = 2}^{\infty} \frac{1}{n^p \ln^q n}\)</span>，当 <span class="math inline">\(p &gt; 1\)</span> 时收敛，<span class="math inline">\(p &lt; 1\)</span> 时发散；当 <span class="math inline">\(p = 1\)</span> 时，只在 <span class="math inline">\(q &gt; 1\)</span> 时该级数收敛。</p></li></ol><h2 id="例题讲解">例题讲解</h2><ol type="1"><li><blockquote><p>求下列级数的和</p></blockquote><p>(1).</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{1}{(3n - 2)(3n + 1)} = \frac{1}{3}\sum_{n = 1}^{\infty} \frac{1}{3n - 2} - \frac{1}{3n + 1} = \frac{1}{3} (1 - \lim_{n \to \infty} \frac{1}{3n + 1}) = \frac{1}{3}\]</span></p><p>(2).</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{1}{n(n + 1)(n + 2)} = \sum_{n = 1}^{\infty} \biggl [\frac{1}{2n} - \frac{1}{2(n + 1)} + \frac{1}{2(n + 2)} - \frac{1}{2(n + 1)} \biggl ] = \frac{1}{2} - \frac{1}{4} = \frac{1}{4}\]</span></p><p>(3).</p><p><span class="math display">\[\sum_{k = 1}^{\infty} \frac{6^k}{(3^k - 2^k)(3^{k + 1} - 2^{k + 1})} = \sum_{k = 1}^{\infty} \frac{3^k}{3^k - 2^k} - \frac{3^{k + 1}}{3^{k + 1} - 2^{k + 1}} = 3 - \lim_{k \to \infty} \frac{3^{k + 1}}{3^{k + 1} - 2^{k + 1}} = 2\]</span></p><p>(4).</p><p><span class="math display">\[\sum_{k = 1}^{\infty} \frac{(k + 1)(k + 2)(k + 3) - 1}{(k + 3)!} = \sum_{k = 1}^{\infty} \frac{1}{k!} - \frac{1}{(k + 3)!} = \frac{5}{3}\]</span></p></li><li><blockquote><p>求级数的和</p><p><span class="math display">\[\sum_{n = 0}^{n} \text{arccot} (n^2 + n + 1)\]</span></p></blockquote><p><span class="math display">\[\begin{aligned}\cot (\alpha - \beta) &amp;= \frac{\cot \alpha \cot \beta + 1}{\cot \beta - \cot \alpha}\\\cot (\text{arccot} n - \text{arccot} (n + 1)) &amp;= n^2 + n + 1\\\text{arccot} (n^2 + n + 1) &amp;= \text{arccot} n - \text{arccot} (n + 1)\\\sum_{n = 0}^{\infty} \text{arccot} (n^2 + n + 1) &amp;= \lim\limits_{n \to \infty} \sum_{k = 0}^{n} \text{arccot} k - \text{arccot} (k + 1) = \frac{\pi}{2}\end{aligned}\]</span></p></li><li><blockquote><p>证明级数收敛并求其和</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{1 + \frac{1}{2} + \cdots + \frac{1}{n}}{(n + 1)(n + 2)}\]</span></p></blockquote><p><span class="math display">\[\begin{aligned}S_n &amp;= \sum_{n = 1}^{\infty} \frac{1 + \frac{1}{2} + \cdots + \frac{1}{n}}{(n + 1)(n + 2)} = \sum_{n = 1}^{\infty} \frac{a_n}{(n + 1)(n + 2)} = \sum_{n = 1}^{\infty} \biggl(\frac{a_n}{n + 1} - \frac{a_n}{n + 2}\biggr)\\&amp;= \frac{a_1}{2} - \frac{a_1}{3} + \frac{a_2}{3} - \frac{a_2}{4} + \cdots + \frac{a_n}{n + 1} - \frac{a_n}{n + 2}\\&amp;= \frac{a_1}{2} - \frac{a_1 - a_2}{3} - \frac{a_2 - a_3}{4} + \cdots + \frac{a_{n - 1} - a_{n}}{n + 1} - \frac{a_n}{n + 2}\\&amp;= \frac{1}{1 \times 2} + \frac{1}{2 \times 3} + \frac{1}{3 \times 4} + \cdots + \frac{1}{n \times (n + 1)} - \frac{a_n}{n + 2}\\&amp;= 1 - \lim\limits_{n \to \infty} \biggl(\frac{1}{n + 1} - \frac{a_n}{n + 2}\biggr) = 1\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(p &gt; 0\)</span>，<span class="math inline">\(x_1 = \frac{1}{4}\)</span>，且 <span class="math inline">\(x_{n + 1}^{p} = x_{n}^{p} + x_{n}^{2p}(n = 1, 2, \cdots)\)</span>。证明：<span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{1}{1 + x_{n}^{p}}\)</span> 收敛且求其和。</p></blockquote><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{1}{1 + x_{n}^{p}} = \sum_{n = 1}^{\infty} \biggl(\frac{x_{n}^{p}}{x_{n}^{p} + x_{n}^{2p}}\biggr) =\sum_{n = 1}^{\infty} \biggl(\frac{1}{x_{n}^{p}} - \frac{1}{x_{n + 1}^{p}}\biggr) = 4^{p}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(u_1 = 2\)</span>，<span class="math inline">\(u_{n + 1} = u_{n}^{2} - u_{n} + 1(n = 1, 2, \cdots)\)</span>。证明：<span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{1}{u_n} = 1\)</span>。</p></blockquote><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{u_{n}}{u_{n}^2} = \sum_{n = 1}^{\infty} \frac{u_n}{u_{n + 1} + u_{n} - 1} = \sum_{n = 1}^{\infty} \frac{u_n^2}{(u_{n + 1} + u_n - 1)u_n}\]</span></p></li><li><blockquote><p>判断下列级数的敛散性</p><p>(1).</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \bigg(1 + \frac{1}{n}\biggr)^{n^2} \text{e}^{-n}\]</span></p><p>(2).</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \sqrt[n]{a} - \sqrt[n]{b}(a &gt; b &gt; 0)\]</span></p></blockquote><p>(1). 发散</p><p><span class="math display">\[\lim_{n \to \infty} \frac{\exp(n^2(\frac{1}{n} - \frac{1}{2n^2} + o(x^n)))}{\exp(n)} = \frac{1}{\sqrt{\text{e}}} \neq 0\]</span></p><p>(2). 发散</p><p><span class="math display">\[\lim_{n \to \infty} \frac{\sqrt[n]{a} - \sqrt[n]{b}}{\frac{1}{n}} = \ln \frac{a}{b} &gt; 0\]</span></p></li><li><blockquote><p>已知级数收敛，求实数 <span class="math inline">\(\alpha\)</span> 的取值范围</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \biggl(\frac{1}{n} - \sin \frac{1}{n}\biggr)^{\alpha}\]</span></p></blockquote><p><span class="math display">\[\lim_{n \to \infty} \biggl(\frac{1}{n} - \sin \frac{1}{n}\biggr)^{\alpha} = \lim_{n \to \infty} \biggl(\frac{1}{n} - \frac{1}{n} + \frac{1}{n^3} + o\bigg(\frac{1}{n^4}\bigg)\biggr)^{\alpha} = \lim_{n \to \infty} \biggl(n^{\alpha - 3} + o(n^{\alpha - 4})\biggr)\]</span></p><p>所以 <span class="math inline">\(3\alpha &gt; 1\)</span>。</p></li><li><blockquote><p>证明级数是收敛的</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \biggl(\text{e} - \biggl(1 + \frac{1}{1!} + \frac{1}{2!} + \cdots + \frac{1}{n!}\biggr)\biggr)\]</span></p></blockquote><p><span class="math inline">\(\text{e} = 1 + \frac{1}{1!} + \frac{1}{2!} + \cdots + \frac{1}{n!} + \frac{\text{e}^\xi}{(n + 1)!}, 1 &gt; \xi &gt; 0\)</span>，所以</p><p><span class="math display">\[0 &lt; \sum_{n = 1}^{\infty} \biggl(\frac{\text{e}^{\xi}}{(n + 1)!}\biggr) &lt; \sum_{n = 1}^{\infty} \biggl(\frac{3}{(n + 1)!}\biggr)\]</span></p><p>所以收敛。</p></li><li><blockquote><p>设 <span class="math inline">\(a &gt; 0\)</span>，判别级数的敛散性</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{a^{\frac{n(n + 1)}{2}}}{(1 + a)(1 + a^2)\cdots(1 + a^n)}\]</span></p></blockquote><p>用比值判别法：</p><p><span class="math display">\[\lim_{n \to \infty} \frac{a^{n + 1}}{1 + a^{n + 1}} =\begin{cases}0, &amp;1 &gt; a &gt; 0\\\frac{1}{2}, &amp;a = 1\\1, &amp;a &gt; 1\end{cases}\]</span></p><p>所以，<span class="math inline">\(1 \geq a &gt; 0\)</span> 时收敛，当 <span class="math inline">\(a &gt; 1\)</span> 时，</p><p><span class="math display">\[1 &gt; \frac{a^{\frac{n(n + 1)}{2}}}{(1 + a)(1 + a^2)\cdots(1 + a^n)} \\= \frac{1}{(1 + \frac{1}{a})(1 + \frac{1}{a^2}) \cdots (1 + \frac{1}{a^n})} &gt; \frac{1}{\text{e}^{\frac{1}{a}} \cdot \text{e}^{\frac{1}{a^2}} \cdots \text{e}^{\frac{1}{a^n}}} &gt; \text{e}^{-\frac{1}{a^{\frac{n(n + 1)}{2}}}} &gt; 0\]</span></p><p>所以发散。</p></li><li><blockquote><p>级数是否收敛</p><p><span class="math display">\[\sum_{n = 2}^{\infty} \frac{1}{\ln n !}\]</span></p></blockquote><p><span class="math display">\[\frac{1}{\ln n !} &gt; \frac{1}{n \ln n}\]</span></p><p>所以发散。</p></li><li><blockquote><p>设 <span class="math inline">\(\alpha &gt; 0\)</span>，<span class="math inline">\(\beta &gt; 0\)</span>，判断下列级数何时收敛与发散：</p><p>(1).</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{1}{\alpha^n + \beta^n}\]</span></p><p>(2).</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{\alpha^n}{\alpha^n + \beta^n}\]</span></p></blockquote><p>(1). 当 <span class="math inline">\(\alpha &gt; 1\)</span> 或者 <span class="math inline">\(\beta &gt; 1\)</span> 时，原级数收敛，当 <span class="math inline">\(\alpha \leq 1\)</span> 且 <span class="math inline">\(\beta \leq 1\)</span> 时，原级数发散。</p><p>(2). <span class="math inline">\(\beta &gt; \alpha\)</span> 时收敛，<span class="math inline">\(\alpha \geq \beta\)</span> 时发散。</p></li><li><blockquote><p>设 <span class="math inline">\(\{F_n\}\)</span> 是斐波那契数列，判断二级数的敛散性</p><p><span class="math display">\[\sum_{n = 0}^{\infty} \frac{1}{F_n} \quad \sum_{n = 2}^{\infty} \frac{1}{\ln F_n}\]</span></p></blockquote><p>显然数列单调递增</p><p><span class="math display">\[\begin{aligned}F_n &amp;= F_{n - 1} + F_{n - 2} &lt; 2F_{n - 1} &lt; 2^2 F_{n - 2} &lt; 2^3 F_{n - 3} &lt; \cdots &lt; 2^{n - 1}\\F_n &amp;= F_{n - 1} + F_{n - 2} &gt; \frac{3}{2} F_{n - 1} &gt; \cdots &gt; \biggl(\frac{3}{2}\biggr)^{n - 1}\\\biggl(\frac{2}{3}\biggr)^{n - 1} &amp;&gt; \frac{1}{F_n} &gt; 0\\\frac{1}{\ln F_n} &amp;&gt; \frac{1}{(n - 1) \ln 2}\end{aligned}\]</span></p><p>所以，<span class="math inline">\(\sum\limits_{n = 0}^{\infty} \frac{1}{F_n}\)</span> 收敛，另一个发散。</p></li><li><blockquote><p>研究级数的敛散性</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{1}{x_n^2}\]</span></p><p>其中， <span class="math inline">\(x_n\)</span> 是方程 <span class="math inline">\(x = \tan x\)</span> 的正根。</p></blockquote><p><span class="math inline">\(0 \leq y_n = \arctan x_n &lt; \frac{\pi}{2}\)</span>，<span class="math inline">\(x_n = n\pi + y_n\)</span>，</p><p><span class="math display">\[\frac{1}{x_n^2} &lt; \frac{1}{(n\pi + y_n)^2} &lt; \frac{1}{n^2}\]</span></p><p>所以收敛。</p></li><li><blockquote><p>讨论级数的收敛性</p><p><span class="math display">\[\sqrt{2} + \sqrt{2 - \sqrt{2}} + \sqrt{2 - \sqrt{2 + \sqrt{2}}} + \sqrt{2 - \sqrt{2 + \sqrt{2 + \sqrt{2}}}}+\cdots\]</span></p></blockquote><p>令 <span class="math inline">\(A_1 = \sqrt{2}\)</span>，<span class="math inline">\(A_2 = \sqrt{2 + \sqrt{2}}\)</span>，<span class="math inline">\(A_n = \sqrt{2 + A_{n - 1}}\)</span>，所以原级数可以变为：</p><p><span class="math display">\[\sqrt{2} + \sum_{n = 1}^{\infty} \sqrt{2 - A_n}\]</span></p><p>用比值法判断级数收敛性</p><p><span class="math display">\[\lim_{n \to \infty} \frac{\sqrt{2 - A_{n + 1}}}{\sqrt{2 - A_n}} = \lim_{n \to \infty} \frac{\sqrt{2 - A_n}}{\sqrt{(2 - A_n)(2 + \sqrt{2 + A_n})}} = \frac{1}{2}\]</span></p><p>所以收敛。</p></li><li><blockquote><p>已知 <span class="math inline">\(c_n \geq 0\)</span> 且级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{c_n}{n}\)</span> 收敛，证明下面级数收敛：</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \sum_{k = 1}^{\infty} \frac{c_n}{k^2 + n^2}\]</span></p></blockquote><p>设 <span class="math inline">\(a_n = \sum\limits_{k = 1}^{\infty} \frac{c_n}{k^2 + n^2}\)</span>，显然级数 <span class="math inline">\(a_n\)</span> 收敛，接下来只需要证明级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n\)</span> 收敛，因此</p><p><span class="math display">\[0 \leq a_n = \frac{c_n}{n^2} \sum_{k = 1}^{\infty} \frac{1}{(\frac{k}{n})^2 + 1} \leq \frac{c_n}{n^2} \sum_{k = 1}^{\infty} \int_{k}^{k + 1} \frac{\text{d} x}{(\frac{x}{n})^2 + 1} = \frac{c_n}{n^2} \int_{1}^{\infty} \frac{\text{d} x}{(\frac{x}{n})^2 + 1} = \frac{c_n}{n} \cdot \frac{\pi}{4}\]</span></p><p>所以</p><p><span class="math display">\[0 \leq \sum_{n = 1}^{\infty} a_n \leq \frac{\pi}{4} \cdot \sum_{n = 1}^{\infty} \frac{c_n}{n} \]</span></p><p>收敛。</p></li><li><blockquote><p>设 <span class="math inline">\(a_n &gt; 0\)</span>，证明：如果级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n\)</span> 收敛，则级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n^2\)</span> 收敛。</p></blockquote><p>当 <span class="math inline">\(n\)</span> 充分大时，<span class="math inline">\(0 &lt; a_n &lt; 1\)</span>，此时 <span class="math inline">\(a_n^2 &lt; a_n\)</span>，由比较法知级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n^2\)</span> 收敛</p></li><li><blockquote><p>设 <span class="math inline">\(\{a_n\}\)</span> 是正项递减数列且级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n\)</span> 收敛，证明：</p><p>(1).</p><p><span class="math display">\[\lim_{n \to \infty} na_n = 0\]</span></p><p>(2).</p><p><span class="math display">\[\sum_{n = 1}^{\infty} n(a_{n - 1} - a_n) = \sum_{n = 1}^{\infty} a_n\]</span></p><p>其中，<span class="math inline">\(a_0 = 0\)</span>。</p></blockquote><p>(1). 设 <span class="math inline">\(\{S_n\}\)</span> 是 <span class="math inline">\(\sum\limits_{n \to \infty}^{\infty} a_n\)</span> 的部分和数列，故</p><p><span class="math display">\[S_{2n} - S_{n} = a_{n + 1} + a_{n + 2} + \cdots + a_{2n} \geq n a_{2n} \geq 0\]</span></p><p>所以，<span class="math inline">\(\{na_n\}\)</span> 的子数列 <span class="math inline">\(\{2n a_{2n}\}\)</span> 收敛，由于 <span class="math inline">\((2n - 1) a_{2n - 1} \leq (2n - 1) a_{2n} = 2n a_{2n} - a_{2n}\)</span>，则子数列 <span class="math inline">\(\{(2n - 1) a_{2n - 1}\}\)</span> 收敛，从而有 <span class="math inline">\(\lim\limits_{n \to \infty} na_n = 0\)</span>。</p><p>(2). 设级数的部分和数列为 <span class="math inline">\(\{\sigma_n\}\)</span>，则</p><p><span class="math display">\[\begin{aligned}\sigma_n &amp;= a_1 + a_2 + \cdots + a_{n - 1} - na_n = S_{n - 1} - na_n\\\lim_{n \to \infty} \sigma_n &amp;= \lim_{n \to \infty} S_{n - 1} = \sum_{n = 1}^{\infty} a_n\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(a_n &gt; 0\)</span>，<span class="math inline">\((n = 1, 2, 3, \cdots)\)</span>，级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n\)</span> 收敛，证明级数发散。</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{a_n}{a_n + a_{n + 1} + a_{n + 2} + \cdots}\]</span></p></blockquote><p>级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n\)</span> 的余项记为 <span class="math inline">\(r_n = a_n + a_{n + 1} + \cdots\)</span>，级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{a_n}{r_n}\)</span> 的余项记为 <span class="math inline">\(\rho_n = \frac{a_n}{r_n} + \frac{a_{n + 1}}{r_{n + 1}} + \cdots\)</span>，因为 <span class="math inline">\(\{r_n\}\)</span> 单调递减，所以 <span class="math inline">\(\rho_n &gt; 1\)</span>，故该级数发散。</p></li><li><blockquote><p>求幂级数的收敛域</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{\sin n}{n^2} x^n\]</span></p></blockquote><p>显然该级数收敛半径大于 1，在其收敛域内对其和函数求二阶导数</p><p><span class="math display">\[S&#39;&#39;(x) = \sum_{n = 3}^{\infty} \frac{(n - 1) \sin n}{n} x^{n - 2}\]</span></p><p>显然有</p><p><span class="math display">\[\bigg| \frac{\sin n}{n^2} x^2 \bigg| &lt; \bigg| x^2 \bigg|\]</span></p><p>所以收敛域包括 <span class="math inline">\((-1, 1)\)</span>，而当 <span class="math inline">\(x = 1\)</span> 时，<span class="math inline">\(\sum\limits_{n = 3}^{\infty} \frac{(n - 1) \sin n}{n}\)</span> 显然发散，所以由阿贝尔定理知当 <span class="math inline">\(|x| &gt; 1\)</span> 时，原级数发散；对于 <span class="math inline">\(x = \pm 1\)</span> 原级数为 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{\sin n}{n^2} (\pm 1)^{n}\)</span>，显然收敛。综上收敛域为 <span class="math inline">\([-1, 1]\)</span>。</p></li><li><blockquote><p>设 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n\)</span> 与 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} b_n\)</span> 为正项级数，证明：若 <span class="math inline">\(\lim\limits_{n \to \infty} \bigl( \frac{a_n}{a_{n + 1} b_{n}} - \frac{1}{b_{n + 1}} \bigr) &gt; 0\)</span>，则 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n\)</span> 收敛。</p></blockquote><p>设极限结果为 <span class="math inline">\(\delta &gt; 0\)</span>，由极限的保号性，存在 <span class="math inline">\(N\)</span>，当 <span class="math inline">\(n &gt; N\)</span> 时，有 <span class="math inline">\(\big(\frac{a_n}{a_{n + 1}b_n} - \frac{1}{b_{n + 1}}\big) &gt; \frac{\delta}{2} &gt; 0\)</span>，所以有</p><p><span class="math display">\[\begin{aligned}\bigg(\frac{a_n}{b_n} - \frac{a_{n + 1}}{b_{n + 1}}\bigg) \frac{2}{\delta} &amp;&gt; a_{n + 1}\\\frac{2}{\delta} \sum_{n = N}^{m} \bigg(\frac{a_n}{b_n} - \frac{a_{n + 1}}{b_{n + 1}}\bigg) &amp;&gt; \sum_{n = N}^{m} a_{n + 1}\\\frac{2}{\delta} \bigg(\frac{a_N}{b_N} - \frac{a_{m + 1}}{b_{m + 1}}\bigg) &amp;&gt; \sum_{n = N}^{m} a_{n + 1}\end{aligned}\]</span></p><p>这表明级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n\)</span> 的部分和有上界，所以收敛。</p></li><li><blockquote><p>设 <span class="math inline">\(\{p_n\}\)</span> 是单调增加的正数列，证明：<span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{1}{p_n}\)</span> 与 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{n}{p_1 + p_2 + \cdots + p_n}\)</span> 同敛散性。</p></blockquote><p>若 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{n}{p_1 + p_2 + \cdots + p_n}\)</span> 收敛，由 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{1}{p_n} = \sum\limits_{n = 1}^{\infty} \frac{n}{np_n} &lt; \sum\limits_{n = 1}^{\infty} \frac{n}{p_1 + p_2 + \cdots + p_n}\)</span> 知 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{1}{p_n}\)</span> 收敛；</p><p>若 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{n}{p_1 + p_2 + \cdots + p_n}\)</span> 发散，由不等式得到</p><p><span class="math display">\[\frac{2n}{p_1 + p_2 + \cdots + p_{2n}} \leq \frac{2n}{p_{n + 1} + p_{n + 2} + \cdots + p_{2n}} \leq \frac{2}{p_{n + 1}}\]</span></p><p>于是</p><p><span class="math display">\[\frac{2n}{p_1 + p_2 + \cdots + p_{2n}} + \frac{2n + 1}{p_1 + p_2 + \cdots + p_{2n + 1}} \leq \frac{5}{p_{n + 1}}\]</span></p><p>因此</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{n}{p_1 + p_2 + \cdots + p_n} = p_1 + \sum_{n = 1}^{\infty} \bigg(\frac{2n}{p_1 + p_2 + \cdots + p_{2n}} + \frac{2n + 1}{p_1 + p_2 + \cdots + p_{2n + 1}}\bigg) \\\leq p_1 + 5\sum_{n = 1}^{\infty}\frac{1}{p_{n + 1}}\]</span></p><p>所以，<span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{1}{p_n}\)</span> 发散</p></li><li><blockquote><p>设级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} u_n (u_n &gt; 0)\)</span> 发散，部分和 <span class="math inline">\(S_n = u_1 + u_2 + \cdots + u_n\)</span>。证明：</p><p>(1). 级数发散</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{u_n}{S_n}\]</span></p><p>(2). 级数收敛</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{u_n}{S_n^2}\]</span></p></blockquote><p>(1). 考虑级数的余项 <span class="math inline">\(\rho_n = \sum\limits_{k = n}^{\infty} \frac{u_k}{S_k} \geq \sum\limits_{n = k}^{n + p} \frac{u_k}{S_k} \geq \frac{1}{S_{n + p}} \sum\limits_{k = n}^{n + p} u_{k} = \frac{S_{n + p} - S_{n - 1}}{S_{n + p}} = 1 - \frac{S_{n - 1}}{S_{n + p}}\)</span>，显然，当 <span class="math inline">\(p \to \infty\)</span> 时，<span class="math inline">\(\rho_n\)</span> 不趋于 0，所以该级数发散。</p><p>(2).</p><p><span class="math display">\[\sum_{k = 2}^{n} \frac{u_k}{S^2_k} \leq \sum_{k = 2}^{n} \frac{S_k - S_{k - 1}}{S_k S_{k - 1}} = \sum_{k = 2}^{n} \bigg(\frac{1}{S_{k - 1}} - \frac{1}{S_{k}} \bigg) = \frac{1}{S_1} - \frac{1}{S_n} &lt; \frac{1}{u_1}\]</span></p><p>故正项级数 <span class="math inline">\(\sum\limits_{k = 2}^{n} \frac{u_k}{S_k^2}\)</span> 的部分和有上界，从而收敛。</p></li><li><blockquote><p>设 <span class="math inline">\(\{u_n\}\)</span> 是单调增加的正数列，证明级数收敛的充要条件是 <span class="math inline">\(\{u_n\}\)</span> 有界</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \biggl(1 - \frac{u_n}{u_{n + 1}}\biggr)\]</span></p></blockquote><p>设部分和为 <span class="math inline">\(S_n = \sum\limits_{k = 1}^{n} \big(1 - \frac{u_k}{u_{k + 1}}\big)\)</span>。</p><p>假设 <span class="math inline">\(\{u_n\}\)</span> 有界，则</p><p><span class="math display">\[S_n = \frac{u_2 - u_1}{u_2} + \cdots + \frac{u_{n + 1} - u_{n}}{u_{n + 1}} \leq \frac{u_{n + 1} - u_1}{u_2} \]</span></p><p>故 <span class="math inline">\(\{S_n\}\)</span> 也有界，所以收敛。</p><p>假设该级数收敛，用反证法，假设此时数列 <span class="math inline">\(\{u_n\}\)</span> 无界，<span class="math inline">\(\lim\limits_{n \to \infty} u_n = \infty\)</span>，对于任意固定的正整数 <span class="math inline">\(n_0\)</span>，存在 <span class="math inline">\(n &gt; n_0\)</span>，使得 <span class="math inline">\(u_n &gt; 2u_{n_0}\)</span>。考虑余项</p><p><span class="math display">\[\sum_{k = n_0}^{\infty} \biggl(1 - \frac{u_{k}}{u_{k + 1}}\biggr) \geq \sum_{k = n_0}^{n} \biggl(1 - \frac{u_{k}}{u_{k + 1}}\biggr) \geq \frac{u_n - u_{n_0}}{u_n} &gt; \frac{1}{2}\]</span></p><p>所以余项不趋于 0，所以发散。</p></li><li><blockquote><p>给定级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n (a_n &gt; 0)\)</span>，且存在极限 <span class="math inline">\(\lim\limits_{n \to \infty} \frac{\ln (1 / a_n)}{\ln n} = q\)</span>。证明：当 <span class="math inline">\(q &gt; 1\)</span> 时，该级数收敛；当 <span class="math inline">\(q &lt; 1\)</span> 时，该级数发散。</p></blockquote><p>当 <span class="math inline">\(q &gt; 1\)</span> 时，取 <span class="math inline">\(q &gt; a &gt; 1\)</span>，当 <span class="math inline">\(n\)</span> 充分大时，恒有 <span class="math inline">\(\ln (\frac{1}{a_n}) &gt; a \ln n\)</span>，即 <span class="math inline">\(a_n &lt; \frac{1}{n^a}\)</span>，所以该级数收敛；当 <span class="math inline">\(q &lt; 1\)</span> 时，取 <span class="math inline">\(q &lt; a &lt; 1\)</span>，同理得到 <span class="math inline">\(a_n &gt; \frac{1}{n^a}\)</span>，所以该级数发散。</p></li><li><blockquote><p>设正项级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n\)</span> 收敛，证明：<span class="math inline">\(\sum\limits_{n = 1}^{\infty} (a_n)^{\frac{n}{n + 1}}\)</span> 也收敛。</p></blockquote><p>设集合 <span class="math inline">\(T = \{n | a^{\frac{n}{n + 1}} &lt; 2a_n\}\)</span>，则级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} (a_n)^{\frac{n}{n + 1}} = \sum\limits_{n \in T} (a_n)^{\frac{n}{n + 1}} + \sum\limits_{n \notin T} (a_n)^{\frac{n}{n + 1}}\)</span>，当 <span class="math inline">\(n \in T\)</span> 时，<span class="math inline">\(\sum\limits_{n \in T} (a_n)^{\frac{n}{n + 1}} &lt; \sum\limits_{n \in T} 2a_n\)</span>，此时收敛；当 <span class="math inline">\(n \notin T\)</span> 时，此时 <span class="math inline">\((a_n)^{\frac{n}{n + 1}} \geq 2a_n \Longrightarrow (a_n)^{\frac{1}{n + 1}} \leq \frac{1}{2} \Longrightarrow (a_n)^{\frac{n}{n + 1}} \leq \frac{1}{2^n}\)</span>，则 <span class="math inline">\(\sum\limits_{n \notin T} (a_n)^{\frac{n}{n + 1}}\)</span> 收敛。综上，<span class="math inline">\(\sum\limits_{n = 1}^{\infty} (a_n)^{\frac{n}{n + 1}}\)</span> 收敛。</p></li><li><blockquote><p>设 <span class="math inline">\(a_n \neq 0\)</span>，<span class="math inline">\(\lim\limits_{n \to \infty} a_n = a \neq 0\)</span>，证明：两个级数 $<em>{n = 1}^{} |a</em>{n + 1} - a_n| $ 与 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \bigl|\frac{1}{a_{n + 1}} - \frac{1}{a_n}\bigr|\)</span> 同敛散性。</p></blockquote><p>由极限的保号性，当 <span class="math inline">\(n\)</span> 充分大以后恒有不等式 <span class="math inline">\(0 &lt; \frac{|a|}{2} &lt; |a_n| &lt; 2|a|\)</span> 成立。于是有不等式</p><p><span class="math display">\[\frac{1}{4a^2} |a_{n + 1} - a_{n}| &lt; \bigg|\frac{a_{n + 1} - a_{n}}{a_{n + 1} a_n}\bigg| &lt; \frac{4}{a^2} |a_{n + 1} - a_{n}|\]</span></p><p>显然同敛散性。</p></li><li><blockquote><p>给定级数，<span class="math inline">\(p &gt; 0\)</span>，证明下列结论</p><p><span class="math display">\[\sum_{n = 2}^{\infty} \ln \biggl(1 + \frac{(-1)^n}{n^p}\biggr)\]</span></p><p>(1). 当 <span class="math inline">\(p &gt; 1\)</span> 时该级数绝对收敛；</p><p>(2). 当 <span class="math inline">\(1 \geq p &gt; \frac{1}{2}\)</span> 时该级数条件收敛；</p><p>(3). 当 <span class="math inline">\(\frac{1}{2} \geq p &gt; 0\)</span> 时该级数发散。</p></blockquote><p>(1).</p><p><span class="math display">\[\lim_{n \to \infty} \frac{\big|\ln \big(1 + \frac{(-1)^n}{n^p}\big)\big|}{\frac{1}{n^p}} = 1\]</span></p><p>(2).</p><p><span class="math display">\[\ln \biggl(1 + \frac{(-1)^n}{n^p}\biggr) = \frac{(-1)^n}{n^p} - \frac{1}{2n^{2p}} + o(\frac{1}{n^{2p}})\]</span></p><p>所以条件收敛。</p><p>(3). 设 <span class="math inline">\(m\)</span> 是使得 <span class="math inline">\(mp &gt; 1\)</span> 的正整数。</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \ln \biggl(1 + \frac{(-1)^n}{n^p}\biggr) = \sum_{n = 1}^{\infty} \bigg(\frac{(-1)^n}{n^p} - \frac{1}{2n^{2p}} + \frac{(-1)^{3n}}{3n^{3p}} - \cdots + (-1)^{m - 1} \frac{(-1)^{mn}}{mn^{mp}} + o\bigg(\frac{1}{n^{mp}}\bigg)\bigg)\]</span></p><p>等式右端为有限个收敛数列和有限个发散数列的和，结果仍是发散数列，所以该级数发散。</p></li><li><blockquote><p>讨论级数的敛散性</p><p><span class="math display">\[\sum_{n = 2}^{\infty} \biggl(\frac{1}{\sqrt{n}} - \sqrt{\ln \bigl(1 + \frac{1}{n}\bigr)}\biggr)\]</span></p></blockquote><p>对 <span class="math inline">\(\ln \big(1 + \frac{1}{n} \big)\)</span> 泰勒展开前 2 项</p><p><span class="math display">\[\frac{1}{\sqrt{n}} - \sqrt{\ln \bigl(1 + \frac{1}{n}\bigr)} = \frac{\frac{1}{n} - \ln \big(1 + \frac{1}{n} \big)}{\frac{1}{\sqrt{n}} + \sqrt{\ln \bigl(1 + \frac{1}{n}\bigr)}} = \frac{\frac{1}{2} \frac{1}{n\sqrt{n}} + o\big(\frac{1}{n\sqrt{n}}\big)}{1 + \sqrt{n \ln \bigl(1 + \frac{1}{n}\bigr)}}\]</span></p><p>当 <span class="math inline">\(n \to \infty\)</span> 级数一般项与 <span class="math inline">\(\frac{1}{n\sqrt{n}}\)</span> 同阶，所以绝对收敛。</p></li><li><blockquote><p>确定 <span class="math inline">\(\alpha\)</span> 的取值范围，使得级数收敛。</p><p><span class="math display">\[1 - \frac{1}{2^{\alpha}} + \frac{1}{3} - \frac{1}{4^\alpha} + \frac{1}{5} - \frac{1}{6^\alpha} + \cdots\]</span></p></blockquote><p>当 <span class="math inline">\(\alpha &gt; 1\)</span> 时，显然该级数发散；当 <span class="math inline">\(\alpha = 1\)</span> 时，显然该级数收敛。当 <span class="math inline">\(\alpha &lt; 1\)</span> 时，此时 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{1}{(2n)^{\alpha}}\)</span> 发散，原级数变为 <span class="math inline">\(1 + \sum\limits_{n = 2}^{\infty} \big(\frac{1}{(2n)^{\alpha}} - \frac{1}{2n - 1}\big)\)</span>，此级数发散。</p></li><li><blockquote><p>确定级数的敛散性；若收敛，请判断是条件收敛还是绝对收敛。</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \sin (\pi \sqrt{n^2 + 1})\]</span></p></blockquote><p><span class="math display">\[\sin (\pi \sqrt{n^2 + 1}) = (-1)^{n} \sin (\pi \sqrt{n^2 + 1} - n) = (-1)^n \sin \bigg(\frac{\pi}{\sqrt{n^2 + 1} + n}\bigg)\]</span></p><p>由莱布尼茨判别法知条件收敛，显然不睡绝对收敛。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x = 0\)</span> 附近有连续的二阶导数，且 <span class="math inline">\(\lim\limits_{x \to 0} \frac{f(x)}{x} = 0\)</span>。证明级数绝对收敛。</p><p><span class="math display">\[\sum_{n = 1}^{\infty} f\biggl(\frac{1}{n}\biggr)\]</span></p></blockquote><p>不妨令 <span class="math inline">\(f(x) &gt; 0\)</span>，此时只需要证明该级数收敛。因为 <span class="math inline">\(\lim\limits_{x \to 0} \frac{f(x)}{x} = 0\)</span>，所以 <span class="math inline">\(f(x) = o(x)\)</span>，将 <span class="math inline">\(f(x)\)</span> 泰勒展开前两项得 <span class="math inline">\(f(x) = f(0) + f&#39;(0) x + \frac{f&#39;&#39;(\xi) }{2} x^2\)</span>，其中 <span class="math inline">\(x &gt; \xi &gt; 0\)</span>，所以 <span class="math inline">\(n \to \infty\)</span> 时 <span class="math inline">\(f(\frac{1}{n})\)</span> 是 <span class="math inline">\(\frac{1}{n^2}\)</span> 的高阶无穷小，所以该级数绝对收敛。</p></li><li><blockquote><p><span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x = 0\)</span> 附近有连续的导数，<span class="math inline">\(\lim\limits_{x \to 0} \frac{f(x)}{x} = a &gt; 0\)</span>。证明级数条件收敛。</p><p><span class="math display">\[\sum_{n = 1}^{\infty} (-1)^{n} f\biggl(\frac{1}{n}\biggr)\]</span></p></blockquote><p>取实数 <span class="math inline">\(k\)</span>，使得 <span class="math inline">\(0 &lt; k &lt; a\)</span>，由导函数的连续性得，在 <span class="math inline">\(x = 0\)</span> 的某个领域内，恒有 <span class="math inline">\(f&#39;(x) &gt; k &gt; 0\)</span>，这表明在领域内 <span class="math inline">\(f(x)\)</span> 严格单调递增，也就是 <span class="math inline">\(f(\frac{1}{n})\)</span> 严格单调递减，又由于</p><p><span class="math display">\[\lim_{n \to \infty} \frac{f(\frac{1}{n})}{\frac{1}{n}} = a\]</span></p><p>由莱布尼茨判别法知该级数条件收敛。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是在 <span class="math inline">\((-\infty, +\infty)\)</span> 上的可微函数，且 <span class="math inline">\(|f&#39;(x)| &lt; mf(x)\)</span>，其中，<span class="math inline">\(0 &lt; m &lt; 1\)</span>，任取实数 <span class="math inline">\(a_0\)</span>，定义 <span class="math inline">\(a_n = \ln f(a_{n - 1})(n = 1, 2, \cdots)\)</span>。证明 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} (a_n - a_{n - 1})\)</span> 绝对收敛。</p></blockquote><p><span class="math display">\[\begin{aligned}a_n - a_{n - 1} &amp;= \ln f(a_{n - 1}) - \ln f(a_{n - 2}) = \frac{f&#39;(\xi)}{f(\xi)} (a_{n - 1} - a_{n - 2})\\|a_n - a_{n - 1}| &amp;&lt; m |a_{n - 1} - a_{n - 2}| &lt; m^2 |a_{n - 2} - a_{n - 3}| &lt; \cdots &lt; m^{n - 1} |a_1 - a_0|\end{aligned}\]</span></p><p>所以绝对收敛。</p></li><li><blockquote><p>讨论级数的敛散性</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \sin \pi (3 + \sqrt{5})^{n}\]</span></p></blockquote><p>令 <span class="math inline">\(M_n = (3 + \sqrt{5})^n + (3 - \sqrt{5})^n\)</span>，分析二项式展开的形式，可知 <span class="math inline">\(M_n\)</span> 为偶数，则原级数</p><p><span class="math display">\[= \sum_{n = 1}^{\infty} \sin \pi (M_n - (3 - \sqrt{5})^{n}) = -\sum_{n = 1}^{\infty} \sin \pi(3 - \sqrt{5})^{n}\]</span></p><p>因为 <span class="math inline">\(1 &gt; 3 - \sqrt{5} &gt; 0\)</span>，所以该级数收敛。</p></li><li><blockquote><p>用间接法将下列函数展开为麦克劳林级数，并指出其收敛域。</p><p>(1).</p><p><span class="math display">\[\ln (4 - 3x - x^2)\]</span></p><p>(2).</p><p><span class="math display">\[\frac{1}{2x^2 - 3x + 1}\]</span></p><p>(3).</p><p><span class="math display">\[\frac{1}{(1 - x^2)^3}\]</span></p><p>(4).</p><p><span class="math display">\[\arctan 2x\]</span></p></blockquote><p>(1).</p><p><span class="math display">\[\begin{aligned}\ln (4 - 3x + x^2) &amp;= \ln 4 + \ln (1 + \frac{x}{4}) + \ln (1 - x)\\&amp;= \ln 4 + \sum_{n = 1}^{\infty} \frac{(-1)^{n - 1}}{n} \bigg(\frac{x}{4}\bigg)^{n} + \sum_{n = 1}^{\infty} \frac{-1}{n} x^{n}\\&amp;= \ln 4 + \sum_{n = 1}^{\infty} \frac{x^n}{n} \bigg[(-1)^{n - 1} \frac{1}{4^n} - 1\bigg], x \in [-1, 1)\end{aligned}\]</span></p><p>(2).</p><p><span class="math display">\[\begin{aligned}\frac{1}{2x^2 - 3x + 1} &amp;= -\frac{2}{2x - 1} + \frac{1}{x - 1}\\&amp;= \frac{2}{1 - 2x} - \frac{1}{1 - x} = 2\sum_{n = 0}^{\infty} (2x)^n - \sum_{n = 0}^{\infty} x^n\\&amp;= \sum_{n = 0}^{\infty} x^n\big(2^{n + 1} - 1\big), x \in \bigg(-\frac{1}{2}, \frac{1}{2}\bigg)\end{aligned}\]</span></p><p>(3).</p><p><span class="math display">\[\begin{aligned}\frac{1}{(1 - x^2)^3} &amp;= \frac{1}{2} \sum_{n = 0}^{\infty} (n + 2)(n + 1) x^{2n}, x \in (-1, 1)\end{aligned}\]</span></p><p>(4).</p><p><span class="math display">\[\begin{aligned}\arctan x &amp;= \sum_{n = 0}^{\infty} \frac{(-1)^{n} 2^{2n + 1}}{2n + 1} x^{2n + 1}, x \in \bigg[-\frac{1}{2}, \frac{1}{2}\bigg]\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(a &gt; 1\)</span>，数列 <span class="math inline">\(\{p_n\}\)</span> 满足 <span class="math inline">\(p_{n + 1} \geq p_{n} &gt; 0\)</span>。证明级数收敛。</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \frac{p_n - p_{n - 1}}{p_n p_{n - 1}^{\alpha}}\]</span></p></blockquote></li><li><blockquote><p>设级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n^2\)</span> 收敛，证明：级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{a_n}{n}\)</span> 也收敛。</p></blockquote><p>由柯西不等式得</p><p><span class="math display">\[\sum_{n = 1}^{\infty}\bigg|\frac{a_n}{n}\bigg| \leq \sqrt{\sum_{n = 1}^{\infty} a_n^2} \sqrt{\sum_{n = 1}^{\infty} \frac{1}{n^2}}\]</span></p><p>故绝对收敛</p></li><li><blockquote><p>将 <span class="math inline">\(\sin x\)</span> 展开为 <span class="math inline">\((x - \frac{\pi}{4})\)</span> 的幂级数。</p></blockquote><p><span class="math display">\[\begin{aligned}\sin x &amp;= \sin \bigg(x - \frac{\pi}{4} + \frac{\pi}{4}\bigg) = \frac{\sqrt{2}}{2} \sin \bigg(x - \frac{\pi}{4} \bigg) + \frac{\sqrt{2}}{2} \cos \bigg(x - \frac{\pi}{4} \bigg)\\&amp;= \frac{\sqrt{2}}{2} \sum_{n = 1}^{\infty} \bigg((-1)^{n - 1}\frac{(x - \frac{\pi}{4})^{2n - 1}}{(2n - 1)!} + (-1)^{n - 1}\frac{(x - \frac{\pi}{4})^{2n - 2}}{(2n - 2)!} \bigg), x \in (-\infty, +\infty)\end{aligned}\]</span></p></li><li><blockquote><p>设级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} a_n\)</span>，<span class="math inline">\(\sum\limits_{n = 1}^{\infty} b_n\)</span> 都收敛，并有 <span class="math inline">\(a_n \leq c_n \leq b_n\)</span>，证明：级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} c_n\)</span> 收敛。</p></blockquote><p><span class="math inline">\(b_n - a_n &gt; c_n - a_n &gt; 0\)</span>，<span class="math inline">\(\sum\limits_{n = 1}^{\infty} c_n = \sum\limits_{n = 1}^{\infty} (c_n - a_n) + \sum\limits_{n = 1}^{\infty} a_n\)</span>，所以收敛。</p></li><li><blockquote><p>设级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} u_n^2\)</span>，<span class="math inline">\(\sum\limits_{n = 1}^{\infty} v_n^2\)</span> 都收敛，证明级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} (u_n + v_n)^{p}\)</span> 也收敛，其中整数 <span class="math inline">\(p \geq 2\)</span></p></blockquote><p>当 <span class="math inline">\(p = 2\)</span> 时，<span class="math inline">\((u_n + v_n)^2 \leq 2(u_n^2 + v_n^2)\)</span>，显然此时收敛。<span class="math inline">\(\lim\limits_{n \to \infty} (u_n + v_n)^2 = 0\)</span>，由极限的保号知，存在 <span class="math inline">\(N\)</span>，当 <span class="math inline">\(n &gt; N\)</span> 时，<span class="math inline">\(|u_n + v_n| &lt; 1\)</span>，<span class="math inline">\(|u_n + v_n|^p \leq |u_n + v_n|^2\)</span>，故绝对收敛。</p></li><li><blockquote><p>设 <span class="math inline">\(x_1 = 2\)</span>，<span class="math inline">\(x_{n + 1} = 2 + \frac{1}{x_n}\)</span>，并求 <span class="math inline">\(\lim\limits_{n \to \infty} x_n\)</span>。</p></blockquote><p>考虑级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} (x_n - x_{n - 1})\)</span> 的敛散性</p><p><span class="math display">\[|x_n - x_{n - 1}| = \bigg|\frac{x_{n - 1} - x_{n - 2}}{x_n x_{n - 1}}\bigg| \leq \frac{1}{4} |x_{n - 1} - x_{n - 2}| \leq \cdots \leq \frac{1}{4^{n - 2}} \frac{1}{2}\]</span></p><p>故级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} (x_n - x_{n - 1})\)</span> 绝对收敛，于是 <span class="math inline">\(\lim\limits_{n \to \infty} x_n\)</span> 存在，的结果为 <span class="math inline">\(1 + \sqrt{2}\)</span></p></li><li><blockquote><p>设 <span class="math inline">\(x_n = \cos x_{n - 1}(n = 1, 2, \cdots)\)</span>，证明 <span class="math inline">\(\lim\limits_{n \to \infty} x_n\)</span> 存在。</p></blockquote><p>考虑级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} (x_n - x_{n - 1})\)</span> 的敛散性</p><p><span class="math display">\[|x_n - x_{n - 1}| = |\cos x_{n - 1} - \cos x_{n - 2}| \leq |\sin \xi_{n - 1}| |x_{n - 1} - x_{n - 2}|\\\leq |\sin \xi_{n - 1}||\sin \xi_{n - 2}||x_{n - 2} - x_{n - 3}|\\\leq \cdots \leq\\|\sin \xi_{n - 1}||\sin \xi_{n - 2}|\cdots|\sin \xi_{1}||x_{1} - x_{0}|\]</span></p><p>因为 <span class="math inline">\(|\sin \xi_i| \in [0, 1]\)</span>，所以 <span class="math inline">\(|\sin \xi_{n - 1}||\sin \xi_{n - 2}|\cdots|\sin \xi_{1}||x_{1} - x_{0}|\)</span> 收敛，故级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} (x_n - x_{n - 1})\)</span> 绝对收敛，所以 <span class="math inline">\(\lim\limits_{n \to \infty} x_n\)</span> 存在。</p></li><li><blockquote><p>设 <span class="math inline">\(x_n = 1 + \frac{1}{\sqrt{2}} + \frac{1}{\sqrt{3}} + \cdots + \frac{1}{\sqrt{n}} - 2\sqrt{n}(n = 1, ,2 \cdots)\)</span>，证明 <span class="math inline">\(\lim\limits_{n \to \infty} x_n\)</span> 存在。</p></blockquote><p>考虑级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} (x_n - x_{n - 1})\)</span> 的敛散性</p><p><span class="math display">\[(x_n - x_{n - 1}) = \frac{1}{\sqrt{n}} - 2 \sqrt{n} + 2 \sqrt{n - 1} = \frac{1}{\sqrt{n}} - \frac{2}{\sqrt{n} + \sqrt{n - 1}} = \frac{\sqrt{n - 1} - \sqrt{n}}{\sqrt{n} (\sqrt{n} + \sqrt{n - 1})}\\= \frac{-1}{\sqrt{n}(\sqrt{n} + \sqrt{n - 1})^2}\]</span></p><p>所以 <span class="math inline">\(n \to \infty\)</span> 时，一般项与 <span class="math inline">\(\frac{1}{\sqrt{n^3}}\)</span> 同阶，故绝对收敛，所以 <span class="math inline">\(\lim\limits_{n \to \infty} x_n\)</span> 存在。</p></li><li><blockquote><p>设 <span class="math inline">\(\{F_n\}\)</span> 是斐波那契数列，证明 <span class="math inline">\(\lim\limits_{n \to \infty} (F_n / F_{n - 1})\)</span> 存在并求其值。</p></blockquote></li><li><blockquote><p>证明下列级数是收敛的：</p><p>(1).</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \int_0^{\frac{1}{n}} \frac{\sqrt{x}}{1 + x^4} \text{d} x\]</span></p><p>(2).</p><p><span class="math display">\[\sum_{n = 1}^{\infty} \int_0^{\frac{\pi}{n}} \frac{\sin x}{1 + x} \text{d} x\]</span></p></blockquote></li><li><blockquote><p>令</p><p><span class="math display">\[a_k = \int_{-\infty}^{+\infty} x^{2k} \text{e}^{-kx^2} \text{d} x (k = 1, 2, \cdots)\]</span></p><p>讨论 <span class="math inline">\(\sum\limits_{k = 1}^{\infty} a_k\)</span> 的敛散性。</p></blockquote></li><li><blockquote><p>设 <span class="math inline">\(a_n = \int_0^{\frac{\pi}{4}} \tan^n x \text{d} x(n = 1, 2, \cdots)\)</span>。</p><p>(1). 求级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{1}{n} (a_n + a_{n + 2})\)</span> 的和；</p><p>(2). 证明级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} (-1)^n a_n\)</span> 条件收敛；</p><p>(3). 证明：对于任何 <span class="math inline">\(\lambda &gt; 0\)</span>，级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} \frac{a_n}{n^{\lambda}}\)</span> 都收敛。</p></blockquote></li><li><blockquote><p>将函数 <span class="math inline">\(\frac{\text{e}^{x}}{1 - x}\)</span> 展开为麦克劳林级数</p></blockquote><p><span class="math display">\[\begin{aligned}\frac{\text{e}^{x}}{1 - x} &amp;= \bigg(\sum_{n = 0}^{\infty} \frac{1}{n!} x^n\bigg) \bigg(\sum_{n = 0}^{\infty} x^n\bigg) = \sum_{n = 0}^{\infty} \bigg(1 + \frac{1}{1!} + \frac{1}{2!} + \cdots + \frac{1}{n!}\bigg) x^n, x \in (-1, 1)\end{aligned}\]</span></p></li><li><blockquote><p>将下列函数展开为麦克劳林级数</p><p>(1).</p><p><span class="math display">\[f(x) = \frac{1}{(1 + x)(1 + x^2)(1 + x^4)(1 + x^8)}\]</span></p><p>(2).</p><p><span class="math display">\[f(x) = \frac{1}{4} \ln \frac{1 + x}{1 - x} + \frac{1}{2} \arctan x - x\]</span></p><p>(3).</p><p><span class="math display">\[f(x) = \frac{\ln (1 + x)}{1 + x}\]</span></p></blockquote><p>(1).</p><p><span class="math display">\[\frac{1 - x}{1 - x^{16}} = (1 - x) \sum_{n = 0}^{\infty} x^{16n}\]</span></p><p>(2).</p><p><span class="math display">\[\begin{aligned}\frac{1}{4} (\ln (1 + x) - \ln (1 - x)) + \frac{1}{2} \arctan x - x &amp;= \sum_{n = 0}^{\infty} \frac{x^{2n + 1}}{4(2n + 1)} + \frac{1}{2} \sum_{n = 0}^{\infty} \frac{x^{2n + 1}}{2n + 1} - x\\&amp;= \sum_{n = 0}^{\infty} \frac{3 x^{2n + 1}}{4(2n + 1)} - x\end{aligned}\]</span></p><p>(3).</p><p><span class="math display">\[\begin{aligned}\frac{\ln (1 + x)}{1 + x} &amp;= \sum_{n = 1}^{\infty} \bigg(\frac{(-1)^{n - 1}}{n} x^{n} \bigg) \sum_{n = 0}^{\infty} \bigg((-1)^{n} x^{n}\bigg)\\&amp;=\end{aligned}\]</span></p></li><li><blockquote><p>用直接法将 <span class="math inline">\(\frac{\arctan x}{\sqrt{1 - x^2}}\)</span> 展开为麦克劳林级数。</p></blockquote><p>令 <span class="math inline">\(f(x) = \frac{\arctan x}{\sqrt{1 - x^2}}\)</span>，则</p><p><span class="math display">\[f&#39;(x) = \frac{\frac{1}{\sqrt{1 - x^2}} \sqrt{1 - x^2} + \arctan x \frac{x}{\sqrt{1 - x^2}}}{1 - x^2} = \frac{1}{1 - x^2} + \frac{x}{1 - x^2} f(x)\]</span></p><p>得到微分方程，对微分方程两端求 <span class="math inline">\(n\)</span> 阶导数。</p><p><span class="math display">\[\begin{aligned}(1 - x^2) f&#39;(x) - x f(x) &amp;= 1\\\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(\{F_n\}\)</span> 是斐波那契数列，求它的母函数，即幂级数 <span class="math inline">\(\sum\limits_{n = 0}^{\infty} F_n x^n\)</span> 的和函数 <span class="math inline">\(S(x)\)</span>。</p></blockquote><p><span class="math display">\[\sum_{n = 1}^{\infty} F_{n + 1} x^{n + 1} = x \sum_{n = 1}^{\infty} F_n x^n + x^2 \sum_{n = 1}^{\infty} F_{n - 1} x^{n - 1} = x[S(x) - 1] + x^2 S(x)\]</span></p><p>所以，</p><p><span class="math display">\[S(x) = 1 + x + \sum_{n = 1}^{\infty} F_{n + 1} x^{n + 1} = 1 + x x[S(x) - 1] + x^2 S(x)\]</span></p><p>解得 <span class="math inline">\(S(x) = \frac{1}{1 - x - x^2}, |x| &lt; G\)</span>，其中 <span class="math inline">\(G = \frac{\sqrt{5} - 1}{2}\)</span></p></li><li><blockquote><p>已知 <span class="math inline">\(u_n(x)\)</span> 满足 <span class="math inline">\(u_n&#39;(x) = u_n(x) + x^{n - 1}\text{e}^{x}\)</span>，其中 <span class="math inline">\(n\)</span> 为正整数，<span class="math inline">\(u_n(1) = \frac{\text{e}}{n}\)</span>。求函数项级数 <span class="math inline">\(\sum\limits_{n = 1}^{\infty} u_n(x)\)</span> 之和。</p></blockquote><p>容易得到 <span class="math inline">\(u_n(x) = \frac{x^n}{n} \text{e}^{x}\)</span>，所以</p><p><span class="math display">\[\text{e}^x \sum_{n = 1}^{\infty} \frac{x^n}{n} = -\text{e}^x \ln (1 - x), -1 \leq x &lt; 1\]</span></p></li><li><blockquote><p>利用傅里叶级数求下列级数的和</p><p>(1).</p><p><span class="math display">\[\delta_1 = \sum_{n = 1}^{\infty} \frac{1}{n^2}\]</span></p><p>(2).</p><p><span class="math display">\[\delta_2 = \sum_{n = 1}^{\infty} \frac{1}{(2n - 1)^2}\]</span></p><p>(3).</p><p><span class="math display">\[\delta_3 = \sum_{n = 1}^{\infty} \frac{(-1)^{n - 1}}{2n - 1}\]</span></p><p>(4).</p><p><span class="math display">\[\delta_4 = \sum_{n = 1}^{\infty} \frac{1}{n^4}\]</span></p></blockquote><p>(1). 设 <span class="math inline">\(f(x)\)</span> 以 <span class="math inline">\(2\pi\)</span> 为周期，它在 <span class="math inline">\([-\pi, \pi]\)</span> 上的表达式为 <span class="math inline">\(f(x) = x^2\)</span>。有收敛定理，在区间内，其傅里叶级数为 <span class="math inline">\(\frac{\pi^2}{3} + \sum\limits_{n = 1}^{\infty}(-1)^n \frac{4}{n^2} \cos nx = x^2\)</span>。取 <span class="math inline">\(x = \pi\)</span>，由 <span class="math inline">\(\cos n\pi = (-1)^n\)</span> 及 <span class="math inline">\(f(\pi) = \pi^2\)</span> 可推出。</p></li><li><blockquote><p>设 <span class="math inline">\(y = y(x) = \frac{1}{4} (1 + x - \sqrt{1 - 6x + x^2})\)</span>，其幂级数展开式为 <span class="math inline">\(y = a_1 x + a_2 x^2 + a_3 x^3 + \cdots\)</span>。证明：该幂级数展开式的系数都是正整数。</p></blockquote></li><li><blockquote><p>幂级数 <span class="math inline">\(f(x) = \sum\limits_{n = 0}^{\infty} a_n x^n\)</span> 的每一个系数 <span class="math inline">\(a_n\)</span> 只取值 0 或 1.证明：<span class="math inline">\(f(x)\)</span> 是有理函数的充要条件为 <span class="math inline">\(f(\frac{1}{2})\)</span> 是有理数。</p></blockquote></li><li><blockquote><p>证明：</p><p><span class="math display">\[\int_0^1 x^{-x} \text{d} x = \sum_{n = 1}^{\infty} \bigg(\frac{1}{n}\bigg)^n\]</span></p></blockquote></li><li><blockquote><p>设 <span class="math inline">\(f(x) = \sum_{n = 1}^{\infty} \frac{1}{n^2} x^n, x \in [0, 1]\)</span></p><p>(1). 证明：<span class="math inline">\(f(x) + f(1 - x) + \ln x \cdot \ln (1 - x) \equiv \frac{\pi^2}{6}\)</span></p><p>(2). 计算：<span class="math inline">\(\int_0^1 \frac{1}{x - 2} \ln x \text{d} x\)</span></p></blockquote></li><li><blockquote><p>设 <span class="math inline">\(S_{mn} = \sum\limits_{i = 1}^{m} \sum\limits_{j = 1}^{n} \frac{(-1)^{i + j}}{i + j}\)</span>，求 <span class="math inline">\(\lim\limits_{m, n \to \infty} S_{mn}\)</span>。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多元函数积分学</title>
    <link href="/2025/08/22/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/"/>
    <url>/2025/08/22/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>包括<strong>重积分</strong>、<strong>曲线积分与曲面积分</strong>和<strong>多元函数积分学的应用</strong>。</p><span id="more"></span><h2 id="二重积分和三重积分的存在性">二重积分和三重积分的存在性</h2><ol type="1"><li><p>如果 <span class="math inline">\(f(x, y)\)</span> 在平面有界闭区域 <span class="math inline">\(D\)</span> 上连续，则二重积分 <span class="math inline">\(\iint\limits_{D} f(x, y) \text{d} \delta\)</span> 存在。</p></li><li><p>如果 <span class="math inline">\(f(x, y, z)\)</span> 在空间有界闭区域 <span class="math inline">\(\Omega\)</span> 上连续，则三重积分 <span class="math inline">\(\iiint\limits_{D} f(x, y, z) \text{d} v\)</span> 存在。</p></li></ol><h2 id="二重积分的计算">二重积分的计算</h2><ol type="1"><li><p>直角坐标系下，可以分别对 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span> 求积分。</p></li><li><p>极坐标系下，有 <span class="math inline">\(\iint\limits_{D} f(x, y) \text{d}x \text{d}y = \iint\limits_{D&#39;} f(r \cos \theta, r \sin \theta) r \text{d}r \text{d} \theta\)</span></p><blockquote><p>一般而言，若变换 <span class="math inline">\(T : x = x(u, v)\)</span>，<span class="math inline">\(y = y(u, v)\)</span>，将 <span class="math inline">\(uOv\)</span> 平面上的区域 <span class="math inline">\(D_{uv}\)</span> 一一对应地映射成 <span class="math inline">\(xOy\)</span> 平面上的区域 <span class="math inline">\(D_{xy}\)</span>，函数 <span class="math inline">\(x = x(u, v)\)</span>，<span class="math inline">\(y = y(u, v)\)</span> 在 <span class="math inline">\(D_{uv}\)</span> 上有连续的偏导数。变换 <span class="math inline">\(T\)</span> 的雅可比行列式定义为 <span class="math display">\[J(u, v) =\begin{vmatrix}x_u &amp; x_v \\y_u &amp; y_v\end{vmatrix}\]</span> 也可以记为： <span class="math display">\[\frac{\partial (x, y)}{\partial (u, v)}\]</span> 如果被积函数 <span class="math inline">\(f(x, y)\)</span> 在区域 <span class="math inline">\(D_{xy}\)</span> 上连续，且 <span class="math inline">\(J(u, v) \neq 0\)</span>，则有被积公式： <span class="math display">\[\iint\limits_{D_{xy}} f(x, y) \text{d}x \text{d}y = \iint\limits_{D_{uv}} f[x(u, v), y(u, v)] |J(u, v)| \text{d}u \text{d}v\]</span></p></blockquote></li></ol><h2 id="含有参数的积分">含有参数的积分</h2><p>设 <span class="math inline">\(f(x, y)\)</span> 在矩形区域 <span class="math inline">\([a, b] \times [c, d]\)</span> 上可积，则积分 <span class="math inline">\(I(x) = \int_{c}^{d} f(x, y) \text{d}y\)</span> 称为含有参数 <span class="math inline">\(x\)</span> 的积分。</p><ol type="1"><li><p>如果 <span class="math inline">\(f(x, y)\)</span> 在区域 <span class="math inline">\([a, b] \times [c, d]\)</span> 上连续，则 <span class="math inline">\(I(x)\)</span> 在 <span class="math inline">\([a, b]\)</span> 上连续。</p></li><li><p>如果 <span class="math inline">\(f(x, y)\)</span> 及 <span class="math inline">\(f_x(x, y)\)</span> 在区域 <span class="math inline">\([a, b] \times [c, d]\)</span> 上连续，则 <span class="math inline">\(I(x)\)</span> 在 <span class="math inline">\([a, b]\)</span> 上可导，且 <span class="math display">\[\frac{\text{d}}{\text{d}x} I(x) = \int_{c}^{d} f_x(x, y) \text{d} y\]</span></p></li></ol><h2 id="三重积分变量代换">三重积分变量代换</h2><ol type="1"><li><p>空间点 <span class="math inline">\(P(x, y, z)\)</span> 的柱坐标为 <span class="math inline">\(P(r, \theta, z)\)</span>，变换为 <span class="math inline">\(x = r \cos \theta\)</span>，<span class="math inline">\(y = r \sin \theta\)</span>，<span class="math inline">\(z = z\)</span>，此时，三重积分可以表示为： <span class="math display">\[\iiint\limits_{\Omega} f(x, y, z) \text{d} x \text{d} y \text{d} z = \iiint\limits_{\Omega&#39;} f(r \cos \theta, r \sin \theta, z) r \text{d} z \text{d} r \text{d} \theta\]</span></p></li><li><p>空间点 <span class="math inline">\(P(x, y, z)\)</span> 的球坐标为 <span class="math inline">\(P(r, \varphi, \theta)\)</span>，变换为 <span class="math inline">\(x = r \sin \varphi \cos \theta\)</span>，<span class="math inline">\(y = r \sin \varphi \sin \theta\)</span>，<span class="math inline">\(z = r \cos \varphi\)</span>，此时，三重积分可以表示为： <span class="math display">\[\iiint\limits_{\Omega} f(x, y, z) \text{d} x \text{d} y \text{d} z = \iiint\limits_{\Omega&#39;} f(r \sin \varphi \cos \theta, r \sin \varphi \sin \theta, r \cos \varphi) r^2 \sin \varphi \text{d} r \text{d} \varphi \text{d} \theta\]</span></p><blockquote><p>其中 <span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\theta\)</span> 分别是与 <span class="math inline">\(z\)</span>正轴，<span class="math inline">\(x\)</span>正轴的夹角</p></blockquote></li><li><p>三重积分的一般变量代换，类似二重积分。</p></li></ol><h2 id="曲面面积和质心公式">曲面面积和质心公式</h2><ol type="1"><li><p>设曲面 <span class="math inline">\(\Sigma : z = f(x, y)\)</span> 在 <span class="math inline">\(xOy\)</span> 做表面上的无重叠投影为 <span class="math inline">\(D_{xy}\)</span>，<span class="math inline">\(f(x, y)\)</span> 在 <span class="math inline">\(D_{xy}\)</span> 上有连续的偏导数，则曲面面积为 <span class="math display">\[S = \iint\limits_{D_{xy}} \sqrt{1 + \biggl(\frac{\partial z}{\partial x} \biggr)^2 + \biggl( \frac{\partial z}{\partial y} \biggr)^2} \text{d}x \text{d}y\]</span></p></li><li><p>空间区域的质心是 <span class="math inline">\((\bar{x}, \bar{y}, \bar{z})\)</span>，则 <span class="math inline">\(\bar{x} = \frac{\iiint\limits_{\Omega} x \text{d}v}{|\Omega|}\)</span>，其中 <span class="math inline">\(|\Omega|\)</span> 指的是体积。</p></li></ol><h2 id="曲线积分与曲面积分">曲线积分与曲面积分</h2><h3 id="对弧长的曲线积分">对弧长的曲线积分</h3><blockquote><p>灵活利用<strong>曲线的对称性</strong>和被积函数的<strong>奇偶性</strong></p></blockquote><p>设 <span class="math inline">\(C\)</span> 是平面光滑曲线，<span class="math inline">\(f(x, y)\)</span> 在 <span class="math inline">\(C\)</span> 上连续，则曲线积分 <span class="math inline">\(\int_{C} f(x, y) \text{d}s\)</span> 存在： <span class="math display">\[\int_{C} f(x, y) \text{d}s = \int_{\alpha}^{\beta} f[x(t), y(t)] \sqrt{x&#39;^2(t) + y&#39;^2(t)} \text{d}t\]</span></p><p>其中曲线 <span class="math inline">\(C\)</span> 表示为参数形式：<span class="math inline">\(l : x = x(t), y = y(t)\)</span>，<span class="math inline">\(\alpha \leq t \leq \beta\)</span>。</p><blockquote><p>空间同理。</p></blockquote><h3 id="对坐标的曲线积分">对坐标的曲线积分</h3><blockquote><p>与对弧长的曲线积分相比，对坐标的曲线积分<strong>不再</strong>具有单调性、积分中值公式、对称奇偶性。</p></blockquote><p>设 <span class="math inline">\(C\)</span> 为平面上一条有向光滑曲线，<span class="math inline">\(\mathbf{F} = \mathbf{F}(x, y) = (P(x, y), Q(x, y))\)</span>，为定义在 <span class="math inline">\(C\)</span> 上的向量场，其中 <span class="math inline">\(P(x, y)\)</span>，<span class="math inline">\(Q(x, y)\)</span> 在 <span class="math inline">\(C\)</span> 上连续，则对坐标的曲线积分为： <span class="math display">\[\int_{C} P(x, y) \text{d}x + Q(x, y) \text{d}y = \int_{C} \mathbf{F} \cdot \text{d} \mathbf{r} = \int_{C} \mathbf{F} \cdot (\cos \alpha, \sin \alpha) \text{d}s\]</span></p><p>若 <span class="math inline">\(C\)</span> 由参数方程 <span class="math inline">\(x = x(t), y = y(t)(\alpha \leq t \leq \beta)\)</span> 给出，起点终点分别对应区间端点，则： <span class="math display">\[\int_{C} P(x, y) \text{d}x + Q(x, y) \text{d}y = \int_{\alpha}^{\beta} \{P[x(t), y(t)]x&#39;(t) + Q[x(t), y(t)]y&#39;(t)\} \text{d}t\]</span></p><blockquote><p>空间同理</p></blockquote><h3 id="格林公式">格林公式</h3><p>设 <span class="math inline">\(D\)</span> 是以光滑闭曲线 <span class="math inline">\(C\)</span> 为边界的平面区域，函数 <span class="math inline">\(P(x, y), Q(x, y)\)</span> 在 <span class="math inline">\(D\)</span> 及 <span class="math inline">\(C\)</span> 上有连续偏导数，则有格林公式： <span class="math display">\[\iint\limits_{D} (\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y}) \text{d}x \text{d}y = \oint_{C} P \text{d}x + Q \text{d}y\]</span></p><p>其中 <span class="math inline">\(C\)</span> 是 <span class="math inline">\(D\)</span> 的取正向的边界曲线。</p><h3 id="对面积的曲面积分">对面积的曲面积分</h3><p>设光滑曲面 <span class="math inline">\(\Sigma\)</span> 在 <span class="math inline">\(xOy\)</span> 平面上的无重叠投影为 <span class="math inline">\(D\)</span>，则其方程可表示为 <span class="math inline">\(\Sigma : z = z(x, y)\)</span>，<span class="math inline">\((x, y) \in D\)</span>。其中偏导数 <span class="math inline">\(z_x\)</span>，<span class="math inline">\(z_y\)</span> 在 <span class="math inline">\(D\)</span> 上连续，则有： <span class="math display">\[\iint\limits_{\Sigma} f(x, y, z) \text{d}S = \iint\limits_{D} f[x, y, z(x, y)] \sqrt{1 + z_x^2 + z_y^2} \text{d}x \text{d}y\]</span></p><blockquote><p>其他坐标面同理</p></blockquote><h3 id="对坐标的曲面积分">对坐标的曲面积分</h3><p>设 <span class="math inline">\(\Sigma\)</span> 是有向光滑曲面，<span class="math inline">\(P(x, y, z)\)</span>，<span class="math inline">\(Q(x, y, z)\)</span>，<span class="math inline">\(R(x, y, z)\)</span> 在 <span class="math inline">\(\Sigma\)</span> 上连续。</p><h3 id="高斯公式">高斯公式</h3><p>设三维空间中闭区域 <span class="math inline">\(\Omega\)</span> 是由分片光滑的闭曲面 <span class="math inline">\(\Sigma\)</span> 围成，函数 <span class="math inline">\(P(x, y, z)\)</span>，<span class="math inline">\(Q(x, y, z)\)</span> 和 <span class="math inline">\(R(x, y, z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 上偏导数连续，则有高斯公式： <span class="math display">\[\iiint\limits_{\Omega} \left(\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z}\right) \text{d}v = \iint\limits_{\Sigma} P\text{d}y \text{d}z + Q\text{d}z \text{d}x + R\text{d}x \text{d}y\]</span></p><p>成立，其中 <span class="math inline">\(\Sigma\)</span> 为 <span class="math inline">\(\Omega\)</span> 整个边界曲面的外侧。</p><h3 id="斯托克斯公式">斯托克斯公式</h3><p>设光滑曲面 <span class="math inline">\(\Sigma\)</span> 的光滑边界曲线 <span class="math inline">\(C\)</span>，函数 <span class="math inline">\(P(x, y, z)\)</span>，<span class="math inline">\(Q(x, y, z)\)</span> 和 <span class="math inline">\(R(x, y, z)\)</span> 在 <span class="math inline">\(\Sigma\)</span>，<span class="math inline">\(C\)</span> 上具有连续的偏导数，则有斯托克斯公式： <span class="math display">\[\oint_{C} P\text{d}x + Q\text{d}y + R\text{d}z = \iint\limits_{\Sigma}(\frac{\partial R}{\partial y} - \frac{\partial Q}{\partial z})\text{d}y \text{d}z + (\frac{\partial P}{\partial z} - \frac{\partial R}{\partial x})\text{d}z \text{d}x + (\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y})\text{d}x \text{d}y\]</span></p><p>成立。其中 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(\Sigma\)</span> 的方向符合右手法则。</p><h2 id="例题">例题</h2><ol type="1"><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在闭区间 <span class="math inline">\([0, 1]\)</span> 上连续，且 <span class="math inline">\(\int_0^1 f(x) \text{d}x = m\)</span>，计算： <span class="math display">\[I = \int_0^1 \text{d}x \int_x^1 \text{d}y \int_x^y f(x) f(y) f(z) \text{d}z\]</span></p></blockquote><p>设 <span class="math inline">\(F(u) = \int_0^u f(t) \text{d}t\)</span>，则： <span class="math display">\[\begin{align*}I &amp;= \int_0^1 \text{d}x \int_x^1 \text{d}y \int_x^y f(x) f(y) \text{d} F(z)\\&amp;= \int_0^1 \text{d}x \int_x^1 \text{d}y f(x) f(y) (F(y) - F(x))\\&amp;= \int_0^1 \text{d}x \int_x^1 f(x)(F(y) - F(x)) \text{d} F(y)\\&amp;= \int_0^1 \text{d} F(x) [\frac{F(1)^2}{2} - F(x)F(1) - \frac{F(x)^2}{2} + F(x)^2]\\&amp;= \frac{m^3}{6}\end{align*}\]</span></p></li><li><blockquote><p>计算 <span class="math display">\[I = \iiint\limits_{\Omega} (x^2 + y^2 + z^2) \text{d}v\]</span> 其中，<span class="math inline">\(\Omega: x^2 + y^2 \leq z \leq \sqrt{2 - x^2 - y^2}\)</span></p></blockquote><p>构建球坐标系，参数方程为：<span class="math inline">\(x = r \sin \varphi \cos \theta\)</span>，<span class="math inline">\(y = r \sin \varphi \sin \theta\)</span>，<span class="math inline">\(z = r \cos \varphi\)</span>，<span class="math inline">\(0 \leq \theta \leq 2\pi\)</span>，<span class="math inline">\(0 \leq \varphi \leq \frac{\pi}{2}\)</span>，以 <span class="math inline">\(\varphi = \frac{\pi}{4}\)</span> 为界限，将原积分分为上下积分，同时通过 <span class="math inline">\(z\)</span> 的范围得出两个区域对应 <span class="math inline">\(r\)</span> 的范围。</p><p><span class="math display">\[\begin{align*}I &amp;= \iiint\limits_{\Omega^1} + \iiint\limits_{\Omega^2}\\&amp;= \int_{0}^{2\pi} \text{d} \theta \int_{0}^{\frac{\pi}{4}} \sin \varphi \text{d} \varphi \int_{0}^{\sqrt{2}} r^4 \text{d} r + \int_{0}^{2\pi} \text{d} \theta \int_{\frac{\pi}{4}}^{\frac{\pi}{2}} \sin \varphi \text{d} \varphi \int_{0}^{\frac{\cos \varphi}{\sin^2 \varphi}} r^4 \text{d} r\\&amp;= \frac{\pi}{60}(96\sqrt{2} - 89)\end{align*}\]</span></p></li><li><blockquote><p>设区域 <span class="math inline">\(\Omega: \frac{x^2}{a^2} + \frac{y^2}{b^2} + \frac{z^2}{c^2} \leq 1\)</span>。计算下列积分： <span class="math display">\[I = \iiint\limits_{\Omega}(x^2 + y^2 + z^2) \text{d}v\]</span></p></blockquote><p><span class="math display">\[\begin{align*}I &amp;= \iiint\limits_{\Omega} x^2 \text{d}v + \iiint\limits_{\Omega} y^2 \text{d}v + \iiint\limits_{\Omega} z^2 \text{d}v\\&amp;= \frac{4\pi abc}{15}(a^2 + b^2 + c^2)\end{align*}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(L\)</span> 是圆 <span class="math inline">\(x^2 + y^2 = a^2\)</span> 的正向，求 <span class="math display">\[I = \oint_{L} \frac{-y \text{d}x + x \text{d}y}{Ax^2 + 2Bxy + Cy^2} (A &gt; 0, AC - B^2 &gt; 0)\]</span></p></blockquote><p>经计算，有<span class="math inline">\(\frac{\partial Q}{\partial x} = \frac{\partial P}{\partial y}\)</span>。故考虑做 <span class="math inline">\(L&#39;\)</span> 是椭圆 <span class="math inline">\(Ax^2 + 2Bxy + Cy^2 = r^2\)</span> 的正向，则：</p><p><span class="math display">\[I = \oint_{L + L&#39;_{-}} + \oint_{L&#39;} = \oint_{L&#39;} = \lim\limits_{r \to 0}\frac{1}{r^2} \oint_{L&#39;} -y \text{d}x + x \text{d}y = \lim\limits_{r \to 0}\frac{1}{r^2} \iint\limits_{S} 2 \text{d} \delta\]</span></p><p>即：</p><p><span class="math display">\[I = \lim\limits_{r \to 0} \frac{1}{r^2} 2 \frac{1}{r^2} \frac{1}{\sqrt{AC - B^2}} \pi = \frac{2\pi}{\sqrt{AC - B^2}}\]</span></p></li><li><blockquote><p>设函数 <span class="math inline">\(u(x, y)\)</span>，<span class="math inline">\(v(x, y)\)</span> 在闭区域 <span class="math inline">\(D: x^2 + y^2 \leq 1\)</span> 上有一阶连续偏导数，且在 <span class="math inline">\(D\)</span> 的边界上 <span class="math inline">\(u(x, y) = 1\)</span>，<span class="math inline">\(v(x, y) = y\)</span>。向量函数 <span class="math inline">\(\mathbb{f}(x, y) = (v(x, y), u(x, y))\)</span>，<span class="math inline">\(\mathbb{g}(x, y) = (u_x - u_y, v_x - v_y)\)</span>，求 <span class="math inline">\(\iint\limits_{D} \mathbb{f} \cdot \mathbb{g} \text{d} \delta\)</span></p></blockquote><p>根据题目条件和格林公式，原积分可以变为：</p><p><span class="math display">\[\iint\limits_{D} \mathbb{f} \cdot \mathbb{g} \text{d} \delta = \iint\limits_{D} [v(x, y)u_x + u(x, y)v_x - (u(x, y)v_y + v(x, y)u_y)] \text{d} \delta = \oint_{x^2 + y^2 = 1} uv \text{d}x + uv \text{d} y = \int_{0}^{2\pi} [-\sin^2 t + \cos t \sin t] \text{d} t = - \pi\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(L\)</span> 是不经过 <span class="math inline">\((2, 0)\)</span>，<span class="math inline">\((-2, 0)\)</span> 的正向光滑闭曲线，试就 <span class="math inline">\(L\)</span> 的不同情形计算曲线积分： <span class="math display">\[I = \oint_{L} \biggl ( \frac{y}{(2 - x)^2 + y^2} + \frac{y}{(2 + x)^2 + y^2} \biggl ) \text{d}x + \biggl ( \frac{2 - x}{(2 - x)^2 + y^2} - \frac{2 + x}{(2 + x)^2 + y^2}\biggl ) \text{d}y\]</span></p></blockquote><p>(1). 当曲线不包含两点时，有格林公式得：</p><p><span class="math display">\[I = \iint\limits_{D} 0 \text{d} \delta = 0\]</span></p><p>(2). 当曲线只包含两点中的一点 <span class="math inline">\((2, 0)\)</span>，考虑 <span class="math inline">\(C_{+}\)</span> 是圆 <span class="math inline">\((2 - x)^2 + y^2 = r^2\)</span> 的正向，则原积分变为：</p><p><span class="math display">\[I = \oint_{C_{+}} \biggl ( \frac{y}{r^2} + \frac{y}{(2 + x)^2 + y^2}\biggl ) \text{d} x + \biggl ( \frac{2 - x}{r^2} - \frac{2 + x}{(2 + x)^2 + y^2} \biggl ) \text{d}y\]</span></p><p>由格林公式得到：</p><p><span class="math display">\[\begin{align}I &amp;= \iint\limits_{D_{C}} \biggl [ -\frac{1}{r^2} - \frac{(2 + x)^2 + y^2 - 2(x + 2)^2}{(2 + x)^2 + y^2} - \frac{1}{r^2} - \frac{(2 + x)^2 + y^2 - 2y^2}{(2 + x)^2 + y^2} \biggl ] \text{d} \delta\\&amp;= \iint\limits_{D_{C}}\biggl [ -2\frac{1}{r^2} \biggl ] \text{d} \delta\\&amp;= -2\pi\end{align}\]</span></p><p>同理可得，只包含点 <span class="math inline">\((-2, 0)\)</span> 时，<span class="math inline">\(I = -2\pi\)</span>。</p><p>(3). 当同时包含两点时，由 (1) (2) 得此时 <span class="math inline">\(I = -4\pi\)</span></p></li><li><blockquote><p>证明下列积分与路径无关，并计算给出的积分 <span class="math display">\[\begin{align}I &amp;= \int_{(1, 2, 3)}^{(6, 1, 1)} yz \text{d}x + xz \text{d}y + xy \text{d}z\\I &amp;= \int_{(1, 0, -1)}^{(1, 2, 0)} (x^2 - 2yz) \text{d}x + (y^2 - 2xz) \text{d}y + (z^2 - 2xy) \text{d}z\end{align}\]</span></p></blockquote><p>(1). 显然在空间中，恒有</p><p><span class="math display">\[\frac{\partial yz}{\partial y} = \frac{\partial xz}{\partial x}, \frac{\partial yz}{\partial z} = \frac{\partial xy}{\partial x}, \frac{\partial xz}{\partial z} = \frac{\partial xy}{\partial y}\]</span></p><p>所以曲线积分与在空间中与路线无关，设原函数为 <span class="math inline">\(U(x, y, z)\)</span>，则</p><p><span class="math display">\[U(x, y, z) = xyz + C\]</span></p><p>则原积分为 <span class="math inline">\(U(6, 1, 1) - U(1, 2, 3) = 0\)</span></p><p>(2). 显然在空间中，恒有</p><p><span class="math display">\[\frac{\partial x^2 - 2yz}{\partial y} = \frac{\partial y^2 - 2xz}{\partial x}, \frac{\partial x^2 - 2yz}{\partial z} = \frac{\partial z^2 - 2xy}{\partial x}, \frac{\partial y^2 - 2xz}{\partial z} = \frac{\partial z^2 - 2xy}{\partial y}\]</span></p><p>所以曲线积分与在空间中与路线无关，设原函数为 <span class="math inline">\(U(x, y, z)\)</span>，则</p><p><span class="math display">\[U(x, y, z) = \frac{1}{3}(x^3 + y^3 + z^3) - 2xyz + C\]</span></p><p>则原积分为 <span class="math inline">\(U(1, 2, 0) - U(1, 0, -1) = 3\)</span></p></li><li><blockquote><p>设函数 <span class="math inline">\(\varphi(x)\)</span> 具有连续的导数，在围绕原点的任意正向光滑的简单闭曲线 <span class="math inline">\(C\)</span> 上，曲线积分</p><p><span class="math display">\[\oint_{C} \frac{2xy \text{d}x + \varphi(x) \text{d}y}{x^4 + y^2}\]</span> 的值为常数 <span class="math inline">\(K\)</span></p><ol type="1"><li>设 <span class="math inline">\(L\)</span> 是正向闭曲线 <span class="math inline">\((x - 2)^2 + y^2 = 1\)</span>。证明：</li></ol><p><span class="math display">\[\oint_{C} \frac{2xy \text{d}x + \varphi(x) \text{d}y}{x^4 + y^2} = 0\]</span></p><ol start="2" type="1"><li><p>求函数 <span class="math inline">\(\varphi(x)\)</span></p></li><li><p>设 <span class="math inline">\(C\)</span> 是围绕原点的简单光滑正向闭曲线，求</p></li></ol><p><span class="math display">\[\oint_{C} \frac{2xy \text{d}x + \varphi(x) \text{d}y}{x^4 + y^2}\]</span></p></blockquote><p>(1). 设正向光滑曲线 <span class="math inline">\(L: l_1 + l_2\)</span> 不包含原点且 <span class="math inline">\(l_1\)</span>，<span class="math inline">\(l_2\)</span> 都以 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 为端点。做同样以 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 为端点的包含原点光滑正向曲线 <span class="math inline">\(l_3\)</span>，则</p><p><span class="math display">\[\oint_{L} = \oint_{l_1 + l_3} - \oint_{l_{2-} + l_3} = K - K = 0\]</span></p><p>所以，原积分结果为 <span class="math inline">\(0\)</span></p><p>(2). 当不包含原点时，曲线积分与路径无关，令 <span class="math inline">\(y = 0\)</span>，即；</p><p><span class="math display">\[\varphi&#39;(x)(x^4) - \varphi(x)(4x^3) = 2x^5\]</span></p><p>解得：<span class="math inline">\(\varphi(x) = cx^4 - x^2\)</span></p><p>(3). 作曲线 <span class="math inline">\(C_{+}\)</span> 是 <span class="math inline">\(x^4 + y^2 = 1\)</span> 的正向，则由格林公式得：</p><p><span class="math display">\[\oint_{C} = \oint_{C_{+}} = \iint_{D_{C_{+}}} (4cx^3 -4x ) \text{d} \delta = 0\]</span></p></li><li><blockquote><p>若给定曲线积分与路径无关，并且 <span class="math inline">\(\int_{(0, 0)}^{(t, t^2)} f(x, y) \text{d}x + x \cos y \text{d}y = t^2\)</span>，其中 <span class="math inline">\(f(x, y)\)</span> 有连续的偏导数，求 <span class="math inline">\(f(x, y)\)</span>。</p></blockquote><p><span class="math display">\[\frac{\partial f(x, y)}{\partial y} = \frac{\partial x \cos y}{\partial x} = \cos y\]</span></p><p>设 <span class="math inline">\(f(x, y) = \sin y + F(x)\)</span>，则原积分变为：</p><p><span class="math display">\[\int_{(0, 0)}^{(t, t^2)} (\sin y + F(x)) \text{d}x + x \cos y \text{d}y = t^2 = \int_{(0, 0)}^{(t, t^2)} F(x) \text{d}x + d(x \sin y)\]</span></p><p>所以，</p><p><span class="math display">\[\int_{0}^{t} F(x) \text{d}x = t^2 - t\sin t^2 \Rightarrow F(x) = 2x - \sin x^2 - 2x^2 \cos x^2\]</span></p><p>综上，<span class="math inline">\(f(x, y) = \sin y + 2x - \sin x^2 - 2x^2 \cos x^2\)</span></p></li><li><blockquote><p>设函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((-\infty, +\infty)\)</span> 内具有连续导数，求积分</p><p><span class="math display">\[\int_{C} \frac{1 + y^2 f(xy)}{y} \text{d} x + \frac{x}{y^2}(y^2f(xy) - 1) \text{d}y\]</span></p><p>其中 <span class="math inline">\(C\)</span> 是从点 <span class="math inline">\(A(3, \frac{2}{3})\)</span> 到点 <span class="math inline">\(B(1, 2)\)</span> 的直线段。</p></blockquote><p><span class="math display">\[\begin{align*}\frac{\partial P}{\partial y} &amp;= \frac{(2yf(xy) + xy^2f&#39;(xy))y - (1 + y^2f(xy))}{y^2} = f(xy) - \frac{1}{y^2} + xyf&#39;(xy)\\\frac{\partial Q}{\partial x} &amp;= \frac{1}{y^2}(y^2f(xy) - 1) + \frac{x}{y^2}(y^3f&#39;(xy)) = f(xy) - \frac{1}{y^2} + xy f&#39;(xy)\end{align*}\]</span></p><p>说明两偏导数相等，故积分结果与路径无关，沿折线 <span class="math inline">\((3, \frac{2}{3}) \to (1, \frac{2}{3}) \to (1, 2)\)</span> 求积分，则原式为</p><p><span class="math display">\[\int_{C} = \int_{(3, \frac{2}{3})}^{(1, \frac{2}{3})} + \int_{(1, \frac{2}{3})}^{(1, 2)} = \int_{3}^{1} \frac{3}{2}[1 + \frac{4}{9}f(\frac{2}{3}x)] \text{d} x + \int_{\frac{2}{3}}^{2} \frac{1}{y^2}[y^2f(y) - 1] \text{d} y = -3 - 1 = -3\]</span></p></li><li><blockquote><p>设曲面 <span class="math inline">\(\Sigma: x^2 + y^2 + z^2 = 1\)</span>，计算下列对面积的曲面积分：</p><p>(1). <span class="math display">\[\iint\limits_{\Sigma} \frac{xy + yz + xz}{\sqrt{x^2 + y^2 + z^2}} \text{d} S\]</span></p><p>(2). <span class="math display">\[\iint\limits_{\Sigma} (x^2 + y^2 + x + y) \text{d}S\]</span></p></blockquote><p>(1). 由对称性易得结果为 <span class="math inline">\(0\)</span></p><p>(2). 先由对称性得原积分等价于 <span class="math display">\[\iint\limits_{\Sigma} x^2 + y^2 \text{d}S\]</span></p><p>再由轮换对称性，得 <span class="math display">\[\iint\limits_{\Sigma} (x^2 + y^2) \text{d}S = \frac{2}{3} S = \frac{8}{3} \pi\]</span></p></li><li><blockquote><p>计算 <span class="math inline">\(I = \iint\limits_{\Sigma} \frac{\text{d} S}{r^2}\)</span>，<span class="math inline">\(\Sigma\)</span> 是柱面 <span class="math inline">\(x^2 + y^2 = R^2\)</span> 介于平面 <span class="math inline">\(z = 0\)</span> 和 <span class="math inline">\(z = H(&gt; 0)\)</span> 的部分，<span class="math inline">\(r\)</span> 为 <span class="math inline">\(\Sigma\)</span> 上的点到原点的距离。</p></blockquote><p>原积分 <span class="math display">\[\iint\limits_{\Sigma} \frac{1}{R^2 + z^2} \text{d}S\]</span></p><p>取面积微元 <span class="math inline">\(\text{d} S = R \text{d}\theta \text{d}z\)</span>，则原积分变为 <span class="math display">\[\int_{0}^{2\pi} \text{d} \theta \int_{0}^{H} \frac{R}{R^2 + z^2} \text{d}z = 2\pi \arctan \frac{H}{R}\]</span></p></li><li><blockquote><p>计算 <span class="math inline">\(I = \iint\limits_{\Sigma} (xy + yz + xz) \text{d}S\)</span>，其中 <span class="math inline">\(\Sigma\)</span> 是圆锥面 <span class="math inline">\(z = \sqrt{x^2 + y^2}\)</span> 被圆柱面 <span class="math inline">\(x^2 + y^2 = 2ax(a &gt; 0)\)</span> 所截部分。</p></blockquote><p>显然曲面关于关于 <span class="math inline">\(y\)</span> 轴对称，则原式变为： <span class="math display">\[\iint\limits_{\Sigma} xz \text{d}S\]</span></p><p>曲面 <span class="math inline">\(\Sigma\)</span> 在 <span class="math inline">\(xOy\)</span> 平面上的无重叠投影为 <span class="math inline">\(D: x^2 + y^2 = 2ax\)</span>，则有： <span class="math display">\[\iint\limits_{\Sigma} = \iint\limits_{D} x\sqrt{x^2 + y^2} \sqrt{2} \text{d}x \text{d}y = 2\sqrt{2} \int_{0}^{\frac{\pi}{2}} \cos \theta\text{d} \theta \int_{0}^{2a \cos \theta} r^3 \text{d} r = \frac{64 a^4 \sqrt{2}}{15}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(S\)</span> 为椭球面 <span class="math inline">\(\frac{x^2}{2} + \frac{y^2}{2} + z^2 = 1\)</span> 的上半部分 <span class="math inline">\((z &gt; 0)\)</span>，点 <span class="math inline">\(P(x, y ,z) \in S\)</span>，<span class="math inline">\(\Pi\)</span> 为 <span class="math inline">\(S\)</span> 在 <span class="math inline">\(P\)</span> 点处的切平面，<span class="math inline">\(\rho(x, y, z)\)</span> 为原点到平面 <span class="math inline">\(\Pi\)</span> 的距离，求 <span class="math inline">\(I = \iint\limits_{S} z^3 \rho(x, y, z) \text{d}S\)</span>。</p></blockquote><p>点 <span class="math inline">\((X, Y, Z)\)</span> 处的切平面方程为 <span class="math inline">\(\Pi: X(x - X) + Y(y - Y) +2Z(z - Z) = 0 \Rightarrow xX + yY + 2zZ = 2\)</span>，所以原点到切平面的距离为： <span class="math display">\[\rho(x, y, z) = \frac{2}{\sqrt{x^2 + y^2 + 4z^2}}\]</span></p><p><span class="math display">\[\begin{align*}\frac{\partial z}{\partial x} &amp;= \frac{-x}{2\sqrt{1 - \frac{x^2}{2} - \frac{y^2}{2}}}\\\frac{\partial z}{\partial y} &amp;= \frac{-y}{2\sqrt{1 - \frac{x^2}{2} - \frac{y^2}{2}}}\end{align*}\]</span></p><p>曲面 <span class="math inline">\(S\)</span> 在 <span class="math inline">\(xOy\)</span> 平面上的无重叠投影为 <span class="math inline">\(D: x^2 + y^2 \leq 2\)</span>。故，原式为 <span class="math display">\[\begin{align*}I &amp;= \iint\limits_{S} z^3 \cdot \frac{2}{\sqrt{x^2 + y^2 + 4z^2}} \text{d}S = \iint_{D} \sqrt{\frac{1 - \frac{x^2}{4} - \frac{y^2}{4}}{1 - \frac{x^2}{2} - \frac{y^2}{2}}} \cdot \sqrt{\frac{(1 - \frac{x^2}{2} - \frac{y^2}{2})^3}{1 - \frac{x^2}{4} - \frac{y^2}{4}}} \text{d}x \text{d}y\\&amp;= \iint\limits_{D} (1 - \frac{x^2}{2} - \frac{y^2}{2}) \text{d}x \text{d}y = \int_{0}^{2\pi} \text{d} \theta \int_{0}^{\sqrt{2}} (1 - \frac{\rho^2}{2}) \rho \text{d} \rho = \pi\end{align*}\]</span></p></li><li><blockquote><p>设函数 <span class="math inline">\(f(x)\)</span> 连续，<span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>，<span class="math inline">\(c\)</span> 为常数，<span class="math inline">\(\Sigma\)</span> 是单位球面 <span class="math inline">\(x^2 + y^2 + z^2 = 1\)</span>。记第一型曲面积分 <span class="math inline">\(I = \iint\limits_{\Sigma} f(ax + by + cz) \text{d}S\)</span>。求证：<span class="math inline">\(I = 2\pi \int_{-1}^{1} f(\sqrt{a^2 + b^2 + c^2}u) \text{d}u\)</span></p></blockquote><p>做旋转变换，其中 <span class="math inline">\(u = \frac{a}{\sqrt{a^2 + b^2 + c^2}} x + \frac{b}{\sqrt{a^2 + b^2 + c^2}} y + \frac{c}{\sqrt{a^2 + b^2 + c^2}} z\)</span>，<span class="math inline">\(v\)</span>，<span class="math inline">\(w\)</span>。<span class="math inline">\(\Sigma&#39;: u^2 + v^2 + w^2 = 1\)</span>，则原积分为： <span class="math display">\[I = \iint\limits_{\Sigma&#39;} f(\sqrt{a^2 + b^2 + c^2}u) \text{d} S = 2\iint\limits_{\Sigma&#39;^{\uparrow}} f(\sqrt{a^2 + b^2 + c^2}u) \text{d} S\]</span></p><p><span class="math inline">\(\Sigma&#39;^{\uparrow}\)</span> 在 <span class="math inline">\(uOv\)</span> 平面上的无重叠投影 <span class="math inline">\(D: u^2 + v^2 \leq 1\)</span>，原积分为： <span class="math display">\[I = 2\iint\limits_{D} f(\sqrt{a^2 + b^2 + c^2}u) \frac{1}{\sqrt{1 - u^2 - v^2}}\text{d}u \text{d}v = 2\pi \int_{-1}^{1} f(\sqrt{a^2 + b^2 + c^2}u) \text{d}u\]</span></p></li><li><blockquote><p>求 <span class="math inline">\(F(t) = \iint\limits_{x + y + z = t} f(x, y, z) \text{d}S\)</span>，其中， <span class="math display">\[f(x, y, z) =\begin{cases}1 - x^2 - y^2 - z^2, &amp;x^2 + y^2 + z^2 \leq 1\\0, &amp;x^2 + y^2 + z^2 &gt; 1\end{cases}\]</span></p></blockquote><p>显然要求 <span class="math inline">\(|t| &lt; \sqrt{3}\)</span>，此时记球体与平面相交圆域为 <span class="math inline">\(\Sigma_{t}\)</span>，旋转当前坐标系到 <span class="math inline">\(uvw\)</span> 坐标系，且保证 <span class="math inline">\(w = \frac{t}{\sqrt{3}}\)</span>，由旋转特性，知： <span class="math display">\[F(t) = \iint\limits_{\Sigma_{t}} (1 - u^2 - v^2 - \frac{t^2}{3}) \text{d}S = \int_{0}^{2\pi} \text{d} \theta \int_{0}^{1 - \sqrt{\frac{t^2}{3}}} (1 - r^2 - \frac{t^2}{3})r \text{d} r = \frac{\pi}{18}(3 - t^2)^2\]</span></p></li><li><blockquote><p>求 <span class="math inline">\(I = \iint\limits_{\Sigma} (\frac{\text{d}y \text{d}z}{x} + \frac{\text{d}z \text{d}x}{y} + \frac{\text{d}x \text{d}y}{z})\)</span>，其中，<span class="math inline">\(\Sigma\)</span> 为椭球面 <span class="math inline">\(\frac{x^2}{a^2} + \frac{y^2}{b^2} + \frac{z^2}{c^2} = 1\)</span> 的外表面。</p></blockquote><p><span class="math inline">\(\Sigma\)</span> 在 <span class="math inline">\(xOy\)</span> 平面的投影有重叠，故将其分为 <span class="math inline">\(\Sigma_{+}: z = c\sqrt{1 - \frac{x^2}{a^2} - \frac{y^2}{b^2}}\)</span> 和 <span class="math inline">\(\Sigma_{-}: z = -c\sqrt{1 - \frac{x^2}{a^2} - \frac{y^2}{b^2}}\)</span> 上下两个对称的部分，则： <span class="math display">\[  \iint\limits_{\Sigma} \frac{\text{d}x \text{d}y}{z} = \iint\limits_{\Sigma_{+}} + \iint\limits_{\Sigma_{-}} = 2\iint\limits_{D} \frac{\text{d}x \text{d}y}{c\sqrt{1 - \frac{x^2}{a^2} - \frac{y^2}{b^2}}} = 4\pi \frac{ab}{c}\]</span></p><p>同理可得，<span class="math inline">\(\iint\limits_{\Sigma} \frac{\text{d}y \text{d}z}{x} = 4\pi \frac{bc}{a}\)</span>，<span class="math inline">\(\iint\limits_{\Sigma} \frac{\text{d}x \text{d}z}{y} = 4\pi \frac{ac}{b}\)</span>，故： <span class="math display">\[I = 4\pi abc(\frac{1}{a^2} + \frac{1}{b^2} + \frac{1}{c^2})\]</span></p></li><li><blockquote><p>计算 <span class="math inline">\(I = \iint\limits_{\Sigma} \frac{x \text{d}y \text{d}z + z^2 \text{d}x \text{d}y}{x^2 + y^2 + z^2}\)</span>，其中 <span class="math inline">\(\Sigma\)</span> 为由曲面 <span class="math inline">\(x^2 + y^2 = R^2\)</span> 及平面 <span class="math inline">\(z = R\)</span>，<span class="math inline">\(z = -R\)</span> 所围成立体的外侧。</p></blockquote><p>设 <span class="math inline">\(\Sigma_1\)</span>，<span class="math inline">\(\Sigma_2\)</span>，<span class="math inline">\(\Sigma_3\)</span>，分别表示 <span class="math inline">\(\Sigma\)</span> 的上、下和侧面部分的曲面。</p><p><span class="math display">\[\iint\limits_{\Sigma_1 + \Sigma_2} = \frac{R^2 \text{d}x \text{d}y}{x^2 + y^2 + R^2} = 0\]</span></p><p>所以， <span class="math display">\[I = \iint\limits_{\Sigma_3} \frac{x \text{d}y \text{d}z}{R^2 + z^2} = 2\iint\limits_{D_{yz}} \frac{\sqrt{R^2 - y^2}}{R^2 + z^2} \text{d}y \text{d}z = \frac{\pi^2 R}{2}\]</span></p></li><li><blockquote><p>计算 <span class="math inline">\(I = \iint\limits_{\Sigma} x \text{d}y \text{d}z + y \text{d}x \text{d}z + z \text{d}x \text{d}y\)</span>，其中 <span class="math inline">\(\Sigma\)</span> 是曲面 <span class="math inline">\(z = 2 - x^2 - y^2\)</span> 被平面 <span class="math inline">\(2x + 2y + z = 0\)</span> 所截的上部，方向向上。</p></blockquote><p>所截平面在 <span class="math inline">\(xOy\)</span> 平面内的无重叠投影 <span class="math inline">\(D\)</span> 为 <span class="math inline">\((x - 1)^2 + (y - 1)^2 \leq 4\)</span>，且由积分坐标变换公式，得到 <span class="math inline">\(\text{d}y \text{d}z = \frac{n_x}{n_{z}} \text{d}x \text{d}y = 2x \text{d}x \text{d}y\)</span>，<span class="math inline">\(\text{d}x \text{d}z = \frac{n_y}{n_{z}} \text{d}x \text{d}y = 2y \text{d}x \text{d}y\)</span>，故原积分为：</p><p><span class="math display">\[\iint\limits_{\Sigma} (2x^2 + 2y^2 + 2 - x^2 - y^2) \text{d}x \text{d}y = \iint\limits_{D} [x^2 + y^2 + 2 ]\text{d}x \text{d}y\]</span></p><p>取坐标变换 <span class="math inline">\(T: u = x - 1, v = y - 1\)</span>，则原积分为：</p><p><span class="math display">\[\iint\limits_{u^2 + v^2 \leq 4} [(u + 1)^2 + (v + 1)^2 + 2] \text{d}u \text{d}v = \int_{0}^{2 \pi} \text{d}\theta \int_{0}^{2} r[r^2 + 2r (\sin \theta + \cos \theta) + 4] \text{d}r = 24 \pi\]</span></p></li><li><blockquote><p>求 <span class="math inline">\(I = \iint\limits_{\Sigma} (x - y + z) \text{d}y \text{d}z + (y - z + x) \text{d}z \text{d}x + (z - x + y) \text{d}x \text{d}y\)</span>，其中 <span class="math inline">\(\Sigma\)</span> 为曲面 <span class="math inline">\(|x - y + z| + |y - z + x| + |z - x + y| = 1\)</span> 的外侧。</p></blockquote><p>由高斯公式得，<span class="math inline">\(I = 3\iiint\limits_{V} \text{d}x \text{d}y \text{d}z\)</span>，做坐标变换 <span class="math inline">\(T: u = x - y + z, v = y - z + x, w = z - x + y\)</span>，则原积分为变为：</p><p><span class="math display">\[I = \iiint\limits_{|u| + |v| + |z| \leq 1} |J(u, v, w)| \text{d}u \text{d}v \text{d}w = \frac{3}{4} \iiint\limits_{|u| + |v| + |z| \leq 1} \text{d}u \text{d}v \text{d}w = 1\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(\Sigma\)</span> 是曲面 <span class="math inline">\(x^2 + y^2 + z^2 = a^2\)</span> 的外侧，<span class="math inline">\(\cos \alpha\)</span>，<span class="math inline">\(\cos \beta\)</span>，<span class="math inline">\(\cos \gamma\)</span> 是其外法线向量的方向余弦，求 <span class="math inline">\(I = \iint\limits_{\Sigma} \frac{x \cos \alpha + y \cos \beta + z \cos \gamma}{(x^2 + y^2 + z^2)^{\frac{3}{2}}} \text{d}S\)</span></p></blockquote><p>由两类曲面积分之间的关系及高斯公式得：</p><p><span class="math display">\[I = \iint\limits_{\Sigma} \frac{x \text{d}y \text{d}z + y \text{d}x \text{d}z + z \text{d}x \text{d}y}{(x^2 + y^2 + z^2)^{\frac{3}{2}}} = \frac{3}{a^3} \iiint\limits_{V} \text{d}v = 4 \pi\]</span></p></li><li><blockquote><p><span class="math inline">\(\iint\limits_{\Sigma} \frac{ax \text{d}y \text{d}z + (z + a)^2 \text{d}x \text{d}y}{(x^2 + y^2 + z^2)^{\frac{1}{2}}}\)</span>，其中 <span class="math inline">\(\Sigma\)</span> 为下半球面 <span class="math inline">\(z = -\sqrt{a^2 - x^2 - y^2}\)</span> 的上侧，<span class="math inline">\(a &gt; 0\)</span>。</p></blockquote><p>做区域 <span class="math inline">\(D: x^2 + y^2 \leq a^2\)</span> 方向向下，与 <span class="math inline">\(\Sigma\)</span> 合并于一个分片光滑的空间 <span class="math inline">\(\Omega\)</span>，则由高斯公式得：</p><p><span class="math display">\[\iint\limits_{\Sigma + D} = -\frac{1}{a}\iiint\limits_{\Omega} (3a + 2z ) \text{d}v = -2\pi a^3 - \frac{2}{a} \iiint\limits_{V} z \text{d}v = \iint\limits_{\Sigma} - \pi a^3  \]</span></p><p>解得：<span class="math inline">\(\iint\limits_{\Sigma} = -\frac{\pi}{2} a^3\)</span></p></li><li><blockquote><p>计算 <span class="math inline">\(I = \iint\limits_{\Sigma} (8y + 1)x \text{d}y \text{d}z + 2(1 - y^2) \text{d}z \text{d}x - 4yz \text{d}x \text{d}y\)</span>，其中 <span class="math inline">\(\Sigma\)</span> 是 <span class="math inline">\(yOz\)</span> 坐标面上的曲线段 <span class="math inline">\(z = \sqrt{y - 1}(1 \leq y \leq 3)\)</span> 绕 <span class="math inline">\(y\)</span> 轴旋转一周所生成的曲面的左侧。</p></blockquote><p>由旋转曲面公式得 <span class="math inline">\(\Sigma: x^2 + z^2 = y - 1(1 \leq y \leq 3)\)</span>，补面 <span class="math inline">\(\Sigma_1: y = 1\)</span> 左侧，<span class="math inline">\(\Sigma_2: y = 3\)</span> 右侧，所得空间 <span class="math inline">\(\Omega\)</span> 由分片光滑的曲面组成，则由高斯公式得：</p><p><span class="math display">\[\iint\limits_{\Sigma + \Sigma_1 + \Sigma_2} = - \iiint\limits_{\Omega}  \text{d}v = -\int_{1}^{3} \text{d}y \iint_{D_{xz}} \text{d} \delta = - \pi \int_{1}^{3} (y - 1) \text{d}y = -2 \pi = I + 32 \pi\]</span></p><p>所以，<span class="math inline">\(I = 34 \pi\)</span></p></li><li><blockquote><p>计算曲线积分 <span class="math inline">\(I = \oint_{C} (z - y) \text{d}x + (x - z) \text{d}y + (x - y) \text{d}z\)</span>，其中，<span class="math inline">\(C: \begin{cases} x^2 + y^2 = 1 \\ x - y + z = 2\end{cases}\)</span>，从 <span class="math inline">\(z\)</span> 正向看去，<span class="math inline">\(C\)</span> 的方向是顺时针的。</p></blockquote><p>由斯托克斯公式得：</p><p><span class="math display">\[\oint_{C} = -2\iint\limits_{x^2 + y^2 \leq 1} \text{d}x \text{d}y = -2 \pi\]</span></p></li><li><blockquote><p>设空间曲线 <span class="math inline">\(C\)</span> 由立方体：<span class="math inline">\(0 \leq x \leq 1\)</span>，<span class="math inline">\(0 \leq y \leq 1\)</span>，<span class="math inline">\(0 \leq z \leq 1\)</span> 的表面与平面 <span class="math inline">\(x + y + z = \frac{3}{2}\)</span> 相截而成，试计算 <span class="math inline">\(|\oint_{C} (z^2 - y^2) \text{d}x + (x^2 - z^2) \text{d}y + (y^2 - x^2) \text{d}z|\)</span>。</p></blockquote><p>由斯托克斯公式得：</p><p><span class="math display">\[|\oint_{C}| = |\iint\limits_{\Sigma} (-2y + 2z)\text{d}y \text{d}z + (-2z + 2x) \text{d}z \text{d}x + (-2x + 2y)\text{d}x \text{d}y| = |\frac{6}{\sqrt{3}}\iint\limits_{S} \text{d}S| = \frac{9}{2}\]</span></p></li><li><blockquote><p>设函数 <span class="math inline">\(f(x)\)</span> 连续可导，<span class="math inline">\(P = Q = R = f((x^2 + y^2)z)\)</span>。有向曲线 <span class="math inline">\(\Sigma_{t}\)</span> 是圆柱体 <span class="math inline">\(x^2 + y^2 \leq t^2\)</span>，<span class="math inline">\(0 \leq z \leq 1\)</span> 表面的外侧。第二型曲面积分。<span class="math inline">\(I_t = \iint\limits_{\Sigma_{t}} P \text{d}y \text{d}z + Q \text{d}z \text{d}x + R \text{d}x \text{d}y\)</span>，求极限 <span class="math inline">\(\lim\limits_{t \to 0^+} \frac{I_t}{t^4}\)</span>。</p></blockquote><p>设 <span class="math inline">\(\Sigma_1\)</span>，<span class="math inline">\(\Sigma_2\)</span>，<span class="math inline">\(\Sigma\)</span>分别是柱体上表面、下表面和侧面部分的外侧，则</p><p><span class="math display">\[I_t = \iint\limits_{\Sigma_1} f((x^2 + y^2)) \text{d}x \text{d}y + \iint\limits_{\Sigma_2} f(0) \text{d}x \text{d}y + 0 = \int_{0}^{2\pi} \text{d}\theta \int_{0}^{t} r f(r^2) \text{d}r - f(0) \pi t^2\]</span></p><p>所以，</p><p><span class="math display">\[\lim\limits_{t \to 0^+} \frac{I_t}{t^4} = \lim\limits_{t \to 0^+} \frac{2 \pi \int_{0}^{t} r f(r^2) \text{d}r - f(0) \pi t^2}{t^4}\]</span></p><p>由于 <span class="math inline">\(f(x)\)</span> 连续，则其可积，其变上限积分可导，应用洛必达法则两次：</p><p><span class="math display">\[\lim\limits_{t \to 0^+} \frac{2\pi t f(t^2) - 2f(0)\pi t}{4t^3} = \lim\limits_{t \to 0^+} \frac{\pi[f(t^2) - f(0)]}{2t^2} = \lim\limits_{t \to 0^+} \frac{2\pi t f&#39;(t^2)}{4t} = \frac{\pi f&#39;(0)}{2}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(\Sigma\)</span> 是一个光滑封闭曲面，方向朝外。给定第二型的曲面积分</p><p><span class="math display">\[I = \iint\limits_{\Sigma} (x^3 - x) \text{d}y \text{d}z + (2y^3 - y) \text{d}z \text{d}x + (3z^3 - z) \text{d}x \text{d}y\]</span></p><p>试确定曲面 <span class="math inline">\(\Sigma\)</span>，使积分 <span class="math inline">\(I\)</span> 值最小，并求该最小值。</p></blockquote><p>由高斯公式得：</p><p><span class="math display">\[I = 3\iiint\limits_{\Omega} (x^2 + 2y^2 + 3z^2 - 1) \text{d}v\]</span></p><p>显然 <span class="math inline">\(\Sigma: x^2 + 2y^2 + 3z^2 - 1 = 0\)</span>，此时被积函数对三重积分无贡献，做变换 <span class="math inline">\(T: u = x, v = \sqrt{2}y, w = \sqrt{3}z\)</span>，则原积分为：</p><p><span class="math display">\[I = 3\iiint\limits_{u^2 + v^2 + w^2 \leq 1} (u^2 + v^2 + w^2 - 1) |J(u, v, w)| \text{d}v = 3\sqrt{\frac{1}{6}} \iiint\limits_{u^2 + v^2 + w^2 \leq 1} (u^2 + v^2 + w^2 - 1) \text{d}v = 3\sqrt{\frac{1}{6}} \int_{0}^{2\pi} \text{d} \theta \int_{0}^{\pi} \sin \varphi \text{d} \varphi \int_{0}^{1} r^2(r^2 - 1) \text{d} r = -4\sqrt{6}\frac{\pi}{15}\]</span></p></li><li><blockquote><p>设一球缺高为 <span class="math inline">\(h\)</span>，所在球的半径为 <span class="math inline">\(R\)</span>。</p><p>(1). 证明该球体缺的体积为 <span class="math inline">\(\frac{\pi}{3}(3R - h)h^2\)</span>，球冠的面积为 <span class="math inline">\(2\pi R h\)</span>。</p><p>(2). 设球体 <span class="math inline">\((x - 1)^2 + (y - 1)^2 + (z - 1)^2 \leq 12\)</span> 被平面 <span class="math inline">\(P: x + y + z = 6\)</span> 所截的小球缺为 <span class="math inline">\(\Omega\)</span>。记球缺上的球冠为 <span class="math inline">\(\Sigma\)</span>，方向指向球外，球第二型曲面积分 <span class="math inline">\(I = \iint\limits_{\Sigma} x \text{d}y \text{d}z + y \text{d}z \text{d}x + z \text{d}x \text{d}y\)</span>。</p></blockquote><p>(1). 体积公式：</p><p><span class="math display">\[V = \int_{0}^{h} \text{d}z \pi(R^2 - (R - h + z)^2) = \pi \int_{0}^{h} (-h^2 - z^2 + 2Rh + 2hz - 2Rz)\text{d}z = \pi h^2(-\frac{1}{3}h + R) = \frac{\pi}{3}(3R - h)h^2\]</span></p><p>(2). 做曲面 <span class="math inline">\(\Sigma&#39;\)</span> 为所截界面方向指向球外，则有高斯公式得</p><p><span class="math display">\[\iint\limits_{\Sigma + \Sigma&#39;} = 3\iiint\limits_{\Omega} \text{d}v = 3\pi(6\sqrt{3} - \sqrt{3}) = 15 \sqrt{3} \pi\]</span></p><p><span class="math display">\[\iint\limits_{\Sigma&#39;} = -\frac{6}{\sqrt{3}} \iint\limits_{\Sigma&#39;} \text{d}S = -18\sqrt{3} \pi\]</span></p><p>所以，<span class="math inline">\(I = 33\sqrt{3}\pi\)</span></p></li><li><blockquote><p>计算</p><p><span class="math display">\[I = \iint\limits_{D} \frac{\text{d} x \text{d} y}{\sqrt{1 - \frac{x^2}{a^2} - \frac{y^2}{b^2}}}, D: \frac{x^2}{a^2} + \frac{y^2}{b^2} \leq 1\]</span></p></blockquote><p>令 <span class="math inline">\(u = \frac{x}{a}\)</span>，<span class="math inline">\(v = \frac{y}{b}\)</span>，则 <span class="math inline">\(u^2 + v^2 \leq 1\)</span>，原积分变为：</p><p><span class="math display">\[\begin{aligned}I &amp;= \iint\limits_{u^2 + v^2 \leq 1} \frac{\text{d}u \text{d}v}{\sqrt{1 - u^2 - v^2}} J(u, v)\\&amp;= ab \int_0^{2\pi} \text{d} \theta \int_0^1 \frac{r}{\sqrt{1 - r^2}} \text{d} r\\&amp;= 2\pi ab\end{aligned}\]</span></p></li><li><blockquote><p>求由抛物线 <span class="math inline">\(y^2 = x\)</span>，<span class="math inline">\(y^2 = 2x\)</span> 及双曲线 <span class="math inline">\(xy = 1\)</span>，<span class="math inline">\(xy = 4\)</span> 所围成的区域 <span class="math inline">\(D\)</span> 的面积 <span class="math inline">\(|D|\)</span>。</p></blockquote><p>令 <span class="math inline">\(u = \frac{y^2}{x}\)</span>，<span class="math inline">\(v = xy\)</span>，则 <span class="math inline">\(y^2 = x \to u = 1\)</span>，<span class="math inline">\(y^2 = 2x \to u = 2\)</span>，<span class="math inline">\(xy = 1 \to v = 1\)</span>，<span class="math inline">\(xy = 4 \to v = 4\)</span>，<span class="math inline">\(J(u, v) = -\frac{1}{u}\)</span>，则面积为：</p><p><span class="math display">\[|D| = \iint\limits_{D} \text{d} x \text{d} y = \iint\limits_{D&#39;} \frac{1}{u} \text{d} u \text{d} v = \ln 2\]</span></p></li><li><blockquote><p>计算由 <span class="math inline">\(y^2 = x\)</span>，<span class="math inline">\(y^2 = 2x\)</span>，<span class="math inline">\(x^2 = y\)</span>，<span class="math inline">\(x^2 = 2y\)</span> 所围比区域 <span class="math inline">\(D\)</span> 的面积 <span class="math inline">\(|D|\)</span>。</p></blockquote><p>作变化 <span class="math inline">\(u = \frac{x^2}{y}\)</span>，<span class="math inline">\(v = \frac{y^2}{x}\)</span>。则：<span class="math inline">\(y^2 = x \to v = 1\)</span>，<span class="math inline">\(y^2 = 2x \to v = 1\)</span>，<span class="math inline">\(x^2 = y \to u = 1\)</span>，<span class="math inline">\(x^2 = y \to u = 1\)</span>，<span class="math inline">\(x^2 = 2y \to u = 2\)</span>。新区域为 <span class="math inline">\(D&#39;\)</span>。</p><p>相应的雅可比行列式为：</p><p><span class="math display">\[J(u, v) = \frac{1}{\frac{\partial (u, v)}{\partial (x, y)}} = \frac{1}{3}\]</span></p><p>则</p><p><span class="math display">\[\iint\limits_{D} \text{d} \sigma = \iint\limits_{D&#39;} \frac{1}{3} \text{d} \sigma = \frac{1}{3}\]</span></p></li><li><blockquote><p>计算</p><p><span class="math display">\[\iint\limits_{D} \frac{(x + y) \ln \biggl(1 + \frac{y}{x}\biggr)}{\sqrt{1 - x - y}} \text{d} x \text{d} y\]</span></p><p>其中区域 <span class="math inline">\(D\)</span> 由直线 <span class="math inline">\(x + y = 1\)</span> 与两坐标轴所围成的三角形区域。</p></blockquote><p>做变换 <span class="math inline">\(u = x + y\)</span>，<span class="math inline">\(v = x\)</span>，则 <span class="math inline">\(x + y = 1 \to u = 1\)</span>，<span class="math inline">\(v = 0\)</span>，<span class="math inline">\(u = v\)</span> 记新区域为 <span class="math inline">\(D&#39;\)</span>。</p><p><span class="math display">\[\begin{aligned}J(u, v) = \frac{1}{\frac{\partial (u, v)}{\partial (x, y)}} &amp;= -1\\\iint\limits_{D&#39;} \frac{u \ln \biggl(\frac{u}{v}\biggr)}{\sqrt{1 - u}} \text{d} u \text{d} v &amp;= \int_0^1 \text{d} u \int_0^u \frac{u\ln u}{\sqrt{1 - u}} \text{d} v - \int_0^1 \text{d} u \int_0^u \frac{u\ln v}{\sqrt{1 - u}} \text{d} v\\\iint\limits_{D&#39;} &amp;= \int_0^1 \frac{u^2 \ln u}{\sqrt{1 - u}} \text{d} u - \int_0^1 \frac{u}{\sqrt{1 - u}} \biggl(u \ln u - u\biggr) \text{d} v\\\iint\limits_{D&#39;} &amp;= \int_0^1 \frac{u^2}{\sqrt{1 - u}} \text{d} u = \frac{16}{15}\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是连续的偶函数，证明：</p><p><span class="math display">\[\iint\limits_{D} f(x - y) \text{d} x \text{d} y = 2 \int_0^{2a} [(2a - u)] f(u) \text{d} u\]</span></p><p>其中，<span class="math inline">\(D: |x| \leq a\)</span>，<span class="math inline">\(|y| \leq a (a &gt; 0)\)</span>。</p></blockquote><p>令 <span class="math inline">\(u = x - y\)</span>，<span class="math inline">\(v = x + y\)</span>，则 <span class="math inline">\(|u| + |v| \leq 2a\)</span>，记新区域为 <span class="math inline">\(D&#39;\)</span>，<span class="math inline">\(|J(u, v)| = \frac{1}{2}\)</span>，所以：</p><p><span class="math display">\[\iint\limits_{D} = \iint\limits_{D&#39;} f(u) \text{d} u \text{d} v = 2 \int_{0}^{2a} \text{d} u \int_{u - 2a}^{2a - u} f(u) \text{d} v = 2 \int_0^{2a} [(2a - u)] f(u) \text{d} u\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(u)\)</span> 连续，<span class="math inline">\(k = \sqrt{a^2 + b^2 + c^2} \neq 0\)</span>。证明：</p><p><span class="math display">\[I = \iiint\limits_{\Omega} f(ax + by + cz) \text{d} x \text{d} y \text{d} z = \pi \int_{-1}^{1} (1 - u^2) f(ku) \text{d} u\]</span></p><p>其中，<span class="math inline">\(\Omega: x^2 + y^2 + z^2 \leq 1\)</span>。</p></blockquote><p>令 <span class="math inline">\(u = \frac{ax + by + cz}{k}\)</span>，对 <span class="math inline">\(Oxyz\)</span> 坐标系作旋转变换，使得新的坐标轴 <span class="math inline">\(Ou\)</span> 与 <span class="math inline">\((a, b, c)\)</span> 同向。旋转变化公式的系数行列式恰是变换的雅可比行列式 <span class="math inline">\(J = 1\)</span>。新区域 <span class="math inline">\(\Omega&#39;: u^2 + v^2 + w^2 \leq 1\)</span>，于是</p><p><span class="math display">\[I = \int_{-1}^{1} f(ku) \text{d} u \iint\limits_{v^2 + w^2 \leq 1 - u^2} \text{d} v \text{d} w = \pi \int_{-1}^{1} (1 - u^2) f(ku) \text{d} u\]</span></p></li><li><blockquote><p>计算</p><p><span class="math display">\[I = \int_0^1 \frac{x^b - x^a}{\ln x} \text{d} x, a &gt; 0, b &gt; 0\]</span></p></blockquote><p><span class="math display">\[I = \int_0^1 \biggl(\frac{x^t}{\ln x} \bigg |_{a}^{b}\biggr) \text{d} x = \int_0^1 \text{d} x \int_a^b x^t \text{d} t = \int_a^b \frac{\text{d} t}{t + 1} = \ln \frac{b + 1}{a + 1}\]</span></p></li><li><blockquote><p>已知在 <span class="math inline">\([0, 1] \times [0, 1]\)</span> 上函数 <span class="math inline">\(k(x, y)\)</span> 连续，在 <span class="math inline">\(0 \leq x \leq 1\)</span> 上函数 <span class="math inline">\(f(x)\)</span>，<span class="math inline">\(g(x)\)</span> 都连续且无零点。假设对于所有满足 <span class="math inline">\(0 \leq x \leq 1\)</span> 的 <span class="math inline">\(x\)</span> 有</p><p><span class="math display">\[\begin{aligned}\int_0^1 f(y) k(x, y) \text{d} y &amp;= g(x)\\\int_0^1 g(y) k(x, y) \text{d} y &amp;= f(x)\end{aligned}\]</span></p><p>证明：对于 <span class="math inline">\(0 \leq x \leq 1\)</span>，有 <span class="math inline">\(f(x) = g(x)\)</span>。</p></blockquote></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\([0, 1]\)</span> 上的连续函数，证明：</p><p><span class="math display">\[\int_0^1 \text{e}^{f(x)} \text{d} x \int_0^1 \text{e}^{-f(x)} \text{d} x \geq 1\]</span></p></blockquote><p><span class="math display">\[\int_0^1 \text{e}^{f(x)} \text{d} x \int_0^1 \text{e}^{-f(x)} \text{d} x = \int_0^1 \text{e}^{f(x)} \text{d} x \int_0^1 \text{e}^{-f(y)} \text{d} y = \iint\limits_{D} \text{e}^{f(x) - f(y)} \text{d} x \text{d} y\\= \iint\limits_{D} \text{e}^{f(y) - f(x)} \text{d} x \text{d} y\]</span></p><p>所以，</p><p><span class="math display">\[\iint\limits_{D} \text{e}^{f(x) - f(y)} \text{d} x \text{d} y = \frac{1}{2} \iint\limits_{D} \biggl(\text{e}^{f(x) - f(y)} + \text{e}^{f(y) - f(x)}\biggr) \text{d} x \text{d} y \geq \iint\limits_{D} \text{d} x \text{d} y = 1\]</span></p></li><li><blockquote><p>在 <span class="math inline">\([0, 1]\)</span> 上 <span class="math inline">\(f(x) &gt; 0\)</span> 且连续、单调减少，证明：</p><p><span class="math display">\[\frac{\int_0^1 x f^2(x) \text{d} x}{\int_0^1 x f(x) \text{d} x} \leq \frac{\int_0^1 f^2(x) \text{d} x}{\int_0^1 f(x) \text{d} x}\]</span></p></blockquote><p><span class="math display">\[\begin{aligned}\biggl(\int_0^1 x f^2(x) \text{d} x\biggr) \biggl(\int_0^1 f(x) \text{d} x\biggr) - \biggl(\int_0^1 x f(x) \text{d} x\biggr) \biggl(\int_0^1 f^2(x) \text{d} x\biggr) &amp;\leq 0\\\biggl(\int_0^1 x f^2(x) \text{d} x\biggr) \biggl(\int_0^1 f(y) \text{d} y\biggr) - \biggl(\int_0^1 x f(x) \text{d} x\biggr) \biggl(\int_0^1 f^2(y) \text{d} y\biggr) &amp;\leq 0\\\iint\limits_{D} \biggl(xf^2(x) f(y) - f^2(y) f(x) x\biggr) \text{d} x \text{d} y &amp;\leq 0\\\iint\limits_{D} x f(x) f(y)\biggl(f(x) - f(y)\biggr) \text{d} x \text{d} y &amp;\leq 0\\\iint\limits_{D} x f(x) f(y)\biggl(f(x) - f(y)\biggr) \text{d} x \text{d} y  = \frac{1}{2} \iint\limits_{D} f(x) f(y)\biggl(f(x) - f(y)\biggr) (x - y)\text{d} x \text{d} y &amp;\leq 0\end{aligned}\]</span></p><p>最后的等式由 <span class="math inline">\(f(x)\)</span> 的单调性得证。</p></li><li><blockquote><p>设区域 <span class="math inline">\(D\)</span> 在 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span> 轴上的投影区间分别为 <span class="math inline">\([a. b]\)</span>，<span class="math inline">\([c, d]\)</span>，<span class="math inline">\(D\)</span> 的面积为 <span class="math inline">\(|D|\)</span>，点 <span class="math inline">\((\alpha, \beta) \in D\)</span>。证明：</p><p>(1).</p><p><span class="math display">\[\biggl|\iint\limits_{D} (x - \alpha) (y - \beta) \text{d} x \text{d} y\biggr| \leq (b - a) (d - c) |D|\]</span></p><p>(2).</p><p><span class="math display">\[\biggl|\iint\limits_{D} (x - \alpha) (y - \beta) \text{d} x \text{d} y\biggr| \leq \frac{1}{4} (b - a)^2 (d - c)^2\]</span></p></blockquote><p>(1).</p><p><span class="math display">\[\biggl|\iint\limits_{D} (x - \alpha) (y - \beta) \text{d} x \text{d} y\biggr| \leq \iint\limits_{D} |(x - \alpha)| |(y - \beta)| \text{d} x \text{d} y \leq \iint\limits_{D} (b - a) (d - c) \text{d} x \text{d} y = (b - a) (d - c) |D|\]</span></p><p>(2). 设区域 <span class="math inline">\(D&#39;: [a, b] \times [c, d]\)</span>，<span class="math inline">\(D \subseteq D&#39;\)</span>。</p><p><span class="math display">\[\biggl|\iint\limits_{D} (x - \alpha) (y - \beta) \text{d} x \text{d} y\biggr| \leq \iint\limits_{D&#39;} |(x - \alpha)| |(y - \beta)| \text{d} x \text{d} y = \int_a^b |x - \alpha| \text{d} x \int_c^d |y - \beta| \text{d} y \leq \frac{1}{4} (b - a)^2 (d - c)^2\]</span></p></li><li><blockquote><p>设区域 <span class="math inline">\(D: [0, 1] \times [0, 1]\)</span>，<span class="math inline">\(I = \iint\limits_{D} f(x, y) \text{d} x \text{d} y\)</span>，其中函数 <span class="math inline">\(f(x, y)\)</span> 在 <span class="math inline">\(D\)</span> 上有连续的二阶偏导数。若对任何 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span> 有 <span class="math inline">\(f(0, y) = f(x, 0) = 0\)</span>，且 <span class="math inline">\(\frac{\partial^2 f}{\partial x \partial y} \leq A\)</span>。证明：<span class="math inline">\(I \leq \frac{A}{4}\)</span>。</p></blockquote><p><span class="math display">\[\begin{aligned}I &amp;= \int_0^1 \text{d} y \int_0^1 f(x, y) \text{d} x = \int_0^1 \text{d} y \int_0^1 -f(x, y) \text{d} (1 - x)\\&amp;= \int_0^1 \text{d} y \int_0^1 (1 - x) f_1&#39;(x, y) \text{d} x\\&amp;= \int_0^1 (1 - x) \text{d} x \int_0^1 f_1&#39;(x, y) \text{d} y\\&amp;= \int_0^1 (1 - x) \text{d} x \int_0^1 (1 - y) f_{12}&#39;(x, y) \text{d} y \leq \frac{A}{4}\end{aligned}\]</span></p></li><li><blockquote><p>求由双叶玫瑰线 <span class="math inline">\((x^2 + y^2)^2 = 2a^2 (x^2 - y^2)\)</span> 与外圆 <span class="math inline">\(x^2 + y^2 \geq a^2 (a &gt; 0)\)</span> 所构成图形的面积 <span class="math inline">\(A\)</span>。</p></blockquote><p><span class="math display">\[A = 4 \int_0^{\frac{\pi}{6}} \text{d} \theta \int_a^{\sqrt{2} a \sqrt{\cos 2 \theta}} \rho \text{d} \rho = 4 \int_0^{\frac{\pi}{6}} a^2 \biggl(\cos 2 \theta -\frac{1}{2} \biggr) \text{d} \theta = 4 a^2 \biggl(\frac{\sqrt{3}}{4} - \frac{\pi}{12}\biggr)\]</span></p></li><li><blockquote><p>计算 <span class="math inline">\(\iiint\limits_{\Omega} z \text{d} v\)</span>，其中 <span class="math inline">\(\Omega\)</span> 是由曲面 <span class="math inline">\((x^2 + y^2 + z^2)^2 = 2 (z^2 - x^2 - y^2)\)</span> 所围成的区域在 $z  $ 的部分。</p></blockquote><p>曲面的球坐标变换为 <span class="math inline">\(x = \rho \cos \theta \cos \varphi\)</span>，<span class="math inline">\(y = \rho \sin \theta \cos \varphi\)</span>，<span class="math inline">\(z = \rho \sin \varphi\)</span>。</p><p><span class="math display">\[\begin{aligned}\rho^4 &amp;= 2 \rho^2 (\sin^2 \varphi - \cos^2 \varphi)\\\rho &amp;= \sqrt{- 2 \cos 2\varphi}, \quad \frac{\pi}{2} \geq \varphi \geq \frac{\pi}{4}\\\iint\limits_{\Omega} &amp;= \int_0^{2\pi} \text{d} \theta \int_{\frac{\pi}{4}}^{\frac{\pi}{2}} \sin^2 \varphi \text{d} \varphi \int_0^{\sqrt{-2\cos 2\varphi}} \rho^3 \text{d} \rho\\&amp;= 2\pi \int_{\frac{\pi}{4}}^{\frac{\pi}{2}} \sin^2 \varphi \cos^2 2\varphi \text{d} \varphi\end{aligned}\]</span></p></li><li><blockquote><p>求曲面 <span class="math inline">\(x^2 + y^2 = az\)</span> 和 <span class="math inline">\(z = 2a - \sqrt{x^2 + y^2}(a &gt; 0)\)</span> 所围成立体的表面积。</p></blockquote><p>交线：</p><p><span class="math display">\[\begin{cases}z = a\\x^2 + y^2 = a^2\end{cases}\]</span></p><p>立体在 <span class="math inline">\(xOy\)</span> 坐标面的投影为 <span class="math inline">\(D: x^2 + y^2 \leq a^2\)</span>，表面积 <span class="math inline">\(|S|\)</span></p><p><span class="math display">\[|S| = \iint\limits_{D} \sqrt{2} \text{d} \sigma + \iint\limits_{D} \sqrt{\frac{a^2 + 4(x^2 + y^2)}{a^2}} \text{d} \sigma = \pi a^2 \biggl(\sqrt{2} + \frac{5\sqrt{5} - 1}{6}\biggr)\]</span></p></li><li><blockquote><p>求球面 <span class="math inline">\(x^2 + y^2 + z^2 = a^2\)</span> 在柱面 <span class="math inline">\(x^2 + y^2 = \pm ax\)</span> 外的那一部分的面积。</p></blockquote><p>设面积为 <span class="math inline">\(A\)</span>。</p><p><span class="math display">\[\begin{aligned}A &amp;= 4\pi a^2 - 4 \iint\limits_{(x - \frac{a}{2})^2 + y^2 \leq \frac{a^2}{4}} \frac{a}{\sqrt{a^2 - x^2 - y^2}} \text{d} x \text{d} y\\&amp;= 4\pi a^2 - 4a \int_{-\frac{\pi}{2}}^{\frac{\pi}{2}} \text{d} \theta \int_0^{a\cos \theta} \frac{r}{\sqrt{a^2 - r^2}} \text{d} r\\&amp;= 4\pi a^2 - 4a \int_{-\frac{\pi}{2}}^{\frac{\pi}{2}} \text{d} \theta (a - a \sin \theta) = 0\end{aligned}\]</span></p></li><li><blockquote><p>求锥面 <span class="math inline">\(\Sigma: z = \sqrt{3x^2 + 3y^2}\)</span> 与平面 <span class="math inline">\(\Sigma_0: x + y + z = 2a(a &gt; 0)\)</span> 所围成的立体的表面积和体积。</p></blockquote><p>交线在 <span class="math inline">\(xOy\)</span> 坐标面的投影 <span class="math inline">\(D: x^2 + y^2 - xy + 2a(x + y) \leq 2a^2\)</span>，记表面积为 <span class="math inline">\(S\)</span>。做变换 <span class="math inline">\(u = x -\frac{1}{2} y\)</span>，<span class="math inline">\(v = \frac{\sqrt{3}}{2} y\)</span>，则新区域为 <span class="math inline">\(D&#39;: u^2 + v^2 + 2a(u + \sqrt{3} v) \leq 2a^2\)</span>，即 <span class="math inline">\(D&#39;: (u + a)^2 + (v + \sqrt{3} a)^2 \leq 6a^2\)</span></p><p><span class="math display">\[S = \iint\limits_{D&#39;} \biggl(\sqrt{3} + \sqrt{4}\biggr) \frac{2}{\sqrt{3}}\text{d} u \text{d} v = 4a^2 \pi (3 + 2\sqrt{3})\]</span></p><p>记体积为 <span class="math inline">\(V\)</span>，记原点到 <span class="math inline">\(\Sigma_0\)</span> 的距离为 <span class="math inline">\(h_0\)</span>。</p><p><span class="math display">\[h_0 = \frac{2a}{\sqrt{3}}\]</span></p><p>所截 <span class="math inline">\(\Sigma_0\)</span> 的面积 <span class="math inline">\(S_0\)</span> 为：</p><p><span class="math display">\[S_0 = \iint\limits_{D&#39;} \sqrt{3} \text{d} \sigma = 6\sqrt{3} \frac{2}{\sqrt{3}} a^2 \pi\]</span></p><p>所以，</p><p><span class="math display">\[V = \frac{1}{3} h_0 S_0 = \frac{8}{\sqrt{3}} a^3 \pi\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x, y)\)</span> 在区域 <span class="math inline">\(0 \leq x \leq 1\)</span>，<span class="math inline">\(0 \leq y \leq 1\)</span> 上可微，且 <span class="math inline">\(f(0, 0) = 0\)</span>。证明：</p><p><span class="math display">\[\lim_{x \to 0^+} \frac{\int_0^{x^2} \text{d} t \int_{\sqrt{t}}^{x} f(t, u) \text{d} u}{1 - \text{e}^{-\frac{x^4}{4}}} = f_y(0, 0)\]</span></p></blockquote><p><span class="math display">\[\begin{aligned}\lim_{x \to 0^+} \frac{\int_0^{x^2} \text{d} t \int_{\sqrt{t}}^{x} f(t, u) \text{d} u}{1 - \text{e}^{-\frac{x^4}{4}}} &amp;= \lim_{x \to 0^+} \frac{\int_{\sqrt{t}}^{x} \bigl(\int_0^{u^2} f(t, u) \text{d} t\bigr) \text{d} u}{\frac{x^4}{4}}\\&amp;= \lim_{x \to 0^+} \frac{\int_0^{x^2} f(t, x) \text{d} t}{x^3}\\&amp;= \lim_{x \to 0^+} \frac{x^2f(\xi, x)}{x^3}, \quad x^2 &gt; \xi &gt; 0\\&amp;= \lim_{x \to 0^+} \frac{f_x(0, 0) \xi + f_y(0, 0)x + o(\sqrt{\xi^2 + x^2})}{x} = f_y(0, 0)\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(D\)</span> 是平面上由光滑封闭曲线围成的有界区域，其面积 <span class="math inline">\(A &gt; 0\)</span>，函数 <span class="math inline">\(f(x, y)\)</span> 在该区域及其边界上连续且 <span class="math inline">\(f(x, y) &gt; 0\)</span>。记 <span class="math inline">\(J_n = \bigl(\frac{1}{A} \iint\limits_{D} f^{\frac{1}{n}} (x, y) \text{d} \sigma \bigr)^n\)</span>，求 <span class="math inline">\(\lim\limits_{n \to \infty} J_n\)</span>。</p></blockquote><p><span class="math display">\[\begin{aligned}\lim\limits_{n \to \infty} J_n &amp;= \lim\limits_{n \to \infty} \exp \biggl(n \ln \frac{1}{A} \iint\limits_{D} f^{\frac{1}{n}} (x, y) \text{d} \sigma \biggr)\\&amp;= \lim\limits_{m \to 0} \exp \biggl(\frac{\ln \frac{1}{A} \iint\limits_{D} \text{e}^{m \ln f(x, y)} \text{d} \sigma}{m} \biggr)\\&amp;= \lim\limits_{m \to 0} \exp \biggl(\frac{1}{\iint\limits_{D} \text{e}^{m \ln f(x, y)} \text{d} \sigma} \iint\limits_{D} \ln f(x, y) \text{e}^{m \ln f(x, y)} \text{d} \sigma \biggr)\\&amp;= \exp \biggl(\frac{1}{A} \iint\limits_{D} \ln f(x, y) \text{d} \sigma \biggr)\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((-\infty, +\infty)\)</span> 上非负且连续，并有 <span class="math inline">\(f(x) \int_0^{x} f(x - t) \text{d} t = \sin^4 x\)</span>。求 <span class="math inline">\(\int_0^{\pi} f(x) \text{d} x\)</span>。</p></blockquote><p><span class="math display">\[\begin{aligned}f(x) \int_0^{x} f(x - t) \text{d} t &amp;= \sin^4 x\\f(x) \int_0^{x} f(u) \text{d} u &amp;= \sin^4 x\\\int_0^{\pi} \text{d} x f(x) \int_0^{x} f(u) \text{d} u &amp;= \int_0^{\pi} \sin^4 x \text{d} x\\\int_0^{\pi} \text{d} x f(x) \int_0^{x} f(u) \text{d} u &amp;= \frac{3}{8} \pi\\\biggl(\int_0^{\pi} f(x) \text{d} x\biggr)^2 &amp;= \frac{3}{4} \pi\\\int_0^{\pi} f(x) \text{d} x &amp;= \frac{\sqrt{3\pi}}{2}\end{aligned}\]</span></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>重积分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多元函数微分学</title>
    <link href="/2025/08/20/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/"/>
    <url>/2025/08/20/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="邻域内点外点边界开区域闭区域以及多元函数的概念与性质">邻域、内点、外点、边界、开区域、闭区域以及多元函数的概念与性质</h2><h3 id="邻域">邻域</h3><p><strong>定义</strong>：设 <span class="math inline">\(P_0(x_0, y_0)\)</span> 是平面上一点，<span class="math inline">\(\delta &gt; 0\)</span>，称集合 <span class="math display">\[U(P_0, \delta) = \{P(x, y) | |P - P_0| &lt; \delta\} = \{(x, y) | \sqrt{(x - x_0)^2 + (y - y_0)^2} &lt; \delta\}\]</span> 为点 <span class="math inline">\(P_0\)</span> 的 <strong><span class="math inline">\(\delta\)</span> 邻域</strong>，也记作 <span class="math inline">\(U(P_0)\)</span>。</p><p><strong>去心邻域</strong>：<span class="math inline">\(\stackrel{\circ}{U}(P_0, \delta) = \{P | 0 &lt; |P - P_0| &lt; \delta\}\)</span></p><h3 id="内点外点边界点">内点、外点、边界点</h3><p>设 <span class="math inline">\(E\)</span> 是平面上的一个点集，<span class="math inline">\(P_0\)</span> 是平面上的一点：</p><p><strong>内点</strong>：如果存在 <span class="math inline">\(P_0\)</span> 的某个邻域 <span class="math inline">\(U(P_0)\)</span> 使得 <span class="math inline">\(U(P_0) \subset E\)</span>，则称 <span class="math inline">\(P_0\)</span> 为 <span class="math inline">\(E\)</span> 的<strong>内点</strong>。</p><p><strong>外点</strong>：如果存在 <span class="math inline">\(P_0\)</span> 的某个邻域 <span class="math inline">\(U(P_0)\)</span> 使得 <span class="math inline">\(U(P_0) \cap E = \emptyset\)</span>，则称 <span class="math inline">\(P_0\)</span> 为 <span class="math inline">\(E\)</span> 的<strong>外点</strong>。</p><p><strong>边界点</strong>：如果 <span class="math inline">\(P_0\)</span> 的任意邻域内既有属于 <span class="math inline">\(E\)</span> 的点，又有不属于 <span class="math inline">\(E\)</span> 的点，则称 <span class="math inline">\(P_0\)</span> 为 <span class="math inline">\(E\)</span> 的<strong>边界点</strong>。</p><p><strong>聚点</strong>（极限点）：如果 <span class="math inline">\(P_0\)</span> 的任意去心邻域内都有 <span class="math inline">\(E\)</span> 中的点，则称 <span class="math inline">\(P_0\)</span> 为 <span class="math inline">\(E\)</span> 的<strong>聚点</strong>。</p><p><strong>孤立点</strong>：如果 <span class="math inline">\(P_0 \in E\)</span> 但 <span class="math inline">\(P_0\)</span> 不是 <span class="math inline">\(E\)</span> 的聚点，则称 <span class="math inline">\(P_0\)</span> 为 <span class="math inline">\(E\)</span> 的<strong>孤立点</strong>。</p><h3 id="开区域与闭区域">开区域与闭区域</h3><p><strong>开集</strong>：如果集合 <span class="math inline">\(E\)</span> 的每一点都是 <span class="math inline">\(E\)</span> 的内点，则称 <span class="math inline">\(E\)</span> 为<strong>开集</strong>。</p><p><strong>闭集</strong>：如果集合 <span class="math inline">\(E\)</span> 的所有聚点都属于 <span class="math inline">\(E\)</span>，则称 <span class="math inline">\(E\)</span> 为<strong>闭集</strong>。</p><p><strong>区域</strong>（开区域）：连通的开集称为<strong>区域</strong>或<strong>开区域</strong>。</p><p><strong>闭区域</strong>：开区域连同它的边界一起称为<strong>闭区域</strong>。</p><p><strong>有界集</strong>：如果存在正数 <span class="math inline">\(M\)</span>，使得集合 <span class="math inline">\(E\)</span> 中的所有点到原点的距离都不超过 <span class="math inline">\(M\)</span>，则称 <span class="math inline">\(E\)</span> 为<strong>有界集</strong>。</p><p><strong>无界集</strong>：不是有界集的集合称为<strong>无界集</strong>。</p><h2 id="方程">方程</h2><h3 id="曲面方程">曲面方程</h3><ol type="1"><li><p>有解三元方程 <span class="math inline">\(\Sigma : F(x, y, z) = 0\)</span> &gt;  也有可能是点或直线</p></li><li><p>参数方程 <span class="math inline">\(\Sigma&#39; : x = x(u, v)\)</span>，<span class="math inline">\(y = y(u, v)\)</span>，<span class="math inline">\(z = z(u, v)\)</span></p></li><li><p><span class="math inline">\(\Sigma&#39;\)</span> 是 <span class="math inline">\(\Sigma\)</span> 的一部分的充要条件为：<span class="math inline">\(F(x(u, v), y(u, v), z(u, v)) \equiv 0\)</span></p></li></ol><h3 id="空间曲线方程">空间曲线方程</h3><ol type="1"><li><p>有解方程组 [ l :</p><span class="math display">\[\begin{cases}F(x, y, z) = 0\\G(x, y, z) = 0\end{cases}\]</span><p>]</p><p>称为一般式</p></li><li><p>参数方程：<span class="math inline">\(l&#39; : x = x(t)\)</span>，<span class="math inline">\(y = y(t)\)</span>，<span class="math inline">\(z = z(t)\)</span></p></li><li><p><span class="math inline">\(l&#39;\)</span> 是 <span class="math inline">\(l\)</span> 的一部分的充要条件为：<span class="math inline">\(F[x(t), y(t), z(t)] \equiv 0\)</span> 且 <span class="math inline">\(G[x(t), y(t), z(t)] \equiv 0\)</span></p></li><li><p>以弧长为参数的曲线方程：<span class="math inline">\(\bar{l} : \bar{x}(s)\)</span>，<span class="math inline">\(\bar{y}(s)\)</span>，<span class="math inline">\(\bar{z}(s)\)</span>，恒有 <span class="math inline">\([\bar{x}&#39;(s)]^2 + [\bar{y}&#39;(s)]^2 + [\bar{z}&#39;(s)]^2 \equiv 1\)</span></p></li><li><p>对一般式同解变形可以分别得到在各坐标面上的投影方程</p></li></ol><h3 id="平面方程">平面方程</h3><ol type="1"><li><p>点法式</p></li><li><p>一般式</p></li><li><p>截距式</p></li><li><p>点到平面距离公式</p></li></ol><h3 id="直线方程">直线方程</h3><ol type="1"><li><p>一般式</p></li><li><p>对称式</p></li><li><p>参数式</p></li><li><p>向量式</p></li></ol><h2 id="偏导数">偏导数</h2><ol type="1"><li><p>可偏导未必连续</p></li><li><p>二阶混合偏导数在某点连续则在该点它们相等</p></li></ol><h2 id="全微分">全微分</h2><ol type="1"><li><p>如果全增量 <span class="math inline">\(\Delta z = f(x + \Delta x, y + \Delta y) - f(x, y)\)</span> 可以表示为 <span class="math inline">\(\Delta z = A \Delta x + B \Delta y + o(\rho)(\rho \rightarrow 0)\)</span>，其中 <span class="math inline">\(\rho = \sqrt{\Delta^2 x + \Delta^2 y}\)</span>，则说可微分。</p></li><li><p>如果可微，则 <span class="math inline">\(\text{d} z = \frac{\partial z}{\partial x} \text{d} x + \frac{\partial z}{\partial y} \text{d} y\)</span>。</p></li><li><p>如果函数的偏导数在某点连续，则在某点可微分。</p></li></ol><h2 id="曲线切线">曲线切线</h2><p>已知空间曲线的参数方程，如果导数连续且不同时为零，则可以用如下公式</p><p>切线方程的对称式： <span class="math display">\[\frac{x - x_0}{x&#39;(t_0)} = \frac{y - y_0}{y&#39;(t_0)} = \frac{z - z_0}{z&#39;(t_0)}\]</span></p><p>切向量： <span class="math display">\[\mathbf{T} = \pm (x&#39;(t_0), y&#39;(t_0), z&#39;(t_0))\]</span></p><p>法平面方程： <span class="math display">\[x&#39;(t_0)(x - x_0) + y&#39;(t_0)(y - y_0) + z&#39;(t_0)(z - z_0) = 0\]</span></p><h2 id="曲面的切平面">曲面的切平面</h2><p>已知空间曲面的方程，若各偏导数连续且不同时为零，则可以用如下公式：</p><p>切平面方程为： <span class="math display">\[F_x(x_0, y_0, z_0)(x - x_0) + F_y(x_0, y_0, z_0)(y - y_0) + F_z(x_0, y_0, z_0)(z - z_0) = 0\]</span></p><p>法线方程： <span class="math display">\[\frac{x - x_0}{F_x(x_0, y_0, z_0)} = \frac{y - y_0}{F_y(x_0, y_0, z_0)} = \frac{z - z_0}{F_z(x_0, y_0, z_0)}\]</span></p><h2 id="多元函数无条件极值">多元函数无条件极值</h2><ol type="1"><li><p>必要条件：在点有<strong>偏导数</strong>，且满足所有偏导数<strong>同时</strong>为零，得到<strong>驻点</strong></p></li><li><p>充分条件：在驻点某领域内如果有<strong>二阶</strong>偏导数，设 <span class="math inline">\(f_{xx}(x_0, y_0) = A\)</span>，<span class="math inline">\(f_{xy}(x_0, y_0) = B\)</span>，<span class="math inline">\(f_{yy}(x_0, y_0) = C\)</span>，<span class="math inline">\(\Delta = AC - B^2\)</span>，则：</p><ol type="1"><li><span class="math inline">\(\Delta &gt; 0\)</span> 时是极值，且 <span class="math inline">\(A &lt; 0\)</span> 是极大值。</li><li><span class="math inline">\(\Delta &lt; 0\)</span> 时不是极值。</li></ol></li></ol><h2 id="多元函数条件极值">多元函数条件极值</h2><p>拉格朗日乘数法</p><h2 id="习题汇编">习题汇编</h2><ol type="1"><li><blockquote><p>设 <span class="math inline">\(z = 2x^2 + y^2\)</span> 截出平面 <span class="math inline">\(4x + 2y + z = 1\)</span> 的一个椭圆，求这个椭圆的面积 <span class="math inline">\(A\)</span>。</p></blockquote><p>先求出截面面积与其在 <span class="math inline">\(xOy\)</span> 平面的投影的比例系数 <span class="math display">\[\cos \alpha = \frac{1}{\sqrt{4^2 + 2^2 + 1^2}} = \sqrt{\frac{1}{21}}\]</span></p><p>交线方程为： <span class="math display">\[\begin{cases}z = 2x^2 + y^2\\4x + 2y + z = 1\end{cases}\]</span></p><p>消去变量 <span class="math inline">\(z\)</span> 得到交线在 <span class="math inline">\(xOy\)</span> 平面的投影 <span class="math display">\[\frac{(x + 1)^2}{2} + \frac{(y + 1)^2}{4} = 1\]</span></p><p>面积为 <span class="math inline">\(2\sqrt{2} \pi\)</span>，从而截面面积为 <span class="math inline">\(2\sqrt{2} \pi \times \sqrt{21} = 2\pi \sqrt{42}\)</span></p></li><li><blockquote><p>设 <span class="math inline">\(a &gt; 0\)</span>，<span class="math inline">\(b &gt; 0\)</span>，<span class="math inline">\(c &gt; 0\)</span>，证明：单叶双曲面 <span class="math inline">\(\Sigma : \frac{x^2}{a^2} + \frac{y^2}{b^2} - \frac{z^2}{c^2} = 1\)</span> 上任意一点都有经过该点并且完全位于 <span class="math inline">\(\Sigma\)</span> 上的直线通过。</p></blockquote></li><li><blockquote><p>求空间曲线 <span class="math inline">\(L: x(t) = t(\text{e}^t - 1)\)</span>，<span class="math inline">\(y(t) = t \sin t\)</span>，<span class="math inline">\(z(t) = t^3 + t^2 + 1\)</span>，在点 <span class="math inline">\(P_0(0, 0, 1)\)</span> 的切线。</p></blockquote><p>参数 <span class="math inline">\(t_0 = 0\)</span>，解得参数方程一阶导数同时为 0，此时只需要计算二阶导数，得到切线方向为 <span class="math inline">\((1, 1, 1)\)</span>，方程为 <span class="math inline">\(x = y = z - 1\)</span>。</p></li><li><blockquote><p>求过直线 <span class="math display">\[L:\begin{cases}3x - 2y - z = 5\\x + y + z = 0\end{cases}\]</span> 与曲面 <span class="math display">\[2x^2 - 2y^2 +2z = \frac{5}{8}\]</span> 相切的切平面方程</p></blockquote><p>曲面上的点 <span class="math inline">\((x_0, y_0, z_0)\)</span> 的切平面法向量为 <span class="math inline">\((4x_0, -4y_0, 2)\)</span>，过直线 <span class="math inline">\(L\)</span> 的平面簇方程为 <span class="math inline">\(3x - 2y - z - 5 + \lambda(x + y + z) = 0 = (3 + \lambda)x + (\lambda - 2)y + (\lambda - 1)z - 5\)</span>。得到该平面的法向量为 <span class="math inline">\((3 + \lambda, \lambda - 2, \lambda - 1)\)</span>。整理得： <span class="math display">\[\begin{cases}\frac{3 + \lambda}{4x_0} = \frac{\lambda - 2}{-4y_0} = \frac{\lambda - 1}{2}\\2x_0^2 - 2y_0^2 + 2z_0 = \frac{5}{8}\\(3 + \lambda)x_0 + (\lambda - 2)y_0 + (\lambda - 1)z_0 - 5 = 0\end{cases}\]</span></p><p>解得 $= $</p></li><li><blockquote><p>长度为 <span class="math inline">\(a\)</span> 的线段两端分别在 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span> 轴上滑动，求这样的线段簇的包络线</p></blockquote><p>设在 <span class="math inline">\(x\)</span> 轴上的位置为 <span class="math inline">\(c\)</span>，则该线段所在直线的方程为 <span class="math display">\[\frac{x}{c} + \frac{y}{\sqrt{a^2 - c^2}} = 1\]</span></p><p>设 <span class="math inline">\(\sin \theta = \frac{c}{a}\)</span>，则直线方程为 <span class="math display">\[F(x, y, \theta) = \frac{x}{\sin \theta} + \frac{y}{\cos \theta} -\frac{1}{a} = 0\]</span></p><p>则包络线方程为： <span class="math display">\[\begin{cases}F(x, y, \theta) = \frac{x}{\sin \theta} + \frac{y}{\cos \theta} -\frac{1}{a} = 0\\F_\theta(x, y, \theta) = \frac{-x \cos \theta}{\sin^2 \theta} + \frac{y \sin \theta}{\cos^2 \theta} = 0\end{cases}\]</span></p><p>从而，<span class="math inline">\(x = a \sin^3 \theta\)</span>，<span class="math inline">\(y = a \cos^3 \theta\)</span>。</p></li><li><blockquote><p>求通过直线</p><p><span class="math display">\[L:\begin{cases}2x + y - 3z + 2 = 0\\5x + 5y - 4z + 3 = 0\end{cases}\]</span></p><p>的两个相互垂直的平面 <span class="math inline">\(\pi_1\)</span> 和 <span class="math inline">\(\pi_2\)</span>，使得其中一个平面过点 <span class="math inline">\((4, -3, 1)\)</span>。</p></blockquote><p>过直线 <span class="math inline">\(L\)</span> 的曲面系为 <span class="math inline">\(\Sigma: (2x + y - 3z + 2) + \lambda(5x + 5y - 4z + 3) = 0\)</span>，要求过点 <span class="math inline">\((4, -3, 1)\)</span> 解得 <span class="math inline">\(\lambda = -1\)</span>，故 <span class="math inline">\(\Sigma: 3x + 4y - z + 1 = 0\)</span>，记为 <span class="math inline">\(\pi_1\)</span>，则 <span class="math inline">\(\pi_2: x - 2y - 5z + 3 = 0\)</span></p></li><li><blockquote><p>设二元函数 <span class="math inline">\(f(x, y) = |x - y| \varphi(x, y)\)</span>，其中 <span class="math inline">\(\varphi(x, y)\)</span> 在点 <span class="math inline">\((0, 0)\)</span> 处连续。证明 <span class="math inline">\(f(x, y)\)</span> 在点 <span class="math inline">\((0, 0)\)</span> 处可微的充分必要条件是 <span class="math inline">\(\varphi(0, 0) = 0\)</span>。</p></blockquote><p>必要性。若 <span class="math inline">\(f(x, y)\)</span> 在 <span class="math inline">\((0, 0)\)</span> 处可微，且 <span class="math inline">\(f_x(0, 0)\)</span> 存在</p><p><span class="math display">\[\begin{aligned}\lim_{x \to 0^+} \frac{f(x, 0) - f(0, 0)}{x} &amp;= \varphi(0, 0)\\\lim_{x \to 0^-} \frac{f(x, 0) - f(0, 0)}{x} &amp;= -\varphi(0, 0)\end{aligned}\]</span></p><p>故，<span class="math inline">\(\varphi(0, 0) = 0\)</span>。</p><p>充分性性。若 <span class="math inline">\(\varphi(0, 0) = 0\)</span>，则</p><p><span class="math display">\[\begin{aligned}f_x(0, 0) &amp;= \lim_{x \to 0} \frac{f(x, 0) - f(0, 0)}{x} = 0\\f_y(0, 0) &amp;= \lim_{y \to 0} \frac{f(0, y) - f(0, 0)}{y} = 0\\o(\rho) &amp;= f(\Delta x, \Delta y) - f(0, 0) - f_x(0, 0) \Delta x - f_y(0, 0) \Delta y\end{aligned}\]</span></p><p>解得</p><p><span class="math display">\[\lim_{(\Delta x, \Delta y) \to (0, 0)} \frac{f(\Delta x, \Delta y) - f(0, 0) - f_x(0, 0) \Delta x - f_y(0, 0) \Delta y}{\sqrt{\Delta^2 x + \Delta^2 y}}\\= \lim_{(\Delta x, \Delta y) \to (0, 0)} \frac{|\Delta x - \Delta y| \varphi(\Delta x, \Delta y)}{\sqrt{\Delta^2 x + \Delta^2 y}} = 0\]</span></p><p>所以，</p><p><span class="math display">\[\Delta f = f(\Delta x, \Delta y) - f(0, 0) = f_x(0, 0) \Delta x + f_y(0, 0) \Delta y + |\Delta x - \Delta y| \varphi(\Delta x, \Delta y)\\= f_x(0, 0) \Delta x + f_y(0, 0) \Delta y + o(\rho)\]</span></p><p>故，<span class="math inline">\(f(x, y)\)</span> 在 <span class="math inline">\((0, 0)\)</span> 可微。</p></li><li><blockquote><p>求原函数</p><p><span class="math display">\[\text{d} u = \frac{x \text{d} y - y \text{d} x}{x^2 + y^2}\]</span></p></blockquote><p><span class="math display">\[u = \arctan \frac{y}{x} + C\]</span></p></li><li><blockquote><p>设椭圆簇为 <span class="math inline">\(\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1\)</span>，其中每个椭圆的面积都为常数 <span class="math inline">\(S\)</span>。求该椭圆簇的包络线。</p></blockquote><p>由面积恒为定值得到 <span class="math inline">\(ab\pi = S\)</span>，则椭圆簇可以表示为</p><p><span class="math display">\[ F(x, y, a) = \frac{x^2}{a^2} + \frac{a^2\pi^2y^2}{S^2} = 1 \]</span></p><p>包络线方程为</p><p><span class="math display">\[ \begin{cases} F(x, y ,a) &amp;= \frac{x^2}{a^2} + \frac{a^2\pi^2y^2}{S^2} - 1 = 0 \\ F_a(x, y, a) &amp;= \frac{-2x^2}{a^3} + \frac{2a\pi^2y^2}{S^2} = 0 \end{cases} \]</span></p><p>则包络线的方程</p><p><span class="math display">\[ C: x^2 y^2 = \frac{S^2}{4\pi^2} \]</span></p></li><li><blockquote><p>求直线 <span class="math inline">\(\frac{x - 1}{0} = \frac{y - 1}{1} = \frac{z - 1}{1}\)</span> 绕 <span class="math inline">\(z\)</span> 轴的旋转面方程。</p></blockquote><p>该直线的参数方程为：<span class="math inline">\(l: x = 1\)</span>，<span class="math inline">\(y = 1 + t\)</span>，<span class="math inline">\(z = 1 + t\)</span>。得到旋转面的参数方程：<span class="math inline">\(\Sigma: x = \sqrt{2 + 2t + t^2} \cos \theta\)</span>，<span class="math inline">\(y = \sqrt{2 + 2t + t^2} \sin \theta\)</span>，<span class="math inline">\(z = 1 + t\)</span>，<span class="math inline">\(t \in R\)</span>，<span class="math inline">\(\theta \in [0, 2\pi]\)</span>。即 <span class="math inline">\(\Sigma: x^2 + y^2 - z^2 = 1\)</span>。</p></li><li><blockquote><p>设 <span class="math inline">\(F(x, y, z)\)</span> 是 <span class="math inline">\(n\)</span> 次齐次函数，即存在正整数 <span class="math inline">\(n\)</span>，使得对任何 <span class="math inline">\(t\)</span> 都有 <span class="math inline">\(F(tx, ty, tz) = t^n F(x, y, z)\)</span>。证明：方程 <span class="math inline">\(F(x, y, z) = 0\)</span> 所代表的曲面是顶点在原点的锥面。</p></blockquote><p>取 <span class="math inline">\(t = 0\)</span>，得 <span class="math inline">\(F(0, 0, 0) = 0\)</span>。设非原点 <span class="math inline">\((x_0, y_0. z_0)\)</span> 在曲面上，由于 <span class="math inline">\(F(tx, ty, tz) = t^n F(x, y, z)\)</span>，故经过原点的直线 <span class="math inline">\(x = tx_0\)</span>，<span class="math inline">\(y = ty_0\)</span>，<span class="math inline">\(z = tz_0\)</span> 在曲面上。这表明曲面上的任何点与原点的连线都在曲面上。因此该曲面为顶点在原点的锥面。</p></li><li><blockquote><p>给定二次曲面 <span class="math inline">\((x + y)^2 + (y + z)^2 + (z + x)^2 - 1 =0\)</span>，求它在 <span class="math inline">\(xOy\)</span> 坐标面上的投影区域 <span class="math inline">\(D\)</span>。</p></blockquote><p>做变换 <span class="math inline">\(T: x + y = u\)</span>，<span class="math inline">\(y + z = v\)</span>，<span class="math inline">\(z + x = w\)</span></p></li><li><blockquote><p>证明：若 <span class="math inline">\(u = u(x, y)\)</span>，<span class="math inline">\(v = v(x, y)\)</span> 都是区域 <span class="math inline">\(D\)</span> 上的调和函数，则 <span class="math inline">\(u(x, y) \equiv C_1\)</span>（常数）及 <span class="math inline">\(v(x, y) \equiv C_2\)</span>（常数）的充要条件是 <span class="math inline">\(u^2(x, y) + v^2(x, y) \equiv C\)</span>（常数）。</p></blockquote><p>充分性显然，下面证明必要性。对等式分别对 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span> 求偏导，并结合调和函数性质得：</p><p><span class="math display">\[\begin{aligned}\frac{\partial u}{\partial x} + \frac{\partial v}{\partial x} &amp;= 0\\\frac{\partial u}{\partial y} + \frac{\partial v}{\partial y} &amp;= 0\\\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 v}{\partial x^2} &amp;= 0\\\frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 v}{\partial y^2} &amp;= 0\\\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} &amp;= 0\\\frac{\partial^2 v}{\partial x^2} + \frac{\partial^2 v}{\partial y^2} &amp;= 0\end{aligned}\]</span></p><p>设 <span class="math inline">\(a \in R\)</span>，则</p><p><span class="math display">\[\begin{aligned}\frac{\partial^2 u}{\partial x^2} &amp;= \frac{\partial^2 v}{\partial y^2} = a\\\frac{\partial^2 u}{\partial y^2} &amp;= \frac{\partial^2 v}{\partial x^2} = -a\end{aligned}\]</span></p><p>则</p><p><span class="math display">\[\begin{aligned}\frac{\partial u}{\partial x} &amp;= ax + C_x, C_x \in R\\\frac{\partial u}{\partial y} &amp;= ay + C_y, C_y \in R\end{aligned}\]</span></p><p>又因为</p><p><span class="math display">\[\frac{\partial u}{\partial x} + \frac{\partial v}{\partial x} = 0\]</span></p><p>所以</p><p><span class="math display">\[\frac{\partial u}{\partial x} = \frac{\partial v}{\partial x} = 0\]</span></p><p>同理</p><p><span class="math display">\[\frac{\partial u}{\partial y} = \frac{\partial v}{\partial y} = 0\]</span></p><p>所以，<span class="math inline">\(u(x, y) \equiv C_1\)</span>，<span class="math inline">\(v(x, y) \equiv C_2\)</span></p></li><li><blockquote><p>设 <span class="math inline">\(f\)</span> 二阶连续可微，求下列复合函数的偏导数：</p><p>(1). <span class="math inline">\(u = f(x^2 + y^2 + z^2)\)</span>，求 <span class="math inline">\(\frac{\partial^2 u}{\partial x^2}\)</span>；</p><p>(2). <span class="math inline">\(u = f(x + y, xy)\)</span>，求 <span class="math inline">\(\frac{\partial^2 u}{\partial x \partial y}\)</span>；</p><p>(3). <span class="math inline">\(u = f(x, xy, xyz)\)</span>，求 <span class="math inline">\(\frac{\partial u}{x}\)</span>，<span class="math inline">\(\frac{\partial u}{y}\)</span>，<span class="math inline">\(\frac{\partial^2 u}{\partial x \partial y}\)</span>。</p></blockquote><p>(1).</p><p><span class="math display">\[\begin{aligned}\frac{\partial u}{\partial x} &amp;= 2x f&#39;\\\frac{\partial^2 u}{\partial x^2} &amp;= 2f&#39; + 4x^2 f&#39;&#39;\end{aligned}\]</span></p><p>(2).</p><p><span class="math display">\[\begin{aligned}\frac{\partial u}{\partial x} &amp;= f_1&#39; + yf_2&#39;\\\frac{\partial^2 u}{\partial x \partial y} &amp;= f_{11}&#39;&#39; + x f_{12}&#39; + f_2&#39; + y f_{21}&#39; + xy f_{22}&#39;\end{aligned}\]</span></p><p>(3).</p><p><span class="math display">\[\begin{aligned}\frac{\partial u}{x} &amp;= f_{1}&#39; + yf_{2}&#39; + yzf_{3}&#39;\\\frac{\partial u}{y} &amp;= xf_{2}&#39; + xzf_{3}&#39;\\\frac{\partial^2 u}{\partial x \partial y} &amp;= f_{2}&#39; + x(f_{21}&#39;&#39; + yf_{22}&#39;&#39; + yzf_{23}&#39;&#39;) + zf_{3}&#39; + xz(f_{31}&#39;&#39; + yf_{32}&#39;&#39; + yzf_{33}&#39;&#39;)\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(z = f(x, y)\)</span> 具有二阶连续的偏导数，且满足 <span class="math inline">\(f(x, 2x) = x\)</span>，<span class="math inline">\(f_1&#39;(x, 2x) = x^2\)</span>，<span class="math inline">\(f_{11}&#39;&#39; = f_{22}&#39;&#39;\)</span>。求二阶偏导数 <span class="math inline">\(f_{12}&#39;&#39;(x, 2x)\)</span>。</p></blockquote><p><span class="math display">\[\begin{aligned}\frac{\partial f}{\partial x} &amp;= f_{1}&#39; + 2f_{2}&#39; = 1\\\frac{\partial^2 f}{\partial x^2} &amp;= f_{11}&#39;&#39; + 2f_{12}&#39;&#39; + 2f_{21}&#39;&#39; + 4f_{22}&#39;&#39; = 0\\\frac{\partial f_{1}}{\partial x} &amp;= f_{11}&#39;&#39; + 2f_{12}&#39;&#39; = 2x\\f_{12}&#39;&#39;(x, 2x) &amp;= \frac{5}{3} x\end{aligned}\]</span></p></li><li><blockquote><p>求偏微分方程</p><p><span class="math display">\[y \frac{\partial z}{\partial x} - x \frac{\partial z}{\partial y} = 0\]</span></p></blockquote><p>做变换 <span class="math inline">\(u = x\)</span>，<span class="math inline">\(v = x^2 + y^2\)</span>，则：</p><p><span class="math display">\[\begin{aligned}\frac{\partial z}{\partial x} &amp;= \frac{\partial z}{\partial u} \frac{\partial u}{\partial x} + \frac{\partial z}{\partial v} \frac{\partial v}{\partial x } = \frac{\partial z}{\partial u} + 2x \frac{\partial z}{\partial v}\\\frac{\partial z}{\partial y} &amp;= \frac{\partial z}{\partial u} \frac{\partial u}{\partial y} + \frac{\partial z}{\partial v} \frac{\partial v}{\partial y} =  2y \frac{\partial z}{\partial v}\end{aligned}\]</span></p><p>带入偏微分方程得到：</p><p><span class="math display">\[y \biggl(\frac{\partial z}{\partial u} + 2x \frac{\partial z}{\partial v}\biggr) - 2xy \frac{\partial z}{\partial v} = y \frac{\partial z}{\partial u} = 0\]</span></p><p>因此 <span class="math inline">\(z = \varphi(x^2 + y^2)\)</span>，其中 <span class="math inline">\(\varphi\)</span> 是任意可导函数。</p></li><li><blockquote><p>设函数 <span class="math inline">\(u = f(\sqrt{x^2 + y^2})\)</span>，其中 <span class="math inline">\(F\)</span> 具有连续的二阶导数，且满足 <span class="math inline">\(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} = x^2 + y^2\)</span>，求函数 <span class="math inline">\(u\)</span> 的表达式。</p></blockquote><p>令 <span class="math inline">\(r = \sqrt{x^2 + y^2}\)</span>，则：</p><p><span class="math display">\[\begin{aligned}\frac{\partial u}{\partial x} &amp;= \frac{\partial u}{\partial r} \frac{\partial r}{\partial x} = \frac{xf&#39;(r)}{r}\\\frac{\partial^2 u}{\partial x^2} &amp;= \frac{f&#39;(r)}{r} + x \frac{\partial}{\partial r} \biggl(\frac{f&#39;(r)}{r}\biggr) \frac{\partial r}{\partial x} = \frac{f&#39;(r)}{r} + \frac{x^2}{r^2} f&#39;&#39;(r) - \frac{x^2}{r^3} f&#39;(r)\\\frac{\partial u}{\partial y} &amp;= \frac{\partial u}{\partial r} \frac{\partial r}{\partial y} = \frac{yf&#39;(r)}{r}\\\frac{\partial^2 u}{\partial y^2} &amp;= \frac{f&#39;(r)}{r} + y \frac{\partial}{\partial r} \biggl(\frac{f&#39;(r)}{r}\biggr) \frac{\partial r}{\partial y} = \frac{f&#39;(r)}{r} + \frac{y^2}{r^2} f&#39;&#39;(r) - \frac{y^2}{r^3} f&#39;(r)\end{aligned}\]</span></p><p>带入微分方程得到：</p><p><span class="math display">\[\begin{aligned}\frac{f&#39;(r)}{r} + \frac{x^2}{r^2} f&#39;&#39;(r) - \frac{x^2}{r^3} f&#39;(r) + \frac{f&#39;(r)}{r} + \frac{y^2}{r^2} f&#39;&#39;(r) - \frac{y^2}{r^3} f&#39;(r) &amp;= \frac{f&#39;(r)}{r} + f&#39;&#39;(r) = r^2\\\frac{\text{d}}{\text{d} r} \biggl(r f&#39;(r)\biggr) &amp;= r^3\\f&#39;(r) &amp;= \frac{r^3}{4} + \frac{C_1}{r}\\f(r) &amp;= \frac{1}{16} r^4 + C_1\ln r + C_2, C_1, C_2 \in R\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(u = f(\ln \sqrt{x^2 + y^2})\)</span>，其中 <span class="math inline">\(f\)</span> 有连续的二阶导数，且满足 <span class="math inline">\(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} = (x^2 + y^2)^{\frac{3}{2}}\)</span>，求 <span class="math inline">\(f(v)\)</span> 的表达式。</p></blockquote><p>设 <span class="math inline">\(v = \ln r\)</span>，<span class="math inline">\(r = \sqrt{x^2 + y^2}\)</span>，由链式法则得到：</p><p><span class="math display">\[\begin{aligned}\frac{\partial u}{\partial x} &amp;= \frac{\text{d} f}{\text{d} v} \frac{\text{d} v}{\text{d} r} \frac{\partial r}{\partial x} = f&#39;(v) \frac{x}{r^2}\\\frac{\partial u}{\partial y} &amp;= \frac{\text{d} f}{\text{d} v} \frac{\text{d} v}{\text{d} r} \frac{\partial r}{\partial y} = f&#39;(v) \frac{y}{r^2}\\\frac{\partial^2 u}{\partial x^2} &amp;= \frac{\text{d}}{\text{d} x} \biggl(f&#39;(v) \frac{x}{r^2}\biggr) = \frac{f&#39;(v)}{r^2} + x^2 \frac{f&#39;&#39;(v)}{r^4} - 2x^2 \frac{f&#39;(v)}{r^4}\\\frac{\partial^2 u}{\partial y^2} &amp;= \frac{\text{d}}{\text{d} y} \biggl(f&#39;(v) \frac{y}{r^2}\biggr) = \frac{f&#39;(v)}{r^2} + y^2 \frac{f&#39;&#39;(v)}{r^4} - 2y^2 \frac{f&#39;(v)}{r^4}\end{aligned}\]</span></p><p>带入微分方程得到：</p><p><span class="math display">\[\begin{aligned}\frac{f&#39;&#39;(v)}{r^2} &amp;= r^3\\f(v) &amp;= \frac{1}{25}\text{e}^{5v} + C_1 v + C_2\end{aligned}\]</span></p></li><li><blockquote><p>证明：在某个开区域上有恒等式 <span class="math inline">\(f(x, y) = \arctan x + \arctan y - \arctan \frac{x + y}{1 - xy} \equiv \pi\)</span>，并求出使之成立的开区域。</p></blockquote><p><span class="math inline">\(f(x, y)\)</span> 分别对 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span> 求偏导</p><p><span class="math display">\[\begin{aligned}\frac{\partial f}{\partial x} &amp;= \frac{1}{1 + x^2} - \frac{1 + y^2}{(1 + x^2)(1 + y^2)} \equiv 0\\\frac{\partial f}{\partial y} &amp;= \frac{1}{1 + y^2} - \frac{1 + x^2}{(1 + x^2)(1 + y^2)} \equiv 0\end{aligned}\]</span></p><p>经检验，开区域：<span class="math inline">\(xy &gt; 1\)</span>，<span class="math inline">\(x &gt; 0\)</span>。</p></li><li><blockquote><p>设二元函数 <span class="math inline">\(f(x, y)\)</span> 有一阶连续偏导数，且 <span class="math inline">\(f(0, 1) \equiv f(1, 0)\)</span>。证明：在单位圆周 <span class="math inline">\(x^2 + y^2 = 1\)</span> 上至少存在两个不同的点满足方程 <span class="math inline">\(y \frac{\partial f}{\partial x} = x \frac{\partial f}{\partial y}\)</span></p></blockquote><p>单位圆周的参数方程为 <span class="math inline">\(x = \cos \theta\)</span>，<span class="math inline">\(y = \sin \theta\)</span>，<span class="math inline">\(0 \leq \theta \leq 2\pi\)</span>，设 <span class="math inline">\(F(\theta) = f(\cos \theta, \sin \theta)\)</span>，<span class="math inline">\(F(0) = F(\frac{\pi}{2}) = F(2\pi)\)</span>，由罗尔定理知存在 <span class="math inline">\(\xi \in (0, \frac{\pi}{2})\)</span>，<span class="math inline">\(\eta \in (\frac{\pi}{2}, 2\pi)\)</span>，使得 <span class="math inline">\(F&#39;(\xi) = F&#39;(\eta) = 0\)</span>，而 <span class="math inline">\(F&#39;(\theta) = -\sin \theta f_1&#39; + \cos \theta f_2&#39;\)</span>，带入 <span class="math inline">\(\xi\)</span>，<span class="math inline">\(\eta\)</span> 得证。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x, y)\)</span> 在区域 <span class="math inline">\(D: x^2 + y^2 \leq R^2\)</span> 上连续，满足 <span class="math inline">\(x \frac{\partial f}{\partial x} + ky\frac{\partial f}{\partial y} = 0\)</span>，其中 <span class="math inline">\(k\)</span> 是正整数。证明：在 <span class="math inline">\(D\)</span> 上 <span class="math inline">\(f(x, y)\)</span> 恒为常数。</p></blockquote><p>对于区域 <span class="math inline">\(D\)</span> 内的点 <span class="math inline">\((x_0, y_0)\)</span>，<span class="math inline">\(x_0 \neq 0\)</span>，不妨设 <span class="math inline">\(0 &lt; x_0 &lt; R\)</span>，做连接点与原点的曲线 <span class="math inline">\(L: x = t, y = \frac{y_0}{x_0^k} t^k\)</span>，<span class="math inline">\(t \in [0, x_0]\)</span>，构造辅助函数 <span class="math inline">\(F(t) = f(t, \frac{y_0}{x_0^k} t^k)\)</span></p></li><li><blockquote><p>设二元函数 <span class="math inline">\(f(x, y)\)</span> 在平面上有连续的二阶偏导数，对任何角度 <span class="math inline">\(\alpha\)</span>，定义一元函数 <span class="math inline">\(g_a(t) = f(t\cos \alpha, t\sin \alpha)\)</span>。若对于任何 <span class="math inline">\(\alpha\)</span> 都有 <span class="math inline">\(\frac{\text{d} g_a(0)}{\text{d} t} = 0\)</span> 且 <span class="math inline">\(\frac{\text{d}^2 g_a(0)}{\text{d} t^2} &gt; 0\)</span>，证明 <span class="math inline">\(f(0, 0)\)</span> 是 <span class="math inline">\(f(x, y)\)</span> 的极小值。</p></blockquote><p>记 <span class="math inline">\(x = t\cos \alpha\)</span>，<span class="math inline">\(y = t\sin \alpha\)</span>，由链式法则得</p><p><span class="math display">\[\begin{aligned}\frac{\partial f}{\partial t} &amp;= \frac{\partial f}{\partial x} \frac{\partial x}{\partial t} + \frac{\partial f}{\partial y} \frac{\partial y}{\partial t} = f_x&#39; \cos \alpha + f_y&#39; \sin \alpha\\\frac{\partial^2 f}{\partial t^2} &amp;= \cos \alpha (f_{xx}&#39;&#39; \cos \alpha + f_{xy}&#39;&#39; \sin \alpha) + \sin \alpha (f_{xy}&#39;&#39; \cos \alpha + f_{yy}&#39;&#39; \sin \alpha)\end{aligned}\]</span></p><p>函数 <span class="math inline">\(f(x, y)\)</span> 在 <span class="math inline">\((0, 0)\)</span> 的 Hessian 矩阵为 <span class="math inline">\(\mathbf{H} = \begin{bmatrix} f_{xx}&#39;&#39; \quad f_{xy}&#39;&#39; \\ f_{yx}&#39;&#39; \quad f_{yy}&#39;&#39;\end{bmatrix}\)</span>，极小值条件等价于 <span class="math inline">\(f_{xx}&#39;&#39; f_{yy}&#39;&#39; - f_{xy}&#39;&#39;^2 &gt; 0\)</span> 且 <span class="math inline">\(f_x&#39;(0, 0) = f_y&#39;(0, 0) = 0\)</span>。根据题目条件，可推出</p><p><span class="math display">\[\frac{\partial f}{\partial t} \bigg|_{t = 0} = f_x&#39;(0, 0) \cos \alpha + f_y&#39;(0, 0) \sin \alpha = 0\]</span></p><p>因为对于任何 <span class="math inline">\(\alpha\)</span> 都上上式，同时因为 <span class="math inline">\(f_x&#39;(0, 0)\)</span> 和 <span class="math inline">\(f_y&#39;(0, 0)\)</span> 存在，所以 <span class="math inline">\(f_x&#39;(0, 0) = f_y&#39;(0, 0) = 0\)</span>。除此之外</p><p><span class="math display">\[\frac{\partial^2 f}{\partial t^2} \bigg|_{t = 0} = \cos \alpha (f_{xx}&#39;&#39; \cos \alpha + f_{xy}&#39;&#39; \sin \alpha) + \sin \alpha (f_{xy}&#39;&#39; \cos \alpha + f_{yy}&#39;&#39; \sin \alpha) &gt; 0\]</span></p><p>对于任何非零向量 <span class="math inline">\(\mathbf{r} = |\mathbf{r}|(\cos \alpha, \sin \alpha)\)</span>，<span class="math inline">\(|\mathbf{r}| \neq 0\)</span>，因此二次型</p><p><span class="math display">\[|\mathbf{r}|^2 \begin{pmatrix}\cos \alpha, \sin \alpha \end{pmatrix} \begin{pmatrix} f_{xx}&#39;&#39; (0, 0) \quad f_{xy}&#39;&#39;(0, 0) \\ f_{yx}&#39;&#39;(0, 0) \quad f_{yy}&#39;&#39;(0, 0)\end{pmatrix} \begin{pmatrix}\cos \alpha \\ \sin \alpha \end{pmatrix} &gt; 0\]</span></p><p>于是 <span class="math inline">\(\mathbf{H}\)</span> 为正定矩阵，则其顺序主子式都大于零，即 <span class="math inline">\(f_{xx}&#39;&#39; &gt; 0\)</span>，<span class="math inline">\(f_{xx}&#39;&#39; f_{yy}&#39;&#39; - f_{xy}&#39;&#39;^2 &gt; 0\)</span>。综上，是极小值点。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>不定积分与定积分</title>
    <link href="/2025/08/01/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
    <url>/2025/08/01/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="基本积分公式">基本积分公式</h2><ol type="1"><li><p><span class="math display">\[\int \frac{1}{x^2 + a^2} \text{d} x = \frac{1}{a} \arctan \frac{x}{a} + C\]</span></p></li><li><p><span class="math display">\[\int \frac{1}{x^2 - a^2} \text{d} x = \frac{1}{2a} \ln \biggl | \frac{x - a}{x + a} \biggr | + C\]</span></p></li><li><p><span class="math display">\[\int \frac{1}{\sqrt{a^2 - x^2}} \text{d} x = \arcsin \frac{x}{a} + C\]</span></p></li><li><p><span class="math display">\[\int \frac{1}{\sqrt{x^2 \pm a^2}} \text{d} x = \ln \bigl | x + \sqrt{x^2 \pm a^2} \bigr | + C\]</span></p></li><li><p><span class="math display">\[\int \sqrt{a^2 - x^2} \text{d} x = \frac{1}{2} \bigl (x\sqrt{a^2 - x^2} + a^2 \arcsin \frac{x}{a} \bigr) + C\]</span></p></li><li><p><span class="math display">\[\int \sqrt{x^2 \pm a^2} \text{d} x = \frac{1}{2} \bigl ( x\sqrt{x^2 \pm a^2} \pm a^2 \ln \bigl| x + x \sqrt{x^2 \pm a^2} \bigr| \bigr) + C\]</span></p></li><li><p><span class="math display">\[\int \sec x \text{d} x = \ln |\sec x + \tan x| + C\]</span></p></li><li><p><span class="math display">\[\int \csc x \text{d} x = \ln |\csc x - \cot x| + C\]</span></p></li><li><p><span class="math display">\[\int \tan x \text{d} x = - \ln | \cos x | + C\]</span></p></li><li><p><span class="math display">\[\int \cot x \text{d} x = \ln |\sin x| + C\]</span></p></li></ol><h2 id="不能表示为初等函数的积分">不能表示为初等函数的积分</h2><ol type="1"><li><p><span class="math display">\[\int \text{e}^{\pm x^2} \text{d} x\]</span></p></li><li><p><span class="math display">\[\int \frac{\sin x}{x} \text{d} x\]</span></p></li><li><p><span class="math display">\[\int \sin x^2 \text{d} x\]</span></p></li><li><p><span class="math display">\[\int \frac{\text{d} x}{\ln x}\]</span></p></li><li><p><span class="math display">\[\int \frac{\text{d} x}{\sqrt{1 + x^4}}\]</span></p></li><li><p><span class="math display">\[\int \sqrt{1 + x^3} \text{d} x\]</span></p></li><li><p><span class="math display">\[\int \sqrt{1 - k^2 \sin^2 x}\text{d} x\]</span></p></li></ol><h2 id="有理函数积分">有理函数积分</h2><ol type="1"><li><p>两种最简分式形式</p><ol type="1"><li><span class="math display">\[ \int \frac{1}{(x - a)^k} \text{d} x \]</span></li><li><span class="math display">\[ \int \frac{Ax + B}{(x^2 + px + q)^k} \text{d} x \ (p^2 - 4q &lt; 0)\]</span></li></ol></li><li><p>对于积分 <span class="math display">\[\int \frac{\text{d} x}{(x^2 + r^2)^k} = I_k\]</span></p><p>有递推公式： <span class="math display">\[I_k = \frac{1}{2(k - 1)r^2}\bigg(\frac{t}{(t^2 + r^2)^{k - 1}} + (2k - 3)I_{k - 1}\bigg)\]</span></p></li><li><p>特例 <span class="math display">\[\int \frac{1}{(x^2 + a^2)^2} \text{d} x = \frac{1}{2a^3} \biggl( \arctan \frac{x}{a}  + \frac{ax}{x^2 + a^2}\biggr) + C\]</span></p></li></ol><h2 id="三角函数有理式积分">三角函数有理式积分</h2><ol type="1"><li><p>通解：<span class="math inline">\(t = \tan \frac{x}{2}\)</span></p></li><li><p>若 <span class="math inline">\(R(\sin x, -\cos x) = -R(\sin x, \cos x)\)</span>，令 <span class="math inline">\(t = \sin x\)</span>。</p></li><li><p>若 <span class="math inline">\(R(-\sin x, \cos x) = -R(\sin x, \cos x)\)</span>，令 <span class="math inline">\(t = \cos x\)</span>。</p></li><li><p>若 <span class="math inline">\(R(-\sin x, -\cos x) = R(\sin x, \cos x)\)</span>，令 <span class="math inline">\(t = \tan x\)</span>。</p></li><li><p><span class="math inline">\(I_n = \int \tan^n x \text{d} x = \frac{\tan^{n - 1} x}{n - 1} - I_{n - 2}\)</span></p></li><li><p><span class="math inline">\(I_n = \int \sin^n x \text{d} x = -\frac{\sin^{n - 1} \cos x}{n} + \frac{n - 1}{n} I_{n - 2}\)</span></p></li></ol><h2 id="三角函数代换法">三角函数代换法</h2><ol type="1"><li><p>若积分形式为$ R(x, )  x$，则令 <span class="math inline">\(x = a\sin t\)</span></p></li><li><p>若积分形式为$ R(x, )  x$，则令 <span class="math inline">\(x = a\tan t\)</span></p></li><li><p>若积分形式为$ R(x, )  x$，则令 <span class="math inline">\(x = a\sec t\)</span></p></li></ol><h2 id="某些根式的换元法">某些根式的换元法</h2><ol type="1"><li><p>若积分形式为$ R(x, )  x$，则令 <span class="math inline">\(u = \sqrt[n]{ax + b}\)</span></p></li><li><p>若积分形式为$ R(x, )  x$，则令 <span class="math inline">\(u = \sqrt[n]{\frac{ax + b}{cx + d}}\)</span></p></li><li><p>若积分形式为$ R(, )  x$，则令 <span class="math inline">\(x = u^{n}\)</span></p></li></ol><h2 id="可积性">可积性</h2><ol type="1"><li><p>可积则有界</p></li><li><p>连续则可积</p></li><li><p>有界且有有限个间断点，则可积</p></li></ol><h2 id="定积分的性质">定积分的性质</h2><ol type="1"><li><p>积分恒等性：设函数 <span class="math inline">\(f(x)\)</span>，<span class="math inline">\(g(x)\)</span> 在区间 <span class="math inline">\([a, b]\)</span> 上连续，且恒有 <span class="math inline">\(f(x) \leq g(x)\)</span>。若 <span class="math inline">\(\int_{a}^{b} f(x) \text{d} x = \int_{a}^{b} g(x) \text{d} x\)</span>，则在 <span class="math inline">\([a, b]\)</span> 上 <span class="math inline">\(f(x) \equiv g(x)\)</span></p></li><li><p>积分中值定理：设函数 <span class="math inline">\(f(x)\)</span> 在区间 <span class="math inline">\([a, b]\)</span> 上连续，<span class="math inline">\(g(x)\)</span> 在 <span class="math inline">\([a, b]\)</span> 上可积且不变号，则至少存在一点 <span class="math inline">\(\xi \in [a, b]\)</span>，使得 <span class="math inline">\(\int_{a}^{b} f(x) g(x) \text{d} x = f(\xi) \int_{a}^{b} g(x) \text{d} x\)</span></p></li></ol><h2 id="定积分简化运算">定积分简化运算</h2><ol type="1"><li><p>设 <span class="math inline">\(n\)</span> 为自然数，则有 <span class="math display">\[I_n = \int_{0}^{\frac{\pi}{2}} \sin^n x \text{d} x = \int_{0}^{\frac{\pi}{2}} \cos^n x \text{d} x\]</span></p><p>并有递推公式 <span class="math display">\[I_n = \frac{n - 1}{n} I_{n - 2}\]</span></p></li><li><p>对于任意整数 <span class="math inline">\(k_1\)</span>，<span class="math inline">\(k_2\)</span>，<span class="math inline">\(n\)</span>，以下积分都等于积分区间的一半 <span class="math display">\[\int_{\frac{\pi}{2} k_1}^{\frac{\pi}{2} k_2} \sin^2 nx \text{d} x\]</span></p><p>和 <span class="math display">\[\int_{\frac{\pi}{2} k_1}^{\frac{\pi}{2} k_2} \cos^2 nx \text{d} x\]</span></p></li><li><p>正交性 以三角函数为例子，函数的集合 <span class="math inline">\(F = \{1, \cos x, \sin x, \cos 2x, \sin 2x, \cdots \}\)</span>，任取其中的两个函数相乘，乘积在区间 <span class="math inline">\([0, 2\pi]\)</span> 上的积分为零。</p></li></ol><h2 id="广义积分">广义积分</h2><h3 id="重要的判定方法">重要的判定方法</h3><h4 id="比较判定法">1. 比较判定法</h4><p>设 <span class="math inline">\(0 \leq f(x) \leq g(x)\)</span> 在 <span class="math inline">\([a, +\infty)\)</span> 上成立：</p><ul><li>若 <span class="math inline">\(\int_a^{+\infty} g(x) \text{d}x\)</span> 收敛，则 <span class="math inline">\(\int_a^{+\infty} f(x) \text{d}x\)</span> 收敛</li><li>若 <span class="math inline">\(\int_a^{+\infty} f(x) \text{d}x\)</span> 发散，则 <span class="math inline">\(\int_a^{+\infty} g(x) \text{d}x\)</span> 发散</li></ul><h4 id="极限判定法">2. 极限判定法</h4><p>设 <span class="math inline">\(f(x) \geq 0\)</span>，<span class="math inline">\(g(x) &gt; 0\)</span>，且 <span class="math inline">\(\lim\limits_{x \to +\infty} \frac{f(x)}{g(x)} = l\)</span>：</p><ul><li>若 <span class="math inline">\(0 &lt; l &lt; +\infty\)</span>，则 <span class="math inline">\(\int_a^{+\infty} f(x) \text{d}x\)</span> 与 <span class="math inline">\(\int_a^{+\infty} g(x) \text{d}x\)</span> 同敛散</li><li>若 <span class="math inline">\(l = 0\)</span> 且 <span class="math inline">\(\int_a^{+\infty} g(x) \text{d}x\)</span> 收敛，则 <span class="math inline">\(\int_a^{+\infty} f(x) \text{d}x\)</span> 收敛</li><li>若 <span class="math inline">\(l = +\infty\)</span> 且 <span class="math inline">\(\int_a^{+\infty} g(x) \text{d}x\)</span> 发散，则 <span class="math inline">\(\int_a^{+\infty} f(x) \text{d}x\)</span> 发散</li></ul><h3 id="常用的标准广义积分">常用的标准广义积分</h3><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>积分</th><th>收敛条件</th><th>结果</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\int_1^{+\infty} \frac{1}{x^p} \text{d}x\)</span></td><td><span class="math inline">\(p &gt; 1\)</span></td><td><span class="math inline">\(\frac{1}{p-1}\)</span></td></tr><tr class="even"><td><span class="math inline">\(\int_0^1 \frac{1}{x^p} \text{d}x\)</span></td><td><span class="math inline">\(p &lt; 1\)</span></td><td><span class="math inline">\(\frac{1}{1-p}\)</span></td></tr><tr class="odd"><td><span class="math inline">\(\int_0^{+\infty} e^{-ax} \text{d}x\)</span></td><td><span class="math inline">\(a &gt; 0\)</span></td><td><span class="math inline">\(\frac{1}{a}\)</span></td></tr><tr class="even"><td><span class="math inline">\(\int_{-\infty}^{+\infty} e^{-x^2} \text{d}x\)</span></td><td>总是收敛</td><td><span class="math inline">\(\sqrt{\pi}\)</span></td></tr></tbody></table></div><h3 id="特殊的广义积分">特殊的广义积分</h3><ol type="1"><li>伽马函数 <span class="math inline">\(\Gamma(s) = \int_{0}^{+\infty} x^{s - 1} \text{e}^{-x} \text{d} x(s &gt; 0)\)</span>，递推公式 <span class="math inline">\(\Gamma(s + 1) = s\Gamma(s)\)</span>，对于任意正整数 <span class="math inline">\(n\)</span> 有 <span class="math inline">\(\Gamma(n + 1) = n!\)</span></li></ol><h3 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h3><ul><li><strong>绝对收敛</strong>：如果 <span class="math inline">\(\int_a^{+\infty} |f(x)| \text{d}x\)</span> 收敛，则称 <span class="math inline">\(\int_a^{+\infty} f(x) \text{d}x\)</span> <strong>绝对收敛</strong></li><li><strong>条件收敛</strong>：如果 <span class="math inline">\(\int_a^{+\infty} f(x) \text{d}x\)</span> 收敛但 <span class="math inline">\(\int_a^{+\infty} |f(x)| \text{d}x\)</span> 发散，则称原积分<strong>条件收敛</strong></li></ul><h2 id="重要公式">重要公式</h2><ol type="1"><li><p>始终存在 <span class="math display">\[\arctan \text{e}^x + \arctan \text{e}^{-x} \equiv \frac{\pi}{2}\]</span></p></li><li><p>设 <span class="math inline">\(f(x)\)</span> 在区间 <span class="math inline">\([0, 1]\)</span> 上连续，有如下公式： <span class="math display">\[\int_{0}^{\pi} x f(\sin x) \text{d} x = \frac{\pi}{2} \int_{0}^{\pi} f(\sin x) \text{d} x\]</span></p><blockquote><p>证明过程只需要令 <span class="math inline">\(x = \pi - u\)</span></p></blockquote></li><li><p>积分的柯西不等式</p><p><span class="math display">\[\bigg(\int_{a}^{b} f(x) g(x) \text{d} x\bigg)^2 \leq \bigg(\int_{a}^{b} f^2(x) \text{d} x\bigg) \cdot \bigg(\int_{a}^{b} g^2(x) \text{d} x\bigg)\]</span></p></li><li><p>设 <span class="math inline">\(f(x)\)</span>，<span class="math inline">\(g(x)\)</span> 都是连续函数，如果 <span class="math inline">\(g(x)\)</span> 是凹函数，则</p><p><span class="math display">\[g\bigg(\frac{1}{b - a} \int_{a}^{b} f(x) \text{d} x\bigg) \leq \frac{1}{b - a} \int_{a}^{b} g[f(x)] \text{d} x\]</span></p><p>特别的，令 <span class="math inline">\(g(x) = x^2\)</span>，则有</p><p><span class="math display">\[\bigg(\int_0^1 f(x) \text{d} x \bigg)^2 \leq \int_0^1 f^2(x) \text{d} x\]</span></p></li></ol><h2 id="例题讲解">例题讲解</h2><h3 id="不定积分">不定积分</h3><ol type="1"><li><blockquote><p>求积分 <span class="math display">\[\int \frac{\text{d} x}{x^4 + 1}\]</span></p></blockquote><p><span class="math display">\[\int \frac{\text{d} x}{x^4 + 1} = \frac{1}{2} \int \frac{1 + \frac{1}{x^2}}{x^2 + \frac{1}{x^2}} \text{d}x - \frac{1}{2} \int \frac{1 - \frac{1}{x^2}}{x^2 + \frac{1}{x^2}} \text{d} x = \frac{1}{2} \int \frac{\text{d}(x - \frac{1}{x})}{(x - \frac{1}{x})^2 + 2} -\frac{1}{2} \int \frac{\text{d} (x + \frac{1}{x})}{(x + \frac{1}{x})^2 - 2}\]</span></p><p>最终结果为： <span class="math display">\[\frac{1}{2 \sqrt{2}} \arctan \frac{x^2 - 1}{\sqrt{2} x} - \frac{1}{4 \sqrt{2}} \ln \biggl | \frac{x^2 - \sqrt{2} x + 1}{x^2 + \sqrt{2} x + 1} \biggr | + C\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(y = f(x)\)</span> 是由方程 <span class="math inline">\(y^2(x - y) = x^2\)</span> 所确定的隐函数，求 <span class="math inline">\(\int \frac{1}{y^2} \text{d}x\)</span></p></blockquote><p>令 <span class="math inline">\(y = ux\)</span>，得</p><p><span class="math display">\[\begin{align*}u^2x^2(x - ux) &amp;= x^2\\u^2(x - ux) &amp;= 1\\x &amp;= \frac{1}{u^2(1 - u)}\end{align*}\]</span></p><p>原式：</p><p><span class="math display">\[\begin{align*}\int \frac{1}{u^2x^2} \text{d}x = \int u^2(1 - u)^2 \frac{3u^2 - 2u}{u^4(1 - u)^2} \text{d}u = \int (3 - \frac{2}{u}) \text{d} u = \frac{3y}{x} - 2 \ln {\frac{y}{x}} + C\end{align*}\]</span></p></li><li><blockquote><p>反函数的不定积分 设 <span class="math inline">\(f(x)\)</span> 可导且单调，<span class="math inline">\(f^{-1}(x)\)</span> 是 <span class="math inline">\(f(x)\)</span> 的反函数。已知</p><p><span class="math display">\[\int f(x) \text{d}x = F(x) + C\]</span></p><p>求 <span class="math inline">\(\int f^{-1}(x) \text{d}x\)</span></p></blockquote><p>令 <span class="math inline">\(y = f(x)\)</span>，则 <span class="math inline">\(x = f^{-1}(y)\)</span>，带入原式得到：</p><p><span class="math display">\[\begin{align*}\int y \text{d} f^{-1}(y) &amp;= F(f^{-1}(y)) + C\\yf^{-1}(y) - \int f^{-1}(y) \text{d}y &amp;= F(f^{-1}(y)) + C\end{align*}\]</span></p><p>所以</p><p><span class="math display">\[\int f^{-1}(x) \text{d}x = xf^{-1}(x) - F(f^{-1}(x)) + C\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x) = \begin{cases}1, &amp;x &lt; 0 \\ x + 1, &amp;0 \leq x \leq 1 \\ 2x, &amp;x &gt; 1 \end{cases}\)</span>，<span class="math inline">\(F(x)\)</span> 是 <span class="math inline">\(f(x)\)</span> 的一个原函数，满足 <span class="math inline">\(F(0) = 0\)</span>，求 <span class="math inline">\(F(x)\)</span> 的表达式。</p></blockquote><p><span class="math display">\[F(x) =\begin{cases}x, &amp;x &lt; 0\\\frac{1}{2}x^2 + x, &amp;0 \leq x \leq 1\\x^2 + \frac{1}{2}, &amp;x &gt; 1\end{cases}\]</span></p></li><li><blockquote><p>设正整数 <span class="math inline">\(n \geq 2\)</span>，求下列积分的递推公式</p><p>(1). <span class="math display">\[\int \tan^n \text{d}x\]</span></p><p>(2). <span class="math display">\[\int \sin^n \text{d}x\]</span></p></blockquote><p>(1). <span class="math display">\[\int \tan^n \text{d}x = \int \frac{1 - \cos^2 x}{\cos^2 x} \tan^{n - 2} \text{d}x = \frac{\tan^{n - 1}}{n - 1} - \int \tan^{n - 2} x \text{d}x\]</span></p><p>(2). <span class="math display">\[\int \sin^n x \text{d}x = \int - \sin^{n - 1} \text{d} \cos x = \frac{- \sin^{n - 1} \cos x}{n} + \frac{n - 1}{n} \int \sin^{n - 2} x \text{d} x\]</span></p></li><li><blockquote><p><span class="math display">\[\int \sin^{2} x \cos^{4} x \text{d} x\]</span> 对于形如 <span class="math inline">\(\int \cos^{m} x \sin^{n} x \text{d} x\)</span> 的积分通常不用万能代换公式化为有理函数积分。积分会退化为对高次有理函数的极其繁琐的部分分式运算。</p></blockquote><p>令 <span class="math inline">\(t = \tan x\)</span>，原式：</p><p><span class="math display">\[\begin{align*}\int \sin^2 x \cos^4 x \text{d}x &amp;= \int \frac{1}{8} \sin^2 2x (\cos 2x + 1) \text{d}x = \frac{1}{16} \int \sin^2 2x \text{d} \sin 2x + \frac{1}{8} \int \sin^2 2x \text{d}x\\&amp;= \frac{1}{48} \sin^3 2x + \frac{1}{16} x - \frac{1}{64} \sin 4x + C\end{align*}\]</span></p></li><li><blockquote><p>求不定积分</p><p><span class="math display">\[\int \frac{1}{\sin^3 x + \cos^3 x} \text{d}x\]</span></p></blockquote><p><span class="math display">\[\begin{align*}\int \frac{1}{\sin^3 x + \cos^3 x} \text{d}x &amp;= \int \frac{1}{(\sin x+ \cos x)(\sin^2 x - \sin x \cos x + \cos^2 x)} \text{d}x\\&amp;= \int \frac{1}{\sqrt{2}\sin (x + \frac{\pi}{4}) [(\sqrt{2} \cos (x + \frac{\pi}{4}))^2 + \sin x \cos x]} \text{d}x\\&amp;= \int \frac{1}{\sqrt{2}\sin (x + \frac{\pi}{4}) \bigl[ (\sqrt{2} \cos (x + \frac{\pi}{4}))^2 + \frac{1}{2}[\sin (x + \frac{\pi}{4}) - \cos (x + \frac{\pi}{4})][\sin (x + \frac{\pi}{4}) + \cos (x + \frac{\pi}{4})] \bigr]} \text{d}x\\&amp;= \int \frac{1}{\sqrt{2}\sin (x + \frac{\pi}{4}) (\sqrt{2} \cos (x + \frac{\pi}{4}))^2 + \frac{1}{2} \bigl[\sin^2 (x + \frac{\pi}{4}) - \cos^2 (x + \frac{\pi}{4}) \bigr]} \text{d}x\\&amp;= \int \frac{-1}{\sqrt{2}\bigl(1 - \cos^2 (x + \frac{\pi}{4})\bigr) \bigl(\frac{1}{2} +  \cos^2 (x + \frac{\pi}{4})\bigr)} \text{d} \cos (x + \frac{\pi}{4})\end{align*}\]</span></p><p>令 <span class="math inline">\(t = \cos (x + \frac{\pi}{4})\)</span></p><p><span class="math display">\[\begin{align*}\int &amp;= \frac{-1}{\sqrt{2}} \int \frac{1}{1 - t^2}\frac{1}{\frac{1}{2} + t^2} \text{d} t\\&amp;= \frac{-2}{3\sqrt{2}} \int \frac{1}{1 - t^2} + \frac{1}{\frac{1}{2} + t^2} \text{d} t\\&amp;= \frac{1}{3\sqrt{2}} \ln \biggl|\frac{t - 1}{t + 1}\biggr| - \frac{2}{3} \arctan(\sqrt{2} t) + C\end{align*}\]</span></p></li><li><blockquote><p>求不定积分</p><p><span class="math display">\[\int \frac{\text{d} x}{(x + 1)^3 \sqrt{x^2 + 2x}}\]</span></p></blockquote><p>令 <span class="math inline">\(x + 1 = \frac{1}{t}\)</span></p><p><span class="math display">\[\begin{align*}\int \frac{\text{d} x}{(x + 1)^3 \sqrt{x^2 + 2x}} &amp;= \int \frac{\frac{-1}{t^2}}{(\frac{1}{t^3} \sqrt{(\frac{1}{t^2}) - 1})} \text{d} t\\&amp;=  \int \frac{1 - t^2}{\sqrt{1 - t^2}} \text{d} t - \int \frac{1}{\sqrt{1 - t^2}} \text{d} t\\&amp;= \int \sqrt{1 - t^2} \text{d} t - \arcsin t + C\\&amp;= \frac{1}{2} t \sqrt{1 - t^2} - \frac{1}{2} \arcsin t + C\\&amp;= \frac{\sqrt{x^2 + 2x}}{2(x + 1)^2} - \frac{1}{2} \arcsin \frac{1}{x + 1} + C\end{align*}\]</span></p></li><li><blockquote><p>求不定积分</p><p><span class="math display">\[\int (1 - \sqrt{x})^{100} \text{d} x\]</span></p></blockquote><p>令 <span class="math inline">\(u = 1 - \sqrt{x}\)</span>，原式：</p><p><span class="math display">\[\int 2u^{100}(u - 1) \text{d} u = 2\int u^{101} - u^{100} \text{d} u = \frac{1}{51} (1 - \sqrt{x})^{102} - \frac{2}{101} (1 - \sqrt{x})^{101} + C\]</span></p></li><li><blockquote><p>求不定积分</p><p><span class="math display">\[\int \frac{\text{d} x}{\sqrt[3]{(x + 1)^2 (x - 1)^4}}\]</span></p></blockquote><p><span class="math display">\[\int = \int \frac{1}{(x^2 - 1)} \sqrt[3]{\frac{x + 1}{x - 1}}\text{d} x\]</span></p><p>令 <span class="math inline">\(t = \sqrt[3]{\frac{x + 1}{x - 1}}\)</span>，得 <span class="math inline">\(x = \frac{2}{t^3 - 1} + 1\)</span>：</p><p><span class="math display">\[\int = \int \frac{-3}{2} \text{d} t = \frac{-3}{2} \sqrt[3]{\frac{x + 1}{x - 1}} + C\]</span></p></li><li><blockquote><p>求不定积分</p><p><span class="math display">\[\int \frac{\text{d} x}{(1 + x^4) \sqrt[4]{(1 + x^4)}}\]</span></p></blockquote><p><span class="math display">\[\int \frac{\text{d} x}{(1 + x^4) \sqrt[4]{(1 + x^4)}} = \frac{-1}{4} \int \frac{1}{(1 + \frac{1}{x^4})^{\frac{5}{4}}} \text{d} (1 + \frac{1}{x^4}) = \frac{|x|}{\sqrt[4]{1 + x^4}} + C\]</span></p></li><li><blockquote><p><span class="math display">\[\int \frac{\text{d} x}{\sqrt[4]{1 + x^4}}\]</span></p></blockquote><p>令 <span class="math inline">\(x = \frac{1}{t}\)</span>，原式为：</p><p><span class="math display">\[-\frac{1}{4} \int \frac{1}{t^4 \sqrt[4]{t^4 + 1}} \text{d} t^4\]</span></p><p>令 <span class="math inline">\(u = t^4\)</span>，原式为：</p><p><span class="math display">\[-\frac{1}{4} \int \frac{1}{u \sqrt[4]{u + 1}} \text{d} u\]</span></p><p>令 <span class="math inline">\(v = \sqrt[4]{u + 1}\)</span>，原式为：</p><p><span class="math display">\[\begin{align*}-\int \frac{v^2}{(v^2 - 1)(v^2 + 1)} \text{d} v &amp;= -\frac{1}{2} \int \biggl[\frac{1}{v^2 - 1} + \frac{1}{v^2 + 1}\biggr] \text{d} v\\&amp;= -\frac{1}{4} \int \biggl[\frac{1}{v - 1} - \frac{1}{v + 1} \biggr] \text{d} v - \frac{1}{2} \arctan v + C\\&amp;= -\frac{1}{4} \ln \biggl|\frac{v - 1}{v + 1} \biggr| - \frac{1}{2} \arctan v + C\end{align*}\]</span></p></li><li><blockquote><p><span class="math display">\[\int \frac{1 - \ln x}{(x - \ln x)^2} \text{d} x\]</span></p></blockquote><p><span class="math display">\[\int \frac{x}{x - \ln x} \text{d} x\]</span></p></li><li><blockquote><p><span class="math display">\[\int \frac{x + 1}{x(1 + x \text{e}^x)} \text{d} x\]</span></p></blockquote><p><span class="math display">\[\int \ln \biggl|\frac{x \text{e}^x}{1 + x \text{e}^x} \biggr| \text{d} x\]</span></p></li><li><blockquote><p><span class="math display">\[\int_0^1 x (1 - x)^{100} \text{d} x\]</span></p></blockquote><p><span class="math display">\[\int_0^1 x (1 - x)^{100} \text{d} x = -\int_0^1 (1 - x)^{101} \text{d} x + \int_0^1 (1 - x)^{100} \text{d} x = \frac{1}{101} - \frac{1}{102}\]</span></p></li><li><blockquote><p><span class="math display">\[\int_{-1}^1 \frac{2x^2 + x\cos x}{1 + \sqrt{1 - x^2}} \text{d}x\]</span></p></blockquote><p>由奇函数性质，原式：</p><p><span class="math display">\[\int_{-1}^1 \frac{(2x^2 )(1 - \sqrt{1 - x^2})}{x^2} \text{d} x = 4 \int_0^1(1 - \sqrt{1 - x^2}) \text{d} x = 4 - 4 \int_0^1 \sqrt{1 - x^2} \text{d} x = 4 - \pi\]</span></p></li><li><blockquote><p>计算 <span class="math display">\[I = \int_0^1 \text{d} x \int_{x - x^3}^{1} (3x^2 - 1) \text{e}^{y^2} \text{d} y\]</span></p></blockquote><p><span class="math display">\[\int_0^1 (3x^2 - 1) \text{d} x \int_{x - x^3}^{1} \text{e}^{y^2} \text{d} y\]</span></p><p>令 <span class="math inline">\(F(x) = \int_{x - x^3}^{1} \text{e}^{y^2} \text{d} y\)</span></p><p><span class="math display">\[\int_0^1 (3x^2 - 1) F(x) \text{d} x = \int_0^1 F(x) \text{d} (x^3 - x) = \frac{1}{2}\int_0^1 \text{e}^{(x - x^3)^2}\text{d} (x^3 - x)^2 = 0\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 连续，对任何 <span class="math inline">\(r &gt; 0\)</span> 积分 <span class="math inline">\(\int_r^{+\infty} \frac{f(x)}{x} \text{d} x\)</span> 都收敛，<span class="math inline">\(f(0) = L\)</span>。证明： <span class="math display">\[\int_0^{+\infty} \frac{f(\alpha x) - f(\beta x)}{x} \text{d} x = L \ln \frac{\beta}{\alpha}\]</span></p><p>其中，<span class="math inline">\(\alpha\)</span>，<span class="math inline">\(\beta &gt; 0\)</span>。</p></blockquote><p><span class="math display">\[\int_r^{+\infty} \frac{f(\alpha x) - f(\beta x)}{x} \text{d} x = \int_{\alpha r}^{\beta r} \frac{f(u)}{u} \text{d} u = f(\xi) \int_{\alpha r}^{\beta r} \frac{1}{u} \text{d} u = f(\xi) \ln \frac{\beta}{\alpha}\]</span></p><p>其中，<span class="math inline">\(\alpha r &lt; \xi &lt; \beta r\)</span>，当 <span class="math inline">\(r \to 0\)</span> 时，得到 <span class="math inline">\(L \ln \frac{\beta}{\alpha}\)</span>。</p></li><li><blockquote><p>设函数</p><p><span class="math display">\[f(x) =\begin{cases}x^2 \sin \frac{1}{x^2}, &amp;x \neq 0\\0, &amp;x = 0\end{cases}\]</span></p><p>证明 <span class="math inline">\(f(x)\)</span> 在闭区间 <span class="math inline">\([-1, 1]\)</span> 上可导，<span class="math inline">\(f&#39;(x)\)</span> 在区间上不可积。</p></blockquote><p><span class="math display">\[f&#39;(x) = 2x \sin \frac{1}{x^2} - 2 \frac{1}{x} \cos \frac{1}{x^2}, x \neq 0\]</span></p><p><span class="math inline">\(x = 0\)</span> 时，有导数定义得</p><p><span class="math display">\[\lim_{x \to 0} \frac{f(x)}{x} = 0\]</span></p><p>故函数 <span class="math inline">\(f&#39;(x)\)</span> 在区间上存在。</p><p>考虑 <span class="math inline">\(f&#39;(x)\)</span> 在 <span class="math inline">\(x = 0\)</span> 处的连续性。</p><p><span class="math display">\[\lim_{x \to 0^+} 2x \sin \frac{1}{x^2} - 2 \frac{1}{x} \cos \frac{1}{x^2}\]</span></p><p>显然极限不存在，所以 <span class="math inline">\(f&#39;(x)\)</span> 在点 <span class="math inline">\(x = 0\)</span> 处不连续，故在区间 <span class="math inline">\([-1, 1]\)</span> 上不可积分。</p></li><li><blockquote><p>设 <span class="math inline">\(s &gt; 0\)</span>，求</p><p><span class="math display">\[I_n = \int_0^{+\infty} \text{e}^{-sx} x^n \text{d} x(n = 1, 2, 3, \cdots)\]</span></p></blockquote><p><span class="math display">\[I_n = \frac{1}{s^{n + 1}}\int_0^{+\infty} \text{e}^{-sx} (sx)^n \text{d} (sx) = \frac{1}{s^{n + 1}} \cdot n!\]</span></p></li><li><blockquote><p><span class="math display">\[\lim_{n \to \infty} \sum_{k = 1}^{n - 1} \biggl(1 + \frac{k}{n} \biggr) \sin \frac{k\pi}{n^2}\]</span></p></blockquote><p><span class="math display">\[\begin{align*}\lim_{n \to \infty} \sum_{k = 1}^{n - 1} \biggl(1 + \frac{k}{n} \biggr) \sin \frac{k\pi}{n^2} = \lim_{n \to \infty} \sum_{k = 1}^{n - 1} \biggl(1 + \frac{k}{n} \biggr) \biggl(\frac{k\pi}{n^2} - \frac{\sin \xi}{2} \biggl(\frac{k\pi}{n^2} \biggr)^2 \biggr) = \frac{5\pi}{6}\end{align*}\]</span></p></li><li><blockquote><p>求</p><p><span class="math display">\[\lim_{n \to \infty} \sum_{j = 1}^{n^2} \frac{n}{n^2 + j^2}\]</span></p></blockquote><p>设</p><p><span class="math display">\[S_n = \sum_{j = 1}^{n^2} \frac{n}{n^2 + j^2} = \sum_{j = 1}^{n^2} \frac{1}{1 + (\frac{j}{n})^2} \frac{1}{n}\]</span></p><p>显然有</p><p><span class="math display">\[\int_{\frac{j}{n}}^{\frac{j + 1}{n}} \frac{\text{d} x}{1 + x^2} &lt; \frac{1}{1 + (\frac{j}{n})^2} \frac{1}{n} &lt; \int_{\frac{j - 1}{n}}^{\frac{j}{n}} \frac{\text{d} x}{1 + x^2}\]</span></p><p>所以</p><p><span class="math display">\[\lim_{n \to \infty} S_n = \frac{\pi}{2}\]</span></p></li><li><blockquote><p>设</p><p><span class="math display">\[A_n = \sum_{j = 1}^{n} \frac{n}{n^2 + j^2}\]</span></p><p>求</p><p><span class="math display">\[\lim_{n \to \infty} n\biggl(\frac{\pi}{4} - A_n \biggr)\]</span></p></blockquote><p>设 <span class="math inline">\(f(x) = \frac{1}{1 + x^2}\)</span>，<span class="math inline">\(J_n = n \bigl(\frac{\pi}{4} - A_n \bigr)\)</span>，<span class="math inline">\(x_i = \frac{i}{n}\)</span>。</p><p><span class="math display">\[\begin{aligned}\frac{\pi}{4} &amp;= \sum_{j = 1}^{n} \int_{x_{i - 1}}^{x_i} f(x) \text{d}x\\A_n &amp;= \sum_{j = 1}^{n} \int_{x_{i - 1}}^{x_i} f(x_i) \text{d}x\\\lim_{n \to \infty} &amp;n \sum_{j = 1}^{n} \int_{x_{i - 1}}^{x_i} \bigl(f(x) - f(x_i)\bigr) \text{d} x\\\lim_{n \to \infty} &amp;n \sum_{j = 1}^{n} \int_{x_{i - 1}}^{x_i} f&#39;[\xi_i(x)] (x - x_i) \text{d} x, \quad \xi_i(x) \in (x_i, x)\\\lim_{n \to \infty} &amp;n \sum_{j = 1}^{n} f&#39;(\eta_i) \int_{x_{i - 1}}^{x_i} (x - x_i) \text{d} x = \frac{-f&#39;(\eta_i)}{2} \cdot \frac{1}{n}\\\lim_{n \to \infty} &amp; \frac{-1}{2} \sum_{j = 1}^{n} f&#39;(\eta_i) \frac{1}{n} = \frac{-1}{2} \cdot \int_0^1 f&#39;(x) \text{d} x = \frac{1}{4}\end{aligned}\]</span></p></li><li><blockquote><p>证明</p><p><span class="math display">\[\int_0^{\frac{\pi}{2}} \sqrt{a^2 \sin^2 \theta + b^2 \cos^2 \theta} \text{d} \theta = a^2 b^2 \int_0^{\frac{\pi}{2}} \frac{1}{(\sqrt{a^2 \sin^2 \theta + b^2 \cos^2 \theta})^3} \text{d} \theta\]</span></p><p><span class="math inline">\(a\)</span>，<span class="math inline">\(b &gt; 0\)</span></p></blockquote><p><span class="math display">\[\begin{aligned}\int_0^{\frac{\pi}{2}} \sqrt{a^2 \sin^2 \theta + b^2 \cos^2 \theta} \text{d} \theta &amp;= \int_0^{\frac{\pi}{2}} \sin \theta \sqrt{a^2 + b^2 \cot^2 \theta} \text{d} \theta\\&amp;= -\int_0^{\frac{\pi}{2}} \frac{\sqrt{a^2 + b^2 \cot^2 \theta}}{(\frac{\sin^2 \theta + \cos^2 \theta}{\sin^2 \theta})^{\frac{3}{2}}} \text{d} \cot \theta\\&amp;= \int_0^{+\infty} \frac{\sqrt{a^2 + b^2 u^2}}{(1 + u^2)^{\frac{3}{2}}} \text{d} u\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}a^2 b^2 \int_0^{\frac{\pi}{2}} \frac{1}{(\sqrt{a^2 \sin^2 \theta + b^2 \cos^2 \theta})^3} \text{d} \theta &amp;= a^2 b^2 \int_0^{\frac{\pi}{2}} \biggl(\sqrt{\frac{\sin^2 \theta + \cos^2 \theta}{a^2 \sin^2 \theta + b^2 \cos^2 \theta}}\biggr)^3 \text{d} \theta\\&amp;=  a^2 b^2 \int_0^{\frac{\pi}{2}} \frac{\bigl(\sqrt{\tan^2 \theta + 1}\bigr)^3}{\bigl(\sqrt{a^2 \tan^2 \theta + b^2}\bigr)^3} \text{d} \theta\\&amp;= a^2 b^2 \int_0^{\frac{\pi}{2}} \frac{\sqrt{\tan^2 \theta + 1}}{\bigl(\sqrt{a^2 \tan^2 \theta + b^2}\bigr)^3} \text{d} \tan \theta\\&amp;= \int_0^{+\infty} \frac{\sqrt{a^2 + b^2 u^2}}{(1 + u^2)^{\frac{3}{2}}} \text{d} u\end{aligned}\]</span></p></li><li><blockquote><p>证明</p><p><span class="math display">\[\int_0^{2\pi} f(a \cos x + b \sin x) \text{d} x = 2 \int_0^{\pi} f(\sqrt{a^2 + b^2} \cos x) \text{d} x\]</span></p><p>其中 <span class="math inline">\(f(x)\)</span> 连续，<span class="math inline">\(a^2 + b^2 \neq 0\)</span>。</p></blockquote><p><span class="math display">\[\begin{aligned}\int_0^{2\pi} f(a \cos x + b \sin x) \text{d} x &amp;= \int_0^{2\pi} f(\sqrt{a^2 + b^2} \cos (x - \theta)) \text{d} x\\&amp;= \int_{-\pi}^{\pi} f(\sqrt{a^2 + b^2} \cos x) \text{d} x\\&amp;= 2 \int_0^{\pi} f(\sqrt{a^2 + b^2} \cos x) \text{d} x\end{aligned}\]</span></p></li><li><blockquote><p>已知 <span class="math inline">\(f(x)\)</span> 连续且 <span class="math inline">\(f(x) = \sin x - \int_0^{x} (x - t) f(t) \text{d} t\)</span>，求 <span class="math inline">\(f(x)\)</span> 的表达式。</p></blockquote><p>等式两端对 <span class="math inline">\(x\)</span> 求导：</p><p><span class="math display">\[\begin{aligned}f&#39;(x) &amp;= \cos x - x f(x) - \int_0^{x} f(t) \text{d} t + x f(x)\\f&#39;&#39;(x) &amp;= -\sin x - f(x)\end{aligned}\]</span></p><p>上述微分方程的通解是：</p><p><span class="math display">\[f(x) = C_1 \cos x + C_2 \sin x + \frac{x \cos x}{2}\]</span></p><p>带入 <span class="math inline">\(f(0) = 0\)</span>，<span class="math inline">\(f&#39;(0) = 1\)</span>，得</p><p><span class="math display">\[f(x) = \frac{1}{2} \sin x + \frac{x \cos x}{2}\]</span></p></li><li><blockquote><p>设可微函数 <span class="math inline">\(y = f(x)\)</span> 满足方程</p><p><span class="math display">\[\int_0^{x} f(t) \text{d} t = x + \int_0^{x} t f(x - t) \text{d} t\]</span></p><p>求 <span class="math inline">\(f(x)\)</span>。</p></blockquote><p><span class="math inline">\(u = x - t\)</span></p><p><span class="math display">\[\begin{aligned}\int_0^{x} f(t) \text{d} t &amp;= x + \int_0^{x} (x - u) f(u) \text{d} u\\f(x) &amp;= 1 + \int_0^{x} f(u) \text{d}u + x f(x) - x f(x)\\f&#39;(x) &amp;= f(x)\end{aligned}\]</span></p><p>所以 <span class="math inline">\(f(x) = \text{e}^x\)</span>。</p></li><li><blockquote><p>设函数 <span class="math inline">\(y = y(x)\)</span> 由方程</p><p><span class="math display">\[x = \int_1^{y - x} \sin^2 \biggl(\frac{\pi t}{4}\biggr) \text{d} t\]</span></p><p>所确定，求 <span class="math inline">\(y&#39;(0)\)</span>。</p></blockquote><p>令 <span class="math inline">\(x = 0\)</span></p><p><span class="math display">\[0 = \int_1^{y(0)} \sin^2 \biggl(\frac{\pi t}{4}\biggr) \text{d} t\]</span></p><p>所以，<span class="math inline">\(y(0) = 1\)</span></p><p><span class="math display">\[1 = (y&#39;(0) - 1) \sin^2 \biggl(\frac{\pi y(0)}{4}\biggr)\]</span></p><p>所以，<span class="math inline">\(y&#39;(0) = 3\)</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是非负的连续函数，且</p><p><span class="math display">\[f(x) \int_0^x f(x - t) \text{d} t = \sin^4 x\]</span></p><p>求 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([0, \pi]\)</span> 上的均值。</p></blockquote><p>令 <span class="math inline">\(u = x - t\)</span>，</p><p><span class="math display">\[\begin{aligned}f(x) \int_0^x f(u) \text{d} u &amp;= \sin^4 x\\\int_0^{\pi} f(x) \int_0^x f(u) \text{d} u  \text{d} x &amp;= \int_0^{\pi} \sin^4 x \text{d} x = \frac{3}{8} \pi\\\int_0^{\pi} f(x) F(x) \text{d} x &amp;= \frac{3}{8} \pi\\\int_0^{\pi} F(x) \text{d} F(x) &amp;= \frac{3}{8} \pi\\F^2(\pi) - \int_0^{\pi} F(x) \text{d} F(x) &amp;= \frac{3}{8} \pi\\F^2(\pi) &amp;= \frac{3}{4} \pi\\F(\pi) &amp;= \frac{\sqrt{3 \pi}}{2}\end{aligned}\]</span></p><p>所以均值 <span class="math inline">\(A = \frac{\sqrt{3 \pi}}{2 \pi}\)</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 可积，对于任意的 <span class="math inline">\(x\)</span> 及 <span class="math inline">\(a\)</span> 满足</p><p><span class="math display">\[\frac{1}{2a} \int_{x - a}^{x + a} f(t) \text{d} t = f(x)(a \neq 0)\]</span></p><p>证明 <span class="math inline">\(f(x)\)</span> 是线性函数。</p></blockquote><p><span class="math display">\[\begin{aligned}\int_{x - a}^{x + a} f(t) \text{d} t &amp;= 2a f(x)\\f(x + a) + f(x - a) &amp;= 2f(x)\\f&#39;(x + a) - f&#39;(x - a) &amp;= 0\\f&#39;(2x) &amp;= f&#39;(0)\end{aligned}\]</span></p><p>所以，<span class="math inline">\(f&#39;(x) \equiv C\)</span>，其中 <span class="math inline">\(C\)</span> 是常数。又题目知，<span class="math inline">\(f(x)\)</span> 连续，再由题设等式知，<span class="math inline">\(f(x)\)</span> 可导，故 <span class="math inline">\(f(x)\)</span> 是线性函数。</p></li><li><blockquote><p> 设函数 <span class="math inline">\(\varphi(x)\)</span> 在 <span class="math inline">\([0, 1]\)</span> 上连续，在 <span class="math inline">\((0, 1]\)</span> 内可导，并有 <span class="math inline">\(\int_0^1 \varphi(tx) \text{d} t = a \varphi(x)\)</span>，其中 <span class="math inline">\(a\)</span> 为常数。试求 <span class="math inline">\(\varphi(x)\)</span>。</p></blockquote><p>令 <span class="math inline">\(u = tx\)</span></p><p><span class="math display">\[\begin{aligned}\int_0^x \varphi(u) \text{d} \frac{u}{x} &amp;= a \varphi(x)\\\varphi(x) &amp;= a \varphi(x) + a x \varphi&#39;(x)\end{aligned}\]</span></p><p><span class="math display">\[\varphi(x) =\begin{cases}0, &amp;a = 0\\Cx^{\frac{1 - a}{a}}, &amp;a \neq 0, C \in R\end{cases}\]</span></p></li><li><blockquote><p>设函数 <span class="math inline">\(f(x)\)</span> 连续，<span class="math inline">\(g(x) = \int_0^1 f(xt) \text{d} t\)</span>，且 <span class="math inline">\(\lim\limits_{x \to 0} \frac{f(x)}{x} = A\)</span>，<span class="math inline">\(A\)</span> 是常数，求 <span class="math inline">\(g&#39;(x)\)</span> 并讨论 <span class="math inline">\(g&#39;(x)\)</span> 在 <span class="math inline">\(x = 0\)</span> 处的连续性。</p></blockquote><p>令 <span class="math inline">\(u = xt\)</span></p><p><span class="math display">\[\begin{aligned}g(x) &amp;= \frac{1}{x} \int_0^x f(u) \text{d} u\\g&#39;(x) &amp;= \frac{f(x) x - \int_0^x f(u) \text{d} u}{x^2}, x \neq 0\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}\lim_{x \to 0} g&#39;(x) &amp;= \lim_{x \to 0} \biggl(\frac{f(x) x - \int_0^x f(u) \text{d} u}{x^2} \biggr)\\&amp;= A - \lim_{x \to 0} \biggl(\frac{\int_0^x f(u) \text{d} u}{x^2}\biggr)\\&amp;= \frac{A}{2}\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在区间 <span class="math inline">\([a, b]\)</span> 上连续，证明下列结论：</p><p>(1). <span class="math inline">\(f(x)\)</span> 为常数的充要条件为对任何 <span class="math inline">\(x \in (a, b)\)</span> 恒有 <span class="math inline">\(\frac{1}{x - a} \int_a^x f(t) \text{d} t = \frac{1}{b - a} \int_a^b f(x) \text{d} x\)</span>；</p><p>(2). <span class="math inline">\(f(x)\)</span> 为常数的充要条件为对任何 <span class="math inline">\(x \in (a, b)\)</span> 恒有 <span class="math inline">\(\frac{1}{x - a} \int_a^x f(t) \text{d} t = \frac{1}{b - x} \int_x^b f(t) \text{d} t\)</span>。</p></blockquote><p>可以尝试用从面积来解释</p></li><li><blockquote><p>设 <span class="math inline">\(x = \int_0^y \frac{\text{d} t}{\sqrt{1 + 4t^2}}\)</span>，证明：<span class="math inline">\(\frac{\text{d}^3 y}{\text{d} x^3} - 4 \frac{\text{d} y}{\text{d} x} = 0\)</span></p></blockquote><p><span class="math display">\[\begin{aligned}\text{d} x &amp;= \frac{\text{d} y}{\sqrt{1 + 4y^2}}\\\frac{\text{d} y}{\text{d} x} &amp;= \sqrt{1 + 4y^2}\\\frac{\text{d}^2 y}{\text{d} x^2} &amp;= \frac{4yy&#39;}{\sqrt{1 + 4y^2}} = 4y\\\frac{\text{d}^3 y}{\text{d} x^3} &amp;= 4 y&#39;\end{aligned}\]</span></p></li><li><blockquote><p>求摆线 <span class="math inline">\(L: x = a(t - \sin t), y = a(1 - \cos t)(0 \leq t \leq 2 \pi)\)</span> 与 <span class="math inline">\(x\)</span> 轴围成的图形绕 <span class="math inline">\(y\)</span> 轴旋转所形成的旋转体体积 <span class="math inline">\(V_y\)</span>。</p></blockquote><p>由柱壳法，设 <span class="math inline">\(y = f(x)(0 \leq x \leq 2\pi a)\)</span>，体积微元 <span class="math inline">\(\text{d} V_y = 2\pi xy \text{d} x\)</span>，则体积可表示为：</p><p><span class="math display">\[V_y = 2\pi \int_0^{2\pi a} xy \text{d} x = 2\pi a^3 \int_0^{2\pi} (t - \sin t)(1 - \cos t)^2 \text{d} t = 6\pi^3 a^3\]</span></p></li><li><blockquote><p>设直线 <span class="math inline">\(l: x + y = 1\)</span>，曲线 <span class="math inline">\(S: \sqrt{x} + \sqrt{y} = 1\)</span>，求由 <span class="math inline">\(l\)</span> 与 <span class="math inline">\(S\)</span> 所围成的平面图形绕 <span class="math inline">\(l\)</span> 旋转所形成的旋转体体积 <span class="math inline">\(V\)</span>。</p></blockquote><p>在曲线上取一点 <span class="math inline">\(P(x, y)\)</span>，该点到直线的距离是 <span class="math inline">\(\rho = \frac{|x + y - 1|}{\sqrt{2}}\)</span>，以 <span class="math inline">\(\rho\)</span> 为长度，旋转轴上 <span class="math inline">\(\text{d} l\)</span> 为宽度作矩形，取体积微元 <span class="math inline">\(\text{d} V = \pi \rho^2 \text{d} l\)</span>，其中 <span class="math inline">\(\text{d} l = \sqrt{2} \text{d} x\)</span>，所以，体积为：</p><p><span class="math display">\[V = \sqrt{2} \int_0^1 \pi \frac{[x + (1 - \sqrt{x})^2 - 1]^2}{2} \text{d} x = \frac{\sqrt{2}}{15} \pi\]</span></p></li><li><blockquote><p>已知空间中的点 <span class="math inline">\(A(1, 0, 0)\)</span>，<span class="math inline">\(B(0, 1, 1)\)</span>，直线 <span class="math inline">\(AB\)</span> 绕 <span class="math inline">\(z\)</span> 轴的旋转面为 <span class="math inline">\(S\)</span>，求 <span class="math inline">\(S\)</span> 与两平面 <span class="math inline">\(z = 0\)</span>，<span class="math inline">\(z = 1\)</span> 所围成的立体的体积 <span class="math inline">\(V\)</span>。</p></blockquote><p>在直线上取一点 <span class="math inline">\(P(x, y, z)\)</span>，该点到 <span class="math inline">\(z\)</span> 轴的距离是 <span class="math inline">\(\rho = \sqrt{x^2 + y^2}\)</span>，以 <span class="math inline">\(\rho\)</span> 为长度，旋转轴上 <span class="math inline">\(\text{d} z\)</span> 为宽度作矩形，取体积微元 <span class="math inline">\(\text{d} V = \pi \rho^2 \text{d} z\)</span>，直线 <span class="math inline">\(AB\)</span> 的方程为：</p><p><span class="math display">\[\begin{cases}y = z\\x = 1 - z\end{cases}\]</span></p><p><span class="math display">\[V = \int_0^1 \pi (1 - 2z + 2z^2) \text{d} z = \frac{2\pi}{3}\]</span></p></li><li><blockquote><p>求曲线 <span class="math inline">\(y = x(x - 1)(x - 2)\)</span> 与 <span class="math inline">\(x\)</span> 轴所围平面区域绕 <span class="math inline">\(y\)</span> 轴旋转所成的旋转体体积 <span class="math inline">\(V_y\)</span>。</p></blockquote><p>用柱壳法</p><p><span class="math display">\[\begin{aligned}2\pi \int_0^2 x |y| \text{d} x &amp;= 2\pi \int_0^1 x^2(x - 1)(x - 2) \text{d} x - 2\pi \int_1^2 x^2(x - 1)(x - 2) \text{d} x\\&amp;= \pi\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a, b]\)</span> 上有连续的导数，<span class="math inline">\(M\)</span> 与 <span class="math inline">\(m\)</span> 分别是 <span class="math inline">\(f(x)\)</span> 的最大值与最小值。证明：<span class="math inline">\(\int_a^b |f&#39;(x)| \text{d} x \geq M - m\)</span>；等号成立当且仅当 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\([a ,b]\)</span> 上的单调函数。</p></blockquote></li><li><blockquote><p>试确定抛物线 <span class="math inline">\(4ay = x^2(a &gt; 0)\)</span> 的一条法线弦（法线穿过抛物线构成的弦）的位置，使得这条弦截该抛物线所成的弓形有最小面积。</p></blockquote><p>该抛物线的参数方程为 <span class="math inline">\(x = 2at\)</span>，<span class="math inline">\(y = at^2(-\infty &lt; t &lt; +\infty)\)</span>，设法线弦交抛物线的交点分别为 <span class="math inline">\(Q(2av, av^2)\)</span>，<span class="math inline">\(P(2au, au^2)\)</span>。 则法线弦的直线方程为：<span class="math inline">\(y = \frac{1}{2}(u + v)x - auv\)</span>。则弓形面积</p><p><span class="math display">\[\begin{aligned}S &amp;= \int_{2av}^{2au} \frac{1}{2}(u + v)x - auv - \frac{1}{4a} x^2 \text{d} x\\&amp;= \frac{1}{4}(u + v)(4a^2u^2 - 4a^2v^2) - auv(2au - 2av) - \frac{1}{4a}(4a^2u^2 - 4a^2v^2)\end{aligned}\]</span></p></li><li><blockquote><p>半径为 <span class="math inline">\(r\)</span> 的初始圆与 <span class="math inline">\(x\)</span> 轴相切于原点，它在 <span class="math inline">\(x\)</span> 轴上向右滚动一周。初始圆上的切点在滚动过程中的轨迹称为旋轮线。它的参数方程为 <span class="math inline">\(L: x = r(\theta - \sin \theta)\)</span>，<span class="math inline">\(y = r(1 - \cos \theta)\)</span>，<span class="math inline">\(0 \leq \theta \leq 2\pi\)</span>，其中 <span class="math inline">\(\theta\)</span> 是滚动圆的旋转角。求旋轮线一拱的弧长 <span class="math inline">\(l\)</span> 以及它与 <span class="math inline">\(x\)</span> 轴所围图形的面积 <span class="math inline">\(A\)</span>。</p></blockquote><p><span class="math display">\[\begin{aligned}l &amp;= \int_0^{2\pi} \sqrt{\biggl(\frac{\text{d} x}{\text{d} \theta}\biggr)^2 + \biggl(\frac{\text{d} y}{\text{d} \theta}\biggr)^2} \text{d} \theta\\&amp;= \int_0^{2\pi} 2r \sqrt{1 - \cos \theta} \text{d} \theta\\&amp;= 8r\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}A &amp;= \int_0^{2\pi r} y(x) \text{d} x\\&amp;= \int_0^{2\pi} r(1 - \cos \theta) \text{d} r(\theta - \sin \theta)\\&amp;= \int_0^{2\pi} r^2 (1 - \cos \theta)^2 \text{d} \theta\\&amp;= 3\pi r^2\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(\Gamma\)</span> 是单位圆周在第一象限的一段圆弧，<span class="math inline">\(A\)</span> 是位于 <span class="math inline">\(\Gamma\)</span> 下方和 <span class="math inline">\(x\)</span> 轴上方区域的面积，<span class="math inline">\(B\)</span> 是位于 <span class="math inline">\(y\)</span> 轴右侧和 <span class="math inline">\(\Gamma\)</span> 左侧之间区域的面积。证明：<span class="math inline">\(A + B\)</span> 只与弧长 <span class="math inline">\(|\Gamma|\)</span> 有关，与 <span class="math inline">\(\Gamma\)</span> 在圆周上的位置无关。</p></blockquote><p>设 <span class="math inline">\(\frac{\pi}{2} &gt; \beta &gt; \alpha &gt; 0\)</span> 所代表的的圆弧是 <span class="math inline">\(\Gamma\)</span>，单位圆的参数方程是 <span class="math inline">\(x = \cos \theta\)</span>，<span class="math inline">\(y = \sin \theta\)</span>，设 <span class="math inline">\(\Gamma\)</span> 的上下端点的坐标分别为 <span class="math inline">\(P\)</span>，<span class="math inline">\(Q\)</span>，坐标分别为 <span class="math inline">\((\cos \beta, \sin \beta)\)</span>，<span class="math inline">\((\cos \alpha, \sin \alpha)\)</span></p><p>先求出 <span class="math inline">\(|\Gamma|\)</span></p><p><span class="math display">\[\begin{aligned}|\Gamma| &amp;= \int_{\alpha}^{\beta} \sqrt{\biggl(\frac{\text{d} x}{\text{d} \theta}\biggr)^2 + \biggl(\frac{\text{d} y}{\text{d} \theta}\biggr)^2} \text{d} \theta\\&amp;= \beta - \alpha\end{aligned}\]</span></p><p>再讨论 <span class="math inline">\(A + B\)</span></p><p><span class="math display">\[\begin{aligned}A &amp;= \int_{\cos \beta}^{\cos \alpha} y(x) \text{d} x\\B &amp;=  \int_{\sin \alpha}^{\sin \beta} x(y) \text{d} y\\A + B &amp;= \int_{\alpha}^{\beta} \sqrt{1 - \cos^2 \theta} \sin \theta \text{d} \theta + \int_{\alpha}^{\beta} \sqrt{1 - \sin^2 \theta} \cos \theta \text{d} \theta\\&amp;= \beta - \alpha\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(C\)</span> 是椭圆，周长为 <span class="math inline">\(l\)</span>。自 <span class="math inline">\(C\)</span> 上一点 <span class="math inline">\(O\)</span> 向外地做它的法线，并沿法线截取线段 <span class="math inline">\(OO&#39; = h\)</span>。当点 <span class="math inline">\(O\)</span> 沿 <span class="math inline">\(C\)</span> 绕行一周后，点 <span class="math inline">\(O&#39;\)</span> 的轨迹构成曲线 <span class="math inline">\(C&#39;\)</span>，证明：</p><p>(1). 曲线 <span class="math inline">\(C&#39;\)</span> 的长度为 <span class="math inline">\(l&#39; = l + 2\pi h\)</span>。</p><p>(2). <span class="math inline">\(C\)</span> 与 <span class="math inline">\(C&#39;\)</span> 所围成的面积是 <span class="math inline">\(lh + \pi h^2\)</span>。</p></blockquote></li><li><blockquote><p>求从原点到曲线 <span class="math inline">\(y^2 = x^3\)</span> 上一点的弧长，已知这一点处的切线与 <span class="math inline">\(x\)</span> 成 <span class="math inline">\(45^{\circ}\)</span>。</p></blockquote><p>曲线上任意一点的斜率为 <span class="math inline">\(\frac{3x^2}{2y}\)</span>，已知曲线上的点与 <span class="math inline">\(x\)</span> 轴成 <span class="math inline">\(45^{\circ}\)</span>，所以该点 <span class="math inline">\(\frac{3x^2}{2y} = \pm 1\)</span></p><p><span class="math display">\[\begin{cases}\frac{3x^2}{2y} = \pm 1\\y^2 = x^3\end{cases}\]</span></p><p>解得 <span class="math inline">\(x = \frac{4}{9}\)</span>，<span class="math inline">\(y = \pm \frac{8}{27}\)</span>，由曲线关于 <span class="math inline">\(x\)</span> 轴对称，所以从原点到这两点的弧长相等，以 <span class="math inline">\((\frac{4}{9}, \frac{8}{27})\)</span> 为例，弧长</p><p><span class="math display">\[\begin{aligned}l &amp;= \int_0^{\frac{4}{9}} \sqrt{(y&#39;)^2 + 1} \text{d} x\\&amp;= \frac{2}{3} \cdot \frac{4}{9} \biggl[\biggl(\frac{9}{4} \cdot \frac{4}{9} + 1\biggr)^{\frac{3}{2}} - \biggl(\frac{9}{4} \cdot 0 + 1\biggr)^{\frac{3}{2}}\biggr]\\&amp;= \frac{8}{27} (2\sqrt{2} - 1)\end{aligned}\]</span></p></li><li><blockquote><p>证明椭圆 <span class="math inline">\(L_1: x = a\cos t\)</span>，<span class="math inline">\(y = b \sin t\)</span> 的周长，<span class="math inline">\(0 \leq t \leq 2\pi\)</span>，<span class="math inline">\(a &gt; b &gt; 0\)</span> 等于正弦曲线 <span class="math inline">\(L_2: y = c \sin \frac{x}{b}\)</span> 的一波之长，<span class="math inline">\(0 \leq x \leq 2\pi b\)</span>，其中 <span class="math inline">\(c = \sqrt{a^2 - b^2}\)</span>。</p></blockquote><p>正弦曲线的一波之长为：</p><p><span class="math display">\[\begin{aligned}l &amp;= \int_0^{2\pi b} \sqrt{(y&#39;)^2 + 1} \text{d} x\\&amp;= \int_0^{2\pi b} \sqrt{(\frac{c}{b} \cos \frac{x}{b})^2 + 1} \text{d} x\\&amp;= \int_0^{2\pi} \sqrt{c^2 \cos^2 u + b^2}  \text{d} u\\&amp;= \int_0^{2\pi} \sqrt{a^2 \cos^2 u + b^2 \sin^2 u} \text{d} u\\&amp;= \int_0^{2\pi} \sqrt{a^2 \sin^2 t + b^2 \cos^2 t} \text{d} t\end{aligned}\]</span></p></li><li><blockquote><p>在平面上有一条从点 <span class="math inline">\((a, 0)\)</span> 向右的射线，线密度为 <span class="math inline">\(\rho\)</span>。在点 <span class="math inline">\((0, h)\)</span> 处，其中 <span class="math inline">\(h &gt; 0\)</span>，有一质量为 <span class="math inline">\(m\)</span> 的质点，求射线对该质点的引力。</p></blockquote><p>射线从 <span class="math inline">\((a, 0)\)</span> 射向 <span class="math inline">\(x\)</span> 轴正无穷，对射线上每个点 <span class="math inline">\((x, 0)\)</span>，取微元，得到线质量为 <span class="math inline">\(\rho \text{d} x\)</span>，设引力为 <span class="math inline">\(\mathbf{F} = (F_x, F_y)\)</span>：</p><p><span class="math display">\[\begin{aligned}F_x &amp;= \int_a^{+\infty} \frac{Gm\rho \text{d} x}{x^2 + h^2} \cdot \frac{x}{\sqrt{x^2 + h^2}}\\&amp;= Gm\rho\int_a^{+\infty} \frac{\text{d} (x^2 + h^2)}{2(x^2 + h^2)^{\frac{3}{2}}}\\&amp;= \frac{Gm\rho}{\sqrt{a^2 + h^2}}\\F_y &amp;= -\int_a^{+\infty} \frac{Gm\rho \text{d} x}{x^2 + h^2} \cdot \frac{h}{\sqrt{x^2 + h^2}}\\&amp;= -Gmh\rho \int_a^{+\infty} \frac{\text{d} x}{(x^2 + h^2)^{\frac{3}{2}}}\\&amp;= \frac{Gm\rho}{h} \biggl(\sin\biggl(\arctan \frac{a}{h}\biggr) - 1\biggr)\end{aligned}\]</span></p></li><li><blockquote><p>已知两条均匀的竿子，每条质量为 <span class="math inline">\(m\)</span>，长度为 <span class="math inline">\(2a\)</span>，相互平行，相距为 <span class="math inline">\(b\)</span>，并且其中心连线与它们垂直。试计算相互引力，并考虑 <span class="math inline">\(a\)</span> 为零的情形。</p></blockquote></li><li><blockquote><p>宽度为 <span class="math inline">\(R\)</span> 的河面上任一点的流速与该点到两岸距离的乘积成正比。已知河道中心线处水的流速为 <span class="math inline">\(v_0\)</span>。求河道上河水的平均流速。</p></blockquote><p>比例系数 <span class="math inline">\(\eta = \frac{4v_0}{R^2}\)</span>，则河面上距离河道 <span class="math inline">\(r\)</span> 的一点的速度为 <span class="math inline">\(\eta \cdot (R - r) \cdot r\)</span>，河面上河水的平均流速为：</p><p><span class="math display">\[\bar{v} = \frac{\int_0^R \eta \cdot (R - r) \cdot r \text{d} r}{R} = \frac{2}{3} v_0\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([0, 1]\)</span> 上可导，<span class="math inline">\(f(0) = 0\)</span>，且当 <span class="math inline">\(x \in (0, 1)\)</span> 时，<span class="math inline">\(0 &lt; f&#39;(x) &lt; 1\)</span>。证明：当 <span class="math inline">\(a \in (0, 1)\)</span> 时，<span class="math inline">\((\int_0^a f(x) \text{d} x)^2 &gt; \int_0^a f^3(x) \text{d} x\)</span>。</p></blockquote><p>设 <span class="math inline">\(F(x) = (\int_0^x f(t) \text{d} t)^2 - \int_0^x f^3(t) \text{d} t\)</span>，<span class="math inline">\(F&#39;(x) = 2 f(x) \int_0^x f(t) \text{d} t - f^3(x) = 2 f(x) [\int_0^x f(t) \text{d} t - \frac{1}{2}f^2(x)] = 2 f(x) g(x)\)</span>，<span class="math inline">\(g&#39;(x) = f(x) - f&#39;(x)f(x) &gt; 0\)</span>，所以 <span class="math inline">\(g(x) &gt; g(0) = 0\)</span>，所以 <span class="math inline">\(F&#39;(x) = 2 f(x) g(x) &gt; 2 f(0) g(0) = 0\)</span>，所以 <span class="math inline">\(F(x) &gt; F(0) = 0\)</span>。得证。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一元函数微分学</title>
    <link href="/2025/07/26/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/"/>
    <url>/2025/07/26/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>包括导数、微分中值定理、导数与函数的单调、极值、凹凸及泰勒公式。</p><span id="more"></span><h2 id="必备知识点">必备知识点</h2><ol type="1"><li><p>导数的定义：</p><p>设函数 <span class="math inline">\(f(x)\)</span> 在点 <span class="math inline">\(x_0\)</span> 的某个领域内有定义，如果极限： <span class="math display">\[\lim_{\Delta x \to 0} \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x}\]</span></p><p>存在，则称函数 <span class="math inline">\(f(x)\)</span> 在点 <span class="math inline">\(x_0\)</span> 处可导，并称此极限值为函数 <span class="math inline">\(f(x)\)</span> 在点 <span class="math inline">\(x_0\)</span> 处的导数，记作： <span class="math display">\[f&#39;(x) = \lim_{\Delta x \to 0} \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x}\]</span></p></li><li><p>微分的定义：</p><p>设函数 <span class="math inline">\(y = f(x)\)</span> 在点 <span class="math inline">\(x_0\)</span> 处可导，则称 <span class="math display">\[dy = f&#39;(x_0) \cdot \text{d}x\]</span></p><p>为函数 <span class="math inline">\(f(x)\)</span> 在点 <span class="math inline">\(x_0\)</span> 处的<strong>微分</strong>，其中 <span class="math inline">\(dx\)</span> 是自变量的增量。 如果函数 <span class="math inline">\(y = f(x)\)</span> 在点 <span class="math inline">\(x\)</span> 处可微，则： <span class="math display">\[\Delta y = f&#39;(x) \cdot \Delta x + o(\Delta x)\]</span></p><p>其中 <span class="math inline">\(o(\Delta x)\)</span> 是比 <span class="math inline">\(\Delta x\)</span> 高阶的无穷小量。</p></li><li><p>存在极限 <span class="math display">\[\lim_{h \to 0} \frac{f[(x + h)^2] - f(x^2)}{h} = [f(x^2)]&#39;\]</span></p></li><li><p>设函数 <span class="math inline">\(y = f(x)\)</span> 在区间 <span class="math inline">\(I\)</span> 上可导，若在 <span class="math inline">\(I\)</span> 上恒有 <span class="math inline">\(f&#39;(x) \geq 0\)</span>，且在 <span class="math inline">\(I\)</span> 中的任何区间上不存在 <span class="math inline">\(f&#39;(x) \equiv 0\)</span>，则 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(I\)</span> 上严格单调增加。</p></li><li><p>函数的凹性：</p><p>设 <span class="math inline">\(f(x)\)</span> 是在区间 <span class="math inline">\(I\)</span> 上的连续函数</p><ol type="1"><li><span class="math inline">\(f(q_1 x_1 + q_2 x_2) \leq q_1 f(x_1) + q_2 f(x_2)\)</span></li><li><span class="math inline">\(f(\frac{x_1 + x_2}{2}) \leq \frac{1}{2} f(x_1) + \frac{1}{2} f(x_2)\)</span></li><li><span class="math inline">\(f(q_1 x_1 + q_2 x_2 + \cdots + q_n x_n) \leq q_1 f(x_1) + q_2 f(x_2) + \cdots + q_n f(x_n)\)</span></li><li>若可导，<span class="math inline">\(f&#39;(x)\)</span> 在 <span class="math inline">\(I\)</span> 上单调递增</li><li>若二阶可导，<span class="math inline">\(f&#39;&#39;(x) \geq 0\)</span></li></ol></li><li><p>高阶导数的莱布尼茨公式：</p><p><span class="math display">\[(uv)^{(n)} = \sum_{k = 0}^{n} \binom{n}{k} u^{(k)} v^{(n - k)}\]</span></p></li><li><p>常用的高阶导数公式：</p><ol type="1"><li><span class="math inline">\((a^x)^{(n)} = a^x \ln^n a\)</span>，<span class="math inline">\(a &gt; 0\)</span></li><li><span class="math inline">\((\log_a x)^{(n)} = (-1)^{n - 1} \frac{(n - 1)!}{x^n \ln a}\)</span>，<span class="math inline">\(a &gt; 0\)</span>，<span class="math inline">\(a \neq 1\)</span></li><li><span class="math inline">\((\cos x)^{(n)} = \cos(x + n \cdot \frac{\pi}{2})\)</span></li><li><span class="math inline">\((\sin x)^{(n)} = \sin(x + n \cdot \frac{\pi}{2})\)</span></li><li><span class="math inline">\((\frac{1}{x + a})^{(n)} = (-1)^n \frac{n!}{(x + a)^{n + 1}}\)</span></li><li><span class="math inline">\((\frac{1}{a - x})^{(n)} = \frac{n!}{(a - x)^{n + 1}}\)</span></li></ol></li><li><p>曲线的曲率与曲率半径：</p><p>设曲线 <span class="math inline">\(L: y = f(x)\)</span> 有连续的二阶导数。它在点 <span class="math inline">\((x, y)\)</span> 处的曲率定义为 <span class="math inline">\(K = \frac{|y&#39;&#39;|}{(1 + y&#39;^2)^{\frac{3}{2}}}\)</span>，曲率半径定义为 <span class="math inline">\(R = \frac{1}{K}\)</span>。</p></li></ol><h2 id="例题讲解">例题讲解</h2><ol type="1"><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x = a\)</span> 处连续，并有 <span class="math inline">\(\lim\limits_{x \to a} \frac{f(x)}{x - a} = k\)</span>。证明：<span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x = a\)</span> 处可导，且 <span class="math inline">\(f&#39;(a) = k\)</span>。</p></blockquote><p>首先由连续性得到 <span class="math inline">\(\lim\limits_{x \to a} f(x) = f(a)\)</span>，由极限与无穷小的关系得到：存在 <span class="math inline">\(a(x)\)</span>，其中 <span class="math inline">\(\lim\limits_{x \to a} a(x) = 0\)</span>，使得 <span class="math inline">\(\frac{f(x)}{x - a} = k + a(x) \Rightarrow f(x) = (x - a)(k + a(x)) \Rightarrow \lim\limits_{x \to a} f(x) = f(a) = \lim\limits_{x \to a} (x - a)(k + a(x)) = 0\)</span>。所以存在 <span class="math inline">\(\lim\limits_{x \to a} \frac{f(x) - f(a)}{x - a} = k\)</span>，由导数定义知，题目结论成立。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在点 <span class="math inline">\(x_0\)</span> 可导，<span class="math inline">\(a_n &lt; x_0 &lt; b_n\)</span> 且 <span class="math inline">\(\lim\limits_{n \to \infty} a_n = \lim\limits_{n \to \infty} b_n = x_0\)</span>。证明：</p><p><span class="math display">\[\lim_{n \to \infty} \frac{f(b_n) - f(a_n)}{b_n - a_n} = f&#39;(x_0)\]</span></p></blockquote><p>记 <span class="math inline">\(\lambda = f&#39;(x_0)\)</span>，由微分的定义可知 <span class="math inline">\(f(x_0 + \Delta x) = f(x_0) + \lambda \Delta x + o(\Delta x)\)</span>，于是有 <span class="math inline">\(f(b_n) = f(x_0) + \lambda(b_n - x_0) + o(b_n - x_0)\)</span>，<span class="math inline">\(f(a_n) = f(x_0) + \lambda(a_n - x_0) + o(a_n - x_0)\)</span>。考虑</p><p><span class="math display">\[\frac{o(b_a - x_0) - o(a_n - x_0)}{b_n - a_n} = \frac{o(b_n - x_0)}{b_n - x_0} \cdot \frac{b_n - x_0}{b_n - a_n} - \frac{o(a_n - x_0)}{a_n - x_0} \cdot \frac{a_n - x_0}{b_n - a_n}\]</span></p><p>因为 <span class="math inline">\(\big|\frac{b_n - x_0}{b_n - a_n} \big| \leq 1\)</span>，<span class="math inline">\(\big|\frac{a_n - x_0}{b_n - a_n} \big| \leq 1\)</span>，所以 <span class="math inline">\(o(b_a - x_0) - o(a_n - x_0) = o(b_n - a_n)\)</span>，于是</p><p><span class="math display">\[f(b_n) - f(a_n) = \lambda(b_n - a_n) + o(b_a - x_0) - o(a_n - x_0) = \lambda(b_n - a_n) + o(b_n - a_n)\]</span></p><p>所以</p><p><span class="math display">\[\lim_{n \to \infty} \frac{f(b_n) - f(a_n)}{b_n - a_n} = f&#39;(x_0)\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在点 <span class="math inline">\(x_0\)</span> 有二阶导数，证明：</p><p><span class="math display">\[\lim_{h \to 0} \frac{f(x_0 + h) - 2f(x_0) + f(x_0 - h)}{h^2} = f&#39;&#39;(x_0)\]</span></p></blockquote><p>此时存在 <span class="math inline">\(x_0\)</span> 的领域 <span class="math inline">\((x_0 - \delta, x_0 + \delta)\)</span>，在此领域上 <span class="math inline">\(f&#39;(x)\)</span> 存在。由洛必达法则及二阶导数的定义得到：</p><p><span class="math display">\[\lim_{h \to 0} \frac{f(x_0 + h) - 2f(x_0) + f(x_0 - h)}{h^2} = \lim_{h \to 0} \frac{f&#39;(x_0 + h) - f&#39;(x_0 - h)}{2h}\\= \frac{1}{2} \lim_{h \to 0} \frac{f&#39;(x_0 + h) - f&#39;(x_0) + f&#39;(x_0) - f&#39;(x_0 - h)}{h} = f&#39;&#39;(x_0)\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x = 1\)</span> 点附近有定义，且在 <span class="math inline">\(x = 1\)</span> 点可导，<span class="math inline">\(f(1) = 0\)</span>，<span class="math inline">\(f&#39;(1) = 2\)</span>。求 <span class="math display">\[\lim_{x \to 0} \frac{f(\sin^2 x + \cos x)}{x^2 + x \tan x}\]</span></p></blockquote><p>由一阶导数定义得到： <span class="math display">\[\lim_{x \to 0} \frac{f(\sin^2 x + \cos x)}{x^2 + x \tan x} = \lim_{x \to 0} \frac{f(\sin^2 x + \cos x) - f(1)}{\sin^2 x + \cos x - 1} \cdot \frac{\sin^2 x + \cos x - 1}{x^2 + x \tan x} = \frac{1}{2}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(a &gt; 0\)</span>，<span class="math inline">\(f(x)\)</span> 在闭区间 <span class="math inline">\([a, b]\)</span> 上连续，在 <span class="math inline">\((a, b)\)</span> 内可导，<span class="math inline">\(f(a) = 0\)</span>。证明：存在 <span class="math inline">\(\xi \in (a, b)\)</span> 使得 <span class="math inline">\(f(\xi) = \frac{b - \xi}{a} f&#39;(\xi)\)</span>。</p></blockquote><p>与欲证等式相对应的微分方程为 <span class="math inline">\(y = \frac{b - x}{a} y&#39;\)</span>，解得 <span class="math inline">\((b - x)^a y = C\)</span>，做辅助函数 <span class="math inline">\(F(x) = (b - x)^a f(x)\)</span>，有 <span class="math inline">\(F(a) = F(b) = 0\)</span>，由罗尔定理得到，存在 <span class="math inline">\(\xi \in (a, b)\)</span>，使得 <span class="math inline">\(F&#39;(\xi) = -a(b - \xi)^{a - 1} f(\xi) + (b - \xi)^{a} f&#39;(\xi) = 0\)</span>，从而得证。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在闭区间 <span class="math inline">\([a, b]\)</span> 上连续，在 <span class="math inline">\((0, 1)\)</span> 内可导，试证：存在 <span class="math inline">\(\xi \in (0, 1)\)</span> 使得</p><p><span class="math display">\[\frac{\pi}{4} (1 + \xi^2) f(1) = f(\xi) + (1 + \xi^2) \arctan \xi \cdot f&#39;(\xi)\]</span></p></blockquote></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a, b]\)</span> 上有 <span class="math inline">\(n + 1\)</span> 阶导数，且 <span class="math inline">\(f^{(k)}(a) = f^{(k)}(b) = 0(k = 0, 1, 2, \cdots, n)\)</span>。证明：存在 <span class="math inline">\(\xi \in (a, b)\)</span>，使得 <span class="math inline">\(f^{(n + 1)} (\xi) = f(\xi)\)</span>。</p></blockquote><p>构造函数 <span class="math inline">\(F(x) = (f(x) + f^{(1)}(x) + f^{(2)}(x) + \cdots + f^{(n)}(x)) \text{e}^{-x}\)</span>，<span class="math inline">\(F(a) = F(b) = 0\)</span>，所以存在 <span class="math inline">\(\xi \in (a, b)\)</span>，使得 <span class="math inline">\(F&#39;(\xi) = (f^{(n + 1)}(x) - f(x)) \text{e}^{-x} = 0\)</span>，即 <span class="math inline">\(f^{(n + 1)} (\xi) = f(\xi)\)</span>。</p></li><li><blockquote><p><span class="math inline">\(f(x)\)</span> 在区间 <span class="math inline">\([0, 3]\)</span> 上连续，在 <span class="math inline">\((0, 3)\)</span> 内可导，<span class="math inline">\(f(0) + f(1) + f(2) = 3\)</span>，<span class="math inline">\(f(3) = 1\)</span>。证明：存在 <span class="math inline">\(\xi \in (0, 3)\)</span>，使得 <span class="math inline">\(f&#39;&#39;(\xi) = 0\)</span>。</p></blockquote></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a ,b]\)</span> 上有二阶导数，<span class="math inline">\(f(a) = f(b) = f&#39;(a) = f&#39;(b) = 0\)</span>，又存在常数 <span class="math inline">\(M\)</span>，使得在 <span class="math inline">\([a, b]\)</span> 上恒有 <span class="math inline">\(|f&#39;&#39;(x)| \leq M\)</span>。证明：在 <span class="math inline">\([a, b]\)</span> 上恒有 <span class="math inline">\(|f(x)| \leq \frac{M}{16}(b - a)^2\)</span></p></blockquote></li><li><blockquote><p>设函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([0, +\infty]\)</span> 上有二阶导数，且 <span class="math inline">\(f&#39;&#39;(x) &lt; 0\)</span>，<span class="math inline">\(f(0) = 0\)</span>。证明对任何正数 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span> 都有 <span class="math inline">\(f(x_1 + x_2) &lt; f(x_1) + f(x_2)\)</span> 成立。</p></blockquote><p>不妨设 <span class="math inline">\(x_2 \geq x_1 &gt; 0\)</span>，</p><p><span class="math display">\[\begin{aligned}f(x_1 + x_2) - f(x_2) - [f(x_1) - f(0)] &amp;= x_1 f&#39;(\xi) - x_1 f&#39;(\zeta) &lt; 0, x_1 + x_2 &gt; \xi &gt; x_2, x_1 &gt; \zeta &gt; 0\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([-2, 2]\)</span> 上二阶可导，且 <span class="math inline">\(|f(x)| \leq 1\)</span>。又 <span class="math inline">\(f^2(0) + [f&#39;(0)]^2 = 4\)</span>。试证：在 <span class="math inline">\((-2, 2)\)</span> 内至少存在一点 <span class="math inline">\(\xi\)</span>，使得 <span class="math inline">\(f(\xi) + f&#39;&#39;(\xi) = 0\)</span>。</p></blockquote><p>设 <span class="math inline">\(F(x) = f^2(x) + [f&#39;(x)]^2\)</span>，<span class="math inline">\(F&#39;(x) = 2 f(x) f&#39;(x) + 2 f&#39;(x) f&#39;&#39;(x) = 2 f&#39;(x) [f(x) + f&#39;&#39;(x)]\)</span>，设 <span class="math inline">\(\xi\)</span> 是 <span class="math inline">\(F(x)\)</span> 的一个极值点，则</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([0, +\infty]\)</span> 上可导，<span class="math inline">\(f&#39;(x)\)</span> 单调增加且 <span class="math inline">\(f(0) = 0\)</span>。证明：<span class="math inline">\(g(x) = \frac{f(x)}{x}\)</span> 在 <span class="math inline">\((0, +\infty)\)</span> 内单调增加。</p></blockquote><p>显然 <span class="math inline">\(g(x)\)</span> 在区间 <span class="math inline">\((0, +\infty)\)</span> 上可导，<span class="math inline">\(g&#39;(x) = \frac{xf&#39;(x) - f(x)}{x^2}\)</span>，故只需要证明 <span class="math inline">\(xf&#39;(x) - f(x) \geq 0\)</span>，即证明 <span class="math inline">\(f&#39;(x) \geq \frac{f(x)}{x}\)</span>。</p><p>由拉格朗日中值定理和 <span class="math inline">\(f&#39;(x)\)</span> 的单调性得：</p><p><span class="math display">\[\frac{f(x) - f(0)}{x - 0} = f&#39;(\xi) \leq f&#39;(x), x &gt; \xi &gt; 0\]</span></p></li><li><blockquote><p>证明不等式：</p><p><span class="math display">\[\frac{|a + b|}{1 + |a + b|} \leq \frac{|a|}{1 + |a|} + \frac{|b|}{1 + |b|}\]</span></p></blockquote><p>设 <span class="math inline">\(f(x) = \frac{x}{1 + x}\)</span>，<span class="math inline">\(x \geq 0\)</span>，显然 <span class="math inline">\(f(x)\)</span> 单调递增，只需证明：<span class="math inline">\(f(|a|) + f(|b|) \geq f(|a + b|)\)</span>，由三角不等式 <span class="math inline">\(|a + b| \leq |a| + |b|\)</span> 得：</p><p><span class="math display">\[\frac{|a + b|}{1 + |a + b|} \leq \frac{|a| + |b|}{1 + |a| + |b|} \leq \frac{|a|}{1 + |a|} + \frac{|b|}{1 + |b|}\]</span></p></li><li><blockquote><p>若 <span class="math inline">\(b &gt; a &gt; 0\)</span>，证明：</p><p><span class="math display">\[(1 + a) \ln (1 + a) + (1 + b) \ln (1 + b) \leq (1 + a + b) \ln (1 + a + b)\]</span></p></blockquote><p>由拉格朗日中值定理及 <span class="math inline">\(f(x) = x \ln x\)</span> 的单调性得到：</p><p><span class="math display">\[\begin{aligned}f(1 + a) - f(1) &amp;= a f&#39;(\zeta), 1 + a &gt; \zeta &gt; 1\\f(1 + a + b) - f(1 + b) =&amp;= a f&#39;(\xi), 1 + a + b &gt; \xi &gt; 1 + b &gt; \zeta\end{aligned}\]</span></p><p>所以，</p><p><span class="math display">\[a f&#39;(\xi) - a f&#39;(\zeta) &gt; 0 \Longleftrightarrow f(1 + a + b) - f(1 + b) \geq f(1 + a)\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([0, + \infty]\)</span> 上可导，<span class="math inline">\(f(0) = 0\)</span>，<span class="math inline">\(0 \leq f&#39;(x) \leq f(x)\)</span>，证明：<span class="math inline">\(f(x) \equiv 0\)</span></p></blockquote><p>构造函数 <span class="math inline">\(F(x) = \text{e}^{-x} f(x)\)</span>，<span class="math inline">\(F&#39;(x) = \text{e}^{-x} [f&#39;(x) - f(x)] \leq 0\)</span>，所以 <span class="math inline">\(F(0) \geq F(x) \geq 0\)</span>，故 <span class="math inline">\(f(x) \equiv 0\)</span>。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 可导，<span class="math inline">\(f(\frac{\pi}{2}) = 1\)</span>，且满足 <span class="math inline">\(\lim\limits_{n \to \infty} \biggl(\frac{f(x + \frac{1}{n})}{f(x)}\biggr)^n = \text{e}^{\cot x}\)</span>，求 <span class="math inline">\(f(x)\)</span></p></blockquote><p><span class="math display">\[\lim_{n \to \infty} \biggl(\frac{f(x + \frac{1}{n})}{f(x)}\biggr)^n = \lim_{n \to \infty} \biggl(1 + \frac{f(x + \frac{1}{n}) - f(x)}{f(x)}\biggr)^n\]</span></p><p>故</p><p><span class="math display">\[\begin{aligned}\lim_{n \to \infty} n\frac{f(x + \frac{1}{n}) - f(x)}{f(x)} &amp;= \lim_{n \to \infty} \frac{f(x + \frac{1}{n}) - f(x)}{\frac{1}{n}} f(x) = \cot x\\f&#39;(x) &amp;= f(x) \cot x\\f(x) &amp;= \sin x\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a, b]\)</span> 上有二阶连续导数，且满足方程 <span class="math inline">\(f&#39;&#39;(x) + x^2 f&#39;(x) - 2f(x) = 0\)</span>。证明：若 <span class="math inline">\(f(a) = f(b) = 0\)</span>，则 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a, b]\)</span> 上恒为 0。</p></blockquote><p>考虑函数在区间上的极大值 <span class="math inline">\(M\)</span> 与极小值 <span class="math inline">\(m\)</span>，对于极大值点 <span class="math inline">\(x_0\)</span>，$f’’(x_0) = 2 f(x_0)  $，即 <span class="math inline">\(f(x) \leq 0\)</span>，对于极小值点同理可得 <span class="math inline">\(f(x) \geq 0\)</span>，故 <span class="math inline">\(f(x) \equiv 0\)</span>。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((-\infty, +\infty)\)</span> 上有任意阶导数，且满足：</p><p>(1). 存在 <span class="math inline">\(M &gt; 0\)</span>，使得对任何 <span class="math inline">\(x\)</span>，<span class="math inline">\(n\)</span> 都有 <span class="math inline">\(|f^{(n)}(x)| \leq M\)</span>；</p><p>(2). <span class="math inline">\(f(\frac{1}{n}) = 0(n = 1, 2, \cdots )\)</span>。</p><p>证明：在 <span class="math inline">\((-\infty, +\infty)\)</span> 上，<span class="math inline">\(f(x) \equiv 0\)</span>。</p></blockquote></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([0, +\infty]\)</span> 上有连续的导数，<span class="math inline">\(f(0) = 1\)</span>，且对一切 <span class="math inline">\(x \geq 0\)</span> 有 <span class="math inline">\(|f(x)| \leq \text{e}^{-x}\)</span>。求证：存在 <span class="math inline">\(\xi \in (0, +\infty)\)</span> 使得 <span class="math inline">\(f&#39;(\xi) = -\text{e}^{-\xi}\)</span>。</p></blockquote><p>构造辅助函数 <span class="math inline">\(F(x) = f(x) - \text{e}^{-x}\)</span>，<span class="math inline">\(F(0) = 0\)</span>，<span class="math inline">\(\lim\limits_{x \to +\infty} F(x) = 0\)</span>，由无穷区间上的罗尔定理得：存在 <span class="math inline">\(\xi \in (0, +\infty)\)</span>，使得 <span class="math inline">\(F&#39;(\xi) = 0\)</span>，即 <span class="math inline">\(f&#39;(\xi) = -\text{e}^{-\xi}\)</span>。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([0, +\infty]\)</span> 上可导，且 <span class="math inline">\(0 \leq f(x) \leq \frac{x}{1 + x^2}\)</span>，证明：存在 <span class="math inline">\(\xi \in (0, +\infty)\)</span> 使得</p><p><span class="math display">\[f&#39;(\xi) = \frac{1 - \xi^2}{(1 + \xi^2)^2}\]</span></p></blockquote><p>构造函数 <span class="math inline">\(F(x) = f(x) - \frac{x}{1 + x^2}\)</span>，<span class="math inline">\(F(0) = 0\)</span>，<span class="math inline">\(\lim\limits_{x \to +\infty} F(x) = 0\)</span>，由无穷区间上的罗尔定理得，存在 <span class="math inline">\(\xi \in (0, +\infty)\)</span>，使得 <span class="math inline">\(F&#39;(\xi) = f&#39;(\xi) - \frac{1 - \xi^2}{(1 + \xi^2)^2} = 0\)</span>。</p></li><li><blockquote><p>已知函数 <span class="math inline">\(f(x)\)</span> 在区间 <span class="math inline">\([0, 1]\)</span> 上连续，在 <span class="math inline">\((0, 1)\)</span> 内可导，且 <span class="math inline">\(f(0) = 0\)</span>，<span class="math inline">\(f(1) = 1\)</span>。证明：存在两个不同的 <span class="math inline">\(\eta\)</span>，<span class="math inline">\(\xi \in (0, 1)\)</span> 使得 <span class="math inline">\(f&#39;(\xi)f&#39;(\eta) = 1\)</span>。</p></blockquote><p>构造函数 <span class="math inline">\(F(x) = f(x) + x - 1\)</span>，则 <span class="math inline">\(F(0) = -1\)</span>，<span class="math inline">\(F(1) = 1\)</span>，由连续函数的零点定理得：存在 <span class="math inline">\(F(c) = 0\)</span>，<span class="math inline">\(c \in (0, 1)\)</span>。于是有 <span class="math inline">\(f(c) = 1 - c\)</span>，<span class="math inline">\(c = 1 - f(c)\)</span>，两式相除得：</p><p><span class="math display">\[\frac{f(c)}{c} = \frac{1 - c}{1 - f(c)} = \frac{f(c) - f(0)}{c - 0}\]</span></p><p>故由拉格朗日中值定理得：</p><p><span class="math display">\[\frac{f&#39;(\xi) c}{c} = \frac{1 - c}{f&#39;(\eta)(1 - c)}, c &gt; \xi &gt; 0, 1 &gt; \eta &gt; c\]</span></p><p>即 <span class="math inline">\(f&#39;(\xi)f&#39;(\eta) = 1\)</span>。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([0, 1]\)</span> 上连续，在 <span class="math inline">\((0, 1)\)</span> 内可导，<span class="math inline">\(f(0) = 0\)</span>，<span class="math inline">\(f(1) = 1\)</span>，<span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span> 为正数。证明：</p><p>(1). 存在 <span class="math inline">\(\xi\)</span>，<span class="math inline">\(\eta\)</span>，<span class="math inline">\(0 &lt; \xi &lt; \eta &lt; 1\)</span>，使得 <span class="math inline">\(\frac{a}{f&#39;(\xi)} + \frac{b}{f&#39;(\eta)} = a + b\)</span>；</p><p>(2). 存在 <span class="math inline">\(\xi\)</span>，<span class="math inline">\(\eta\)</span>，<span class="math inline">\(0 &lt; \xi &lt; \eta &lt; 1\)</span>，使得 <span class="math inline">\(af&#39;(\xi) + bf&#39;(\eta) = a + b\)</span></p></blockquote><p>(1). 变形：</p><p><span class="math display">\[\frac{a}{a + b} \frac{1}{f&#39;(\xi)} + \frac{b}{a + b} \frac{1}{f&#39;(\eta)} = 1\]</span></p><p>记 <span class="math inline">\(\frac{a}{a + b} = \lambda \in (0, 1)\)</span>，由介质定理得：存在 <span class="math inline">\(f(c) = \lambda\)</span>，由拉格朗日中值定理得：存在 <span class="math inline">\(\xi \in (0, c)\)</span>，使得 <span class="math inline">\(f(c) - f(0) = c f&#39;(\xi)\)</span>，由此 <span class="math inline">\(\frac{\lambda}{f&#39;(\xi)} = c\)</span>，同理，存在 <span class="math inline">\(\eta \in (c, 1)\)</span> 使得 <span class="math inline">\(\frac{1 - \lambda}{f&#39;(\eta)} = 1 - c\)</span>，相加得证。</p><p>(2). 记 <span class="math inline">\(\frac{a}{a + b} = \lambda \in (0, 1)\)</span>，由拉格朗日中值定理得：存在 <span class="math inline">\(\xi \in (0, \lambda)\)</span>，使得 <span class="math inline">\(f(\lambda) - f(0) = \lambda f&#39;(\xi)\)</span>；存在 <span class="math inline">\(\eta \in (\lambda, 1)\)</span>，使得 <span class="math inline">\(f(1) - f(\lambda) = (1 - \lambda) f&#39;(\eta)\)</span>，相加得证。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a ,b]\)</span> 上连续，在 <span class="math inline">\((a, b)\)</span> 内可导，且 <span class="math inline">\(f(a) = f(b) = 1\)</span>。证明：存在 <span class="math inline">\(\xi\)</span>，<span class="math inline">\(\eta \in (a, b)\)</span>，使得 <span class="math inline">\(\text{e}^{\eta - \xi} [f(\eta) + f&#39;(\eta)] = 1\)</span>。</p></blockquote><p>即证明：<span class="math inline">\(\text{e}^{\eta} [f(\eta) + f&#39;(\eta)] = \text{e}^{\xi}\)</span>，构造辅助函数 <span class="math inline">\(F(x) = f(x) \text{e}^{x}\)</span>，由拉格朗日中值定理得：</p><p><span class="math display">\[\text{e}^{\xi} = \frac{\text{e}^b - \text{e}^a}{b - a} = \frac{F(b) - F(a)}{b - a} = F&#39;(\eta)\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a, c]\)</span> 上连续，<span class="math inline">\(f&#39;(x)\)</span> 在 <span class="math inline">\((a, c)\)</span> 内严格单调增加，证明：对于任何 <span class="math inline">\(b \in (a, c)\)</span>，都成立着不等式</p><p><span class="math display">\[(b - a) f(c) + (c - b) f(a) &gt; (c - a) f(b)\]</span></p></blockquote><p>显然，<span class="math inline">\(f(x)\)</span> 是凹函数，故</p><p><span class="math display">\[\begin{aligned}\frac{b - a}{c - a} f(c) + \frac{c - b}{c - a} f(a) &gt; f(\frac{b - a}{c - a} \cdot c + \frac{c - b}{c - a} \cdot a) = f(b)\end{aligned}\]</span></p></li><li><blockquote><p>证明：对于任何正数 <span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>，<span class="math inline">\(c\)</span>，不等式</p><p><span class="math display">\[a \ln a + b \ln b + c \ln c \geq (a + b + c) \ln \frac{a + b + c}{3}\]</span></p><p>都成立；其中的等号成立当且仅当 <span class="math inline">\(a = b = c\)</span>。</p></blockquote><p>显然 <span class="math inline">\(f(x) = x \ln x\)</span> 是严格凹函数，则由凹函数的性质得：</p><p><span class="math display">\[\frac{1}{3} (f(a) + f(b) + f(c)) \geq f(\frac{1}{3}(a + b + c))\]</span></p><p>再由严格凹函数的性质得其中的等号成立当且仅当 <span class="math inline">\(a = b = c\)</span>。</p></li><li><blockquote><p>设 <span class="math inline">\(0 &lt; x_i &lt; \pi(i = 1, 2, \cdots, n)\)</span>，记 <span class="math inline">\(x = \frac{x_1 + x_2 + \cdots + x_n}{n}\)</span>，证明：<span class="math inline">\(\prod\limits_{i = 1}^{n} \frac{\sin x_i}{x_i} \leq \bigl(\frac{\sin x}{x}\bigr)^{n}\)</span></p></blockquote><p>设 <span class="math inline">\(f(x) = - \ln \frac{\sin x}{x}\)</span>，<span class="math inline">\(f&#39;&#39;(x) = \bigl(\frac{1}{\sin x} - \frac{1}{t}\bigr)\bigr(\frac{1}{\sin x} + \frac{1}{t}\bigl) &gt; 0\)</span>，所以 <span class="math inline">\(f(x)\)</span> 是严格凹函数，由凹函数的性质得：</p><p><span class="math display">\[\begin{aligned}\frac{-1}{n} \sum_{i = 1}^{n} \biggl(\ln \frac{\sin x_i}{x_i}\biggr) &amp;\geq - \ln \frac{\sin x}{x}\\\biggl(\frac{\sin x}{x}\biggr)^{n} &amp;\geq \prod_{i = 1}^{n} \frac{\sin x_i}{x_i}\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span> 是正数，证明：<span class="math inline">\(a^s b^t \leq as + bt\)</span>，其中 <span class="math inline">\(s\)</span>，<span class="math inline">\(t\)</span> 是正数且 <span class="math inline">\(s + t = 1\)</span>，当且仅当 <span class="math inline">\(a = b\)</span> 时，不等式的等号成立。</p></blockquote><p>设 <span class="math inline">\(f(x) = \ln x\)</span>，则 <span class="math inline">\(f&#39;&#39;(x) = - \frac{1}{x^2} &lt; 0\)</span>，所以 <span class="math inline">\(f(x)\)</span> 是凸函数，根据凸函数的性质得：</p><p><span class="math display">\[\begin{aligned}s f(a) + t f(b) &amp;\leq f(sa + tb)\\\ln (a^s b^t) &amp;\leq \ln (sa + tb)\end{aligned}\]</span></p></li><li><blockquote><p>证明柯西不等式 <span class="math inline">\(|a_1b_1 + a_2b_2 + \cdots + a_nb_n| \leq \sqrt{a_1^2 + a_2^2 + \cdots + a_n^2} \sqrt{b_1^2 + b_2^2 + \cdots + b_n^2}\)</span>，等号成立当且仅当存在 <span class="math inline">\(\lambda\)</span> 使得 <span class="math inline">\(a_1 = \lambda b_1\)</span>，<span class="math inline">\(a_2 = \lambda b_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(a_n = \lambda b_n\)</span>。</p></blockquote><p>设函数 <span class="math inline">\(f(x) = (a_1 x + b_1)^2 + (a_2 x + b_2)^2 + \cdots + (a_n x + b_n)^2 = (a_1^2 + a_2^2 + \cdots + a_n^2) x^2 + 2(a_1b_1 + a_2b_2 + \cdots + a_nb_n)x + (b_1^2 + b_2^2 + \cdots + b_n^2) \geq 0\)</span>，所以 <span class="math inline">\(\Delta = 4(a_1^2 + a_2^2 + \cdots + a_n^2)(b_1^2 + b_2^2 + \cdots + b_n^2) - 4(a_1b_1 + a_2b_2 + \cdots + a_nb_n)^2 \geq 0\)</span>，得证不等式；等号成立时可知此时函数只有一个实根，设为 <span class="math inline">\(f(\lambda) = 0\)</span>，可得 <span class="math inline">\(a_1 = \lambda b_1\)</span>，<span class="math inline">\(a_2 = \lambda b_2\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(a_n = \lambda b_n\)</span>。</p></li><li><blockquote><p>设 <span class="math inline">\(p\)</span>，<span class="math inline">\(q\)</span> 都是正数且 <span class="math inline">\(p + q = 1\)</span>，证明不等式：</p><p>(1). <span class="math inline">\(p^p q^q \geq \frac{1}{2}\)</span></p><p>(2). <span class="math inline">\(p^q q^p \leq \frac{1}{2}\)</span></p><p>(3). 在前两个不等式中等号成立当且仅当 <span class="math inline">\(p = q = \frac{1}{2}\)</span></p></blockquote><p>(1). 设 <span class="math inline">\(f(x) = x \ln x\)</span>，显然 <span class="math inline">\(f(x)\)</span> 是凹函数，则由凹函数的性质得：</p><p><span class="math display">\[\begin{aligned}\frac{1}{2} (f(p) + f(q)) &amp;\geq f(\frac{1}{2}(p + q))\\\frac{1}{2} \ln (p^p q^q) &amp;\geq \frac{1}{2} \ln \frac{1}{2}\\p^p q^q &amp;\geq \frac{1}{2}\end{aligned}\]</span></p><p>等号成立当且仅当 <span class="math inline">\(p = q\)</span>，带入求得 <span class="math inline">\(p = q =\frac{1}{2}\)</span></p><p>(2). 设 <span class="math inline">\(f(x) = \ln x\)</span>，显然 <span class="math inline">\(f(x)\)</span> 是凸函数，则由凸函数的性质得：</p><p><span class="math display">\[\begin{aligned}q f(p) + p f(q) &amp;\leq f(2pq)\\\ln p^q q^p &amp;\leq \ln (2pq) \leq \ln \biggl(\frac{(p + q)^2}{2}\biggr) = \ln \biggl(\frac{1}{2}\biggr)\end{aligned}\]</span></p><p>等号成立当且仅当 <span class="math inline">\(p = q\)</span>，带入求得 <span class="math inline">\(p = q =\frac{1}{2}\)</span></p><p>(3). 由 (1) (2) 得证。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 有连续的二阶导数，<span class="math inline">\(f&#39;(0) = 0\)</span>，且 <span class="math inline">\(\lim\limits_{x \to 0} \frac{f&#39;&#39;(x)}{|x|} = 1\)</span>，问：<span class="math inline">\(f(0)\)</span> 是否为极值？</p></blockquote><p>将 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x = 0\)</span> 处泰勒展开得到 <span class="math inline">\(f(x) - f(0) = \frac{f&#39;&#39;(\xi)}{2} x^2\)</span>，其中 <span class="math inline">\(x &gt; \xi &gt; 0\)</span>，<span class="math inline">\(\lim\limits_{x \to 0} \frac{f&#39;&#39;(x)}{|x|} = 1\)</span> 和极限的保号性，在 <span class="math inline">\(x = 0\)</span> 的某个去心领域内，<span class="math inline">\(f&#39;&#39;(x) &gt; 0\)</span>，同时 <span class="math inline">\(f(x) - f(0) &gt; 0\)</span> 由极值的定义，<span class="math inline">\(f(0)\)</span> 是极小值。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 有连续的二阶导数且满足微分方程 <span class="math inline">\(x f&#39;&#39;(x) + 3x [f&#39;(x)]^2 = 1 - \text{e}^{-x}\)</span>，问：</p><p>(1). 如果 <span class="math inline">\(x_0 \neq 0\)</span> 是 <span class="math inline">\(f(x)\)</span> 的极值点，则 <span class="math inline">\(f(x_0)\)</span> 是极大值还是极小值？</p><p>(2). 如果 <span class="math inline">\(f(0)\)</span> 是 <span class="math inline">\(f(x)\)</span> 的极值，则 <span class="math inline">\(f(0)\)</span> 是极大值还是极小值？</p></blockquote><p>(1). 此时 <span class="math inline">\(f&#39;(x_0) = 0\)</span>，<span class="math inline">\(f&#39;&#39;(x_0) = \frac{1 - \text{e}^{-{x_0}}}{x_0} &lt; 0\)</span>，所以是极小值。</p><p>(2). 由等价无穷小得：</p><p><span class="math display">\[\lim_{x \to 0} f&#39;&#39;(x) = \lim_{x \to 0} \frac{1 - \text{e}^{-x}}{x} = -1 &lt; 0\]</span></p><p>所以是极小值。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x) = (x - 1)^3 \cos \pi x\)</span>，证明：<span class="math inline">\(x = 1\)</span> 不是 <span class="math inline">\(f(x)\)</span> 的极值点。</p></blockquote><p><span class="math inline">\(f&#39;&#39;(x) = 6(x - 1) \cos \pi x - 3\pi (x - 1)^2 \sin \pi x - 3\pi (x - 1)^2 \sin \pi x - \pi^2 (x - 1)^3 \sin \pi x\)</span>。将 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x = 1\)</span> 处泰勒展开得到 <span class="math inline">\(f(x) - f(1) = \frac{f&#39;&#39;(\xi)}{2} (x - 1)^2\)</span>，其中 <span class="math inline">\(\xi\)</span> 在 <span class="math inline">\(x\)</span> 和 1 之间。由于 <span class="math inline">\(\lim\limits_{x \to 1^+} \frac{f&#39;&#39;(x)}{|x|} = -1\)</span> 和 <span class="math inline">\(\lim\limits_{x \to 1^-} \frac{f&#39;&#39;(x)}{|x|} = 1\)</span>，再结合极限的保号性，可知在 <span class="math inline">\(x = 1\)</span> 的某个右领域内 <span class="math inline">\(f&#39;&#39;(x) &lt; 0\)</span>，从而 <span class="math inline">\(f(x) &lt; 0\)</span>；某个左领域内 <span class="math inline">\(f&#39;&#39;(x) &gt; 0\)</span>，从而 <span class="math inline">\(f(x) &gt; 0\)</span>。综上 <span class="math inline">\(x = 1\)</span> 不是 <span class="math inline">\(f(x)\)</span> 的极值点。</p></li><li><blockquote><p>设在 <span class="math inline">\((-\infty, +\infty)\)</span> 上 <span class="math inline">\(f&#39;&#39;(x) \geq 0\)</span>，<span class="math inline">\(\lim\limits_{x \to 0} \frac{f(x)}{x} = 1\)</span>，证明：<span class="math inline">\(f(x) \geq x\)</span></p></blockquote><p><span class="math inline">\(f(x) = x + o(x)\)</span>，所以 <span class="math inline">\(\lim\limits_{x \to 0} f(x) = 0\)</span>，则 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x = 0\)</span> 处的导数为 1，将 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x = 0\)</span> 处泰勒展开，<span class="math inline">\(f(x) = x + \frac{f&#39;&#39;(\xi)}{2} x^2\)</span>，其中 <span class="math inline">\(\xi\)</span> 在 <span class="math inline">\(x\)</span> 与 0 之间，由于 <span class="math inline">\(f&#39;&#39;(x) \geq 0\)</span>，所以 <span class="math inline">\(f(x) \geq x\)</span>。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(n\)</span> 次多项式，且恒有 <span class="math inline">\(f(x) \geq 0\)</span>，证明：恒有</p><p><span class="math display">\[F(x) = f(x) + f&#39;(x) + \cdots + f^{(n)}(x) \geq 0\]</span></p></blockquote><p>构造函数 <span class="math inline">\(G(x) = F(x) \text{e}^{-x}\)</span>，<span class="math inline">\(G&#39;(x) = \text{e}^{-x}(F&#39;(x) - F(x)) = -f(x) \text{e}^{-x} \leq 0\)</span>，故 <span class="math inline">\(G(x)\)</span> 单调减少，<span class="math inline">\(\lim\limits_{x \to +\infty} G(x) = 0\)</span>，所以 <span class="math inline">\(G(x) \geq 0\)</span>，<span class="math inline">\(F(x) \geq 0\)</span>。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>函数、极限、连续</title>
    <link href="/2025/07/12/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%81%E9%99%90%E3%80%81%E8%BF%9E%E7%BB%AD/"/>
    <url>/2025/07/12/%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B/%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%81%E9%99%90%E3%80%81%E8%BF%9E%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="必备知识点">必备知识点</h2><ol type="1"><li><p><span class="math display">\[\lim_{n \to \infty} \sqrt[n]{a_1^n + a_2^n \dots + a_m^n} = \max_{1 \leq i \leq m}\{a_i\}\]</span></p><p>这个公式用<strong>夹逼定理</strong>证明，证明如下：记 <span class="math inline">\(\max\limits_{1 \leq i \leq m} = a\)</span>，则 <span class="math display">\[a = \sqrt[n]{a^n} \leq \sqrt[n]{a_1^n + a_2^n \dots + a_m^n} \leq \sqrt[n]{m \times a^n} = a \sqrt[n]{m}\]</span></p><p>而<span class="math inline">\(\lim\limits_{n \to \infty} \sqrt[n]{m} = 1\)</span>，所有根号下变量要求 <span class="math inline">\(\geq 0\)</span>。</p></li><li><p>拉格朗日中值定理 如果函数 <span class="math inline">\(f(x)\)</span> 满足以下条件：</p><ol type="1"><li>在闭区间 <span class="math inline">\([a, b]\)</span> 上连续</li><li>在开区间 <span class="math inline">\((a, b)\)</span> 上可导</li></ol><p>那么，至少存在一点 <span class="math inline">\(\xi \in (a, b)\)</span>，使得： <span class="math display">\[f&#39;(\xi) = \frac{f(b) - f(a)}{b - a}\]</span></p></li><li><p>立方和公式与立方差公式 <span class="math display">\[\begin{align*}a^3 + b^3 &amp;= (a + b)(a^2 - ab + b^2)\\a^3 - b^3 &amp;= (a - b)(a^2 + ab + b^2)\end{align*}\]</span></p><p>更进一步， <span class="math display">\[\begin{align*}a^n + b^n &amp;= (a + b)(a^{n - 1} - a^{n - 2}b + a^{n - 3}b^2 - \cdots + b^{n - 1}), n = 2k - 1\\a^n - b^n &amp;= (a - b)(a^{n - 1} + a^{n - 2}b + a^{n - 3}b^2 + \cdots + b^{n - 1})\end{align*}\]</span></p></li><li><p>几个常用函数的麦克劳林公式 <span class="math inline">\((n = 0, 1, \cdots)\)</span> <span class="math display">\[\begin{align*}\text{e}^x &amp;= 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots + \frac{x^n}{n!} + o(x^n)\\\sin x &amp;= x - \frac{x^3}{3!} + \frac{x^5}{5!} - \cdots + (-1)^{n } \frac{x^{2n + 1}}{(2n + 1)!} + o(x^{2n + 2})\\\cos x &amp;= 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \cdots + (-1)^n \frac{x^{2n}}{(2n)!} + o(x^{2n + 1})\\\ln (1 + x) &amp;= x - \frac{x^2}{2} + \frac{x^3}{3} - \cdots + (-1)^{n} \frac{x^{n + 1}}{n + 1} + o(x^{n + 1})\\(1 + x)^{\alpha} &amp;= 1 + \alpha x + \frac{\alpha(\alpha - 1)}{2!} x^2 + \cdots + \frac{\alpha(\alpha - 1) \cdots (\alpha - n + 1)}{n!} x^n + o(x^n)\\\frac{1}{1- x} &amp;= 1 + x + x^2 + \cdots + x^n + o(x^n)\\\frac{1}{1 + x} &amp;= 1 - x + x^2 - \cdots + (-1)^{n} x^n + o(x^n)\\\arctan x &amp;= x - \frac{1}{3} x^3 + \frac{1}{5} x^5 - \cdots + (-1)^n \frac{1}{2n + 1} x^{2n + 1} + o(x^{2n + 1})\end{align*}\]</span></p></li><li><p>若函数 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 在区间 <span class="math inline">\(I\)</span>上连续，对于 <span class="math inline">\(x \in I\)</span>，构造函数 <span class="math inline">\(M(x) = \max\{f(x), g(x)\} = \frac{f(x) + g(x) + |f(x) - g(x)|}{2}\)</span>，<span class="math inline">\(m(x) = \min\{f(x), g(x)\} =\frac{f(x) + g(x) - |f(x) - g(x)|}{2}\)</span></p></li><li><p>双侧极限存在的充要条件是两个单侧极限存在且相等。</p></li><li><p>常用的等价无穷小</p><p><span class="math display">\[\begin{align*}\sin x &amp;\sim x\\\tan x &amp;\sim x\\1 - \cos x &amp;\sim \frac{x^2}{2}\\\arcsin x &amp;\sim x\\\arctan x &amp;\sim x\\\text{e}^x - 1 &amp;\sim x\\\ln(x + 1) &amp;\sim x\\(1 + x)^{\lambda} - 1 &amp;\sim \lambda x\end{align*}\]</span></p></li><li><p>无穷小 <span class="math inline">\(o(x^n)\)</span> 的意义是最低次数大于 <span class="math inline">\(n\)</span>。</p></li><li><p>洛必达法则要求可导，对于<strong>无穷比无穷</strong>型，无需要求分子趋于无穷。</p></li><li><p>归结原则：对于任何趋于某一状态 <span class="math inline">\(a\)</span> 的数列 <span class="math inline">\(\{x_n\}\)</span>，都有 <span class="math inline">\(\lim\limits_{n \to \infty} f(x_n) = A\)</span>，则 <span class="math inline">\(\lim\limits_{x \to a} f(x) = A\)</span>。</p></li><li><p><span class="math inline">\(\lim\limits_{n \to \infty} x_n = A\)</span> 的充要条件是对于任何 <span class="math inline">\(\{x_n\}\)</span> 的子数列 <span class="math inline">\(\{x_{k_n}\}\)</span> 都有 <span class="math inline">\(\lim\limits_{n \to \infty} x_{k_{n}} = A\)</span></p></li><li><p>Stolz 定理：设数列 <span class="math inline">\(\{b_n\}\)</span> 单调增加且 <span class="math inline">\(\lim\limits_{n \to \infty} b_n = +\infty\)</span>。如果 <span class="math inline">\(\lim\limits_{n \to \infty} \frac{a_n - a_{n - 1}}{b_n - b_{n - 1}}\)</span> 存在或为 <span class="math inline">\(\pm \infty\)</span>，则其结果等于 <span class="math inline">\(\lim\limits_{n \to \infty} \frac{a_n}{b_n}\)</span>。</p></li><li><p><span class="math inline">\(\lim\limits_{x \to 0^{+}} x^x = 1\)</span></p></li><li><p>曲线的斜渐近线：<span class="math inline">\(\lim\limits_{x \to \pm \infty} \frac{f(x)}{x} = k\)</span> 和 <span class="math inline">\(\lim\limits_{x \to \pm \infty} (f(x) - kx) = b\)</span></p></li><li><p>一元函数连续：<span class="math inline">\(\lim\limits_{x \to x_0} f(x) = f(x_0)\)</span></p></li><li><p>如果 <span class="math inline">\(f(x)\)</span> 在点 <span class="math inline">\(x_0\)</span> 处不连续，则称 <span class="math inline">\(x_0\)</span> 是 <span class="math inline">\(f(x)\)</span> 的一个间断点。</p></li></ol><h2 id="例题讲解">例题讲解</h2><ol type="1"><li><blockquote><p>设</p><p><span class="math display">\[x_n=\prod_{k = 1}^n\Bigl(1 + \frac1{2^{2^k}}\Bigr)=(1 + \frac12)(1 + \frac1{2^2})(1 + \frac1{2^4})\cdots(1 + \frac1{2^{2^n}})\]</span></p><p>求 <span class="math inline">\(\lim\limits_{n \to \infty}x_n\)</span>。</p></blockquote><p>构造望远镜乘积 <span class="math display">\[\frac{1}{2^{2^n}} + 1 = \frac{(\frac{1}{2^{2n}} + 1)(\frac{1}{2^{2n}} - 1)}{\frac{1}{2^{2n}} - 1}= \frac{\frac{1}{2^{2^{n + 1}}} - 1}{\frac{1}{2^{2^n}} - 1}\]</span></p><p>替换所有元素的形式，最终得到： <span class="math display">\[\lim_{n \to \infty}x_n = \lim_{n \to \infty} \frac{\frac{1}{2^{2^{n + 1}}} - 1}{\frac{1}{2^{2^0}} - 1} = 2\]</span></p></li><li><blockquote><p>求 <span class="math display">\[\lim_{n \to \infty} \sin(\pi \sqrt{n^2 + 1})\]</span></p></blockquote><p>变形： <span class="math display">\[\lim_{n \to \infty} \sin(\pi \sqrt{n^2 + 1}) = (-1)^n\lim_{n \to \infty} \sin(\pi \sqrt{1 + n^2} -n\pi) = (-1)^n \lim_{n \to \infty} \sin(\frac{\pi}{\sqrt{1 + n^2} + n}) = 0\]</span></p></li><li><blockquote><p>求 <span class="math display">\[\lim_{n \to \infty} \frac{(1 + 1/n)^{n^{2}}}{\text{e}^n}\]</span></p></blockquote><p>变形： <span class="math display">\[\text{e}^{\ln \lim\limits_{n \to \infty} \frac{(1 + 1/n)^{n^{2}}}{\text{e}^n}} = \text{e}^{\lim\limits_{n \to \infty} n^2 \ln (1 + \frac{1}{n}) - n} = \text{e}^{\lim\limits_{n \to \infty} n^2 (\frac{1}{n} - \frac{1}{2n^2} + o(\frac{1}{n^2})) - n} = \text{e}^{-\frac{1}{2}}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(\alpha &gt; 0\)</span>，求 <span class="math display">\[\lim_{n \to \infty} \Bigl(\cos \frac{1}{n^\alpha}\Bigr)^n\]</span></p></blockquote><p>变形： <span class="math display">\[\text{e}^{\lim\limits_{n \to \infty} n \ln (1 - \frac{1}{2! \cdot n^{2\alpha}} + o(\frac{1}{n^{3 \alpha}}))} = \text{e}^{\lim\limits_{n \to \infty} n \cdot(- \frac{1}{2! \cdot n^{2\alpha}} + o(\frac{1}{n^{3 \alpha}}) + o(- \frac{1}{2! \cdot n^{2\alpha}} + o(\frac{1}{n^{3 \alpha}})))}\]</span></p><p>可以分析： <span class="math display">\[\lim_{n \to \infty} \Bigl(\cos \frac{1}{n^\alpha}\Bigr)^n =\begin{cases}0, &amp;\alpha &lt; \frac{1}{2}\\\text{e}^{-\frac{1}{2}}, &amp;\alpha = \frac{1}{2}\\1, &amp;\alpha &gt; \frac{1}{2}\end{cases}\]</span></p></li><li><blockquote><p>求极限 <span class="math display">\[\lim_{n \to \infty} \sqrt[n]{\ln n}\]</span></p></blockquote><p>对 <span class="math inline">\(\ln n\)</span> 放缩，<span class="math inline">\(1 - \frac{1}{n} &lt; \ln n &lt; n - 1\)</span>，而 <span class="math inline">\(\lim\limits_{n \to \infty} \sqrt[n]{1 - \frac{1}{n}} = \lim\limits_{n \to \infty} \sqrt[n]{n - 1} = 1\)</span>，再由夹逼定理，得到问题极限结果也为 1</p></li><li><blockquote><p>设 <span class="math display">\[x_n = \frac{1}{2} \cdot \frac{3}{4} \cdot \cdots \cdot \frac{2n - 1}{2n}\]</span></p><p>求 <span class="math display">\[\lim_{n \to \infty} x_n\]</span></p></blockquote><p><span class="math display">\[\frac{2n - 1}{2n}  = 1 - \frac{1}{2n} &gt; \frac{2n - 2}{2n - 1} = 1 - \frac{1}{2n - 1}\]</span></p><p>因为 <span class="math inline">\(1 &gt; \frac{2n - 1}{2n} &gt; 0\)</span>，所以</p><p><span class="math display">\[0 \leq \prod_{k = 1}^{n} \frac{2k - 1}{2k} \leq \prod_{k = 1}^{n} \sqrt{\frac{2k - 1}{2k + 1}} = \sqrt{\frac{1}{2n + 1}}\]</span></p><p>所以极限为 0.</p></li><li><blockquote><p>设数列 <span class="math inline">\(\{a_n\}\)</span> 有界，对于任何 <span class="math inline">\(n\)</span> 总有 <span class="math inline">\(a_n \leq a_{n + 2}\)</span>，<span class="math inline">\(a_n \leq a_{n + 3}\)</span> 成立，证明 <span class="math inline">\(\lim\limits_{n \to \infty} a_n\)</span> 存在。</p></blockquote><p>此时有，<span class="math inline">\(a_{2n} \leq a_{2n + 2}\)</span>，<span class="math inline">\(a_{2n - 1} \leq a_{2n + 1}\)</span>，<span class="math inline">\(a_{3n} \leq a_{3n + 3}\)</span>，<span class="math inline">\((n = 1, 2, \cdots)\)</span>，这表明子数列 <span class="math inline">\(\{a_{2n}\}\)</span>，<span class="math inline">\(\{a_{2n - 1}\}\)</span> 和 <span class="math inline">\(\{a_{3n}\}\)</span> 都是单调有界的，故都存在极限，分别设为 <span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>，<span class="math inline">\(c\)</span>。由于数列 <span class="math inline">\(\{a_{2n}\}\)</span> 和 <span class="math inline">\(\{a_{3n}\}\)</span> 有公共数列 <span class="math inline">\(\{a_{6n}\}\)</span>，所以 <span class="math inline">\(a = c\)</span>；又由于数列 <span class="math inline">\(\{a_{2n - 1}\}\)</span> 和 <span class="math inline">\(\{a_{3n}\}\)</span> 有公共数列 <span class="math inline">\(\{a_{6n -3}\}\)</span>，所以 <span class="math inline">\(b = c\)</span>，从而 <span class="math inline">\(a = b\)</span>，所以 <span class="math inline">\(\lim\limits_{n \to \infty} a_n\)</span> 存在。</p></li><li><blockquote><p>如果存在正整数 <span class="math inline">\(p\)</span>，使得 <span class="math display">\[\lim_{n \to \infty} (a_{n + p} - a_n) = \lambda\]</span></p><p>则， <span class="math display">\[\lim_{n \to \infty} \frac{a_n}{n} = \frac{\lambda}{p}\]</span></p></blockquote><p>将数列 <span class="math inline">\(\{\frac{a_n}{n}\}\)</span>，划分为如下互不相交的子数列，<span class="math inline">\(\{\frac{a_{1 + (n - 1)p}}{1 + (n - 1)p}\}\)</span>，<span class="math inline">\(\{\frac{a_{2 + (n - 1)p}}{2 + (n - 1)p}\}\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(\{\frac{a_{p + (n - 1)p}}{p + (n - 1)p}\}\)</span>，<span class="math inline">\(n \geq 1\)</span>，记为 <span class="math inline">\(\{\frac{a_{i + (n - 1)p}}{i + (n - 1)p}\}\)</span>，<span class="math inline">\(1 \leq i \leq p\)</span>，只需要证明对于所有的 <span class="math inline">\(i\)</span>，都有 <span class="math display">\[\lim_{n \to \infty} \frac{a_{i + (n - 1)p}}{i + (n - 1)p} = \frac{\lambda}{p}\]</span></p><p>由 stolz 定理，得 <span class="math inline">\(\lim\limits_{n \to \infty} \frac{a_{i + (n - 1)p}}{i + (n - 1)p} = \frac{\lim\limits_{n \to \infty} a_{i + (n - 1)p} - a_{i + (n - 2)p}}{p} = \frac{\lambda}{p}\)</span>。综上，题目推论成立</p></li><li><blockquote><p>设 <span class="math inline">\(x_0 = a\)</span>，<span class="math inline">\(x_1 = b\)</span>，<span class="math inline">\(x_{n + 1} = \frac{1}{2} (x_n + x_{n - 1})(n = 1, 2, \cdots)\)</span>。证明数列 <span class="math inline">\(\{x_n\}\)</span> 有极限，并求 <span class="math inline">\(\lim\limits_{n \to \infty} x_n\)</span>。</p></blockquote><p>不妨设 <span class="math inline">\(b &gt; a\)</span>，由题目可得：</p><p><span class="math display">\[\begin{align*}x_1 &amp;&gt; x_0\\x_1 &amp;&gt; x_2 &gt; x_0\\x_1 &amp;&gt; x_3 &gt; x_2\\x_1 &amp;&gt; x_3 &gt; x_4 &gt; x_2 &gt; x_0\\x_1 &amp;&gt; x_3 &gt; x_5 &gt; x_4 &gt; x_2 &gt; x_0\\x_1 &amp;&gt; x_3 &gt; x_5 &gt; x_6 &gt; x_4 &gt; x_2 &gt; x_0\\\cdots\end{align*}\]</span></p><p>有数学归纳法容易证明，数列 <span class="math inline">\(\{x_{2n - 1}\}\)</span> 单调递减，数列 <span class="math inline">\(\{x_{2n}\}\)</span> 单调递增，同时有界，所以这两个数列均有极限。</p><p><span class="math display">\[\begin{aligned}x_{2n + 1} &amp;= \frac{1}{2} (x_{2n} + x_{2n - 1})\\x_{2n} &amp;= \frac{1}{2} (x_{2n - 1} + x_{2n - 2})\\x_{2n + 1} - x_{2n} &amp;= \frac{1}{2} (x_{2n} - x_{2n - 2})\end{aligned}\]</span></p><p>因为极限存在，所以</p><p><span class="math display">\[\lim_{n \to \infty} (x_{2n + 1} - x_{2n}) = \lim_{n \to \infty} \frac{1}{2} (x_{2n} - x_{2n - 2}) = 0\]</span></p><p>所以奇数项和偶数项的极限相等，故改数列极限存在，同时 <span class="math inline">\(x_{n + 1} + \frac{1}{2} x_n = x_1 + \frac{1}{2} x_0\)</span>，解得极限为 <span class="math inline">\(\frac{2}{3}(b + \frac{a}{2})\)</span></p></li><li><blockquote><p>设数列：<span class="math inline">\(x_0 = a\)</span>，<span class="math inline">\(x_1 = 1 + b x_0\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_{n + 1} = 1 + b x_n\)</span>，<span class="math inline">\(\cdots\)</span>，求 <span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span> 使得该数列收敛。</p></blockquote><p>由题目可得： <span class="math display">\[\begin{align*}x_{n} &amp;= 1 + b x_{n - 1}\\x_{n - 1} &amp;= 1 + b x_{n - 2}\\&amp;\cdots\\x_1 &amp;= 1 + b x_0\end{align*}\]</span></p><p>从而推出 <span class="math inline">\(x_n = 1 + b + b^2 + \cdots + b^{n - 1} + b^n \cdot a = \frac{b^n - 1}{b - 1} + b^n \cdot a = \frac{-1}{b - 1} + b^n (\frac{1}{b - 1} + a)\)</span>，分析得：当 <span class="math inline">\(|b| &lt; 1\)</span> 时，收敛；当 <span class="math inline">\(b \leq -1\)</span> 和 <span class="math inline">\(b &gt; 1\)</span> 时，<span class="math inline">\(a = \frac{1}{1 - b}\)</span> 时，收敛。</p></li><li><blockquote><p>设 <span class="math inline">\(x_0 = a\)</span>，<span class="math inline">\(x_1 = b\)</span>，<span class="math inline">\(x_{n + 1} = \frac{x_{n - 1} + (2n - 1) x_n}{2n}(n = 1, 2, \cdots)\)</span>，求 <span class="math inline">\(\lim\limits_{n \to \infty} x_n\)</span>。</p></blockquote><p><span class="math display">\[x_{n + 1} - x_{n} = -\frac{x_{n} - x_{n - 1}}{2n} = (-1)^2\frac{x_{n - 1} - x_{n - 2}}{2n \cdot 2(n - 1)} = \cdots = \frac{(-1)^{n - 1} (x_2 - x_1)}{2n \cdot 2(n - 1) \cdots 2}\\= \bigg(\frac{-1}{2}\bigg)^{n} \frac{1}{n!} (b - a) = a + (b - a)\text{e}^{-\frac{1}{2}}\]</span></p><p>所以</p><p><span class="math display">\[\begin{aligned}x_{n + 1} &amp;= a + (b - a) \sum_{k = 0}^{n} \bigg(\frac{-1}{2}\bigg)^{k} \frac{1}{k!}\\\lim_{n \to \infty} x_{n + 1} &amp;= a + (b - a) \sum_{k = 0}^{\infty} \bigg(\frac{-1}{2}\bigg)^{k} \frac{1}{k!}\end{aligned}\]</span></p></li><li><blockquote><p>设数列由递推公式 <span class="math inline">\(u_1 = b\)</span>，<span class="math inline">\(u_{n + 1} = u_n^2 + (1 - 2a) u_n + a^2 (n = 1, 2, \cdots)\)</span> 所确定。当 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 为何值时，数列 <span class="math inline">\(\{u_n\}\)</span> 收敛？它的极限等于什么？</p></blockquote><p><span class="math display">\[\begin{aligned}u_{n + 1} - u_{n} &amp;= (u_n - a)^2\\u_{n} - u_{n - 1} &amp;= (u_{n - 1} - a)^2\\\cdots\\u_2 - u_1 &amp;= (u_1 - a)^2\end{aligned}\]</span></p><p>所以，<span class="math inline">\(u_{n + 1} = b + \sum\limits_{k = 1}^{n} (u_{k} - a)^2\)</span>，所以需要级数 <span class="math inline">\(\sum\limits_{k = 1}^{n} (u_{k} - a)^2\)</span> 收敛，必要条件是 <span class="math inline">\(\lim\limits_{n \to \infty} u_n = a\)</span>。同时，因为数列 <span class="math inline">\(\{u_n\}\)</span> 单调递增，<span class="math inline">\(\lim\limits_{n \to \infty} u_{n + 1} = \lim\limits_{n \to \infty} u_n^2 + (1 - 2a) u_n + a^2 = a\)</span>，应有 <span class="math inline">\(a - 1 \leq u_n \leq a\)</span>，故 <span class="math inline">\(a - 1 \leq b \leq a\)</span>。</p></li><li><blockquote><p>设数列 <span class="math inline">\(\{x_n\}\)</span> 定义如下：<span class="math inline">\(x_1 = \sqrt{5}\)</span>，<span class="math inline">\(x_{n + 1} = x_n^2 - 2(n = 1, 2, \cdots)\)</span>。求极限 <span class="math inline">\(\lim\limits_{n \to \infty} \frac{x_1 x_2 \cdots x_n}{x_{n + 1}}\)</span>。</p></blockquote><p><span class="math display">\[x_{n + 1}^2 - 4 = x_n^2 (x_n^2 - 4) = x_n^2 x_{n - 1}^2 \cdots x_2^2 x_1^2\]</span></p><p>所以，</p><p><span class="math display">\[\lim\limits_{n \to \infty} \frac{x_1 x_2 \cdots x_{n}}{x_{n + 1}} = \lim\limits_{n \to \infty} \sqrt{\big(\frac{x_1 x_2 \cdots x_{n}}{x_{n + 1}}\big)^2} = \lim\limits_{n \to \infty} \sqrt{\frac{x_{n + 1}^2 - 4}{x_{n + 1}^2}} = 1\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(x_1 \in (0, 1)\)</span>，<span class="math inline">\(x_{n + 1} = x_n (1 - x_n)\)</span>，证明 <span class="math inline">\(\lim\limits_{n \to \infty} n x_n = 1\)</span>。</p></blockquote><p>因为 <span class="math inline">\(x_1 \in (0, 1)\)</span>，且 <span class="math inline">\(x_i(1 - x_i) = x_{i + 1} \leq 0.25\)</span>，容易证明数列 <span class="math inline">\(\{x_n\}\)</span> 单调递减且有界。</p><p>易证 <span class="math inline">\(\lim\limits_{n \to \infty} x_n = 0\)</span>，证明 <span class="math inline">\(\lim\limits_{n \to \infty} n x_n = 1\)</span> 等价于证明 <span class="math inline">\(\lim\limits_{n \to \infty} \frac{1}{n x_n} = 1\)</span>。由 stolz 定理得：</p><p><span class="math display">\[\lim_{n \to \infty} \frac{1}{n x_n} = \lim_{n \to \infty} \bigg(\frac{1}{x_n} - \frac{1}{x_{n - 1}} \bigg)= \lim_{n \to \infty} \frac{x_{n - 1} - x_n}{x_n x_{n - 1}} = \lim_{n \to \infty} \frac{x_{n - 1}^2}{x_{n - 1}^2 (1 - x_{n - 1})} = 1\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(x_1 = \sin x_0 &gt; 0\)</span>，<span class="math inline">\(x_{n + 1} = \sin x_n(n = 1, 2, \cdots)\)</span>，证明 <span class="math inline">\(\lim\limits_{n \to \infty} x_n \sqrt{\frac{n}{3}} = 1\)</span></p></blockquote><p><span class="math inline">\(1 &gt; x_1 = \sin x_0 &gt; x_1 = x_2 &gt; \cdots\)</span> &gt; 0，故数列 <span class="math inline">\(\{x_n\}\)</span> 单调递减且有下界，故极限存在。</p><p>易证 <span class="math inline">\(\lim\limits_{n \to \infty} x_n = 0\)</span>，证明 <span class="math inline">\(\lim\limits_{n \to \infty} x_n \sqrt{\frac{n}{3}} = 1\)</span> 等价于证明 <span class="math inline">\(\lim\limits_{n \to \infty} \frac{1}{n x_n^2} = \frac{1}{3}\)</span>，由 stolz 定理和洛必达法则得： <span class="math display">\[\lim_{n \to \infty} \frac{1}{n x_n^2} = \lim_{n \to \infty} \frac{1}{x_n^2} - \frac{1}{x_{n - 1}^2} = \lim_{n \to \infty} \frac{x_{n - 1}^2 - x_{n}^2}{x_n^2 x_{n - 1}^2} = \lim_{x \to 0^+} \frac{x^2 - \sin^2 x}{x^4} = \frac{1}{3}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(x_n = (1 + \frac{1}{n + 1})^{n + 1} -(1 + \frac{1}{n})^n (n = 1, 2, 3, \cdots)\)</span>。证明 <span class="math inline">\(\{x_n\}\)</span> 与 <span class="math inline">\(\{\frac{1}{n^2}\}\)</span> 是同阶无穷小。</p></blockquote><p>只需要证明 <span class="math inline">\(\lim\limits_{n \to \infty} \frac{x_n}{\frac{1}{n^2}}\)</span> 存在</p><p><span class="math display">\[\begin{aligned}x_n n^2 &amp;= \bigg(1 + \frac{1}{\xi}\bigg)^{\xi}\bigg[\ln (1 + \frac{1}{\xi}) - \frac{1}{1 + \xi}\bigg] n^2, n &lt; \xi &lt; n + 1\\\lim_{n \to \infty} x_n n^2 &amp;= \lim_{n \to \infty} n^2\bigg(1 + \frac{1}{\xi}\bigg)^{\xi}\bigg[\ln (1 + \frac{1}{\xi}) - \frac{1}{1 + \xi}\bigg]\\\lim_{n \to \infty} x_n n^2 &amp;= \text{e} n^2 \lim_{n \to \infty} \bigg(\frac{1}{\xi} - \frac{1}{2\xi^2} + o\bigg(\frac{1}{\xi^2}\bigg) - \frac{1}{1 + \xi} \bigg) = \frac{\text{e}}{2}\end{aligned}\]</span></p></li><li><blockquote><p>求极限 <span class="math display">\[\lim_{n \to \infty} \frac{\sqrt[n]{n} - 1}{\frac{1}{n^{\alpha}}}(0 &lt; \alpha &lt; 1)\]</span></p></blockquote><p>由等价无穷小，原极限为： <span class="math display">\[\lim_{n \to \infty} \frac{\sqrt[n]{n} - 1}{\frac{1}{n^{\alpha}}} = \lim_{n \to \infty} \frac{\text{e}^{\frac{\ln n}{n}} - 1}{\frac{1}{n^{\alpha}}} = \lim_{n \to \infty} \frac{\frac{\ln n}{n}}{\frac{1}{n^{\alpha}}} = \lim_{n \to \infty} \frac{\ln n}{ n^{1 - \alpha}} = 0\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(x_1 = \sqrt{2}\)</span>，<span class="math inline">\(x_{n + 1} = \sqrt{2 + x_n}(n = 1, 2, \cdots)\)</span>，证明 <span class="math inline">\(x_n - 2 = o(\frac{1}{3^n})(n \to \infty)\)</span></p></blockquote><p>显然数列单调递增，极限为 <span class="math inline">\(A = 2\)</span>。</p><p><span class="math display">\[x_{n + 1} - A = \sqrt{2 + x_n} - \sqrt{2 + A} = \frac{x_n - A}{\sqrt{2 + x_n} \sqrt{2 + A}} \leq \frac{x_n - A}{4} \leq \cdots \leq \frac{\sqrt{2} - 2}{4^{n}} = o\bigg(\frac{1}{3^n}\bigg)\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x) = \frac{2 + x}{1 + x}\)</span>，<span class="math inline">\(x_0 = 1\)</span>，<span class="math inline">\(x_{n + 1} = f(x_n)(n = 0, 1, 2, \cdots)\)</span>，求 <span class="math inline">\(\lim\limits_{n \to \infty} x_n\)</span>，并尽可能估计数列趋于极限得速度。</p></blockquote><p><span class="math inline">\(x_{n + 1} = \frac{2 + x_n}{1 + x_n}\)</span>，当 <span class="math inline">\(n \geq 1\)</span> 时，数列 <span class="math inline">\(\{x_n\}\)</span> 单调递减且有下界，故有极限 <span class="math inline">\(A\)</span>。</p><p><span class="math display">\[|x_{n + 1} - A| = \bigg|\frac{1}{1 + x_n} - \frac{1}{1 + A}\bigg| = \bigg|\frac{x_n - A}{(1 + x_n)(1 + A)}\bigg| \leq \bigg|\frac{x_n - A}{(1 + \sqrt{2})^2}\bigg| \leq \cdots \leq \frac{|x_1 - A|}{(1 + \sqrt{2})^{2n}}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span>，<span class="math inline">\(x_3\)</span>，<span class="math inline">\(\cdots\)</span>，<span class="math inline">\(x_n\)</span>，<span class="math inline">\(\cdots\)</span> 是将方程 <span class="math inline">\(\tan x = x\)</span> 的全部正根按由小到大的次序编号而成的，求极限 <span class="math inline">\(\lim\limits_{n \to \infty} (x_{n} - x_{n - 1})\)</span>。</p></blockquote><p>由几何关系记 <span class="math inline">\(y_n = \arctan x_n\)</span>，<span class="math inline">\(x_n = y_n + n\pi\)</span>，所以 <span class="math inline">\(\lim\limits_{n \to \infty} (y_n - y_{n - 1} + \pi) = \pi\)</span></p></li><li><blockquote><p>设 <span class="math inline">\(a &gt; 0\)</span>，<span class="math inline">\(f_n(x) = x^n + nx - a(n = 1, 2, \cdots)\)</span>，<span class="math inline">\(x_n\)</span> 是 <span class="math inline">\(f_n(x)\)</span> 在 <span class="math inline">\((0, +\infty)\)</span> 上的唯一零点，求 <span class="math inline">\(\lim\limits_{n \to \infty} (1 + x_n)^n\)</span></p></blockquote><p><span class="math inline">\(n &gt; a\)</span> 时，<span class="math inline">\(f_n(\frac{a}{n} - \frac{a}{n^2}) = (\frac{a}{n} - \frac{a}{n^2})^n - \frac{a}{n} &lt; 0\)</span>，所以 <span class="math inline">\(\frac{a}{n} - \frac{a}{n^2} &lt; x_n &lt; \frac{a}{n}\)</span>，由夹逼定理得极限为 <span class="math inline">\(\text{e}^a\)</span></p></li><li><blockquote><p>设 <span class="math inline">\(x_1 = a\)</span>，<span class="math inline">\(y_1 = b(0 &lt; a &lt; b)\)</span>；<span class="math inline">\(x_{n + 1} = \sqrt{x_n y_n}\)</span>，<span class="math inline">\(y_{n + 1} = \frac{x_n + y_n}{2}\)</span>。证明：数列 <span class="math inline">\(\{x_n\}\)</span>，<span class="math inline">\(\{y_n\}\)</span> 的极限都存在且相同。</p></blockquote><p>由均值不等式得到 <span class="math inline">\(y_{n + 1} = \frac{x_n + y_n}{2} \geq \sqrt{x_n y_n} = x_{n + 1}\)</span>，若存在等号成立的 <span class="math inline">\(x_n\)</span> 和 <span class="math inline">\(y_n\)</span>，记为 <span class="math inline">\(a\)</span>，则有 <span class="math inline">\(x_{n + 1} = x_n = y_{n + 1} = y_{n} = a\)</span>，此时显然存在极限且相同。若不存在等号成立的 <span class="math inline">\(x_n\)</span> 和 <span class="math inline">\(y_n\)</span>，此时严格有 <span class="math inline">\(y_{n} &gt; x_{n}\)</span>，从而可以推出，<span class="math inline">\(x_{n + 1} = \sqrt{x_n y_n} &gt; x_{n}\)</span> 和 <span class="math inline">\(y_{n + 1} = \frac{x_n + y_n}{2} &lt; y_n\)</span>，且 <span class="math inline">\(x_n &lt; y_n &lt; y_1 = b\)</span> 和 <span class="math inline">\(y_n &gt; x_n &gt; x_1 = a\)</span>，所以数列 <span class="math inline">\(\{x_n\}\)</span> 严格单调递增且有界，数列 <span class="math inline">\(\{y_n\}\)</span> 严格单调递减且有界，故数列 <span class="math inline">\(\{x_n\}\)</span>，<span class="math inline">\(\{y_n\}\)</span> 的极限都存在，分别设极限为 <span class="math inline">\(x_0\)</span> 和 <span class="math inline">\(y_0\)</span>，由 <span class="math inline">\(\lim\limits_{n \to \infty} y_{n + 1} = \lim\limits_{n \to \infty} \frac{x_n + y_n}{2}\)</span> 得 <span class="math inline">\(x_0 = y_0\)</span>，所以极限相等。</p></li><li><blockquote><p>求极限 <span class="math display">\[\lim_{x \to 0^{+}} \frac{x^x - (\sin)^x}{x^3}\]</span></p></blockquote><p>原极限为： <span class="math display">\[\lim_{x \to 0^{+}} \frac{x^x - (\sin)^x}{x^3} = \lim_{x \to 0^{+}} \frac{\text{e}^{x \ln x} - \text{e}^{x \ln \sin x}}{x^3} = \lim_{x \to 0^{+}} \frac{\text{e}^{\xi}(x \ln x - x \ln \sin x)}{x^3} = \frac{1}{6}\]</span></p></li><li><blockquote><p>求极限 <span class="math display">\[\lim_{x \to + \infty} \bigg(\frac{x^{1 + x}}{(1 + x)^{x}} - \text{e}^{-1} x\bigg)\]</span></p></blockquote><p>原极限为： <span class="math display">\[\lim_{x \to + \infty} \bigg(\frac{x^{1 + x}}{(1 + x)^{x}} - \text{e}^{-1} x\bigg) = \lim_{x \to + \infty} x \cdot \bigg(\frac{1}{(1 + \frac{1}{x})^x} - \frac{1}{\text{e}}\bigg) = \lim_{t \to 0^{+}} \frac{\text{e} - (1 + t)^{\frac{1}{t}}}{t(1 + t)^{\frac{1}{t}} \text{e}}=\\= \frac{1}{\text{e}} \lim_{t \to 0^{+}} \frac{1 - \text{e}^{\frac{1}{t} \ln (1 + t) - 1}}{t} = \frac{1}{2\text{e}}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在区间 <span class="math inline">\([0, 1]\)</span> 上连续，<span class="math inline">\(f(0) = 0\)</span>，<span class="math inline">\(f(1) = 1\)</span>。证明：<span class="math inline">\(F(x) = f(x)(1 - f(x)) - x(1 - x)\)</span> 在 <span class="math inline">\([0, 1]\)</span> 上至少有 <span class="math inline">\(3\)</span> 个不同的零点。</p></blockquote><p><span class="math inline">\(x = 0\)</span> 和 <span class="math inline">\(x = 1\)</span> 是两个零点，故只需要证明在区间 <span class="math inline">\((0, 1)\)</span> 上至少有一个零点。<span class="math inline">\(F(x) = f(x) - f^2(x) - x + x^2 = (f(x) - x) -(f(x) - x)(f(x) + x) = (f(x) - x)(1 - f(x) - x)\)</span>，令 <span class="math inline">\(g(x) = 1 - f(x) - x\)</span>，有 <span class="math inline">\(g(0) = 1\)</span>，<span class="math inline">\(g(1) = -1\)</span>，由零点定理得，至少存在一点 <span class="math inline">\(c\)</span>，使得 <span class="math inline">\(g(c) = 0\)</span>，所以至少有 <span class="math inline">\(3\)</span> 个零点。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在闭区间 <span class="math inline">\([0, 1]\)</span> 上连续，<span class="math inline">\(f(0) = f(1)\)</span>。证明：对于任何自然数 <span class="math inline">\(n\)</span>，总存在 <span class="math inline">\(\xi_n \in (0, 1)\)</span> 使得 <span class="math inline">\(f(\xi_n) = f(\frac{1}{n} + \xi_n)\)</span></p></blockquote><p>令 <span class="math inline">\(F(x) = f(x) - f(\frac{1}{n} + x)\)</span>，只需要证明 <span class="math inline">\(F(x)\)</span> 在区间 <span class="math inline">\([0, 1 - \frac{1}{n}]\)</span> 上有零点。假设不存在零点，此时不妨设恒有 <span class="math inline">\(F(x) &gt; 0\)</span>，因此有 $F(0) + F() + + F() &gt; 0 $，也就是 <span class="math inline">\(f(0) - f(\frac{1}{n}) + f(\frac{1}{n}) - f(\frac{2}{n}) - \cdots - f(1) = f(0) - f(1) &gt; 0\)</span>，显然出现矛盾，因为 <span class="math inline">\(f(0) - f(1) = 0\)</span>，因此必然有零点。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span>，<span class="math inline">\(g(x)\)</span> 在闭区间 <span class="math inline">\([a, b]\)</span> 上连续，并有数列 <span class="math inline">\(\{x_0\} \subset [a, b]\)</span>，使得 <span class="math inline">\(f(x_{n + 1}) = g(x_n) (n = 1, 2, \cdots)\)</span>。证明：存在一点 <span class="math inline">\(x_0\)</span>，使得 <span class="math inline">\(f(x_0) = g(x_0)\)</span>。</p></blockquote><p>设 <span class="math inline">\(F(x) = f(x) - g(x)\)</span>，假设 <span class="math inline">\(F(x)\)</span> 在区间 <span class="math inline">\([a, b]\)</span> 不存在零点，其在区间内的最小值为 <span class="math inline">\(m\)</span>，不妨设恒有 <span class="math inline">\(F(x) &gt; 0\)</span>，$f(x_{n + 1}) = g(x_n) = g(x_n) - f(x_n) + g(x_{n - 1}) = [g(x_n) - f(x_n)] + [g(x_{n - 1}) - f(x_{n - 1})] + + [g(x_2) - f(x_2)] + g(x_1) $<span class="math inline">\(= -F(x_n) - F(x_{n - 1}) - \cdots - F(x_2) + g(x_1) \leq (1 - n)m + g(x_1)\)</span>，显然 <span class="math inline">\(\lim\limits_{n \to \infty} f(x_n) = -\infty\)</span> 和 <span class="math inline">\(f(x)\)</span> 有界条件矛盾，所以必然存在一点 <span class="math inline">\(x_0\)</span>，使得 <span class="math inline">\(f(x_0) = g(x_0)\)</span>。</p></li><li><blockquote><p>设函数 <span class="math inline">\(f(x)\)</span> 在闭区间 <span class="math inline">\([a, b]\)</span> 上连续，其值域 <span class="math inline">\(f([a, b]) \subseteq [a, b]\)</span>。证明：该函数存在不动点，即存在 <span class="math inline">\(x_0 \in [a, b]\)</span> 使得 <span class="math inline">\(f(x_0) = x_0\)</span>。</p></blockquote><p>设函数 <span class="math inline">\(F(x) = f(x)- x\)</span>，由题知：<span class="math inline">\(a \leq f(x) \leq b\)</span>，所以有 <span class="math inline">\(F(a) = f(a) - a \geq 0\)</span> 和 <span class="math inline">\(F(b) = f(b) - b \leq 0\)</span>，有零点定理得：至少存在一点 <span class="math inline">\(x_0\)</span> 使得 <span class="math inline">\(f(x_0) = x_0\)</span>。</p></li><li><blockquote><p>设函数 <span class="math inline">\(f(x)\)</span> 在区间 <span class="math inline">\((0, 1)\)</span> 内有定义，且 <span class="math inline">\(\text{e}^{x} f(x)\)</span> 与 <span class="math inline">\(\text{e}^{-f(x)}\)</span> 在区间 <span class="math inline">\((0, 1)\)</span> 内都是单调递加的函数，证明：<span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((0, 1)\)</span> 内连续。</p></blockquote><p>根据 <span class="math inline">\(\text{e}^{-f(x)}\)</span> 的单调性，可知，函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((0, 1)\)</span> 上单调递减。任取 <span class="math inline">\(x_0 \in (0, 1)\)</span>，当 <span class="math inline">\(x \in (x_0, 1)\)</span>，有 <span class="math inline">\(\text{e}^{x_0 - x} f(x_0) \leq f(x) &lt; f(x_0)\)</span>，由夹逼定理得到 <span class="math inline">\(\lim\limits_{x \to x_0^+} f(x) = f(x_0)\)</span>；当 <span class="math inline">\(x \in (0, x_0)\)</span>，同理可得 <span class="math inline">\(f(x_0) &lt; f(x) &lt; \text{e}^{x_0 - x} f(x)\)</span>，由夹逼定理得 <span class="math inline">\(\lim\limits_{x \to x_0^{-}} f(x) = f(x_0)\)</span>，综上，<span class="math inline">\(\lim\limits_{x \to x_0} f(x) =f(x_0)\)</span>，得连续性。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在区间 <span class="math inline">\((0, +\infty)\)</span> 上有定义，在 <span class="math inline">\(x = 1\)</span> 处连续且 <span class="math inline">\(f(1) = 3\)</span>。如果对任意正数 <span class="math inline">\(x\)</span> 都有 <span class="math inline">\(f(x^2) = f(x)\)</span> 成立，求 <span class="math inline">\(f(x)\)</span> 的表达式。</p></blockquote><p><span class="math inline">\(f(x) = f(\sqrt{x}) = f(\sqrt[4]{x}) = \cdots = f(\sqrt[2^n]{x})\)</span>，由于在 <span class="math inline">\(x = 1\)</span> 处连续，<span class="math inline">\(\lim\limits_{n \to \infty} f(\sqrt[2^n]{x}) = f(1) = 3\)</span>，所以有 <span class="math inline">\(f(x) \equiv 3\)</span>。</p></li><li><blockquote><p>设函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((-\infty, +\infty)\)</span> 上有定义，在 <span class="math inline">\(x = 0\)</span> 处连续且 <span class="math inline">\(f(0) = 2\)</span>。证明：恒等式 <span class="math inline">\(f(2x) = f(x) \text{e}^x\)</span> 成立的充要条件是 <span class="math inline">\(f(x) = 2 \text{e}^{x}\)</span>。</p></blockquote><p>充分性显然，下面证明必要性。<span class="math inline">\(f(x) = f(\frac{x}{2}) \text{e}^{\frac{x}{2}} = f(\frac{x}{4}) \text{e}^{\frac{x}{4}} \text{e}^{\frac{x}{2}} = \cdots = f(\frac{x}{2^n}) \text{e}^{x(\frac{\frac{1}{2} - \frac{1}{2^{n + 1}}}{1 - \frac{1}{2}})}\)</span>，由于 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x = 0\)</span> 处连续，所以 <span class="math inline">\(\lim\limits_{n \to \infty} f(x) = f(0) \text{e}^{x} = 2 \text{e}^{x}\)</span>，所以 <span class="math inline">\(f(x) = 2 \text{e}^{x}\)</span>。综上，得证充分必要性。</p></li><li><blockquote><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((-\infty. +\infty)\)</span> 上有定义，在点 <span class="math inline">\(x = 0\)</span> 处连续且 <span class="math inline">\(f(1) = 2\)</span>。又对于任何 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span> 满足函数方程 <span class="math inline">\(f(x + y) = f(x) + f(y)\)</span> 成立。求 <span class="math inline">\(f(x)\)</span> 的表达式。</p></blockquote><p>先证明，<span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((-\infty. +\infty)\)</span> 上连续，<span class="math inline">\(f(0) = 0\)</span> 且在点 <span class="math inline">\(x = 0\)</span> 处连续，所以 <span class="math inline">\(\lim\limits_{x \to 0} f(x) = 0\)</span>，对任意 <span class="math inline">\(x_0 \in (-\infty, +\infty)\)</span>，<span class="math inline">\(\lim\limits_{\Delta x \to 0} f(x + \Delta x) = f(x) + \lim\limits_{\Delta x \to 0} f(\Delta x) = f(x)\)</span>，故证明连续性。对于任意正整数 <span class="math inline">\(n\)</span>，有 <span class="math inline">\(f(1) = f(\frac{1}{n}) + f(\frac{1}{n}) + \cdots + f(\frac{1}{n}) = n f(\frac{1}{n})\)</span>，也就是 <span class="math inline">\(f(1) \frac{1}{n} = f(\frac{1}{n})\)</span>；同理，对于任意正有理数 <span class="math inline">\(\frac{m}{n}\)</span>，有 <span class="math inline">\(f(\frac{m}{n}) = m f(\frac{1}{n}) = 2 \frac{m}{n}\)</span>，也就是 <span class="math inline">\(f(x) = 2x\)</span>。对任意负有理数 <span class="math inline">\(x\)</span>，<span class="math inline">\(-x\)</span> 是正有理数，所以 <span class="math inline">\(f(0) = f(x) + f(-x)\)</span>，得到 <span class="math inline">\(f(-x) = 2 \cdot -x\)</span>，同样说明了 <span class="math inline">\(f(x) = 2x\)</span>。对于任何无理数 <span class="math inline">\(x\)</span>，存在有理数列 <span class="math inline">\(r_n\)</span>，<span class="math inline">\(\lim\limits_{n \to \infty} r_n = x\)</span>，由函数及其连续性知 <span class="math inline">\(f(x) = \lim\limits_{n \to \infty} f(r_n) = \lim\limits_{n \to \infty} 2r_n = 2x\)</span>。综上，<span class="math inline">\(f(x) = 2x\)</span>。</p></li><li><blockquote><p>设有一非负连续函数，对于所有的实数 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 满足函数方程 <span class="math inline">\(f(\sqrt{x^2 + y^2}) = f(x)f(y)\)</span> 及 <span class="math inline">\(f(1) = 2\)</span>，证明：<span class="math inline">\(f(x) = 2^{x^{2}}\)</span>。</p></blockquote><p>容易得到 <span class="math inline">\(f(x) = f(-x)\)</span>。对任意正整数 <span class="math inline">\(n\)</span>，有 <span class="math inline">\(f(\sqrt{n + 1} x) = f(\sqrt{n}x)f(x) = [f(x)]^{n + 1}\)</span>。设正整数 <span class="math inline">\(p\)</span>，<span class="math inline">\(q\)</span>，得 <span class="math inline">\(f(|p|) = f(\sqrt{q^2}|\frac{p}{q}|) = [f(|\frac{p}{q}|)]^{q^2} = 2^{p^2}\)</span></p></li><li><blockquote><p>求极限 <span class="math display">\[\lim_{x \to 0^-} -\frac{1}{x^2} \text{e}^{\frac{1}{x}}\]</span></p></blockquote><p><span class="math display">\[\lim_{x \to 0^-} -\frac{1}{x^2} \text{e}^{\frac{1}{x}} = \lim_{t \to +\infty} - \frac{t^2}{\text{e}^t} = 0\]</span></p></li><li><blockquote><p>给定三个实数 <span class="math inline">\(a_1\)</span>，<span class="math inline">\(b_1\)</span>，<span class="math inline">\(c_1\)</span>。将每个数换为另外两个数的算术平均值，即 <span class="math inline">\(a_2 = \frac{b_1 + c_1}{2}\)</span>，<span class="math inline">\(b_2 = \frac{a_1 + c_1}{2}\)</span>，<span class="math inline">\(c_2 = \frac{a_1 + b_1}{2}\)</span>，如此下去构造的三个数列 <span class="math inline">\(\{a_n\}\)</span>，<span class="math inline">\(\{b_n\}\)</span>，<span class="math inline">\(\{c_n\}\)</span>。证明三个数列的极限都为 <span class="math inline">\(\frac{S}{3}\)</span>，其中 <span class="math inline">\(S = a_1 + b_1 + c_1\)</span>。</p></blockquote><p><span class="math inline">\(a_n = \frac{b_{n - 1} + c_{n - 1}}{2}\)</span>，<span class="math inline">\(b_n = \frac{a_{n - 1} + c_{n - 1}}{2}\)</span>，所以 <span class="math inline">\(a_n - b_n = \frac{b_{n - 1} - a_{n - 1}}{2} = \frac{a_{n - 2} - b_{n - 2}}{2^2} = \cdots = (-1)^{n - 1} \frac{b_1 - a_1}{2^{n - 1}}\)</span>，即 <span class="math inline">\(\lim\limits_{n \to \infty} a_n - b_n = 0\)</span>，同理可得 <span class="math inline">\(a_n = b_n = c_n\)</span>，同时 <span class="math inline">\(a_n + b_n + c_n = a_{n - 1} + b_{n - 1} + c_{n - 1} = \cdots = a_1 + b_1 + c_1 = S\)</span>。综上，三个数列的极限结果都是 <span class="math inline">\(\frac{S}{3}\)</span>。</p></li><li><blockquote><p>设 <span class="math inline">\(\lim\limits_{n \to \infty} x_n = a\)</span>，<span class="math inline">\(\lim\limits_{n \to \infty} y_n = b\)</span>，证明：数列</p><p><span class="math display">\[z_n = \frac{x_1 y_n + x_2 y_{n - 1} + \cdots + x_n y_1}{n}\]</span></p><p>收敛于 <span class="math inline">\(ab\)</span></p></blockquote><p>设 <span class="math inline">\(x_n = a + \alpha_n\)</span>，<span class="math inline">\(y_n = b + \beta_n\)</span>，其中 <span class="math inline">\(\alpha_n\)</span>，<span class="math inline">\(\beta_n \to 0\)</span>，<span class="math inline">\(n \to \infty\)</span>，于是</p><p><span class="math display">\[\begin{aligned}z_n &amp;= \frac{1}{n} \sum_{k = 1}^{n} (a + \alpha_n)(b + \beta_{n - k})\\&amp;= \frac{1}{n} \biggl(\sum_{k = 1}^{n} ab + \sum_{k = 1}^{n} a\beta_{n - k} + \sum_{k = 1}^{n} \alpha_kb + \sum_{k = 1}^{n} \alpha_k \beta_{n - k}\biggr)\\&amp;= ab\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(a &gt; 0\)</span>，参数方程：<span class="math inline">\(x = \frac{3at}{1 + t^3}\)</span>，<span class="math inline">\(y = \frac{3at^2}{1 + t^3}\)</span> 表示的曲线称为笛卡儿叶形线。</p><p>(1). 求出该曲线在直角坐标系下的方程；</p><p>(2). 仅就直角坐标系下的方程求出该曲线的渐近线；</p><p>(3). 仅就参数方程求出该曲线的渐近线。</p></blockquote><p>(1). 直角坐标系下的方程为</p><p><span class="math display">\[x^3 + y^3 = 3axy\]</span></p><p>(2). 对曲线的直角坐标系下的方程变形得到：</p><p><span class="math display">\[\frac{x^3}{y} + y^2 = 3ax\]</span></p><p>如果存在垂直渐近线，也就是存在 <span class="math inline">\(c \in R\)</span>，<span class="math inline">\(\lim\limits_{x \to c} y = \pm \infty\)</span>，则会推出变形后的方程左端的值为 <span class="math inline">\(\infty\)</span>，右端为 <span class="math inline">\(3ac\)</span>，产生矛盾，故不存在垂直渐近线。同理不存在水平渐近线。</p><p>设曲线有斜渐近线 <span class="math inline">\(y = kx + b\)</span>，则 <span class="math inline">\(\lim\limits_{x \to \pm \infty}\frac{y}{x} = k\)</span>，<span class="math inline">\(\lim\limits_{x \to \pm \infty} (y - kx) = b\)</span>，再次变形原直角坐标系方程</p><p><span class="math display">\[\biggl(\frac{y}{x}\biggr)^2 + \frac{x}{y} = \frac{3a}{x}\]</span></p><p>解得 <span class="math inline">\(k = -1\)</span>，从而</p><p><span class="math display">\[b = \lim_{x \to \pm \infty} (y + x) = \lim_{x \to \pm \infty} \frac{x^3 + y^3}{x^2 - xy + y^2} = \lim_{x \to \pm \infty} \frac{3axy}{x^2 - xy + y^2} = -a\]</span></p><p>所以，渐近线方程为 <span class="math inline">\(x + y + a = 0\)</span></p><p>(3).</p><p><span class="math display">\[\lim_{x \to \infty} \frac{y}{x} = \lim_{t \to -1} \frac{\frac{3at^2}{1 + t^3}}{\frac{3at}{1 + t^3}} = -1\]</span></p><p><span class="math display">\[\lim_{x \to \infty} (y + x) = \lim_{t \to -1}\biggl(\frac{3at^2}{1 + t^3} + \frac{3at}{1 + t^3} \biggr) = -a\]</span></p></li><li><blockquote><p>求极坐标方程的曲线 <span class="math inline">\(\Gamma: \rho = \frac{1}{3\theta - \pi}\)</span> 在直角坐标系下的渐近线方程。</p></blockquote><p>直角坐标系下，该曲线的参数方程为</p><p><span class="math display">\[\begin{cases}x &amp;= \rho \cos \theta\\y &amp;= \rho \sin \theta\end{cases}\]</span></p><p>由于 <span class="math inline">\(\cos x\)</span> 和 <span class="math inline">\(\sin x\)</span> 都是有界函数，易见不存在垂直渐近线和水平渐近线，下面求其斜渐近线。</p><p><span class="math display">\[\begin{aligned}\lim_{x \to \pm \infty} \frac{y}{x} &amp;= \lim_{\theta \to \frac{\pi}{3}} \tan \theta = \sqrt{3}\\\lim_{x \to \pm \infty} (y - kx) &amp;= \lim_{\theta \to \frac{\pi}{3}} \rho(\sin \theta - \sqrt{3} \cos \theta) = \frac{2}{3}\end{aligned}\]</span></p></li><li><blockquote><p>设 <span class="math inline">\(F(x) = \bigl(\frac{a_1^x + a_2^x + \cdots + a_n^x}{n}\bigr)^{\frac{1}{x}}\)</span>，<span class="math inline">\(a_i^x\)</span> 都是正数，，求下列极限；</p><p>(1). <span class="math inline">\(\lim\limits_{x \to +\infty} F(x)\)</span>；</p><p>(2). <span class="math inline">\(\lim\limits_{x \to -\infty} F(x)\)</span>；</p><p>(3). <span class="math inline">\(\lim\limits_{x \to 0} F(x)\)</span></p></blockquote><p>记 <span class="math inline">\(\max \{a_1, a_2, \cdots, a_n\} = a_x\)</span>，<span class="math inline">\(\min \{a_1, a_2, \cdots, a_n\} = a_y\)</span></p><p>(1).</p><p><span class="math display">\[\frac{a_x}{n^{\frac{1}{x}}} \leq F(x) \leq a_x\]</span></p><p>故 <span class="math inline">\(\lim\limits_{x \to +\infty} F(x) = a_x\)</span></p><p>(2). 因为 <span class="math inline">\(x &lt; 0\)</span>，所以有</p><p><span class="math display">\[\frac{a_y}{n^{\frac{1}{x}}} \leq F(x) \leq a_y\]</span></p><p>故 <span class="math inline">\(\lim\limits_{x \to -\infty} F(x) = a_y\)</span></p><p>(3). 由洛必达法则得到</p><p><span class="math display">\[F(x) = \text{e}^{\frac{1}{x} [\ln (a_1^x + a_2^x + \cdots + a_n^x) - \ln n]} = \sqrt[n]{a_1 a_2 \cdots a_n}\]</span></p></li><li><blockquote><p>已知</p><p><span class="math display">\[\lim_{x \to 0} \frac{\ln (1 + \frac{f(x)}{\sin 2x})}{3^x - 1} = 5\]</span></p><p>求 <span class="math inline">\(\lim\limits_{x \to 0} \frac{f(x)}{x^2}\)</span>。</p></blockquote><p>利用等价无穷小可得：</p><p><span class="math display">\[\lim_{x \to 0} \frac{\ln (1 + \frac{f(x)}{\sin 2x})}{3^x - 1} = \lim_{x \to 0} \frac{f(x)}{2x \cdot \ln 3 \cdot x} = 5\]</span></p><p>所以，<span class="math inline">\(\lim\limits_{x \to 0} \frac{f(x)}{x^2} = 10 \ln 3\)</span></p></li><li><blockquote><p>设在 <span class="math inline">\((-\infty, +\infty)\)</span> 上，<span class="math inline">\(f(x) \geq 0\)</span>，且对于任何 <span class="math inline">\(x_1\)</span>，<span class="math inline">\(x_2\)</span> 总有 <span class="math inline">\(\frac{1}{2} f(x_1) + \frac{1}{2} f(x_2) \leq f(\frac{x_1 + x_2}{2})\)</span> 成立。证明：<span class="math inline">\(f(x)\)</span> 恒为常数。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>数竞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction</title>
    <link href="/2025/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Introduction/"/>
    <url>/2025/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="network-edge">Network Edge</h1><p>applications and hosts</p><h1 id="client-program-and-server-program">Client Program and Server Program</h1><p>一般而言，客户端程序是 <strong>发送请求</strong> 的，而服务器端程序是 <strong>接受请求</strong> 的。</p><h1 id="access-technologies">Access Technologies</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>接入技术</th><th>分类</th><th>简要说明</th></tr></thead><tbody><tr class="odd"><td>数字用户线（DSL）</td><td>居家接入</td><td>通过电话线为家庭用户提供宽带互联网接入</td></tr><tr class="even"><td>电缆调制解调器</td><td>居家接入</td><td>通过有线电视网络为家庭用户提供互联网接入</td></tr><tr class="odd"><td>光纤到户（FTTH）</td><td>居家接入/公司接入</td><td>通过光纤直接连接家庭或公司，提供高速接入</td></tr><tr class="even"><td>以太网</td><td>公司接入</td><td>企业内部常用的局域网接入方式</td></tr><tr class="odd"><td>Wi-Fi</td><td>居家接入/公司接入</td><td>无线局域网，常用于家庭和公司内部无线接入</td></tr><tr class="even"><td>蜂窝移动网络（3G/4G/5G）</td><td>移动接入</td><td>通过移动运营商网络为移动设备提供互联网接入</td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>接入技术</th><th>典型速率范围</th><th>速率共享性</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>拨号调制解调器</td><td>最高 56 Kbps</td><td>专用</td><td>每户独占电话线</td></tr><tr class="even"><td>HFC</td><td>10 Mbps ~ 1 Gbps（下行）</td><td>共享</td><td>同轴电缆段内用户共享带宽</td></tr><tr class="odd"><td>DSL</td><td>256 Kbps ~ 100 Mbps（下行）</td><td>专用</td><td>每户独占电话线，汇聚点可能有瓶颈</td></tr><tr class="even"><td>FTTH</td><td>100 Mbps ~ 10 Gbps</td><td>通常专用</td><td>部分PON架构下分光器后带宽被共享</td></tr></tbody></table></div><h1 id="hfc-hybrid-fiber-coax">HFC: hybrid fiber coax</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>问题</th><th>答案</th></tr></thead><tbody><tr class="odd"><td>HFC 传输速率是专用还是共享？</td><td>共享</td></tr><tr class="even"><td>下行 HFC 信道是否可能发生冲突？</td><td>不会</td></tr><tr class="odd"><td>原因</td><td>只有头端设备发送，无多发冲突</td></tr></tbody></table></div><h1 id="ethernet-lans">Ethernet LANs</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>以太网类型</th><th>典型速率</th><th>每用户能否持续满速发送？</th></tr></thead><tbody><tr class="odd"><td>10BASE-T</td><td>10 Mbps</td><td>否</td></tr><tr class="even"><td>100BASE-TX</td><td>100 Mbps</td><td>否</td></tr><tr class="odd"><td>1000BASE-T</td><td>1 Gbps</td><td>否</td></tr><tr class="even"><td>10GBASE-T</td><td>10 Gbps</td><td>否</td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>物理介质类型</th><th>典型应用场景</th><th>传输距离</th><th>传输速率</th></tr></thead><tbody><tr class="odd"><td>双绞线</td><td>局域网、办公、家庭</td><td>最远可达100米</td><td>10 Mbps ~ 40 Gbps</td></tr><tr class="even"><td>光纤</td><td>数据中心、骨干网</td><td>数百米至数十公里</td><td>100 Mbps ~ 400 Gbps</td></tr><tr class="odd"><td>同轴电缆</td><td>早期局域网</td><td>数百米</td><td>10 Mbps</td></tr></tbody></table></div><h1 id="wireless-internet-access-technologies">Wireless Internet Access Technologies</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>技术类型</th><th>典型速率范围</th><th>覆盖范围</th><th>主要应用场景</th><th>延迟</th><th>主要优缺点</th></tr></thead><tbody><tr class="odd"><td>Wi-Fi</td><td>数十 Mbps ~ 数 Gbps</td><td>局部（几十米）</td><td>家庭、办公、热点</td><td>低</td><td>速率高、成本低、覆盖范围有限</td></tr><tr class="even"><td>蜂窝网络（4G/5G）</td><td>数十 Mbps ~ 数 Gbps</td><td>广域（城市/乡村）</td><td>移动设备、车载、物联网</td><td>低（5G更优）</td><td>覆盖广、速率高、需付流量费用</td></tr><tr class="odd"><td>卫星互联网</td><td>数十 Mbps ~ 数百 Mbps</td><td>全球（含偏远区）</td><td>偏远地区、应急通信</td><td>中~高</td><td>覆盖广、不依赖地面设施、延迟较高</td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>设备类型</th><th style="text-align: center;">物理层</th><th style="text-align: center;">链路层</th><th style="text-align: center;">网络层</th><th style="text-align: center;">传输层</th><th style="text-align: center;">应用层</th></tr></thead><tbody><tr class="odd"><td>路由器</td><td style="text-align: center;"><span class="math display">\[\surd\]</span></td><td style="text-align: center;"><span class="math display">\[\surd\]</span></td><td style="text-align: center;"><span class="math display">\[\surd\]</span></td><td style="text-align: center;"><span class="math display">\[\times\]</span></td><td style="text-align: center;"></td></tr><tr class="even"><td>链路层交换机</td><td style="text-align: center;"><span class="math display">\[\surd\]</span></td><td style="text-align: center;"><span class="math display">\[\surd\]</span></td><td style="text-align: center;"><span class="math display">\[\times\]</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td>主机</td><td style="text-align: center;"><span class="math display">\[\surd\]</span></td><td style="text-align: center;"><span class="math display">\[\surd\]</span></td><td style="text-align: center;"><span class="math display">\[\surd\]</span></td><td style="text-align: center;"><span class="math display">\[\surd\]</span></td><td style="text-align: center;"><span class="math display">\[\surd\]</span></td></tr></tbody></table></div><h1 id="packet-switching-and-circuit-switching">Packet Switching and Circuit Switching</h1><ul><li><strong>带宽保证</strong>：电路交换网络（如传统电话网）在通信双方建立连接时，会为其分配一条固定的物理路径和带宽，整个通信期间该带宽专属使用，不会被其他用户占用。</li><li><strong>通信延迟低且稳定</strong>：由于路径和带宽在会话期间独占，数据传输延迟固定且可预测，适合对实时性要求高的应用（如语音通话）。</li><li><strong>无拥塞丢包</strong>：通信过程中不会因网络拥塞导致丢包或重传，通信质量有保障。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>网络类型</th><th>主要优势</th></tr></thead><tbody><tr class="odd"><td>电路交换网络</td><td>带宽独占、延迟稳定、无拥塞丢包</td></tr><tr class="even"><td>分组交换网络</td><td>资源利用率高、灵活、适合突发性数据传输</td></tr></tbody></table></div><h2 id="statistical-multiplexing">Statistical Multiplexing</h2><p>分组交换（Packet Switching）中，网络资源（如链路带宽）是<strong>按需动态分配</strong>给各个数据流的。每个用户的数据被分成分组（包），这些分组在网络中独立传输，多个用户的分组在同一链路上<strong>交错传输</strong>。<br>由于不是每个用户都持续发送数据，链路带宽可以被“活跃”的用户动态共享，这种方式称为<strong>统计复用（Statistical Multiplexing）</strong>。</p><ul><li><strong>核心思想</strong>：利用用户流量的突发性和不均匀性，通过动态分配资源，提高链路利用率。</li><li><strong>资源分配</strong>：没有为每个用户预留固定带宽，资源按需分配。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>复用方式</th><th>资源分配方式</th><th>利用率</th><th>适用场景</th><th>主要特点</th></tr></thead><tbody><tr class="odd"><td>统计复用</td><td>动态分配，按需使用</td><td>高</td><td>分组交换网络</td><td>用户多时可能拥塞，利用率高</td></tr><tr class="even"><td>TDM（时分复用）</td><td>固定分配，每用户固定时隙</td><td>低（有空闲浪费）</td><td>电路交换网络</td><td>时隙空闲时无法被他人利用</td></tr></tbody></table></div><h2 id="store-and-forward-packet-switching">Store-and-Forward Packet Switching</h2><p><strong>存储转发</strong>：交换机必须在收到整个分组后，才能开始向下一个链路转发。</p><h1 id="isp">ISP</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>ISP 类型</th><th>互联方式</th><th>是否需购买上网带宽</th><th>网络覆盖范围</th></tr></thead><tbody><tr class="odd"><td>Tier-1 ISP</td><td>与其他 Tier-1 ISP 结算互免互联</td><td>否</td><td>全球骨干</td></tr><tr class="even"><td>Tier-2 ISP</td><td>部分互联+向上级 ISP 购买带宽</td><td>是</td><td>区域/国家级</td></tr></tbody></table></div><h1 id="delay">Delay</h1><ul><li>Processing Delay：每个路由器或主机在接收到分组时进行首部检查、差错检测等处理所需的时间。</li><li>Queuing Delay：分组在路由器的输出队列中等待转发的时间，取决于当前队列的长度和网络拥塞状况。</li><li>Transmission Delay： 分组所有比特从路由器或主机的输出端口“上线”所需的时间，计算公式为 <span class="math display">\[\text{传输时延} = \frac{L}{R}\]</span> 其中，<span class="math inline">\(L\)</span> 为分组长度（比特），<span class="math inline">\(R\)</span> 为链路带宽（比特/秒）。</li><li>Propagation Delay： 分组在物理链路上传播所需的时间，计算公式为： <span class="math display">\[\text{传播时延} = \frac{d}{s}\]</span> 其中，<span class="math inline">\(d\)</span> 为链路长度，<span class="math inline">\(s\)</span> 为信号在介质中的传播速率。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>时延类型</th><th>公式</th><th>是否依赖分组长度 L</th><th>是否依赖传输速率 R</th></tr></thead><tbody><tr class="odd"><td>传播时延</td><td><span class="math display">\[\frac{d}{s}\]</span></td><td>否</td><td>否</td></tr><tr class="even"><td>传输时延</td><td><span class="math display">\[\frac{L}{R}\]</span></td><td>是</td><td>是</td></tr><tr class="odd"><td>总时延</td><td><span class="math display">\[\frac{L}{R} + \frac{d}{s}\]</span></td><td>部分依赖</td><td>部分依赖</td></tr></tbody></table></div><h1 id="throughput">Throughput</h1><p>吞吐量：传输速率，单位 <span class="math inline">\(\text{bits} / \text{time}\)</span>。</p><p>每一个用于传输比特流的 <strong>pipe</strong> 的吞吐量可能不一致，这时如何计算端到端的吞吐量？ <span class="math display">\[\min \, \{R_C, R_S, \dots\}\]</span></p><p>这种情况下，端到端的吞吐量取决于整个传输路径中最慢的通道</p><h1 id="layer-structure">Layer Structure</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>任务名称</th><th>可能涉及的层级</th><th>是否可多层实现</th></tr></thead><tbody><tr class="odd"><td>分段与重组</td><td>传输层、网络层</td><td>是</td></tr><tr class="even"><td>差错检测与纠正</td><td>数据链路层、传输层</td><td>是</td></tr><tr class="odd"><td>流量控制</td><td>数据链路层、传输层</td><td>是</td></tr><tr class="even"><td>寻址与路由选择</td><td>网络层</td><td>否（主要网络层）</td></tr><tr class="odd"><td>封装与解封装</td><td>各层均有</td><td>是</td></tr></tbody></table></div><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>层级</th><th>数据单元名称</th><th>主要内容说明</th></tr></thead><tbody><tr class="odd"><td>应用层</td><td>应用层消息</td><td>应用协议数据（如HTTP请求、邮件内容等）</td></tr><tr class="even"><td>传输层</td><td>报文段（Segment）</td><td>传输层首部 + 应用层消息</td></tr><tr class="odd"><td>网络层</td><td>数据报（Datagram）</td><td>网络层首部 + 传输层报文段</td></tr><tr class="even"><td>链路层</td><td>帧（Frame）</td><td>链路层首部 + 网络层数据报 + 链路层尾部</td></tr></tbody></table></div><h1 id="security">Security</h1><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>类型</th><th style="text-align: center;">是否自我复制</th><th style="text-align: center;">是否依附宿主</th><th style="text-align: center;">是否主动传播</th><th>主要危害方式</th></tr></thead><tbody><tr class="odd"><td>病毒</td><td style="text-align: center;">是</td><td style="text-align: center;">是</td><td style="text-align: center;">否</td><td>破坏文件、传播感染</td></tr><tr class="even"><td>蠕虫</td><td style="text-align: center;">是</td><td style="text-align: center;">否</td><td style="text-align: center;">是</td><td>网络传播、资源消耗</td></tr><tr class="odd"><td>特洛伊木马</td><td style="text-align: center;">否</td><td style="text-align: center;">否</td><td style="text-align: center;">否</td><td>窃密、远控、伪装攻击</td></tr></tbody></table></div><ul><li><strong>僵尸网络（Botnet）</strong>：由大量被恶意控制的设备组成的分布式网络。</li><li><strong>DDoS攻击（分布式拒绝服务攻击）</strong>：利用僵尸网络同时发起大规模攻击，瘫痪目标服务。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>阶段</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>恶意软件传播</td><td>通过多种方式感染大量设备</td></tr><tr class="even"><td>设备感染与控制</td><td>感染设备与C&amp;C服务器建立联系，成为“僵尸”</td></tr><tr class="odd"><td>集中管理</td><td>攻击者统一管理所有僵尸设备</td></tr><tr class="even"><td>发起DDoS攻击</td><td>僵尸设备同时向目标发起流量，导致目标服务瘫痪</td></tr></tbody></table></div><h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1><h2 id="r.15">R.15</h2><p>Suppose users share a <span class="math inline">\(2\)</span> Mbps link. Also suppose each user transmits continuously at <span class="math inline">\(1\)</span> Mbps when transmitting, but each user transmits only <span class="math inline">\(20\)</span> percent of the time. (See the discussion of statistical multiplexing in Section <span class="math inline">\(1.3\)</span>.)</p><p><strong>Questions and Answers:</strong></p><p><strong>a. When circuit switching is used, how many users can be supported?</strong></p><p>在电路交换中，每个用户需要预留 <span class="math inline">\(1\)</span> Mbps 的带宽，而链路总带宽为 <span class="math inline">\(2\)</span> Mbps。因此，最多可以支持：</p><p><span class="math display">\[\text{用户数} = \frac{\text{总带宽}}{\text{每用户带宽}} = \frac{2 \, \text{Mbps}}{1 \, \text{Mbps}} = 2 \, \text{用户}\]</span></p><p><strong>b. For the remainder of this problem, suppose packet switching is used. Why will there be essentially no queuing delay before the link if two or fewer users transmit at the same time? Why will there be a queuing delay if three users transmit at the same time?</strong></p><ul><li>如果两名或更少的用户同时传输，每个用户的传输速率为 <span class="math inline">\(1\)</span> Mbps，总传输速率为 <span class="math inline">\(2\)</span> Mbps 或更少，等于链路的总带宽。因此，数据可以立即通过链路传输，不会产生排队延迟。</li><li>如果三名用户同时传输，总传输速率为 <span class="math inline">\(3 \, \text{Mbps}\)</span>，超过了链路的总带宽 <span class="math inline">\(2 \, \text{Mbps}\)</span>。此时，链路无法立即传输所有数据，导致数据在队列中等待，从而产生排队延迟。</li></ul><p><strong>c. Find the probability that a given user is transmitting.</strong></p><p>每个用户有 <span class="math inline">\(20\%\)</span> 的时间在传输数据，因此某个用户正在传输的概率为：</p><p><span class="math display">\[P(\text{用户传输}) = 0.2\]</span></p><p><strong>d. Suppose now there are three users. Find the probability that at any given time, all three users are transmitting simultaneously. Find the fraction of time during which the queue grows.</strong></p><ul><li>每个用户独立传输的概率为 <span class="math inline">\(0.2\)</span>，因此三名用户同时传输的概率为：</li></ul><p><span class="math display">\[P(\text{三名用户同时传输}) = P(\text{用户1传输}) \cdot P(\text{用户2传输}) \cdot P(\text{用户3传输}) = 0.2 \cdot 0.2 \cdot 0.2 = 0.008\]</span></p><ul><li>队列增长的时间比例等于三名用户同时传输的概率，因为只有在这种情况下，传输速率超过链路带宽：</li></ul><p><span class="math display">\[\text{队列增长的时间比例} = 0.008\]</span></p><h2 id="r.19">R.19</h2><p>Suppose Host A wants to send a large file to Host B. The path from Host A to Host B has three links, of rates <span class="math inline">\(R_1\)</span> = <span class="math inline">\(500\)</span> Kbps, <span class="math inline">\(R_2\)</span> = <span class="math inline">\(2\)</span> Mbps, and <span class="math inline">\(R_3\)</span> = <span class="math inline">\(1\)</span> Mbps.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. Assuming no other traffic in the network, what is the throughput for the file transfer.</strong></p><ul><li>用公式 <span class="math inline">\(\min {R_i}\)</span> 计算得到实际吞吐量是 <span class="math inline">\(500\)</span> Kbps。</li></ul><p><strong>b. Suppose the file is 4 million bytes. Dividing the file size by the throughput, roughly how long will it take to transfer the file to Host B?</strong></p><ul><li><span class="math display">\[\text{传输时间} = \frac{4 \times 10^{6} \times 8}{500 \times 1000} = 64 \, \text{s}\]</span></li></ul><p><strong>c. Repeat (a) and (b), but now with R2 reduced to 100 Kbps.</strong></p><ul><li>用公式 <span class="math inline">\(\min {R_i}\)</span> 计算得到实际吞吐量是 <span class="math inline">\(100\)</span> Kbps。</li><li><span class="math display">\[\text{传输时间} = \frac{4 \times 10^{6} \times 8}{100 \times 1000} = 320 \, \text{s}\]</span></li></ul><h2 id="r.23">R.23</h2><p><strong>Questions and Answers:</strong></p><p><strong>What are the five layers in the Internet protocol stack? What are the principal responsibilities of each of these layers?</strong></p><p>There are application layer, transport layer, network layer, data link layer and physical layer. Their principal responsibilities are as follow:</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><strong>层级</strong></th><th><strong>名称</strong></th><th><strong>主要职责</strong></th><th><strong>典型协议举例</strong></th></tr></thead><tbody><tr class="odd"><td><strong>第5层</strong></td><td>应用层 (Application)</td><td>提供<strong>网络服务的接口</strong>，支持应用程序间的通信</td><td>HTTP, FTP, SMTP, DNS</td></tr><tr class="even"><td><strong>第4层</strong></td><td>传输层 (Transport)</td><td>提供<strong>端到端的传输服务</strong>，负责分段、重组、流量控制和差错恢复</td><td>TCP, UDP</td></tr><tr class="odd"><td><strong>第3层</strong></td><td>网络层 (Network)</td><td>负责<strong>数据包的路由和转发</strong>，实现<strong>端到端的寻址和路径选择</strong></td><td>IP, ICMP, OSPF, BGP</td></tr><tr class="even"><td><strong>第2层</strong></td><td>数据链路层 (Data Link)</td><td>提供<strong>相邻节点间可靠传输</strong>，处理帧的封装、寻址、差错检测和媒体访问控制</td><td>Ethernet, PPP, HDLC, Wi-Fi</td></tr><tr class="odd"><td><strong>第1层</strong></td><td>物理层 (Physical)</td><td>负责<strong>比特流的传输</strong>，定义物理介质、信号编码和传输速率等物理特性</td><td>RS-232, USB, SONET, 以太网物理标准</td></tr></tbody></table></div><h2 id="p.8">P.8</h2><p>Consider the discussion in Section <span class="math inline">\(1.3\)</span> of statistical multiplexing in which an example is provided with a <span class="math inline">\(1\)</span> Mbps link. Users are generating data at a rate of <span class="math inline">\(100\)</span> Kbps when busy, but are busy generating data only with probability <span class="math inline">\(p = 0.1\)</span>. Suppose that the <span class="math inline">\(1\)</span> Mbps link is replaced by a <span class="math inline">\(1\)</span> Gbps link.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is <span class="math inline">\(N\)</span>, the maximum number of users that can be supported simultaneously under circuit switching?</strong></p><p><span class="math display">\[N = \frac{1 \, \text{Gbps}}{100 \, \text{Kbps}} = 10000\]</span></p><p><strong>b. Now consider packet switching and a user population of <span class="math inline">\(M\)</span> users. Give a formula (in terms of <span class="math inline">\(p\)</span>, <span class="math inline">\(M\)</span>, <span class="math inline">\(N\)</span>) for the probability that more than <span class="math inline">\(N\)</span> users are sending data.</strong></p><p>假设用户的发送行为是独立的，则发送数据的用户数目服从二项分布，只考虑 <span class="math inline">\(M \geq N\)</span>： <span class="math display">\[P_{ &gt; N} = 1 - \sum_{k = 0}^{N} \binom{M}{k} p^k (1 - p)^{M - k}\]</span></p><h2 id="p.22">P.22</h2><p>Consider Figure <span class="math inline">\(1.19(a)\)</span>. Assume that we know the bottleneck link along the path from the server to the client is the first link with rate <span class="math inline">\(R_s\)</span> <span class="math inline">\(\text{bits/sec}\)</span>. Suppose we send a pair of packets back to back from the server to the client, and there is no other traffic on this path. Assume each packet of size <span class="math inline">\(L\)</span> <span class="math inline">\(\text{bits}\)</span>, and both links have the same propagation delay <span class="math inline">\(d_{prop}\)</span>.</p><figure><img src="/2025/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Introduction/Throughput%20for%20a%20file%20transfer%20from%20server%20to%20client.png" style="display: block; margin: 0 auto; width: 90%" alt="Figure 1.19(a)"><figcaption aria-hidden="true">Figure 1.19(a)</figcaption></figure><p>back-to-back 指的是一组数据包在没有间隔的情况下连续发送</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is the packet inter-arrival time at the destination? That is, how much time elapses from when the last bit of the first packet arrives until the last bit of the second packet arrives?</strong></p><p>从图中我们可以看到有两条 <strong>link</strong>，速率分别是 <span class="math inline">\(R_s\)</span> 和 <span class="math inline">\(R_c\)</span>，前者导致瓶颈，也就是 <span class="math inline">\(R_c\)</span> &gt; <span class="math inline">\(R_s\)</span>。所以，<strong>inter-arrival time</strong>： <span class="math display">\[t = \frac{L}{R_s}\]</span></p><p><strong>b. Now assume that the second link is the bottleneck link (i.e., <span class="math inline">\(R_c\)</span> &lt; <span class="math inline">\(R_s\)</span>). Is it possible that the second packet queues at the input queue of the second link? Explain. Now suppose that the server sends the second packet <span class="math inline">\(T\)</span> seconds after sending the first packet. How large must <span class="math inline">\(T\)</span> be to ensure no queuing before the second link? Explain.</strong></p><p>有可能第二个包在第二条 link 输入处排队，因为 <span class="math inline">\(R_c\)</span> &lt; <span class="math inline">\(R_s\)</span> 导致，第一包仍在传输。只要保证当第二个包到达第二条 link 输入时，第一个包已经传完了，也就是： <span class="math display">\[T = \frac{L}{R_c}\]</span></p><h2 id="p.28">P.28</h2><p>Suppose there is a <span class="math inline">\(10\)</span> <span class="math inline">\(\text{Mbps}\)</span> microwave link between a geostationary satellite and its base station on Earth. Every minute the satellite takes a digital photo and sends it to the base station. Assume a propagation speed of <span class="math inline">\(2.4 \cdot 10^8\)</span> <span class="math inline">\(\text{meters/sec}\)</span>.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is the propagation delay of the link?</strong></p><p>地球静止卫星轨道高度约为 <span class="math inline">\(d \approx 3.5786 \times 10^7 \, \text{m}\)</span>，再由公式 <span class="math inline">\(d_{prop} = \frac{d}{s}\)</span> 得到 <span class="math inline">\(d_{prop} \approx 150 \, \text{ms}\)</span></p><p><strong>b. What is the bandwidth-delay product, <span class="math inline">\(R \cdot d_{prop}\)</span>?</strong></p><p>这个乘式中的 <span class="math inline">\(R\)</span> 是 link 的传输速率，表示的是因延迟而没有传输的数据大小。结果是 <span class="math inline">\(10 \times 10^6 \times 0.15 = 1.5 \times 10^6 \, \text{bits}\)</span>。</p><p><strong>c. Let <span class="math inline">\(x\)</span> denote the size of the photo. What is the minimum value of <span class="math inline">\(x\)</span> for the microwave link to be continuously transmitting?</strong></p><p>设照片大小为 <span class="math inline">\(x\)</span>（单位：<span class="math inline">\(\text{bits}\)</span>），要使链路持续发送，需满足传输时间 <span class="math inline">\(\frac{x}{R}\)</span> 不小于拍照间隔 <span class="math inline">\(60\,\text{s}\)</span>，即<br><span class="math display">\[\frac{x}{R} \geq 60 \, \Longrightarrow \; x \geq R \times 60 = 10\times10^6\ \text{bps} \times 60\ \text{s} = 600\times10^6\ \text{bits} = 75\ \text{MB}.\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Introduction</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Wireless and Mobile Networks</title>
    <link href="/2025/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireless-and-Mobile-Networks/"/>
    <url>/2025/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireless-and-Mobile-Networks/</url>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><h2 id="elements-of-a-wireless-networks">Elements of a Wireless Networks</h2><ul><li><strong>Wireless Hosts:</strong> laptop, PDA, IP phone.</li><li><strong>Base Station:</strong><ul><li>connected to a <strong>wired network</strong>.</li><li><strong>relays</strong><ul><li>responsible for sending packets between wired network and wireless hosts in its area.</li></ul></li></ul></li><li><strong>Wireless Link:</strong><ul><li>typically used to connect mobiles to bas stations.</li><li><strong>multiple access protocol</strong> coordinates link access.</li></ul></li><li><strong>Infrastructure Mode:</strong><ul><li><strong>handoff:</strong> mobile changes base station providing connection into wired network.</li></ul></li><li><strong>Ad Hoc Mode:</strong><ul><li>no base stations.</li><li>nodes can only transmit to other nodes within link coverage.</li><li>nodes organize themselves into a network: route among themselves.</li></ul></li></ul><h2 id="wireless-network-taxonomy">Wireless Network Taxonomy</h2><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><strong>Infrastructure</strong></th><th><strong>Single Hop</strong></th><th><strong>Multiple Hops</strong></th></tr></thead><tbody><tr class="odd"><td><strong>With Infrastructure</strong></td><td>Host connects to base station (WiFi, WiMAX, cellular) which connects to larger Internet.</td><td>Host relays through several wireless nodes to connect to larger Internet (mesh net).</td></tr><tr class="even"><td><strong>Without Infrastructure</strong></td><td>No base station, no connection to larger Internet (e.g., Bluetooth, ad hoc nets).</td><td>No base station, no connection to larger Internet. Nodes relay to reach other nodes (e.g., MANET, VANET).</td></tr></tbody></table></div><h1 id="wireless-link-characteristics">Wireless Link Characteristics</h1><blockquote><p>从下文可以分析出，这里的 link 不能翻译成<strong>链路</strong>而应该翻译成<strong>连接</strong>。</p></blockquote><ul><li><strong>decreased signal strength</strong></li><li><strong>interference from other sources</strong></li><li><strong>multipath propagation</strong></li></ul><p>Multiple wireless senders and receivers create additional problems (beyond multiple access): - <strong>Hidden Terminal Problem:</strong> A and C can not hear each other means A and C are unaware of their interference B.</p><blockquote><p>这里是在讲，A 和 C 因为障碍物的问题而无法直接通信从而无法协调，但他们都能和 B 进行通信，如果 A 和 C 同时向 B 通信会导致冲突。</p></blockquote><ul><li><strong>SNR (Signal-to-Noise Ratio):</strong><ul><li>larger SNR, easier to extract signal from noise.</li><li>increases power <span class="math inline">\(\to\)</span> increases SNR <span class="math inline">\(\to\)</span> decreases <strong>BER (Bit Error Rate)</strong>.</li><li>Given SNR, choose physical layer that meets BER requirement, giving highest throughput.</li></ul></li></ul><blockquote><p>SNR 是信噪比，顾名思义是一个比值，具体计算公式为 <span class="math display">\[\mathrm{SNR} = \frac{P_{\text{signal}}}{P_{\text{noise}}}\]</span> 实际中用单位 db 表示。SNR 越大，说明信号越容易从噪声中分辨出来，通信质量越好。</p></blockquote><h2 id="code-division-multiple-access-cdma">Code Division Multiple Access (CDMA)</h2><blockquote><p>码分多址，这个我们在 data link layer 提到过，类似的有 TDMA 和 FDMA。需要注意的是 CDMA 是一个 physical layer protocol。所以下文用的是 channel 而不是 link。</p></blockquote><p>A kind of <strong>channel partitioning protocol</strong>.</p><ul><li><strong>Usage</strong>: Used in <strong>wireless broadcast channels</strong> (e.g., cellular, satellite).</li><li><strong>Code Assignment</strong>: Each user is assigned a <strong>unique “code”</strong> (code set partitioning).</li><li><strong>Frequency Sharing</strong>: All users share the same frequency but use distinct <strong>“chipping”</strong> sequences to encode data.</li><li><strong>Signal Encoding</strong>:<ul><li>Encoded signal = (original data) (chipping sequence).</li></ul></li><li><strong>Signal Decoding</strong>:<ul><li>Decoding is done using the inner product of the encoded signal and the chipping sequence.</li></ul></li><li><strong>Advantage</strong>: Allows multiple users to coexist and transmit simultaneously with minimal interference (if codes are orthogonal). &gt; 这里提到的 unique code 和 chipping sequence 是同一个事物。</li></ul><h3 id="cdma-encodedecode-process">CDMA Encode/Decode Process</h3><h4 id="sender"><strong>Sender:</strong></h4><ol type="1"><li><strong>Data Encoding</strong>:<ul><li>Each sender has a unique code (chipping sequence) <code>c_m</code>.</li><li>Encoded signal for each data bit:<br><span class="math display">\[ Z_{i,m} = d_i \cdot c_m \]</span><ul><li><code>d_i</code>: Original data bit.</li><li><code>c_m</code>: Chipping sequence.</li></ul></li></ul></li><li><strong>Channel Output</strong>:<ul><li>Encoded signals are transmitted over the shared channel.</li><li>Channel output combines signals from all senders.</li></ul></li></ol><h4 id="receiver"><strong>Receiver:</strong></h4><ol type="1"><li><strong>Signal Decoding</strong>:<ul><li>Receiver uses the inner product of the received signal and its own chipping sequence to decode data: <span class="math display">\[ D_i = \frac{\sum_{m=1}^{M} Z_{i,m} \cdot c_m}{M} \]</span><ul><li><code>D_i</code>: Decoded data bit.</li><li><code>Z_&#123;i,m&#125;</code>: Received signal.</li><li><code>c_m</code>: Receiver’s chipping sequence.</li></ul></li></ul></li><li><strong>Output</strong>:<ul><li>Decoded data bits are extracted from the combined channel output.</li></ul></li></ol><blockquote><p>每个发送端都被分配一个唯一的码字（chipping sequence），码字的长度应该足够长，按理来讲，如果有 <span class="math inline">\(N\)</span> 个用户，码字长度 <span class="math inline">\(M \geq N\)</span>。码字具体为：用 <span class="math inline">\(+1\)</span> 和 <span class="math inline">\(-1\)</span> 分别代表 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(0\)</span>。发送者将发送数据与码字相乘，这里指的是位对码字相乘。发送后数据会和其他所有发送者的信息在 channel 中叠加。解码公式有一个前提：要求 user 使用的码字之间正交。除以 M 是为保证归一化。</p><p>还要补充的是，CDMA 的核心思想是：所有用户在 <strong>same frequency</strong> 和 <strong>same time</strong> 的情况下发送信息。此时应用 CDMA。如果 frequency 不一致，也不会发生信号叠加，此时应该用 FDMA。</p></blockquote><h1 id="wifi-802.11-wireless-lans">WiFi: 802.11 Wireless LANs</h1><blockquote><p>前部分介绍了 wireless link 及其用到的 CDMA protocol，</p></blockquote><ul><li>all use <strong>CSMA/CA</strong> for multiple access. &gt; data link layer 部分我们讲过了 CSMA/CD。</li><li>all have base-station and ad-hoc network versions.</li></ul><h2 id="the-802.11-lan-architecture">The 802.11 LAN Architecture</h2><ul><li>wireless host communicates with base station (base station = access point (AP))</li><li>Basic Service Set (BSS) (aka “cell”一片区域) in infrastructure mode contains:<ul><li>wireless hosts</li><li>access point (AP): base station</li><li>ad hoc mode: hosts only</li></ul></li><li><strong>层次关系</strong>：一个 subnet 可以包含<strong>多个 BSS</strong>，多个无线主机通过不同接入点接入同一子网</li><li><strong>切换过程</strong>：<ul><li>当移动设备在<strong>同一子网内</strong>的不同 BSS 之间移动时，只需改变 BSS 关联（链路层切换），IP 地址<strong>保持不变</strong></li><li>当移动设备跨子网移动时，除了需要切换 BSS，还需要获取新子网的 IP 地址（通常通过 DHCP）</li></ul></li><li><strong>地址分配</strong>：BSS 关注 MAC 地址，而 Subnet 关注 IP 地址</li><li><strong>管理机制</strong>：BSS 由 AP 管理，Subnet 由路由器管理</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><strong>特性</strong></th><th><strong>BSS</strong></th><th><strong>Subnet</strong></th></tr></thead><tbody><tr class="odd"><td><strong>所属网络层次</strong></td><td>物理层和数据链路层 (OSI 第 1、2 层)</td><td>网络层 (OSI 第 3 层)</td></tr><tr class="even"><td><strong>定义标准</strong></td><td>IEEE 802.11 标准</td><td>IP 协议标准</td></tr><tr class="odd"><td><strong>标识符</strong></td><td>BSSID (MAC 地址)</td><td>IP 地址前缀和子网掩码</td></tr><tr class="even"><td><strong>地址范围</strong></td><td>单个无线接入点覆盖范围</td><td>可跨多个接入点，由路由器定义</td></tr><tr class="odd"><td><strong>关注点</strong></td><td>无线媒体访问和信号传输</td><td>IP 数据包的寻址和路由</td></tr><tr class="even"><td><strong>设备组织方式</strong></td><td>围绕单个接入点的无线主机集合</td><td>共享同一网络前缀的主机集合</td></tr><tr class="odd"><td><strong>移动特性</strong></td><td>设备在 BSS 间移动需要进行<strong>切换 (handoff)</strong></td><td>在同一子网内的移动不需要更改 IP 地址</td></tr></tbody></table></div><h2 id="channels-association">802.11: Channels, Association</h2><ul><li><strong>Frequency Spectrum</strong>: 2.4GHz-2.485GHz (802.11b) divided into 11 channels.</li><li><strong>AP Configuration</strong>: Admin selects frequency for AP; interference may occur if neighboring APs use the same channel.</li><li><strong>Host Association</strong>:<ul><li>Scans channels for beacon frames with AP’s SSID and MAC address.</li><li>Selects an AP to associate with.</li><li>May perform authentication.</li><li>Typically runs <strong>DHCP</strong> to obtain an IP address in the AP’s subnet. &gt; 前文我们讲 CDMA 的时候提到了： CDMA 的所有用户使用相同的 frequency。通常情况下，一个 AP 在同一时刻只工作在一个信道（即一个频率范围），只能收发该信道上的无线信号。</li></ul></li></ul><h2 id="passiveactive-scanning">802.11: Passive/Active Scanning</h2><blockquote><p>Beacon Frame（信标帧） 是 IEEE 802.11 无线局域网（WiFi）协议中由接入点（AP, Access Point）周期性广播的一种管理帧。</p></blockquote><ul><li><strong>Passive Scanning</strong>:<ul><li>APs send <strong>beacon frames</strong>.</li><li>Host (H1) sends Association Request frame to selected AP.</li><li>Selected AP sends Association Response frame to H1.</li></ul></li><li><strong>Active Scanning</strong>:<ul><li>Host (H1) broadcasts Probe Request frame.</li><li>APs respond with Probe Response frames.</li><li>Host (H1) sends Association Request frame to selected AP.</li><li>Selected AP sends Association Response frame to H1.</li></ul></li></ul><blockquote><p>这两种方式最后两步都是一样的。</p></blockquote><h2 id="ieee-802.11-multiple-access">IEEE 802.11: Multiple Access</h2><blockquote><p>data link layer</p></blockquote><h3 id="collision-avoidance-in-802.11">Collision Avoidance in 802.11</h3><ul><li><strong>Problem</strong>: Collisions occur when <span class="math inline">\(2\)</span> more nodes transmit simultaneously.</li><li><strong>Solution</strong>:<ul><li><strong>CSMA</strong>: Sense the channel before transmitting to avoid collisions with ongoing transmissions.</li><li><strong>No Collision Detection</strong>:<ul><li>Difficult to sense collisions while transmitting due to weak received signals (fading).</li><li><strong>Hidden terminal</strong> and <strong>fading issues</strong> prevent sensing all collisions.</li></ul></li><li><strong>Goal</strong>: Use <strong>CSMA/CA (Collision Avoidance)</strong> to minimize collisions.</li></ul></li></ul><h2 id="ieee-802.11-mac-protocol-csmaca">IEEE 802.11 MAC Protocol: CSMA/CA</h2><blockquote><p>DIFS 是<strong>分布式帧间间隔</strong>（Distributed Inter-Frame Space）的缩写。SIFS 是<strong>短帧间间隔</strong>（Short Inter-Frame Space）的缩写。<strong>Link（链路）</strong>：在有线网络中，通常指两个节点之间的物理连接。<strong>Channel（信道）</strong>：在无线网络中，指的是一段特定频率范围内的无线传输资源，多个节点可以共享同一个信道。</p></blockquote><h3 id="sender-1"><strong>802.11 Sender</strong></h3><ol type="1"><li><strong>Channel Idle</strong>:<ul><li>If the channel is idle for DIFS, transmit the entire frame (no collision detection).</li></ul></li><li><strong>Channel Busy</strong>:<ul><li>Start a random backoff timer.</li><li>Timer counts down while the channel is idle.</li><li>Transmit when the timer expires.</li><li>If no ACK is received, increase the random backoff interval and repeat step <span class="math inline">\(2\)</span>.</li></ul></li></ol><h3 id="receiver-1"><strong>802.11 Receiver</strong></h3><ul><li>If the frame is received correctly:<ul><li>Return an ACK after SIFS (ACK is needed to address the hidden terminal problem).</li></ul></li></ul><h3 id="avoiding-collisions-rtscts-mechanism">Avoiding Collisions: RTS/CTS Mechanism</h3><ul><li><strong>Idea</strong>: Allow sender to reserve the channel to avoid collisions of long data frames.</li><li><strong>Process</strong>:<ol type="1"><li>Sender transmits a small <strong>Request-to-Send (RTS)</strong> packet to the base station (BS) using CSMA.</li><li>RTS packets may collide, but they are short.</li><li>BS responds with a <strong>Clear-to-Send (CTS)</strong> packet, broadcast to all nodes.</li><li>Sender transmits the data frame.</li><li>Other stations defer their transmissions upon hearing the CTS.</li></ol></li><li><strong>Advantage</strong>: Completely avoids collisions of long data frames by using small reservation packets.</li></ul><ol type="1"><li><strong>发送预约请求（RTS）</strong><ul><li>发送方先发送一个很短的 RTS（Request to Send）帧给基站（或接入点，AP），请求占用信道。</li></ul></li><li><strong>接收预约确认（CTS）</strong><ul><li>基站收到 RTS 后，如果信道空闲，则广播一个 CTS（Clear to Send）帧，通知所有节点允许该发送方发送数据。</li></ul></li><li><strong>数据发送</strong><ul><li>发送方收到 CTS 后，立即发送长数据帧。</li></ul></li><li><strong>其他节点监听</strong><ul><li>网络中其他节点收到 CTS 后，会在指定时间内暂停发送，避免与当前数据帧发生冲突。</li></ul></li></ol><h2 id="addressing">802.11 Addressing</h2><p>下表总结了 802.11 帧的各字段及其作用：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>字段名</th><th>长度（字节）</th><th>作用说明</th></tr></thead><tbody><tr class="odd"><td>frame control</td><td>2</td><td>帧控制字段，指示帧类型、控制信息等</td></tr><tr class="even"><td>duration</td><td>2</td><td>持续时间字段，指示信道预留时间</td></tr><tr class="odd"><td>address 1</td><td>6</td><td>接收方 MAC 地址（无线主机或 AP）</td></tr><tr class="even"><td>address 2</td><td>6</td><td>发送方 MAC 地址（无线主机或 AP）</td></tr><tr class="odd"><td>address 3</td><td>6</td><td>路由器接口的 MAC 地址（AP 所连接的路由器接口）</td></tr><tr class="even"><td>seq control</td><td>2</td><td>序列控制字段，帧编号等</td></tr><tr class="odd"><td>address 4</td><td>6</td><td>仅在 ad hoc 模式下使用的地址</td></tr><tr class="even"><td>payload</td><td>0 - 2312</td><td>数据负载部分</td></tr><tr class="odd"><td>CRC</td><td>4</td><td>循环冗余校验，用于差错检测</td></tr></tbody></table></div><p><strong>说明：</strong> - address 1：接收方 MAC 地址 - address 2：发送方 MAC 地址 - address 3：AP 所连接的路由器接口的 MAC 地址 - address 4：仅 ad hoc 模式下使用</p><h2 id="mobility-within-same-subnet">Mobility within Same Subnet</h2><p>Host 在统一子网下不同 BSS 移动，switch 如何得知 host 当前在哪个 BSS 内？实际上 switch 能通过 self-learning：switch will see frame from H1 and remember which switch port can be used to reach H1。</p><h2 id="power-management">Power Management</h2><ul><li><strong>定时唤醒机制</strong>：<br>休眠节点在进入省电模式（Power Save Mode）时，会本地保存下一个 beacon frame 的预计到达时间，并设置定时器（timer）。</li><li><strong>硬件支持</strong>：<br>无线网卡硬件通常具备低功耗计时功能，可以在主机休眠时保持计时，确保在 beacon frame 到来前自动唤醒。</li><li><strong>唤醒流程</strong>：<br>节点休眠后，定时器到达设定时间，节点自动唤醒，监听并接收 AP 广播的 beacon frame，判断是否有待接收的数据。</li><li><strong>节能的核心在于节点休眠</strong>：<br>节能的关键不是 AP 是否省电，而是<strong>无线终端（如手机、笔记本）可以长时间休眠，仅在 beacon frame 到来时短暂唤醒</strong>，大大减少无线网卡的活跃时间和能耗。</li><li><strong>AP 通常为插电设备</strong>：<br>AP 持续广播 beacon frame 对其本身能耗影响不大，因为 AP 通常是接入电源的设备，不依赖电池。</li><li><strong>终端省电效果显著</strong>：<br>终端设备在无数据通信时可以关闭大部分无线模块，仅保留低功耗计时和唤醒功能，只有在需要接收数据或发送数据时才唤醒主模块，极大延长了电池续航。</li></ul><h2 id="personal-area-network">802.15: Personal Area Network</h2><p>个人热点。使用 ad hoc mode，参考 bluetooth protocol。</p><h2 id="wimax">802.16: WiMAX</h2><h1 id="cellular-internet-access">Cellular Internet Access</h1><p>介绍几个概念： - <strong>Cell</strong>：一个区域，里面有一个 base station，mobile users 通过这个基站连接到 network。 - <strong>MCS</strong>：Mobile Switching Center。连接 base station 和 wired network。</p><h2 id="the-first-hop">The First Hop</h2><p>第一跳为 users 到 base station。显然是一个 multiple senders 的场景，可以用 FDMA、TDMA 和 CDMA 分离数据。</p><h2 id="cellular-standards-brief-survey">Cellular standards: brief survey</h2><h3 id="g-systems"><strong>2G Systems</strong></h3><ul><li><strong>Voice Channels</strong>:<ul><li><strong>IS-136 TDMA</strong>: Combined FDMA/TDMA (North America).</li><li><strong>GSM</strong>: Global System for Mobile Communications, combined FDMA/TDMA (most widely deployed).</li><li><strong>IS-95 CDMA</strong>: Code Division Multiple Access.</li></ul></li></ul><h3 id="g-systems-1"><strong>2.5G Systems</strong></h3><ul><li><strong>Voice and Data Channels</strong>:<ul><li><strong>GPRS</strong>: Evolved from GSM, data sent on multiple channels.</li><li><strong>EDGE</strong>: Enhanced modulation, data rates up to 384K.</li><li><strong>CDMA-2000 (Phase 1)</strong>: Data rates up to 144K, evolved from IS-95.</li></ul></li></ul><h3 id="g-systems-2"><strong>3G Systems</strong></h3><ul><li><strong>Voice/Data</strong>:<ul><li><strong>UMTS</strong>: High-Speed Uplink/Downlink Packet Access (HSDPA/HSUPA), 3 Mbps.</li><li><strong>CDMA-2000</strong>: Data service (1xEVDO), up to 14 Mbps.</li></ul></li></ul><h3 id="g-systems-3"><strong>4G Systems</strong></h3><ul><li><strong>Voice/Data</strong>:<ul><li><strong>LTE</strong>: Employs OFDM and MIMO techniques, 100 Mbps for downlink, 50 Mbps for uplink.</li></ul></li></ul><h1 id="principles-addressing-and-routing-to-mobile-users">Principles: Addressing and Routing to Mobile Users</h1><p><strong>mobile user, passing through multiple access point while maintaining ongoing connections (like cell phone)</strong></p><h2 id="mobility-vocabulary">Mobility: Vocabulary</h2><h3 id="home-network"><strong>Home Network</strong></h3><ul><li>Permanent “home” of the mobile device (e.g., 128.119.40/24).</li><li><strong>Permanent Address</strong>: Address in the home network, always used to reach the mobile (e.g., 128.119.40.186).</li><li><strong>Home Agent</strong>: Entity in the home network that performs mobility functions for the mobile when it is remote.</li></ul><h3 id="visited-network"><strong>Visited Network</strong></h3><ul><li>Network where the mobile device currently resides (e.g., 79.129.13/24).</li><li><strong>Care-of-Address</strong>: Temporary address assigned to the mobile in the visited network (e.g., 79.129.13.2).</li><li><strong>Foreign Agent</strong>: Entity in the visited network that performs mobility functions on behalf of the mobile.</li></ul><h3 id="correspondent"><strong>Correspondent</strong></h3><ul><li>The entity that wants to communicate with the mobile device.</li></ul><h3 id="consider-friend-frequently-changing-addresses-how-do-you-find-her">Consider friend frequently changing addresses, how do you find her?</h3><p><strong>let end-systems handle it:</strong> - indirect routing: communication from correspondent to mobile goes through home agent, then forwarded to remote - direct routing: correspondent gets foreign address of mobile, sends directly to mobile</p><figure><img src="/2025/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireless-and-Mobile-Networks/Indirect%20routing%20to%20a%20mobile%20node.png" style="display: block; margin: 0 auto; width: 90%" alt="Indirect routing"><figcaption aria-hidden="true">Indirect routing</figcaption></figure><p>第一种 indirect routing，见上图所示，当你的朋友移动到其它 <strong>foreign</strong> 网络，他会得到一个 <strong>Care-of-Address</strong>，这个地址是临时的，用于在当前所在子网下通信，但他有一个 <strong>Permanent Address</strong>，可以通过联系他的 <strong>Home agent</strong>，从而联系到他所在子网的 <strong>Foreign agent</strong>，从而联系到他。</p><figure><img src="/2025/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireless-and-Mobile-Networks/Direct%20routing%20to%20a%20mobile%20user.png" style="display: block; margin: 0 auto; width: 90%" alt="Direct routing"><figcaption aria-hidden="true">Direct routing</figcaption></figure><p>第二种是 direct routing，这种是先通过联系他的 Home agent，得到他所在子网的 IP address，从联系到他。</p><p>需要补充两点： 1. <strong>correspondent 如何得到 friend 的 permanent address</strong>. - <strong>permanent address（永久地址）</strong> 是 friend 在 home network 的固定 IP 地址，通常是 friend 在 home network 注册时分配的。 - <strong>correspondent（通信对端）</strong> 想要联系 friend 时，通常会通过 DNS 查询等方式获得 friend 的 permanent address（即 home address）。 - 这个 permanent address 是公开的、长期有效的，类似于家庭住址，所有通信发起者都可以通过标准方式获得。 2. <strong>home agent 如何维护 friend 所在子网的 agent 和 IP address</strong>. - <strong>home agent（归属代理）</strong> 是部署在 friend 的 home network 内的一个特殊节点，负责跟踪 friend 的当前位置。 - 当 friend 移动到新的 visited network 并获得新的 care-of address 时，会向 home agent 注册自己的新位置（即 care-of address 和 foreign agent 的信息）。 - home agent 会维护一个映射表，记录每个移动节点的 permanent address 与其当前的 care-of address（以及 foreign agent 的信息，如果有）。 - 当有数据包发往 friend 的 permanent address 时，home agent 会将这些数据包<strong>隧道转发</strong>（tunnel）到 friend 当前的 care-of address（即 friend 所在子网的 foreign agent 或直接到 friend 本身）。</p><h1 id="mobile-ip-agent-discovery">Mobile IP: agent discovery</h1><p>Agent advertisement: foreign/home agents advertise service by broadcasting ICMP messages (<code>typefield = 9</code>)</p><h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1><h2 id="r.1">R.1</h2><p><strong>Question and Answer:</strong></p><p>What does it mean for a wireless network to be operating in “infrastructure mode”? If the network is not in infrastructure mode, what mode of operation is it in, and what is the different between that mode of operation and infrastructure mode?</p><p>在无线网络中，“基础设施模式”（infrastructure mode）指的是网络中存在一个基站（如接入点，AP），无线主机通过基站连接到有线网络或更大的互联网。在这种模式下，基站负责在无线主机和有线网络之间中继数据。如果网络不处于基础设施模式，则它处于“自组织模式”（ad hoc mode）。在自组织模式中，没有基站，节点只能与其链路覆盖范围内的其他节点通信，节点之间通过自组织的方式形成网络并相互路由。两者的主要区别在于是否依赖基站：基础设施模式依赖基站，而自组织模式则完全由节点自主协作。</p><h2 id="r.2">R.2</h2><p><strong>Question and Answer:</strong></p><p>What are the four type of wireless networks identified in our taxonomy in Section <span class="math inline">\(6.1\)</span>? Which of these types of wireless networks have you used?</p>Section <span class="math inline">\(6.1\)</span> 中提到的 <span class="math inline">\(4\)</span> 种无线网络结构如下：<div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><strong>Infrastructure</strong></th><th><strong>Single Hop</strong></th><th><strong>Multiple Hops</strong></th></tr></thead><tbody><tr class="odd"><td><strong>With Infrastructure</strong></td><td>Host connects to base station (WiFi, WiMAX, cellular) which connects to larger Internet.</td><td>Host relays through several wireless nodes to connect to larger Internet (mesh net).</td></tr><tr class="even"><td><strong>Without Infrastructure</strong></td><td>No base station, no connection to larger Internet (e.g., Bluetooth, ad hoc nets).</td><td>No base station, no connection to larger Internet. Nodes relay to reach other nodes (e.g., MANET, VANET).</td></tr></tbody></table></div><p>其中像 WiFi 和 Bluetooth 经常使用。</p><h2 id="r.3">R.3</h2><p><strong>Question and Answer:</strong></p><p>What are the differences between the following types of wireless channel impairments: path loss, multipath propagation, interference from other sources?</p>下面是对三种信道损伤的解释：<div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><strong>损伤类型</strong></th><th><strong>详细解释</strong></th></tr></thead><tbody><tr class="odd"><td><strong>路径损耗 (path loss)</strong></td><td>信号随<strong>传播距离增加</strong>而自然衰减的现象。遵循<strong>平方反比或更高次幂</strong>衰减规律，与距离和频率相关。主要包括<strong>自由空间损耗</strong>、<strong>大气吸收</strong>、<strong>障碍物衰减</strong>等，是无线通信中的<strong>基础衰减现象</strong>。</td></tr><tr class="even"><td><strong>多径传播 (multipath propagation)</strong></td><td>信号通过<strong>多个不同路径</strong>同时到达接收器的现象。由信号在建筑物、地面等物体表面的<strong>反射</strong>、<strong>散射</strong>、<strong>折射</strong>和<strong>绕射</strong>导致。产生<strong>相位差异</strong>使信号彼此<strong>增强或抵消</strong>，造成<strong>信号衰落</strong>、<strong>时延扩展</strong>和<strong>符号间干扰</strong>。</td></tr><tr class="odd"><td><strong>外部干扰 (interference from other sources)</strong></td><td>来自<strong>其他发射源</strong>的电磁波对当前通信的干扰。包括<strong>同频干扰</strong>（相同频道上的其他发射器）、<strong>相邻频道干扰</strong>和<strong>电子设备噪声</strong>等。干扰与当前信号混合，<strong>降低信噪比</strong>和通信质量。</td></tr></tbody></table></div><h2 id="r.4">R.4</h2><p><strong>Question and Answer:</strong></p><p>As a mobile node gets farther and farther away from a base station, what are two actions that a base station could take to ensure that the loss probability of a transmitted frame does not increase?</p><ol type="1"><li><strong>Wireless Link Characteristics</strong> 部分提到：<ul><li><strong>SNR (Signal-to-Noise Ratio)</strong>：增大信号强度可以提高信噪比，从而降低误码率（BER）。</li><li><strong>decreased signal strength</strong>：信号强度的降低会影响通信质量。</li></ul></li><li><strong>IEEE 802.11 MAC Protocol: CSMA/CA</strong> 部分提到：<ul><li><strong>Collision Avoidance</strong>：通过避免冲突来提高传输成功率。</li></ul></li><li><strong>Cellular Internet Access</strong> 部分提到：<ul><li><strong>LTE</strong> 使用了 <strong>OFDM</strong> 和 <strong>MIMO</strong> 技术，这些技术可以提高信号覆盖范围和传输效率。</li></ul></li></ol><p>结合这些内容，可以得出以下两种可能的措施： - <strong>增大发射功率</strong>：提高信号强度以补偿路径损耗。 - <strong>使用多天线技术（如 MIMO）</strong>：通过空间分集技术提高信号质量和覆盖范围。</p><h2 id="r.10">R.10</h2><p><strong>Question and Answer:</strong></p><p>Suppose the IEEE <span class="math inline">\(802.11\)</span> RTS and CTS frames were as long as the standard DATA and ACK frames. Would there be any advantage to using the CTS and RTS frames? Why or why not?</p><ul><li><strong>Avoiding Collisions: RTS/CTS Mechanism</strong> 部分提到：<ul><li>RTS 和 CTS 的主要作用是 <strong>避免长数据帧的冲突</strong>。</li><li>RTS 和 CTS 包较小，即使发生冲突，影响也较小。</li><li>使用 RTS/CTS 机制可以通过小型的预留包来减少长数据帧的冲突。</li></ul></li><li>如果 RTS 和 CTS 包与标准的 DATA 和 ACK 包一样长，那么它们的优势将丧失，因为：<ol type="1"><li><strong>冲突成本增加</strong>：长 RTS 和 CTS 包的冲突会导致更大的资源浪费。</li><li><strong>效率降低</strong>：长 RTS 和 CTS 包会增加额外的开销，降低整体网络效率。</li></ol></li></ul><h2 id="r.16">R.16</h2><p><strong>Question and Answer:</strong></p><p>If a node has a wireless connection to the Internet, does that node have to be mobile? Explain. Suppose that a user with a laptop walks around her house with her laptop, and always accesses the Internet through the same access point. Is this user mobile from a network standpoint? Explain.</p><p>一个节点拥有无线连接，并不意味着它是<strong>移动的</strong>。无线连接只是物理层和链路层的接入方式，只要设备通过无线方式接入网络，无论它是否实际移动，都可以称为无线节点，但不一定是<strong>移动节点</strong>。用户在家中携带笔记本，始终通过同一个 AP 上网，这说明用户始终在同一个 subnet 和 BSS 内，所以不认为用户发生了网络层的移动。</p><h2 id="r.17">R.17</h2><p><strong>Question and Answer:</strong></p><p>What is the difference between a permanent address and a care-of address? Who assigns a care-of address?</p><ul><li><strong>permanent address（永久地址）</strong><ul><li>也称为 home address（归属地址），是移动节点在其<strong>归属网络</strong>（home network）中的固定 IP 地址。</li><li>这个地址在移动节点无论身处何地都不会改变，始终用于标识该节点的身份。</li><li>例如：移动节点在家乡网络的 IP 地址 128.119.40.186。</li></ul></li><li><strong>care-of address（临时地址）</strong><ul><li>是移动节点在<strong>访问网络</strong>（visited network）中临时获得的 IP 地址。</li><li>当移动节点离开归属网络，进入其他网络时，会在该访问网络中分配一个新的 IP 地址，这个地址用于在当前网络中进行通信。</li><li>例如：移动节点在外地网络获得的 IP 地址 79.129.13.2。</li></ul></li><li>care-of address 通常由<strong>访问网络 visited network</strong> 分配，具体来说：<ul><li>可以由访问网络中的<strong>外部代理 Foreign Agent</strong> 分配；</li><li>也可以通过 DHCP 等自动分配协议由访问网络的路由器分配。</li></ul></li></ul><h2 id="r.19">R.19</h2><p><strong>Question and Answer:</strong></p><p>What are the purposes of the HLR and VLR in GSM networks? What elements of mobile IP are similar to the HLR and VLR?</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>GSM 网络</th><th>Mobile IP 协议</th><th>主要作用</th></tr></thead><tbody><tr class="odd"><td>HLR</td><td>Home Agent</td><td>记录永久信息和当前位置</td></tr><tr class="even"><td>VLR</td><td>Foreign Agent</td><td>临时管理当前区域内的用户/节点信息</td></tr></tbody></table></div><h2 id="p.5">P.5</h2><p><strong>Question and Answer:</strong></p><p>Suppose there are two ISPs providing WiFi access in a particular café, with each ISP operating its own AP and having its own IP address block. a. Further suppose that by accident, each ISP has configured its AP to operate over channel 11. Will the 802.11 protocol completely break down in this situation? Discuss what happens when two stations, each associated with a different ISP, attempt to transmit at the same time. b. Now suppose that one AP operates over channel 1 and the other over channel 11. How do your answers change?</p><p><strong>a.</strong>：802.11 协议不会完全失效，但两个 AP 及其关联的 hosts 会在 physical layer 竞争同一个信道的使用权。如果两个 hosts 同时发送数据，此时会产生 collision，尽管 CSMA/CA 协议会尽可能避免冲突，但由于信号干扰，冲突仍会发生，导致通信变得不稳定。</p><p><strong>b.</strong>：此时两个 AP 用不同的信道，互不干扰，通信正常。</p><h2 id="p.13">P.13</h2><p><strong>Question and Answer:</strong></p><p>In mobile IP, what effect will mobility have on end-to-end delays of datagrams between the source and destination?</p><ol type="1"><li><strong>间接路由（Indirect Routing）增加路径长度</strong><ul><li>在移动 IP 的典型实现中，数据报首先被发送到移动节点的 home agent（归属代理），然后由 home agent 转发（隧道）到移动节点当前的 care-of address（临时地址）。</li><li>这种绕路导致数据报的实际传输路径比直接路由更长，<strong>增加了端到端延迟</strong>。</li><li>例如，源主机 → home agent → foreign agent → 移动节点。</li></ul></li><li><strong>切换期间的延迟抖动</strong><ul><li>当移动节点从一个网络切换到另一个网络时（如切换 AP 或基站），需要重新获取 care-of address 并向 home agent 注册新位置。</li><li>在切换和注册期间，可能会出现短暂的不可达或数据包丢失，<strong>导致延迟波动或瞬时增加</strong>。</li></ul></li><li><strong>三角路由问题</strong><ul><li>在 indirect routing 下，通信对端（correspondent）始终将数据包发往 permanent address，导致所有流量都要经过 home agent，形成所谓的三角路由。</li><li>这进一步增加了端到端的传输时延，尤其当 home agent 距离通信双方较远时影响更明显。</li></ul></li><li><strong>优化路由（Direct Routing）可减少延迟</strong><ul><li>如果采用 direct routing（如移动节点的当前位置被通知给通信对端），数据报可以直接从源主机发往移动节点当前的 care-of address，<strong>端到端延迟会降低</strong>。</li><li>但 direct routing 需要额外的机制来保证安全和地址同步。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Wireless and Mobile Networks</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Transport Layer</title>
    <link href="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/"/>
    <url>/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="transport-layer-services">Transport-Layer Services</h1><p>Transport protocols run in <strong>end systems</strong>: - Sending side: breaks app messages into <strong>segments</strong>, passes to network layer. - Receiving side: reassembles segments into <strong>messages</strong>, passes to app layer.</p><h1 id="multiplexing-and-demultiplexing">Multiplexing and Demultiplexing</h1><p><strong>Multiplexing at sending host:</strong> gather data from multiple sockets, enveloping data with <strong>header</strong>(later used for demultiplexing). <strong>demultiplexing at receiving host:</strong> deliver segments to correct socket.</p><h2 id="demultiplexing">Demultiplexing</h2><p>Hosts receives <strong>IP datagrams</strong>. Each IP datagram has source IP address and destination IP address. Each IP datagram carries a transport-layer segment. Each segment has source port numbers and destination port numbers.</p><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/a-transport-layer-segment.png" style="display: block; margin: 0 auto; width: 90%" alt="A transport layer segment"><figcaption aria-hidden="true">A transport layer segment</figcaption></figure><blockquote><p>将 segment 传到目标 host，host 再将 segment 通过 socket 传给对应的 application。</p></blockquote><h3 id="connectionless-demultiplexing">Connectionless Demultiplexing</h3><p>在 <strong>UDP</strong> 协议中使用。</p><p>Creates socket with <strong>port numbers</strong>. Each UDP socket identified with <code>(dest IP address, dest port numbers)</code>.</p><blockquote><p>当终端收到 IP datagrams 中是 UDP segment 时。 The host will check destination port in the segment and then directs the segment to corresponding socket。发生在 transport layer。</p></blockquote><h3 id="connection-oriented-demultiplexing">Connection-oriented Demultiplexing</h3><p><strong>Used in TCP protocol</strong>.</p><p>TCP socket identified by <strong>4</strong>-tuple: <code>(source IP address, source port numbers, dest IP address, dest port numbers)</code>.</p><h1 id="connectionless-transport-udp">Connectionless Transport: UDP</h1><h2 id="udp-segment-structure">UDP Segment Structure</h2><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/UDP-segment-structure.png" style="display: block; margin: 0 auto; width: 90%" alt="UDP segment structure"><figcaption aria-hidden="true">UDP segment structure</figcaption></figure><h2 id="udp-checksum">UDP Checksum</h2><p><strong>Goal</strong>: detect “errors” (e.g., flipped bits) in transmitted segment. 指的是位比特发生了 <span class="math inline">\(01\)</span> 翻转。</p><p>“Calculation:” 1. <strong>Group Data</strong>: - Divide all fields of the UDP segment (including header and data) into 16-bit blocks. If the data length is odd, pad with a zero byte. 这里要注意，不同的比特排序方式会影响到最终结果，数据通常以<strong>大端序</strong>（高位字节在前）表示。</p><ol start="2" type="1"><li><strong>Compute Sum</strong>:<ul><li>Perform a 1’s complement sum of all 16-bit blocks。就是二进位加法。</li><li>If overflow occurs (exceeds 16 bits), wrap the overflow back into the result.</li></ul></li><li><strong>Take Complement</strong>:<ul><li>Take the 1’s complement of the computed sum to get the final checksum。这里可以看作进行了一次<strong>同位全 <span class="math inline">\(1\)</span></strong> 加法。</li></ul></li><li><strong>Fill Checksum Field</strong>:<ul><li>Place the computed checksum into the checksum field of the UDP segment.</li></ul></li></ol><h1 id="principles-of-reliable-data-transfer">Principles of Reliable Data Transfer</h1><p><strong>应用程序即使运行在 UDP 之上，也可以实现可靠数据传输</strong>。虽然 UDP 本身是无连接、无保证的协议，不提供诸如数据包重传、顺序保证、丢包检测等机制，但<strong>应用层可以自行实现这些功能</strong>，从而达到可靠传输的目的。</p><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/Reliable-data-transfer.png" style="display: block; margin: 0 auto; width: 90%" alt="Reliable data transfer: Service model and service implementation"><figcaption aria-hidden="true">Reliable data transfer: Service model and service implementation</figcaption></figure><h2 id="reliable-data-transfer-over-a-perfectly-reliable-channel-rdt-1.0">Reliable Data Transfer over a Perfectly Reliable Channel: rdt 1.0</h2><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt1.png" style="display: block; margin: 0 auto; width: 90%" alt="rdt1.0 - A protocol for a completely reliable channel"><figcaption aria-hidden="true">rdt1.0 - A protocol for a completely reliable channel</figcaption></figure><p><strong>Unrealistic:</strong> underlying channel perfectly reliable - no bit errors - no loss of packets</p><h2 id="reliable-data-transfer-over-a-channel-with-bit-errors-rdt-2.0">Reliable Data Transfer over a Channel with Bit Errors: rdt 2.0</h2><p>增添检查错误机制：checksum 和 ACK。</p><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2.png" style="display: block; margin: 0 auto; width: 90%" alt="rdt 2.0 - A protocol for a channel with bit errors"><figcaption aria-hidden="true">rdt 2.0 - A protocol for a channel with bit errors</figcaption></figure><p><strong>New mechanism in rdt 2.0 (beyond rdt 1.0)</strong> - Error detection; - <strong>Checksum</strong>. - Receiver feedback. - <strong>ACKs and NAKs</strong>.</p><blockquote><p>rdt 2.0 有一个致命问题：如果 ACK/NAK 出错导致信息改变。</p></blockquote><h2 id="rdt-2.1">rdt 2.1</h2><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2-1-sender.png" style="display: block; margin: 0 auto; width: 90%" alt="rdt 2.1 sender"><figcaption aria-hidden="true">rdt 2.1 sender</figcaption></figure><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2-1-receiver.png" style="display: block; margin: 0 auto; width: 90%" alt="rdt 2.1 receiver"><figcaption aria-hidden="true">rdt 2.1 receiver</figcaption></figure><blockquote><p>可以看到 rdt 2.1 新增了一个 sequence number。在 rdt 2.0 中提到过其有着一个致命的问题，这个问题可能会导致两个问题：重传和丢失。从 Figure P.6 和 Figure P.7 可以看到 rdt 2.1 能解决重传的问题，但是不能解决丢失的问题。</p></blockquote><h2 id="rdt-2.2">rdt 2.2</h2><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2-2-sender.png" style="display: block; margin: 0 auto; width: 90%" alt="rdt2.2 sender"><figcaption aria-hidden="true">rdt2.2 sender</figcaption></figure><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt2-2-receiver.png" style="display: block; margin: 0 auto; width: 90%" alt="rdt2.2 receiver"><figcaption aria-hidden="true">rdt2.2 receiver</figcaption></figure><blockquote><p>rdt 2.1 的机制是：如果是 NAK 或者 checksum 出错就重传。从 Figure P.8 和 Figure P.9 可以看出，receiver 收了什么序号的包就回什么序号，如果是自己要的包就 extract，然后 sender 发下个序号的包，如果重传导致 duplicate，那么只需要 delete 然后给 sender 发送 ACK。显然，receiver 回什么序号，sender 都会发下一个序号的包，也就是 rdt 2.2 没有使用 NAK 就解决了重传的问题。</p></blockquote><p>补充：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>变量/语句</th><th>作用说明</th></tr></thead><tbody><tr class="odd"><td><code>oncethru == 1</code></td><td>是否第一次进入该状态</td></tr><tr class="even"><td><code>udt_send(sndpkt)</code></td><td>发送 ACK 包</td></tr><tr class="odd"><td>结合使用</td><td>首次进入状态时主动重发 ACK，防止因 ACK 丢失而死锁</td></tr></tbody></table></div><h2 id="rdt-3.0">rdt 3.0</h2><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rdt3-0-receiver.png" style="display: block; margin: 0 auto; width: 90%" alt="rdt3.0 sender"><figcaption aria-hidden="true">rdt3.0 sender</figcaption></figure><blockquote><p>增加了一个计时器，可以解决包丢失的问题，如果超时就重传，</p></blockquote><h2 id="pipelined-reliable-data-transfer-protocols">Pipelined Reliable Data Transfer Protocols</h2><p><strong>rdt 3.0 stop-and-wait operation</strong>: rdt 3.0 can work, but its performance stinks.</p><blockquote><p>这里是说 rdt 3.0 的机制一轮就处理一个包而效率低下。</p></blockquote><p>For example, we suppose condition with 1 Gbps link, 15 ms propagation delay, 8000 bits packet.</p><p><span class="math display">\[\text{d}_{trans} = \frac{L}{R} = \frac{8000 \text{bits}}{10^9 \text{bps}} = 8 \text{microseconds}\]</span></p><p><span class="math display">\[\text{Utilization} = \frac{\frac{L}{R}}{\text{RTT} + \frac{L}{R}} = 0.00027\]</span></p><p>So, we use <strong>Pipelined Reliable Data Transfer Protocols</strong> to increase utilization!</p><p><strong>Pipelining:</strong> sender allows multiple, “in-flight”,yet-to-be-acknowledged pkts. - Range of sequence numbers must be <strong>increased</strong>. - <strong>Buffering</strong> at sender and/or receiver.</p><h3 id="go-back-n-gbn-protocol">Go-Back-N (GBN) Protocol</h3><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/Sender&#39;s-view-of-sequence-numbers-in-Go-Back-N.png" style="display: block; margin: 0 auto; width: 90%" alt="Sender’s view of sequence numbers in Go-Back-N"><figcaption aria-hidden="true">Sender’s view of sequence numbers in Go-Back-N</figcaption></figure><p><strong>Timeout(n):</strong> retransmit pkt <code>n</code> and all higher seq <code>#</code> pkts in window</p><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/GBN-sender.png.png" style="display: block; margin: 0 auto; width: 90%" alt="GBN sender"><figcaption aria-hidden="true">GBN sender</figcaption></figure><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/GBN-receiver.png.png" style="display: block; margin: 0 auto; width: 90%" alt="GBN receiver"><figcaption aria-hidden="true">GBN receiver</figcaption></figure><p>需要注意的是，上述图片中是<strong>覆盖确认</strong>：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>协议类型</th><th>ACK 处理方式</th><th>base 变化方式</th></tr></thead><tbody><tr class="odd"><td>累计确认（GBN）</td><td>只确认按序最大已收到的包</td><td>base 只前进不回退</td></tr><tr class="even"><td>覆盖确认（图中）</td><td>收到哪个 ACK 就直接覆盖 base</td><td>base 可能跳跃前进</td></tr></tbody></table></div><h3 id="selective-repeat-sr">Selective Repeat (SR)</h3><p>Sender only <strong>resends</strong> pkts for which ACK not received.</p><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/RS-sender-receiver-view.png" style="display: block; margin: 0 auto; width: 90%" alt="Selective-repeat (SR) sender and receiver views of sequence-number space"><figcaption aria-hidden="true">Selective-repeat (SR) sender and receiver views of sequence-number space</figcaption></figure><p><span class="math display">\[\text{window size} \leq \frac{1}{2} \text{seq}\]</span></p><h4 id="sender">Sender</h4><ul><li><strong>Data from above</strong>:<ul><li>If next available sequence number is within the window, send the packet.</li></ul></li><li><strong>Timeout(n)</strong>:<ul><li>Resend packet <code>n</code>, restart the timer.</li></ul></li><li><strong>ACK(n) in [sendbase, sendbase <span class="math inline">\(+\)</span> <span class="math inline">\(N\)</span>]</strong>:<ul><li>Mark packet <code>n</code> as received.</li><li>If <code>n</code> is the smallest unACKed packet, <strong>advance</strong> the window base to the next unACKed sequence number.</li></ul></li></ul><h4 id="receiver">Receiver</h4><ul><li><strong>Packet <code>n</code> in [rcvbase, rcvbase <span class="math inline">\(+\)</span> <span class="math inline">\(N\)</span> <span class="math inline">\(-\)</span> <span class="math inline">\(1\)</span>]</strong>:<ul><li>Send ACK(n).</li><li><strong>Out-of-order</strong>: Buffer the packet.</li><li><strong>In-order</strong>: Deliver the packet (also deliver buffered, in-order packets), advance the window to the next not-yet-received packet.</li></ul></li><li><strong>Packet <code>n</code> in [rcvbase <span class="math inline">\(-\)</span> <span class="math inline">\(N\)</span>, rcvbase <span class="math inline">\(-\)</span> <span class="math inline">\(1\)</span>]</strong>:<ul><li>Send ACK(n). 解决 duplicate。</li></ul></li><li><strong>Otherwise</strong>:<ul><li>Ignore the packet.</li></ul></li></ul><h1 id="connection-oriented-transport-tcp">Connection-oriented transport: TCP</h1><h2 id="tcp-segment-structure">TCP Segment Structure</h2><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/TCP-segment-structure.png" style="display: block; margin: 0 auto; width: 90%" alt="TCP segment structure"><figcaption aria-hidden="true">TCP segment structure</figcaption></figure><p><strong>How to set sequence number and acknowledgment number?</strong></p><ul><li><strong>sequence number</strong>: represents the byte stream number of the first byte in the segment’s data.</li><li><strong>ACKs</strong>: indicates the sequence number of the next byte expected from the sender. Using cumulative acknowledgment.</li></ul><h2 id="tcp-round-trip-time-and-timeout">TCP Round Trip Time and Timeout</h2><p><strong>How to estimate <span class="math inline">\(\mathbf{RTT}\)</span>?</strong></p><p><span class="math display">\[\text{EstimateRTT} = (1 - \alpha) \cdot \text{EstimateRTT} + \alpha \cdot \text{SampleRTT}, \quad \text{Typically } \alpha = 0.125\]</span></p><p><strong>How to set TCP timeout value?</strong></p><p>Longer than <span class="math inline">\(\text{RTT}\)</span>, but <span class="math inline">\(\text{RTT}\)</span> varies. <span class="math display">\[\text{DevRTT} = (1 - \beta) \cdot \text{DevRTT} + \beta \cdot |\text{SampleRTT} - \text{EstimateRTT}|, \quad \text{Typically } \beta = 0.25\]</span></p><p><span class="math display">\[\text{TimeOutInterval} = \text{EstimateRTT} + 4 \cdot \text{DevRTT}\]</span></p><h2 id="tcp-reliable-data-transfer">TCP Reliable Data Transfer</h2><h3 id="fast-retransmit">Fast Retransmit</h3><p>If sender receives <span class="math inline">\(3\)</span> ACKs for same data, it assumes that segment after ACKed data was lost.</p><h2 id="flow-control">Flow control</h2><p>Receiver side of TCP connection has a <strong>receive buffer</strong>.</p><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/rwnd-buffer.png" style="display: block; margin: 0 auto; width: 90%" alt="The receive window (rwnd) and the receive buffer (RcvBuffer)"><figcaption aria-hidden="true">The receive window (rwnd) and the receive buffer (RcvBuffer)</figcaption></figure><h3 id="how-it-works">How it works?</h3><ul><li><strong>Receiver:</strong> advertises unused buffer space by including <span class="math inline">\(\text{rwnd}\)</span> value in segment header.</li><li><strong>Sender:</strong> limits unAcked bytes to <span class="math inline">\(\text{rwnd}\)</span>.</li></ul><p><span class="math display">\[\text{rwnd} = \text{RcvBuffer} - \left[\text{LastByteRcvd} - \text{LastByteRead} \right]\]</span></p><p><strong>字节编号</strong>的问题。在TCP中：</p><ul><li>如果初始序列号为0，发送50字节后：<ul><li>这些字节的序号为：0, 1, 2, …, 49</li><li><strong>最后一个字节</strong>的序号为49，即 LastByteRcvd = 49</li><li>根据公式 <span class="math inline">\(y = \text{LastByteRcvd} + 1\)</span>，得到确认号 y = 50</li></ul></li></ul><p>其中 y 是 ACK。</p><h2 id="connection-management">Connection Management</h2><h3 id="three-way-handshake">Three Way Handshake</h3><p><strong>握手协议（Handshaking Protocol）</strong> 是指在两个通信实体（如客户端和服务器）之间建立通信连接之前，双方通过一系列消息的交换，协商通信参数、确认彼此身份、同步状态等，从而为后续的数据传输做好准备的过程。</p><ol type="1"><li><strong>Step 1</strong>:<ul><li>Client sends TCP <code>SYN</code> segment to server, specifying initial seq. No data.</li></ul></li><li><strong>Step 2</strong>:<ul><li>Server host receives <code>SYN</code>, replies with <code>SYNACK</code> segment. Server allocates buffers and specifies server initial seq.</li></ul></li><li><strong>Step 3</strong>:<ul><li>Client receives <code>SYNACK</code>, replies with ACK segment, which may contain data</li></ul></li></ol><h3 id="closing-a-connection">Closing a Connection</h3><ol type="1"><li><strong>Step 1</strong>:<ul><li>Client sends TCP <code>FIN</code> segment to server, specifying initial seq. No data.</li></ul></li><li><strong>Step 2</strong>:<ul><li>Server receives <code>FIN</code>, replies with ACK. Closes connection, sends <code>FIN</code>.</li></ul></li><li><strong>Step 3</strong>:<ul><li>Client receives <code>FIN</code>, replies with ACK.</li></ul></li><li><strong>Step 4</strong>:<ul><li>Server, receives ACK. Connection closed.</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">客户端A                                      服务器B<br>   | ----------- SYN, Seq=1000 ------------&gt; |<br>   |                                         |<br>   | &lt;------ SYN+ACK, Seq=2000, Ack=1001 --- |<br>   |                                         |<br>   | ----------- ACK, Seq=1001, Ack=2001 --&gt; |<br></code></pre></td></tr></table></figure><p>上面所说的 <code>SYN</code> 和 <code>FIN</code> 都在 TCP segment 结构 header 中。</p><h1 id="principles-of-congestion-control">Principles of Congestion control</h1><p>Too many sources sending too much data too fast for <strong>network (router)</strong> to handle.</p><h2 id="approaches-towards-congestion-control">Approaches towards Congestion Control</h2><ul><li><strong>end-end congestion control</strong>: congestion inferred from end-system observed loss, delay.</li><li><strong>network-assisted congestion control</strong>: routers provide feedback to end systems.</li></ul><h1 id="tcp-congestion-control">TCP Congestion Control</h1><p><strong>Goal:</strong> TCP sender should transmit as fast as possible, but without congesting network</p><p><strong>probing for bandwidth:</strong> increase transmission rate on receipt of ACK, until eventually loss occurs, then decrease transmission rate. //一种贪心策略</p><p>Sender limits rate by limiting number of unACKed bytes “in pipeline”: <span class="math display">\[\text{LastByteSent} - \text{LastByteAcked} \leq \min \{\text{cwnd}, \text{rwnd} \}\]</span></p><p><span class="math display">\[\text{rate} \approx \frac{\text{cwnd}}{\text{RTT}}\]</span></p><h2 id="slow-start-phase">Slow Start Phase</h2><p>When connection begins, <span class="math inline">\(\text{cwnd} = 1 \, \text{MSS}\)</span>.</p><blockquote><p><span class="math display">\[ \text{MSS} = \text{MTU} - \text{IP头部大小} - \text{TCP头部大小} \]</span></p></blockquote><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>特性</th><th>MSS</th><th>MTU</th></tr></thead><tbody><tr class="odd"><td>所属协议层</td><td>传输层 (TCP)</td><td>数据链路层</td></tr><tr class="even"><td>计量对象</td><td>TCP 数据部分</td><td>整个数据包（包括所有头部）</td></tr><tr class="odd"><td>设置目的</td><td>避免 IP 分片</td><td>适应物理媒介的限制</td></tr><tr class="even"><td>典型值</td><td>1460 字节 (以太网)</td><td>1500 字节 (以太网)</td></tr><tr class="odd"><td>协商方式</td><td>TCP 三次握手时协商</td><td>网络设备固定或自动发现</td></tr></tbody></table></div><p>Increase rate exponentially until first <strong>loss event</strong> or when <strong>threshold reached</strong>. - <strong>Double</strong> cwnd every RTT. 没有发生 loss 就以指数函数增长。 - Done by incrementing cwnd by <span class="math inline">\(1\)</span> for every ACK received. 超过 <span class="math inline">\(\text{ssthresh}\)</span> 后线性增长。</p><h2 id="congestion-avoidance">Congestion Avoidance</h2><p>When <span class="math inline">\(\text{cwnd} \geq \text{ssthresh}\)</span>, increase <span class="math inline">\(\text{cwnd}\)</span> by <span class="math inline">\(1\)</span> <span class="math inline">\(\text{MSS}\)</span> per <span class="math inline">\(\text{RTT}\)</span>.</p><h2 id="tcp-reno">TCP RENO</h2><p><strong>Fast recovery</strong>: When triple duplicate ACKs occurs, <span class="math inline">\(\text{ssthresh}\)</span> sets to <span class="math inline">\(\frac{\text{cwnd}}{2}\)</span>, <span class="math inline">\(\text{cwnd}\)</span> sets to <span class="math inline">\(\text{ssthresh}\)</span>. 传快了，适当减小。</p><p>But when <strong>timeout</strong> occurs, <span class="math inline">\(\text{ssthresh}\)</span> sets to <span class="math inline">\(\frac{\text{cwnd}}{2}\)</span>, <span class="math inline">\(\text{cwnd}\)</span> sets to <span class="math inline">\(1\)</span> <span class="math inline">\(\text{MSS}\)</span>. 丢包。</p><h2 id="tcp-throughput">TCP throughput</h2><p><strong>Question:</strong> What’s the average throughput of TCP as a function of window size and RTT?</p><p><strong>Assumptions:</strong> - Ignoring slow start. - Let <code>W</code> be the window size when loss occurs.</p><p><strong>Throughput Analysis:</strong> 1. <strong>When window size is <code>W</code></strong>: - Throughput = <span class="math inline">\(\frac{W}{\text{RTT}}\)</span>.</p><ol start="2" type="1"><li><strong>Just after loss</strong>:<ul><li>Window size drops to <span class="math inline">\(\frac{W}{2}\)</span>.</li><li>Throughput = <span class="math inline">\(\frac{W}{2 \cdot \text{RTT}}\)</span>.</li></ul></li><li><strong>Average throughput</strong>:<ul><li>Average throughput = <span class="math inline">\(0.75 \cdot \frac{W}{\text{RTT}}\)</span>.</li></ul></li></ol><h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1><h2 id="r.4">R.4</h2><p><strong>Question:</strong></p><p>Describe why an application developer might choose to run an application over UDP rather than TCP.</p><p><strong>Answer:</strong></p><p>An application developer might choose to run an application over UDP rather than TCP for the following reasons:</p><ol type="1"><li><p><strong>Low Latency</strong>: UDP is a connectionless protocol, meaning it does not establish a connection before sending data. This reduces latency, making it suitable for real-time applications like video streaming, online gaming, and voice over IP (VoIP).</p></li><li><p><strong>No Overhead for Reliability</strong>: Unlike TCP, UDP does not provide reliability mechanisms such as retransmissions, acknowledgments, or congestion control. This reduces overhead and allows applications to handle reliability themselves if needed.</p></li><li><p><strong>Broadcast/Multicast Support</strong>: UDP supports broadcasting and multicasting, which is useful for applications like live video streaming or network discovery.</p></li><li><p><strong>Simple Protocol</strong>: UDP is simpler and requires fewer resources, making it ideal for lightweight applications or systems with limited processing power.</p></li><li><p><strong>Custom Error Handling</strong>: Some applications prefer to implement their own error handling and flow control mechanisms tailored to their specific needs, which is easier with UDP.</p></li><li><p><strong>Unordered Data Delivery</strong>: For applications where the order of data packets is not critical (e.g., DNS queries), UDP is a better choice as it does not enforce packet ordering.</p></li></ol><h2 id="p.4">P.4</h2><p><strong>Question:</strong> a. Suppose you have the following <span class="math inline">\(2\)</span> bytes: <span class="math inline">\(01011100\)</span> and <span class="math inline">\(01010110\)</span>. What is the <span class="math inline">\(1\)</span>s complement of the sum of these <span class="math inline">\(2\)</span> bytes? b. Suppose you have the following <span class="math inline">\(2\)</span> bytes: <span class="math inline">\(11011010\)</span> and <span class="math inline">\(00110110\)</span>. What is the <span class="math inline">\(1\)</span>s complement of the sum of these <span class="math inline">\(2\)</span> bytes? c. For the bytes in part (a), give an example where one bit is flipped in each of the <span class="math inline">\(2\)</span> bytes and yet the <span class="math inline">\(1\)</span>s complement doesn’t change.</p><p><strong>Answer:</strong> - <strong>a.</strong> <span class="math inline">\(10110010\)</span>. - <strong>b.</strong> <span class="math inline">\(00010001\)</span>. - <strong>c.</strong> <span class="math inline">\(01011110\)</span> and <span class="math inline">\(01010100\)</span>.</p><h2 id="p.11">P.11</h2><p><strong>Question:</strong></p><p>The sender side of <span class="math inline">\(\text{rdt}3.0\)</span> simply ignores (that is, takes no action on) all received packets that are either in error or have the wrong value in the acknum field of an acknowledgment packet. Suppose that in such circumstances, <span class="math inline">\(\text{rdt}3.0\)</span> were simply to retransmit the current data packet. Would the protocol still work? (Hint: Consider what would happen if there were only bit errors; there are no packet losses but premature timeouts can occur. Consider how many times the <span class="math inline">\(n^{th}\)</span> packet is sent, in the limit as <span class="math inline">\(n\)</span> approaches infinity.)</p><p><strong>Answer:</strong></p><p>在这种情况下，rdt <span class="math inline">\(3.0\)</span> 仍然是有效的。首先，该协议接收方可以通过检查 <strong>sequence number</strong> 来判断当前的包是否重复，这个检查方式一直有效。原本的 <span class="math inline">\(\text{rdt}3.0\)</span> 协议在超时后会重传，但现在只要检查出 <strong>acknowledgment packet</strong> 中出错就重传，这显然会增加网络负载，比如：在极端情况下，发送方可能会多次重传一个包，若 ACK 错误率为 <span class="math inline">\(p\)</span>，则每个数据包平均需要发送 <span class="math inline">\(1/(1-p)\)</span> 次，直到接受到正确的 <strong>ACKs</strong>。总结：<span class="math inline">\(\text{rdt}3.0\)</span> 协议在这种情况下仍然是可靠的，但立即重传错误数据包会导致性能问题，因此这种修改并不是一个好的设计选择。</p><h2 id="p.14">P.14</h2><p><strong>Question:</strong></p><p>Consider the cross-country example shown in Figure <span class="math inline">\(3.17\)</span>. How big would the window size have to be for the channel utilization to be greater than <span class="math inline">\(95\)</span> percent? Suppose that the size of a packet is <span class="math inline">\(1,500\)</span> bytes, including both header fields and data.</p><p><strong>Complement:</strong> <span class="math inline">\(1\)</span> Gbps link. RTT, is approximately <span class="math inline">\(30\)</span> milliseconds.</p><p><strong>Answer:</strong></p><p><span class="math display">\[\text{d}_{trans} = \frac{L}{R} = \frac{1500 \times 8}{1 \times 10^9} = 1.2 \times 10^{-5} \, \text{s}\]</span></p><p><span class="math display">\[\text{Utilization} = \frac{\text{rwnd} \times \frac{L}{R}}{\text{RTT} + \text{rwnd} \times \frac{L}{R}} \geq 0.95\]</span></p><p>解得，<span class="math inline">\(\text{rwnd} \geq 4750\)</span>。</p><h2 id="p.22">P.22</h2><p><strong>Questions and Answers:</strong></p><p>Answer true or false to the following questions and briefly justify your answer:</p><p><strong>a. With the SR protocol, it is possible for the sender to receive an ACK for a packet that falls outside of its current window.</strong></p><p><strong>True</strong>; 在 <strong>SR</strong> 协议中，由于网络延迟等原因，发送方可能收到对应于已经滑出当前窗口的数据包的 ACK。</p><p><strong>b. With GBN, it is possible for the sender to receive an ACK for a packet that falls outside of its current window.</strong></p><p><strong>False</strong>; 在 <strong>GBN</strong> 协议中，<strong>ACK</strong> 是累积的，表示所有序列号小于等于 ACK 的包已经被正确接收。</p><p><strong>c. The alternating-bit protocol is the same as the SR protocol with a sender and receiver window size of <span class="math inline">\(1\)</span>.</strong></p><p><strong>True</strong>; 交替位协议是 SR 协议的一个特例，其中发送方和接收方的窗口大小均为 <span class="math inline">\(1\)</span>。它只允许发送一个未确认的包，并通过序列号（<span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>）来区分包。</p><p><strong>d. The alternating-bit protocol is the same as the GBN protocol with a sender and receiver window size of <span class="math inline">\(1\)</span>.</strong></p><p><strong>True</strong>; 交替位协议也可以看作是 GBN 协议的一个特例，其中发送方和接收方的窗口大小均为 <span class="math inline">\(1\)</span>。在这种情况下，GBN 的行为与交替位协议完全一致，因为它只允许发送一个未确认的包，并在超时或收到 NAK 时重传该包。</p><h2 id="p.24">P.24</h2><p><strong>Questions and Answers:</strong></p><p>Consider transferring an enormous file of <span class="math inline">\(L\)</span> bytes from Host A to Host B. Assume an MSS of <span class="math inline">\(536\)</span> bytes.</p><p><strong>a. What is the maximum value of <span class="math inline">\(L\)</span> such that TCP sequence numbers are not exhausted? Recall that the TCP sequence number field has <span class="math inline">\(4\)</span> bytes.</strong></p><p>TCP segment structure 中 sequence number 有 <span class="math inline">\(32\)</span> bits，从 <span class="math inline">\(0\)</span> 开始。所以最大的 <span class="math inline">\(L = 2^{32} - 1\)</span>。</p><p><strong>b. For the <span class="math inline">\(L\)</span> you obtain in (a), find how long it takes to transmit the file. Assume that a total of <span class="math inline">\(66\)</span> bytes of transport, network, and data-link header are added to each segment before the resulting packet is sent out over a <span class="math inline">\(155\)</span> Mbps link. Ignore flow control and congestion control so A can pump out the segments back to back and continuously.</strong></p><ul><li>MSS = <span class="math inline">\(536\)</span> bytes<br></li><li>每报文附加头部 = <span class="math inline">\(66\)</span> bytes<br></li><li>总报文尺寸 (536 + 66 = 602) bytes<br></li><li>报文数量<br><span class="math display">\[N = \left\lceil \frac{L_{\max}}{\text{MSS}} \right\rceil  = \left\lceil \frac{2^{32}-1}{536} \right\rceil  = 8\,012\,999\]</span></li><li>总传输位数<br><span class="math display">\[B = N \times 602\ \text{bytes} \times 8\ \tfrac{\text{bits}}{\text{byte}}  = 8\,012\,999 \times 602 \times 8  \approx 3.85906\times 10^{10}\ \text{bits}\]</span></li><li>链路速率 (R = 155 )<br></li><li>传输时间<br><span class="math display">\[T = \frac{B}{R}  = \frac{3.85906\times 10^{10}}{155\times 10^6}  \approx 249\ \text{秒}  \approx 4.15\ \text{分钟}\]</span></li></ul><h2 id="p.25">P.25</h2><p>Host A and B are communicating over a TCP connection, and Host B has already received from A all bytes up through byte <span class="math inline">\(126\)</span>. Suppose Host A then sends two segments to Host B back-to-back. The first and second segments contain <span class="math inline">\(70\)</span> and <span class="math inline">\(50\)</span> bytes of data, respectively. In the first segment, the sequence number is <span class="math inline">\(127\)</span>, the source port number is <span class="math inline">\(302\)</span>, and the destination port number is <span class="math inline">\(80\)</span>. Host B sends an acknowledgement whenever it receives a segment from Host A.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. In the second segment sent from Host A to B, what are the sequence number, source port number, and destination port number?</strong> - The sequence number is <span class="math inline">\(197\)</span>, the source port number is <span class="math inline">\(302\)</span> and the dest port number is <span class="math inline">\(80\)</span>.</p><p><strong>b. If the first segment arrives before the second segment, in the acknowledgement of the first arriving segment, what is the acknowledgment number, the source port number, and the destination port number?</strong> - The acknowledgement number is <span class="math inline">\(197\)</span>, the source port number is <span class="math inline">\(80\)</span> and the dest port number is <span class="math inline">\(302\)</span>.</p><p><strong>c. If the second segment arrives before the first segment, in the acknowledgement of the first arriving segment, what is the acknowledgment number?</strong> - The acknowledgement number is <span class="math inline">\(127\)</span>.</p><p><strong>d. Suppose the two segments sent by A arrive in order at B. The first acknowledgement is lost and the second acknowledgement arrives after the first timeout interval. Draw a timing diagram, showing these segments and all other segments and acknowledgements sent. (Assume there is no additional packet loss.) For each segment in your figure, provide the sequence number and the number of bytes of data; for each acknowledgement that you add, provide the acknowledgement number.</strong></p><ul><li>假设：<br></li><li>A→B 连续发送两段<br></li><li>B 收到每段即发 ACK<br></li><li>第一条 ACK(197) 丢失，第二条 ACK(247) 成功到达<br></li><li>超时重传未触发（因为第二条 ACK 收到后 A 已完成确认）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>Time →<br>Host A                          Host B<br>  |                                |<br>  |-- [Seq=127, Len=70] ----------&gt;|   接收 127-196，B 发送 ACK(197) → 丢失<br>  |                                |<br>  |-- [Seq=197, Len=50] ----------&gt;|   接收 197-246，B 发送 ACK(247)<br>  |                                |<br>  |      [超时等待 ACK(197)]       |<br>  |                                |<br>  |-- [Seq=127, Len=70] ----------&gt;|   重复包，B 再次发送 ACK(247)<br>  |                                |<br>  |&lt;----------- ACK(247) ----------|   A 收到确认，确认两段都已接收<br></code></pre></td></tr></table></figure><h2 id="p.31">P.31</h2><p><strong>Question and Answer:</strong></p><p>What is the relationship between the variable SendBase in Section <span class="math inline">\(3.5.4\)</span> and the variable LastByteRcvd in Section <span class="math inline">\(3.5.5\)</span>?</p><p>在理想网络条件下（无丢包、延迟较小）：</p><p><span class="math display">\[\text{SendBase} - 1 = \text{LastByteRcvd}\]</span></p><p>这是因为： - 接收方接收到字节序号为 n 的数据后，LastByteRcvd = n - 接收方发送 ACK(n+1) - 发送方收到 ACK(n+1) 后，更新 SendBase = n+1</p><p>由于网络延迟、丢包等因素： - LastByteRcvd 可能<strong>小于</strong> SendBase-1（发送方已收到更新的确认） - LastByteRcvd 可能<strong>大于</strong> SendBase-1（某些已接收数据未被确认接收）</p><h2 id="p.32">P.32</h2><p><strong>Question and Answer:</strong></p><p>What is the relationship between the variable <span class="math inline">\(\text{LastByteRcvd}\)</span> in Section <span class="math inline">\(3.5.5\)</span> and the variable <span class="math inline">\(\text{y}\)</span> in Section <span class="math inline">\(3.5.4\)</span>?</p><p>由上题所述：</p><p><span class="math display">\[\text{acknowledgement number} = \text{LastByteRcvd} + 1\]</span></p><h2 id="p.34">P.34</h2><p>Compare GBN, SR, and TCP (no delayed ACK). Assume that the timeout values for all three protocols are sufficiently long such that <span class="math inline">\(5\)</span> consecutive data segments and their corresponding ACKs can be received (if not lost in the channel) by the receiving host (Host B) and the sending host (Host A) respectively. Suppose Host A sends <span class="math inline">\(5\)</span> data segments to Host B, and the <span class="math inline">\(2^{nd}\)</span> segment (sent from A) is lost. In the end, all <span class="math inline">\(5\)</span> data segments have been correctly received by Host B.</p><p><strong>Question and Answer:</strong></p><p><strong>a. How many segments has Host A sent in total and how many ACKs has Host B sent in total? What are their sequence numbers? Answer this question for all three protocols.</strong></p><p>题目没有指定 sequence number，这里默认从 <span class="math inline">\(0\)</span> 开始，所有 segment 大小为 <span class="math inline">\(1\)</span> byte。首先，receiver 收到多少个 segment 就会回多少个 ACK。</p><p>首先明确各协议的ACK机制：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><strong>协议</strong></th><th><strong>确认机制</strong></th><th><strong>ACK含义</strong></th></tr></thead><tbody><tr class="odd"><td>GBN</td><td>累积确认</td><td>ACK(n)表示期望收到序号n的段</td></tr><tr class="even"><td>SR</td><td>选择确认</td><td>ACK(n)表示已收到序号n的段</td></tr><tr class="odd"><td>TCP</td><td>累积确认+SACK</td><td>ACK(n)表示期望收到序号n的段</td></tr></tbody></table></div><p>分析 GBN 协议，第一个 segment 的 sequence number 为 <span class="math inline">\(0\)</span>，以此类推，接下来的 sequence number 分别为 <span class="math inline">\(1\)</span> <span class="math inline">\(2\)</span> <span class="math inline">\(3\)</span> <span class="math inline">\(4\)</span>，相应的 ACK 为 <span class="math inline">\(1\)</span> <span class="math inline">\(2\)</span> <span class="math inline">\(3\)</span> <span class="math inline">\(4\)</span> <span class="math inline">\(5\)</span>。但由于第二个包丢失，实际上的 ACK 为 <span class="math inline">\(1\)</span> 丢失 <span class="math inline">\(1\)</span> <span class="math inline">\(1\)</span> <span class="math inline">\(1\)</span>， 再重发，<span class="math inline">\(2\)</span> <span class="math inline">\(3\)</span> <span class="math inline">\(4\)</span> <span class="math inline">\(5\)</span>。再分析剩下两个协议，最终得到</p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr class="header"><th><strong>Protocol</strong></th><th><strong>Segments Sent</strong></th><th><strong>ACKs Received</strong></th><th><strong>Their Sequence</strong></th></tr></thead><tbody><tr class="odd"><td>GBN</td><td>9</td><td>8</td><td>1 1 1 1 2 3 4 5</td></tr><tr class="even"><td>SR</td><td>6</td><td>5</td><td>0 2 3 4 1</td></tr><tr class="odd"><td>TCP</td><td>6</td><td>5</td><td>1 1 1 1 5</td></tr></tbody></table></div><p><strong>b. If the timeout values for all three protocol are much longer than <span class="math inline">\(5\)</span> RTT, then which protocol successfully delivers all five data segments in shortest time interval?</strong></p><p>SR 和 TCP，因为这两种协议都只发送了 <span class="math inline">\(6\)</span> 次包。</p><h2 id="p.37">P.37</h2><p><strong>Questions and Answers:</strong></p><figure><img src="/2025/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Transport-Layer/TCP%20window%20size%20as%20a%20function%20of%20time.png" style="display: block; margin: 0 auto; width: 90%" alt="TCP window size as a function of time"><figcaption aria-hidden="true">TCP window size as a function of time</figcaption></figure><p>Assuming TCP <strong>Reno</strong> is the protocol experiencing the behavior shown above, answer the following questions. In all cases, you should provide a short discussion justifying your answer.</p><p><strong>a. Identify the intervals of time when TCP slow start is operating.</strong></p><p>根据 TCP congestion control 机制，slow start phase 期间 <strong>cwnd</strong> 是以指数函数增长，从图中可以得出大概是在 <span class="math inline">\(\text{Transmission round} \in [1, 6] \cup [23, 26]\)</span> 期间。</p><p><strong>b. Identify the intervals of time when TCP congestion avoidance is operating</strong></p><p>TCP congestion avoidance 期间的特点是 <strong>cwnd</strong> 以 $ k = 1 $ MSS 的速率线性增长，从图中可以得出大概是在 <span class="math inline">\(\text{Transmission round} \in [6, 16] \cup [17, 22]\)</span> 期间。</p><p><strong>c. After the 16th transmission round, is segment loss detected by a triple duplicate ACK or by a timeout?</strong></p><p>从图中可以分析出，<span class="math inline">\(\text{ssthresh} = \frac{\text{cwnd}}{2}\)</span>，<span class="math inline">\(\text{cwnd} = \text{ssthresh}\)</span>，然后线性增长，所以 detected by a triple duplicate ACK。</p><p><strong>d. After the 22nd transmission round, is segment loss detected by a triple duplicate ACK or by a timeout?</strong></p><p><strong>cwnd</strong> 归一，进入 slow start phase，所以 detected by a timeout。</p><p><strong>e. What is the initial value of <span class="math inline">\(\text{ssthresh}\)</span> at the first transmission round?</strong></p><p>大概是 <span class="math inline">\(32\)</span> MSS，当 <span class="math inline">\({\text{cwnd} \geq \text{ssthresh}}\)</span> 会进入 congestion avoidance phase，然后线性增长。</p><p><strong>f. What is the value of ssthresh at the <span class="math inline">\(18^{th}\)</span> transmission round?</strong></p><p>减半了，所以是，<span class="math inline">\(\text{ssthresh} = \frac{\text{cwnd}}{2} = 21\)</span> MSS</p><p><strong>g. What is the value of ssthresh at the <span class="math inline">\(24^{th}\)</span> transmission round?</strong></p><p>减半了，所以是，<span class="math inline">\(\text{ssthresh} = \frac{\text{cwnd}}{2} = 13\)</span> MSS</p><p><strong>h. During what transmission round is the <span class="math inline">\(70^{th}\)</span> segment sent?</strong></p><p>第一次 slow start phase 阶段后传了 63 个，所在第 <span class="math inline">\(6\)</span> 和 <span class="math inline">\(7\)</span> 轮之间。</p><p><strong>i. Assuming a packet loss is detected after the <span class="math inline">\(26^{th}\)</span> round by the receipt of a triple duplicate ACK, what will be the values of the congestion window size and of ssthresh?</strong></p><p><span class="math inline">\(\text{ssthresh} = \frac{\text{cwnd}}{2}\)</span>，<span class="math inline">\(\text{cwnd} = \text{ssthresh}\)</span>，都是 <span class="math inline">\(4\)</span> segment.</p><p><strong>j. Suppose TCP Tahoe is used (instead of TCP Reno), and assume that triple duplicate ACKs are received at the <span class="math inline">\(16^{th}\)</span> round. What are the ssthresh and the congestion window size at the <span class="math inline">\(19^{th}\)</span> round?</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>特性</th><th>TCP Tahoe</th><th>TCP Reno</th></tr></thead><tbody><tr class="odd"><td><strong>三次重复ACK时</strong></td><td>cwnd=1MSS, 进入慢启动</td><td>cwnd=ssthresh, 进入拥塞避免</td></tr><tr class="even"><td><strong>超时事件时</strong></td><td>cwnd=1MSS, 进入慢启动</td><td>cwnd=1MSS, 进入慢启动</td></tr><tr class="odd"><td><strong>恢复速度</strong></td><td>较慢(需要重新慢启动)</td><td>较快(可能直接进入拥塞避免)</td></tr><tr class="even"><td><strong>快速恢复机制</strong></td><td>不支持</td><td>支持</td></tr></tbody></table></div><p>第 <span class="math inline">\(16^{th}\)</span> 出现了 triple duplicate ACKs，所以，第 <span class="math inline">\(17^{th}\)</span> <span class="math inline">\(\text{ssthresh} = \frac{\text{cwnd}}{2} = 21\)</span>，<span class="math inline">\(\text{cwnd} = 1\)</span>，然后进入 slow start 阶段，第 <span class="math inline">\(19^{th}\)</span> <span class="math inline">\(\text{cwnd} = 4\)</span></p><p><strong>k. Again suppose TCP Tahoe is used, and there is a timeout event at <span class="math inline">\(22^{nd}\)</span> round. How many packets have been sent out from <span class="math inline">\(17^{th}\)</span> round till <span class="math inline">\(22^{nd}\)</span> round, inclusive?</strong></p><p>需要注意的是，在第 <span class="math inline">\(16^{th}\)</span> 收到了三个 ACKs，同时，在第 <span class="math inline">\(22^{th}\)</span> 到达 ssthresh 所以实际收到 <span class="math inline">\(1 + 2 + 4 + 8 + 16 + 21 = 52\)</span> MSS。</p><h2 id="p.43">P.43</h2><p>Consider that only a single TCP (Reno) connection uses one <span class="math inline">\(10\)</span> Mbps link which does not buffer any data. Suppose that this link is the only congested link between the sending and receiving hosts. Assume that the TCP sender has a huge file to send to the receiver, and the receiver’s receive buffer is much larger than the congestion window. We also make the following assumptions: each TCP segment size is <span class="math inline">\(1\,500\)</span> bytes; the two-way propagation delay of this connection is <span class="math inline">\(100\)</span> msec; and this TCP connection <strong>is always in congestion avoidance phase, that is, ignore slow start</strong>.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is the maximum window size (in segments) that this TCP connection can achieve?</strong></p><p>最大窗口大小由 <strong>带宽延迟积(BDP)</strong> 决定：</p><p>首先计算 RTT： - 传播延迟 = <span class="math inline">\(100\)</span> 毫秒 - 传输延迟 = 段大小/带宽 = (<span class="math inline">\(1500 \times 8\)</span>) 比特/(<span class="math inline">\(10 \times 10^6\)</span>) 比特/秒 = <span class="math inline">\(1.2\)</span> 毫秒 - <strong>总RTT</strong> = <span class="math inline">\(101.2\)</span> 毫秒</p><p>带宽延迟积： <span class="math display">\[\text{BDP} = 10\text{ Mbps} \times 0.1012\text{ s} = 1.012 \times 10^6 \text{ bits}\]</span></p><p>也就是 PPT 上的公式： <span class="math display">\[\text{rate} \approx \frac{\text{cwnd}}{\text{RTT}}\]</span></p><p>最大窗口大小(段数)： <span class="math display">\[\text{最大窗口} = \frac{\text{BDP}}{\text{段大小}} = \frac{1.012 \times 10^6}{1500 \times 8} \approx 84.33 = \boxed{84\text{ 段}}\]</span></p><p><strong>b. What is the average window size (in segments) and average throughput (in bps) of this TCP connection?</strong></p><p>根据TCP Reno特性，窗口大小在拥塞避免阶段会在 <span class="math inline">\(\frac{W}{2}\)</span> 和 <span class="math inline">\(W\)</span> 之间周期变化。</p><p>平均窗口大小： <span class="math display">\[\text{平均窗口} = 0.75 \times W = 0.75 \times 84 = \boxed{63\text{ 段}}\]</span></p><p>平均吞吐量： <span class="math display">\[\text{平均吞吐量} = 0.75 \times \frac{W \times \text{段大小} \times 8}{\text{RTT}} = 0.75 \times \frac{84 \times 1500 \times 8}{0.1012} \approx \boxed{7.5\text{ Mbps}}\]</span></p><p><strong>c. How long would it take for this TCP connection to reach its maximum window again after recovering from a packet loss?</strong></p><p>在TCP Reno中，丢包后窗口大小减半，然后每个RTT增加 <span class="math inline">\(1\)</span> 个MSS：</p><ul><li>初始窗口（丢包后）= <span class="math inline">\(\frac{W}{2} = 42\)</span> 段</li><li>每个RTT增加 <span class="math inline">\(1\)</span> 段</li><li>需要增加的段数 = <span class="math inline">\(\frac{W}{2} = 42\)</span> 段</li><li>所需RTT数 = <span class="math inline">\(42\)</span></li></ul><p><span class="math display">\[\text{恢复时间} = 42 \times 0.1012 = \boxed{4.25\text{ 秒}}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Transport Layer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Application Layer</title>
    <link href="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/"/>
    <url>/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="principles-of-network-applications">Principles of network applications</h1><h2 id="application-architectures">Application architectures</h2><p><strong>Three Kinds:</strong> - Peer to Peer - Client-Server - hybrid of P2P and Client-Server</p><h3 id="client-server">Client-Server</h3><p><strong>Client-Server architecture has following characteristics:</strong> - Server is <strong>always-on</strong> host; - Server has a <strong>permanent IP address</strong>; - Clients do not communicate with each other directly.</p><blockquote><p>clients 之间通过 server 交流。</p></blockquote><h3 id="pure-p2p">Pure P2P</h3><p>In <strong>P2P architecture</strong>, there is no always-on server, what’s more, arbitrary end systems communicate directly.</p><h3 id="hybrid-of-client-server-and-p2p">Hybrid of Client-Server and P2P</h3><p>As the name suggests, this architecture is implemented with Client-Server and P2P.</p><p><strong>There are two important instance, Skype and QQ</strong> - <strong>Skype:</strong> a voice-over-IP P2P application. If a host A wants to voice another host B, he will get B’s IP address from a server. And then they communicate with each other directly. - <strong>QQ:</strong> a chat-over-IP P2P application.</p><blockquote><p>clients 会给 server 提交自己的 IP address。</p></blockquote><h4 id="client-server-部分">Client-Server 部分</h4><ul><li>用户登录、查找好友、获取在线状态等操作都需要通过<strong>集中服务器</strong>完成。</li><li>服务器维护所有用户的索引和状态信息，起到“中介”作用。</li></ul><h4 id="p2p-部分">P2P 部分</h4><ul><li>当用户之间需要发送即时消息或文件时，<strong>实际数据传输可以直接在用户之间进行</strong>，不经过服务器。</li><li>这样可以减轻服务器压力，提高传输效率。</li></ul><h2 id="processes-communicating">Processes Communicating</h2><p><strong>Process</strong> is a program controlled by <strong>app developer</strong>, running within a host. Within a same host, two processes communicate with each other by <strong>inter-process communication</strong>. Between two hosts, processes communicate with each other by <strong>exchanging messages</strong>. Generally speaking, there are two kinds of processes, they are <strong>client process</strong> and <strong>server process</strong>. Client process initializes a communication, and server process waits to be contacted.</p><h2 id="sockets">Sockets</h2><p>A <strong>door</strong> between application layer and transport layer.</p><h2 id="addressing-processes">Addressing Processes</h2><p>To receive message, process must have an <strong>identifier</strong>. Identifier includes both <strong>IP address</strong> and <strong>port numbers</strong> associated with process on host.</p><h2 id="app-layer-protocol-defines">App-layer Protocol Defines</h2><p><strong>What does an app-layer protocol define?</strong> - Type of message exchanged; - Message syntax: what fields in messages and how fields are delineated; - Message semantics: meaning of information in fields; - Rules for when and how a process requests and sends messages.</p><blockquote><p>message 类型、语义、语法、传输时间和方式。</p></blockquote><p>Generally speaking, there are two sorts of app-layer protocols, they <strong>public-domain protocol</strong> and <strong>proprietary protocol</strong>.</p><blockquote><p>前者公开后者不公开。</p></blockquote><h2 id="what-transport-service-dose-an-application-need">What transport service dose an application need?</h2><p>We can consider four standards to select transport service. - data loss - timing - throughput - security</p><p>下面是常见的应用类型其需要的传输层服务：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><strong>Application</strong></th><th><strong>Data Loss</strong></th><th><strong>Throughput</strong></th><th><strong>Time Sensitive</strong></th></tr></thead><tbody><tr class="odd"><td>File transfer</td><td>No loss</td><td>Elastic</td><td>No</td></tr><tr class="even"><td>E-mail</td><td>No loss</td><td>Elastic</td><td>No</td></tr><tr class="odd"><td>Web documents</td><td>No loss</td><td>Elastic</td><td>No</td></tr><tr class="even"><td>Real-time audio/video</td><td>Loss-tolerant</td><td>Audio: 5kbps-1Mbps<br>Video: 10kbps-5Mbps</td><td>Yes, 100’s msec</td></tr><tr class="odd"><td>Stored audio/video</td><td>Loss-tolerant</td><td>Same as above</td><td>Yes, few secs</td></tr><tr class="even"><td>Interactive games</td><td>Loss-tolerant</td><td>Few kbps up</td><td>Yes, 100’s msec</td></tr><tr class="odd"><td>Instant messaging</td><td>No loss</td><td>Elastic</td><td>Yes and no</td></tr></tbody></table></div><blockquote><p>远程医疗手术系统是 requires no data loss and is highly time-sensitive 实际上，在当今互联网中，语音和视频流量经常通过 <strong>TCP</strong> 发送，主要原因是<strong>防火墙和 NAT（网络地址转换）设备的兼容性和穿透性更好</strong>。许多防火墙和 NAT 设备默认只允许 TCP 流量通过，而对 UDP 流量进行限制或直接丢弃。这样做是出于安全性和管理的考虑，因为 TCP 连接有明确的建立和关闭过程，便于追踪和控制，而 UDP 是无连接的，容易被滥用。因此，为了确保语音和视频应用能够在各种网络环境下顺利传输数据，开发者往往选择基于 TCP 协议进行数据传输，即使 UDP 在实时性和低延迟方面更有优势。</p></blockquote><p>下面是常见的应用类型其需要的应用层、传输层协议：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><strong>Application</strong></th><th><strong>Application Layer Protocol</strong></th><th><strong>Underlying Transport Protocol</strong></th></tr></thead><tbody><tr class="odd"><td>E-mail</td><td>SMTP [RFC 2821]</td><td>TCP</td></tr><tr class="even"><td>Remote terminal access</td><td>Telnet [RFC 854]</td><td>TCP</td></tr><tr class="odd"><td>Web</td><td>HTTP [RFC 2616]</td><td>TCP</td></tr><tr class="even"><td>File transfer</td><td>FTP [RFC 959]</td><td>TCP</td></tr><tr class="odd"><td>Streaming multimedia</td><td>HTTP (e.g., YouTube), RTP [RFC 1889]</td><td>TCP or UDP</td></tr><tr class="even"><td>Internet telephony</td><td>SIP, RTP, proprietary (e.g., Skype)</td><td>Typically UDP</td></tr></tbody></table></div><h1 id="web-and-http">Web and HTTP</h1><p>Web pages consist of some <strong>objects</strong>, each object can be HTML file, Java script and so on. Each object is addressed by a URL, for example, <code>www.someschool.edu/someDept/pic.gif</code>. Among this URL, <code>www.someschool.edu</code> is host name and <code>someDept/pic.gif</code> is path name.</p><p><strong>Base HTML-file</strong> is the core of a page. It may includes several referenced objects.</p><h2 id="http-hypertext-transfer-protocol">HTTP: Hypertext Transfer Protocol</h2><p><strong>HTTP</strong> is Web’s application protocol with <strong>Client-Server model</strong>. Its transport layer protocol is <strong>TCP</strong>.</p><p>HTTP is <strong>stateless</strong>, this means server maintains no information of past clients requests. The reason why protocol that maintains state are complex is that if server or client crashes, their views of “state” may be inconsistent, must be reconciled.</p><blockquote><p>需要和后文的 cookie 区分开，cookie 并不和 stateless 的性质相违背，原因是：Cookie 只是让状态在客户端和服务器之间传递，而不是让服务器主动维护状态。</p></blockquote><h3 id="non-persistent-http">Non-Persistent HTTP</h3><h4 id="rtt-round-trip-time">RTT: Round Trip Time</h4><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/Non-Persistent-HTTP.png" style="display: block; margin: 0 auto; width: 90%" alt="Non Persistent HTTP"><figcaption aria-hidden="true">Non Persistent HTTP</figcaption></figure><p><strong>Definition of <span class="math inline">\(\text{RTT}\)</span>:</strong> time for a small packet to travel from client to server and back.</p><p>From the picture, we can calculate total time. <span class="math inline">\(\text{total time} = 2 \times \text{RTT} + \text{transmit time}_1\)</span></p><h3 id="persistent-http">Persistent HTTP</h3><p>Persistent HTTP leaves <strong>TCP connection open</strong> after sending response. Client sends request as soon as it encounters a referenced object. As little as one RTT for all the referenced objects. <span class="math inline">\(\text{total time} \approx 3 \times \text{RTT} + \text{transmit time}_1 + \text{transmit time}_2\)</span></p><h2 id="http-message">HTTP Message</h2><p>Two types of HTTP message: <strong>request</strong> and <strong>response</strong>. <strong>Sent as ASCII text</strong></p><h3 id="request">Request</h3><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/Request-Format.png" style="display: block; margin: 0 auto; width: 90%" alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure><ol type="1"><li><strong>Request Line</strong><ul><li><strong>Method:</strong> GET, POST, HEAD; PUT, DELETE;<ul><li><strong>POST:</strong> Server decides the path;</li><li><strong>PUT:</strong> Client decides the path;</li></ul></li><li><strong>URL:</strong> path;</li><li><strong>Version:</strong> HTTP version.</li></ul></li><li><strong>Header Lines</strong><ul><li><strong>Host:</strong></li><li><strong>User-Agent:</strong></li><li><strong>Connection:</strong> keep-alive or close;</li><li><strong>Accept-Language:</strong> .</li></ul></li><li><strong>Entity Body:</strong></li></ol><blockquote><p>如果是 keep-alive 则是 persistent connection；如果是 close 则是 non-persistent connection。</p></blockquote><h3 id="response">Response</h3><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/Response-Format.png" style="display: block; margin: 0 auto; width: 90%" alt="Response Format"><figcaption aria-hidden="true">Response Format</figcaption></figure><p><strong>A few sample codes</strong> - <code>200: OK</code> - <code>301: Moved Permanently</code> - <code>400: Bad Request</code> - <code>404: Not Found</code> - <code>505: HTTP Version Not Supported</code></p><h2 id="user-server-state-cookies">User-Server State: Cookies</h2><p><strong>How to set cookies and use cookies?</strong> When a client first initialize HTTP TCP connection, server will <strong><code>set cookies</code></strong> in response message’s <strong>Header</strong> filed. After that, each request message from same client will take will <strong><code>cookies</code></strong> in request message <strong>HEADER</strong> filed.</p><p><strong>What cookies can bring:</strong></p><ul><li>authorization</li><li>shopping carts</li><li>recommendations</li><li>user session state (Web e-mail)</li></ul><p>比如：</p><ol type="1"><li>用户访问电商网站 → 服务器分配并下发 <code>user_id</code> Cookie</li><li>用户下单 → 浏览器携带 <code>user_id</code> Cookie → 服务器根据 <code>user_id</code> 更新购买记录</li><li>用户后续访问 → 服务器通过 Cookie 识别用户，展示其购买历史</li></ol><h2 id="web-caches">Web Caches</h2><p><strong>Goal</strong>: satisfy client request without involving origin server.</p><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/Web-Caches.png" style="display: block; margin: 0 auto; width: 90%" alt="Web Caches"><figcaption aria-hidden="true">Web Caches</figcaption></figure><blockquote><p>typically cache is installed by ISP.</p></blockquote><p><strong>Why Web caching?</strong> - <strong>reduce response time</strong> for client request - <strong>reduce traffic</strong> on an institution’s access link. - Internet dense with caches: enables “poor” content providers to effectively deliver content (but so does P2P file sharing)</p><h3 id="conditional-get">Conditional GET</h3><p><strong>Goal:</strong> don’t send object if cache has <strong>up-to-date</strong> cached version</p><p><strong>cache:</strong> specify date of cached copy in <strong>HTTP request</strong>: <code>If-modified-since: date</code> <strong>server:</strong> <strong>response</strong> contains no object if cached copy <code>is up-to-date: HTTP/1.0 304 Not Modified</code></p><h1 id="ftp-the-file-transfer-protocol">FTP: the File Transfer Protocol</h1><p><strong>Goal:</strong> File transfers from/to remote host.</p><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/FTP.png" style="display: block; margin: 0 auto; width: 90%" alt="FTP"><figcaption aria-hidden="true">FTP</figcaption></figure><p>FTP client contacts FTP server at <strong>port 21</strong>, <strong>TCP</strong> is transport protocol. When server receives <strong>file transfer command</strong>, server opens <span class="math inline">\(2^{nd}\)</span> TCP connection for file to client. After transferring one file, server closes data connection. Server opens another TCP data connection to transfer another file.</p><p>这是一种 <strong>out-of-band</strong> 的协议。</p><ul><li><strong>带外（Out-of-band）</strong> 指的是控制信息和数据内容通过<strong>不同的通道</strong>进行传输，而不是混合在同一个通道中。</li></ul><h2 id="ftp-commands-responses">FTP Commands, Responses</h2><p>Sent as <strong>ASCII text</strong>, response: <strong>status code and phrase</strong>.</p><p><strong>Sample commands:</strong> - <code>USER</code> username; - <code>PASS</code> password; - <code>LIST</code> return list of file in current directory; - <code>RETR</code> filename retrieves (gets) file; - <code>STOR</code> filename stores (puts) file onto remote host.</p><p><strong>Sample return codes:</strong> - <code>331</code> Username OK, password required; - <code>125</code> data connection already open; transfer starting; - <code>425</code> Can’t open data connection; - <code>452</code> Error writing file.</p><h1 id="electronic-mail">Electronic Mail</h1><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/e-mail-system.png" style="display: block; margin: 0 auto; width: 90%" alt="e mail system"><figcaption aria-hidden="true">e mail system</figcaption></figure><p><strong>Three Major Components:</strong> - user agents; - mail servers; - simple mail transfer protocol: SMTP.</p><p><strong>Mail Server</strong> - <strong>mailbox</strong> contains incoming messages for user; - <strong>message queue</strong> of outgoing (to be sent) mail messages - SMTP protocol <strong>between mail servers</strong> to send email messages</p><h2 id="smtp-simple-mail-transfer-protocol">SMTP: Simple Mail Transfer Protocol</h2><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/SMTP-example.png" style="display: block; margin: 0 auto; width: 90%" alt="SMTP example"><figcaption aria-hidden="true">SMTP example</figcaption></figure><p><strong>Characteristics:</strong> - Uses <strong>TCP</strong> to reliably transfer email message from client to server, <strong>port 25</strong>; - Three phases of transfer; - <strong>Handshaking</strong> (Greeting); - <strong>Transfer of Messages</strong>; - <strong>Closure</strong>. - Command/Response interaction; - Commands: ASCII text; - Response: status code and phrase.</p><p><strong>What’s more:</strong> - SMTP uses <strong>persistent connections</strong>; - SMTP requires message (header &amp; body) to be in <strong>7-bit ASCII</strong>; - SMTP server uses <code>CRLF.CRLF</code> to determine end of message.</p><p><strong>Comparison with HTTP</strong> - HTTP: pull; SMTP: push - HTTP: each object encapsulated in its own response msg; SMTP: <strong>multiple objects sent in multipart msg</strong>.</p><h2 id="mail-message-format">Mail Message Format</h2><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/Message-Format.png" style="display: block; margin: 0 auto; width: 90%" alt="Message Format"><figcaption aria-hidden="true">Message Format</figcaption></figure><h2 id="mail-access-protocols">Mail Access Protocols</h2><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/Mail-Access-Protocol.png" style="display: block; margin: 0 auto; width: 90%" alt="Mail Access Protocol"><figcaption aria-hidden="true">Mail Access Protocol</figcaption></figure><ul><li>SMTP: <strong>delivery/storage</strong> to receiver’s server;</li><li>Mail Access Protocol: <strong>retrieval</strong> from server.</li></ul><h3 id="pop3-protocol">POP3 Protocol</h3><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/POP3.png" style="display: block; margin: 0 auto; width: 90%" alt="POP3"><figcaption aria-hidden="true">POP3</figcaption></figure><p><strong>More about POP3:</strong> Previous example uses “download and delete” mode. Bob cannot re-read e-mail if he changes client;<strong>“Download-and-keep”:</strong> copies of messages on different clients; POP3 is stateless across sessions.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>模式</th><th>邮件服务器是否保留邮件</th><th>多终端访问体验</th><th>适用场景</th></tr></thead><tbody><tr class="odd"><td>download-and-delete</td><td>否</td><td>仅首台设备可见</td><td>单一终端、节省空间</td></tr><tr class="even"><td>download-and-keep</td><td>是</td><td>多终端均可访问</td><td>多终端、备份安全</td></tr></tbody></table></div><h3 id="imap">IMAP</h3><ul><li>Keep all messages in one place: <strong>the server</strong>;</li><li>Allows user to <strong>organize</strong> messages in folders;</li><li>IMAP keeps user state across sessions: names of folders and mappings between message IDs and folder name.</li></ul><h1 id="dns-domain-name-system">DNS: Domain Name System</h1><p>组织的 Web 服务器和邮件服务器能否拥有相同的主机别名？对应的 RR 类型是什么？</p><p><strong>可以。</strong><br>一个组织的 Web 服务器和邮件服务器完全可以使用同一个主机别名（如 <code>foo.com</code>）。这是因为 DNS 允许为同一个域名设置不同类型的资源记录（Resource Record, RR），分别指向 Web 服务和邮件服务。</p><ul><li>当用户在浏览器中访问 <code>http://foo.com</code> 时，DNS 查询的是该域名的 <strong>A 记录</strong>（IPv4 地址）或 <strong>AAAA 记录</strong>（IPv6 地址），用于定位 Web 服务器。</li><li>当发送邮件到 <code>user@foo.com</code> 时，邮件系统会查询该域名的 <strong>MX 记录</strong>，用于定位邮件服务器。</li></ul><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>记录类型</th><th>作用说明</th></tr></thead><tbody><tr class="odd"><td>A</td><td>域名到 IPv4 地址（Web 服务器）</td></tr><tr class="even"><td>MX</td><td>域名到邮件服务器主机名（邮件服务）</td></tr></tbody></table></div><p><strong>Hostname to IP address translation</strong></p><h2 id="distributed-hierarchical-database">Distributed, Hierarchical Database</h2><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/DNS-Server.png" style="display: block; margin: 0 auto; width: 90%" alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure><h3 id="top-level-domain-tld-servers">Top-Level Domain (TLD) Servers</h3><ul><li>Responsible for com, org, net, edu, etc, and all top-level country domains uk, fr, ca, jp;</li><li><strong>Network Solutions(a company)</strong> maintains servers for com TLD;</li><li><strong>Educause(an institution)</strong> for edu TLD</li></ul><h3 id="authoritative-dns-servers">Authoritative DNS Servers</h3><p>Organization’s DNS servers, providing authoritative <strong>hostname to IP mappings</strong> for organization’s servers (e.g., Web, mail). Can be maintained by organization or service provider.</p><h3 id="local-name-server">Local Name Server</h3><ul><li>Does not strictly belong to hierarchy;</li><li>Each <strong>ISP</strong> (residential ISP, company, university) has one;</li><li>When host makes DNS query, query is sent to its local DNS server.</li></ul><h2 id="dns-name-resolution">DNS Name Resolution</h2><h3 id="iterated-query">Iterated Query</h3><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/Iterated-Query.png" style="display: block; margin: 0 auto; width: 70%" alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure><h3 id="recursive-query">Recursive Query</h3><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/Recursive-Query.png" style="display: block; margin: 0 auto; width: 70%" alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure><h2 id="dns-caching-and-updating-records">DNS: Caching and Updating Records</h2><ul><li>Once (any) name server learns mapping, it caches mapping;</li><li>Cache entries timeout (disappear) after some time;</li><li><strong>TLD servers</strong> typically cached in local name servers. Thus root name servers not often visited.</li></ul><h3 id="dns-records">DNS records</h3><p>DNS: distributed db storing <strong>resource records (RR)</strong>.</p><p>RR format: <code>(name, value, type, ttl)</code>.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><strong>Type</strong></th><th><strong>Name</strong></th><th><strong>Value</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr class="odd"><td><strong>A</strong></td><td>Hostname</td><td>IP address</td><td>Maps hostname to IP address</td></tr><tr class="even"><td><strong>NS</strong></td><td>Domain (e.g., <code>foo.com</code>)</td><td>Hostname of authoritative name server</td><td>Specifies authoritative name server for domain</td></tr><tr class="odd"><td><strong>CNAME</strong></td><td>Alias name</td><td>Canonical name</td><td>Maps alias to canonical (real) name</td></tr><tr class="even"><td><strong>MX</strong></td><td>Domain name</td><td>Mail server name</td><td>Specifies mail server associated with domain</td></tr></tbody></table></div><h2 id="dns-protocol-messages">DNS Protocol, Messages</h2><p>DNS protocol : <strong>query</strong> and <strong>reply</strong> messages, both with <strong>same message format</strong>.</p><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/DNS-message-format.png" style="display: block; margin: 0 auto; width: 90%" alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure><p><strong>Identification:</strong> 16 bit <code>#</code> for query, reply to query uses same <code>#</code>.</p><p><strong>Flags:</strong> - query or reply; - recursion desired; - recursion available; - reply is authoritative.</p><h1 id="p2p-applications">P2P applications</h1><h2 id="pure-p2p-architecture">Pure P2P Architecture</h2><h3 id="file-distribution-server-client-vs-p2p">File Distribution: Server-Client vs P2P</h3><ul><li><span class="math inline">\(u_s\)</span>: server upload bandwidth;</li><li><span class="math inline">\(u_i\)</span>: peer i upload bandwidth;</li><li><span class="math inline">\(d_i\)</span>: peer i download bandwidth;</li><li><span class="math inline">\(F\)</span>: file size.</li></ul><p><strong>Question: How much time to distribute file from one server to <span class="math inline">\(N\)</span> peers?</strong></p><p><strong>Answer with Client-Server</strong> <span class="math display">\[t_{cs} = \max \left \{\frac{NF}{u_s}, \frac{F}{d_i} \right \} \tag{1}\]</span></p><p><strong>Answer with P2P</strong> <span class="math display">\[t_{p2p} = \max \left \{\frac{F}{u_s}, \frac{F}{d_i}, \frac{NF}{u_s + \sum_{i} u_i} \right \} \tag{2}\]</span></p><h3 id="bittorrent">BitTorrent</h3><p>基于 <strong>tit-for-tat</strong> （互惠）策略鼓励节点之间公平交换。每个节点会优先向那些<strong>当前向自己上传速度最快的节点</strong>上传数据块。</p><p>但是，即使 Alice 在 30 秒内持续向 Bob 上传数据块，Bob 也<strong>不一定会在同一时间段内回馈 Alice</strong>，原因如下：</p><ol type="1"><li><strong>带宽和资源限制</strong>：Bob 可能已经将上传带宽分配给了其他上传速度更快或更优先的 peer。</li><li><strong>块的可用性</strong>：Bob 可能没有 Alice 需要的数据块，无法立即回馈。</li><li><strong>策略调整延迟</strong>：BitTorrent 的“互惠”是基于一段时间内的统计结果，回馈行为可能会有延迟。</li><li><strong>乐善好施（optimistic unchoking）</strong>：每隔一段时间，客户端会随机选择一个 peer 上传数据块，以发现潜在的更优互惠对象，这也可能导致回馈不及时。</li></ol><p>上述 4. 解决了新加入节点启动问题。</p><h3 id="skype">Skype</h3><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>功能</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>用户查找与登录</td><td>通过 P2P 网络分布式存储和查找用户信息</td></tr><tr class="even"><td>媒体数据的传输</td><td>语音、视频、文件等数据优先点对点传输，必要时通过中继节点转发</td></tr></tbody></table></div><h1 id="socket-programming">Socket programming</h1><p><strong>Goal:</strong> learn how to <strong>build Client-Server application</strong> that communicate using sockets.</p><h2 id="definition-of-socket">Definition of Socket</h2><p><strong>An application-created, OS-controlled interface (a “door”) into which application process can both send and receive messages to/from another application process.</strong></p><h2 id="socket-programming-with-udp">Socket Programming with UDP</h2><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/Socket-Programming-with-UDP.png" style="display: block; margin: 0 auto; width: 90%" alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure><h3 id="udpclient.java">UDPClient.java</h3><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/UDPClient-java.png" style="display: block; margin: 0 auto; width: 90%" alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure><h2 id="socket-programming-with-tcp">Socket programming with TCP</h2><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/Socket-Programming-with-TCP.png" style="display: block; margin: 0 auto; width: 90%" alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/Three-kinds-of-Socket.png" style="display: block; margin: 0 auto; width: 90%" alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/TCP-Socket.png" style="display: block; margin: 0 auto; width: 90%" alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure><h3 id="tcpclient.java">TCPClient.java</h3><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/TCPClient-java.png" style="display: block; margin: 0 auto; width: 90%" alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure><h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1><h2 id="r.1">R.1</h2><p>List five nonproprietary Internet applications and the application-layer protocols that they use.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;"><strong>Type</strong></th><th style="text-align: center;"><strong>Protocol(s)</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Email</td><td style="text-align: center;">SMTP, IMAP, POP3</td></tr><tr class="even"><td style="text-align: center;">Web Browser</td><td style="text-align: center;">HTTP</td></tr><tr class="odd"><td style="text-align: center;">File Transfer</td><td style="text-align: center;">FTP</td></tr><tr class="even"><td style="text-align: center;">Domain Name Resolution</td><td style="text-align: center;">DNS</td></tr><tr class="odd"><td style="text-align: center;">Remote Terminal Access</td><td style="text-align: center;">SSH, Telnet</td></tr></tbody></table></div><h2 id="r.2">R.2</h2><p>What is the difference between network architecture and application architecture?（不太理解这里的 network architecture，默认和 application architecture 一样，都指的是在一个 OSI layer）</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><strong>Aspect</strong></th><th><strong>Network Architecture</strong></th><th><strong>Application Architecture</strong></th></tr></thead><tbody><tr class="odd"><td><strong>Definition</strong></td><td>Describes the organization of network layers and components for data transmission.</td><td>Describes how application components interact to achieve specific functionalities.</td></tr><tr class="even"><td><strong>Focus</strong></td><td>Focuses on data transmission methods, routing, switching, and protocol stacks.</td><td>Focuses on the logical structure and communication patterns of applications.</td></tr><tr class="odd"><td><strong>Scope</strong></td><td>Concerned with the entire network, including physical, data link, and network layers.</td><td>Concerned with the application layer and its communication between processes.</td></tr><tr class="even"><td><strong>Examples</strong></td><td>Virtual circuit networks, datagram networks.</td><td>Client-server model, P2P model (e.g., Skype, HTTP).</td></tr></tbody></table></div><h2 id="r.6">R.6</h2><p>Suppose you wanted to do a transaction from a remote client to a server as fast as possible. Would you use UDP or TCP? Why?</p><ul><li>对于<strong>简单、小型且允许失败的事务</strong>（如状态查询、监控数据上报），可以选择<strong>UDP</strong></li><li>对于<strong>大多数商业事务</strong>（如金融交易、数据库操作），应选择<strong>TCP</strong>，因为：<ul><li>事务的<strong>完整性和正确性</strong>通常比速度更重要</li><li>TCP的<strong>可靠性保障</strong>减少了应用层的复杂度</li><li>虽然TCP建立连接有开销，但对于事务的整体成功率和效率更有保障</li><li>在现代网络环境中，<strong>TCP连接建立的时延</strong>相对事务处理总时间通常可以接受</li></ul></li><li>但题目要求 <strong>as fast as possible</strong>，所以还是用 <strong>UDP</strong>。</li></ul><h2 id="r.17">R.17</h2><p>Print out the header of an e-mail message you have recently received. How many <code>Received:</code> header lines are there? Analyze each of the header lines in the message.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Received: from codeforces.com (mx2.codeforces.com [77.234.215.195])<br>        by newxmmxszgpub6-1.qq.com (NewMX) with SMTP id BF70781A<br>        for &lt;1xx575xxxx@qq.com&gt;; Sat, 17 May 2025 00:47:55 +0800<br>Received: from localhost (gauss.codeforces.com [192.168.10.103])<br>        by codeforces.com (Postfix) with ESMTP id D7D9F322729C1<br>        for &lt;1xx575xxxx@qq.com&gt;; Fri, 16 May 2025 18:48:56 +0300 (MSK)<br>From: &quot;Codeforces@codeforces.com&quot; &lt;Codeforces@codeforces.com&gt;<br>To: &quot;1xx575xxxx@qq.com&quot; &lt;1xx575xxxx@qq.com&gt;<br>Subject: Codeforces Round 1025 (Div. 2)<br></code></pre></td></tr></table></figure><p>There are <span class="math inline">\(2\)</span> <code>Received:</code> header lines.</p><p>The first part is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Received: from codeforces.com (mx2.codeforces.com [77.234.215.195])<br>        by newxmmxszgpub6-1.qq.com (NewMX) with SMTP id BF70781A<br>        for &lt;1xx575xxxx@qq.com&gt;; Sat, 17 May 2025 00:47:55 +0800<br></code></pre></td></tr></table></figure><ul><li><code>Received: from codeforces.com (mx2.codeforces.com [77.234.215.195])</code>: The email was sent from the Codeforces mail server with public IP.</li><li><code>by newxmmxszgpub6-1.qq.com (NewMX)</code>: Received by QQ Mail’s mail server.</li><li>Using <strong>SMTP</strong> protocol, <code>Date\Time</code>: <code>Sat, 17 May 2025 00:47:55 +0800</code>.</li><li>其中的 <code>mx2</code> 指的是 <strong>Mail eXchanger 2</strong>，即 codeforces 的第二台邮件交换 server。</li></ul><p>The second part is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Received: from localhost (gauss.codeforces.com [192.168.10.103])<br>        by codeforces.com (Postfix) with ESMTP id D7D9F322729C1<br>        for &lt;1xx575xxxx@qq.com&gt;; Fri, 16 May 2025 18:48:56 +0300 (MSK)<br></code></pre></td></tr></table></figure><ul><li><code>Received: from localhost (gauss.codeforces.com [192.168.10.103])</code>: The email originated from the local server named <code>gauss.codeforces.com</code> (internal IP).</li><li><code>by codeforces.com (Postfix)</code>: Received by the main Codeforces mail server using Postfix.</li><li>Using <strong>ESMTP</strong> protocol.</li></ul><ol type="1"><li><p><strong>邮件头传输顺序说明</strong>：邮件头按照邮件传输的<strong>相反顺序</strong>排列（最新的记录在最上面）。因此第二个<code>Received</code>行实际上是邮件传输的<strong>起始点</strong>，第一个是<strong>最后一跳</strong>。</p></li><li><p><strong>时区分析</strong>：注意到两个头部行的时间戳不同:</p><ul><li>第一个记录: <code>Sat, 17 May 2025 00:47:55 +0800</code>(中国时区)</li><li>第二个记录: <code>Fri, 16 May 2025 18:48:56 +0300</code>(莫斯科时区MSK) 这说明邮件确实是从俄罗斯发往中国的，时间差符合时区差异。</li></ul></li><li><p><strong>ESMTP vs SMTP的区别</strong>：第二个头部使用ESMTP(扩展SMTP)而不是普通SMTP，这表明使用了更多高级功能(如身份验证、加密等)。</p></li></ol><h2 id="r.22">R.22</h2><p>What is an overlay network? Does it include routers? What are the edges in the overlay network? How is the query-flooding overlay network created and maintained?</p><p>An <strong>overlay network</strong> is a virtual network built on top of an existing physical network. It consists of logical connections (or “edges”) between nodes, which are typically end systems or hosts. These logical connections are established using the underlying physical network infrastructure.</p><ul><li><p><strong>Does it include routers?</strong><br>No, an overlay network does not include physical routers. Instead, the nodes in the overlay network are typically end systems (e.g., computers, servers) that communicate directly with each other using logical links. The physical routers are part of the underlying network and are not explicitly represented in the overlay.</p></li><li><p><strong>What are the edges in the overlay network?</strong><br>The edges in an overlay network are logical connections between nodes. These connections are established using the underlying physical network but are abstracted away from the physical topology. For example, in a peer-to-peer (P2P) network, the edges represent direct communication paths between peers.</p></li><li><p><strong>How is the query-flooding overlay network created and maintained?</strong><br>A query-flooding overlay network is created by connecting nodes in a logical topology where each node knows a subset of other nodes (its neighbors). When a query is initiated, it is broadcasted (or “flooded”) to all neighboring nodes, which in turn forward the query to their neighbors, and so on.<br>Maintenance of the overlay involves:</p><ol type="1"><li><strong>Node discovery:</strong> New nodes join the network by discovering existing nodes and establishing connections.</li><li><strong>Topology updates:</strong> Nodes periodically update their neighbor lists to reflect changes in the network (e.g., nodes joining or leaving).</li><li><strong>Failure handling:</strong> Mechanisms are implemented to detect and recover from node or connection failures to ensure the overlay remains functional.</li></ol></li></ul><h2 id="r.28">R.28</h2><p>For the client-server application over TCP described in Section <span class="math inline">\(2.7\)</span>, why must the server program be executed before the client program? For the clientserver application over UDP described in Section <span class="math inline">\(2.8\)</span>, why may the client program be executed before the server program?</p><ul><li><strong>For the TCP client-server application (Section <span class="math inline">\(2.7\)</span>):</strong> The server program must be executed before the client because the server needs to create a socket, bind it to a port, and listen for incoming connections. If the client starts first, it will try to connect to the server’s port, but if the server isn’t running and listening yet, the connection will fail.</li><li><strong>For the UDP client-server application (Section <span class="math inline">\(2.8\)</span>):</strong> The client program may be executed before the server because UDP is connectionless. The client can send a datagram to the server’s address and port even if the server isn’t running yet; the datagram may be lost, but the client doesn’t need to establish a connection first. When the server starts, it can immediately receive any new datagrams sent to its port.</li></ul><h2 id="p.4">P.4</h2><p>Consider the following string of ASCII characters that were captured by Wireshark when the browser sent an HTTP <code>GET</code> message (i.e., this is the actual content of an HTTP <code>GET</code> message). The characters <code>&lt;cr&gt;&lt;lf&gt;</code> are carriage return and line-feed characters (that is, the italized character string <code>&lt;cr&gt;</code> in the text below represents the single carriage-return character that was contained at that point in the HTTP header). Answer the following questions, indicating where in the HTTP GET message below you find the answer.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">GET /cs453/index.html HTTP/1.1&lt;cr&gt;&lt;lf&gt;Host: gai<br>a.cs.umass.edu&lt;cr&gt;&lt;lf&gt;User-Agent: Mozilla/5.0 (<br>Windows;U; Windows NT 5.1; en-US; rv:1.7.2) Gec<br>ko/20040804 Netscape/7.2 (ax) &lt;cr&gt;&lt;lf&gt;Accept:ex<br>t/xml, application/xml, application/xhtml+xml, text<br>/html;q=0.9, text/plain;q=0.8,image/png,*/*;q=0.5<br>&lt;cr&gt;&lt;lf&gt;Accept-Language: en-us,en;q=0.5&lt;cr&gt;&lt;lf&gt;Accept-<br>Encoding: zip,deflate&lt;cr&gt;&lt;lf&gt;Accept-Charset: ISO<br>-8859-1,utf-8;q=0.7,*;q=0.7&lt;cr&gt;&lt;lf&gt;Keep-Alive: 300&lt;cr&gt;<br>&lt;lf&gt;Connection:keep-alive&lt;cr&gt;&lt;lf&gt;&lt;cr&gt;&lt;lf&gt;<br></code></pre></td></tr></table></figure><p><strong>Questions:</strong></p><ol type="a"><li>What is the URL of the document requested by the browser?</li><li>What version of HTTP is the browser running?</li><li>Does the browser request a non-persistent or a persistent connection?</li><li>What is the IP address of the host on which the browser is running?</li><li>What type of browser initiates this message? Why is the browser type needed in an HTTP request message?</li></ol><p><strong>Answers:</strong></p><p><strong>a. What is the URL of the document requested by the browser?</strong> - <code>http://gaia.cs.umass.edu/cs453/index.html</code>.</p><p><strong>b. What version of HTTP is the browser running?</strong> - <code>HTTP/1.1</code></p><p><strong>c. Does the browser request a non-persistent or a persistent connection?</strong> - <code>Connection:keep-alive</code>: a persistent connection.</p><p><strong>d. What is the IP address of the host on which the browser is running?</strong> - The IP address of the host is not explicitly provided in the HTTP GET message. It would typically be determined by examining the network layer (IP) headers in the packet capture, which are not included in the provided data.</p><p><strong>e. What type of browser initiates this message? Why is the browser type needed in an HTTP request message?</strong><br>- The browser type is <code>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.2) Gecko/20040804 Netscape/7.2 (ax)</code>.<br>- The browser type is included in the <code>User-Agent</code> header. It is needed in an HTTP request message to allow the server to tailor its response based on the browser’s capabilities, such as supported features, rendering engine, or platform-specific optimizations.</p><h2 id="p.5">P.5</h2><p>The text below shows the reply sent from the server in response to the HTTP <code>GET</code> message in the question above. Answer the following questions, indicating where in the message below you find the answer.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">HTTP/1.1 200 OK&lt;cr&gt;&lt;lf&gt;Date: Tue, 07 Mar 2008<br>12:39:45GMT&lt;cr&gt;&lt;lf&gt;Server: Apache/2.0.52 (Fedora)<br>&lt;cr&gt;&lt;lf&gt;Last-Modified: Sat, 10 Dec2005 18:27:46<br>GMT&lt;cr&gt;&lt;lf&gt;ETag: &quot;526c3-f22-a88a4c80&quot;&lt;cr&gt;&lt;lf&gt;Accept-<br>Ranges: bytes&lt;cr&gt;&lt;lf&gt;Content-Length: 3874&lt;cr&gt;&lt;lf&gt;<br>Keep-Alive: timeout=max=100&lt;cr&gt;&lt;lf&gt;Connection:<br>Keep-Alive&lt;cr&gt;&lt;lf&gt;Content-Type: text/html; charset=<br>ISO-8859-1&lt;cr&gt;&lt;lf&gt;&lt;cr&gt;&lt;lf&gt;&lt;!doctype html public &quot;-<br>//w3c//dtd html 4.0 transitional//en&quot;&gt;&lt;lf&gt;&lt;html&gt;&lt;lf&gt;<br>&lt;head&gt;&lt;lf&gt; &lt;meta http-equiv=&quot;Content-Type&quot;<br>content=&quot;text/html; charset=iso-8859-1&quot;&gt;&lt;lf&gt; &lt;meta<br>name=&quot;GENERATOR&quot; content=&quot;Mozilla/4.79 [en] (Windows NT<br>5.0; U) Netscape&quot;&gt;&lt;lf&gt; &lt;title&gt;CMPSCI 453 / 591 /<br>NTU-ST550A Spring 2005 homepage&lt;/title&gt;&lt;lf&gt;&lt;/head&gt;&lt;lf&gt;<br>&lt;much more document text following here (not shown)&gt;<br></code></pre></td></tr></table></figure><p><strong>Questions and Answers:</strong></p><p><strong>a. Was the server able to successfully find the document or not? What time was the document reply provided?</strong> - <code>200 OK</code>: successfully find the document; <code>Tue, 07 Mar2008 12:39:45</code></p><p><strong>b. When was the document last modified?</strong> - <code>Last-Modified: Sat, 10 Dec2005 18:27:46</code></p><p><strong>c. How many bytes are there in the document being returned?</strong> - <code>Ranges: bytes&lt;cr&gt;&lt;lf&gt;Content-Length: 3874</code>: <span class="math inline">\(3874\)</span> bytes.</p><p><strong>d. What are the first 5 bytes of the document being returned? Did the server agree to a persistent connection?</strong></p><ul><li><strong>First 5 bytes of the document:</strong> <code>&lt;!doc</code> (from the document content starting with <code>&lt;!doctype html public...</code>). 所选的 HTTP 报文内容声明了 <code>Content-Type: text/html; charset=ISO-8859-1</code>，该编码是单字节编码（每个字符 1 字节）</li><li><strong>Persistent connection:</strong> Yes, the server agreed to a persistent connection as indicated by the header <code>Connection: Keep-Alive</code>.</li></ul><h2 id="p.9">P.9</h2><p>Consider Figure <span class="math inline">\(2.12\)</span>, for which there is an institutional network connected to the Internet. Suppose that the average object size is <span class="math inline">\(850,000\)</span> bits and that the average request rate from the institution’s browsers to the origin servers is <span class="math inline">\(16\)</span> requests per second. Also suppose that the amount of time it takes from when the router on the Internet side of the access link forwards an HTTP request until it receives the response is <span class="math inline">\(3\)</span> seconds on average (see <span class="math inline">\(\text{Section}\)</span> <span class="math inline">\(2.2.5\)</span>). <strong>Model the total average response time as the sum of the average access delay (that is, the delay from Internet router to institution router) and the average Internet delay</strong>. For the average access delay, use <span class="math inline">\(\Delta / (1 - \Delta \beta)\)</span>, where <span class="math inline">\(\Delta\)</span> is the average time required to send an object over the access link and <span class="math inline">\(\beta\)</span> is the arrival rate of objects to the access link.</p><p><strong>Complement:</strong> <span class="math inline">\(15\)</span> Mbps access link and <span class="math inline">\(100\)</span> Mbps LAN.</p><figure><img src="/2025/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Application-Layer/Bottleneck%20between%20an%20institutional%20network%20and%20the%20Internet.png" style="display: block; margin: 0 auto; width: 90%" alt="Bottleneck between an institutional network and the Internet"><figcaption aria-hidden="true">Bottleneck between an institutional network and the Internet</figcaption></figure><p><strong>Questions and Answers:</strong></p><p><strong>a. Find the total average response time.</strong></p><p>The total average response time is the sum of the <strong>average access delay</strong> and the <strong>average Internet delay</strong>.</p><ol type="1"><li><p><strong>Given data:</strong></p><ul><li>Average object size: <span class="math inline">\(L = 850,000\)</span> bits</li><li>Access link rate: <span class="math inline">\(R = 15\)</span> Mbps</li><li>Request rate: <span class="math inline">\(\beta = 16\)</span> requests/second</li><li>Average Internet delay: <span class="math inline">\(3\)</span> seconds</li></ul></li><li><p><strong>Calculate <span class="math inline">\(\Delta\)</span>:</strong> <span class="math display">\[\Delta = \frac{L}{R} = \frac{850,000}{15 \times 10^6} = 0.0567 \, \text{seconds}\]</span></p></li><li><p><strong>Calculate average access delay:</strong> <span class="math display">\[\text{Access delay} = \frac{\Delta}{1 - \Delta \beta} = \frac{0.0567}{1 - (0.0567 \times 16)} = \frac{0.0567}{1 - 0.9072} = \frac{0.0567}{0.0928} \approx 0.611 \, \text{seconds}\]</span></p></li><li><p><strong>Total average response time:</strong> <span class="math display">\[\text{Total response time} = \text{Access delay} + \text{Internet delay} = 0.611 + 3 = 3.611 \, \text{seconds}\]</span></p></li></ol><p><strong>b. Now suppose a cache is installed in the institutional LAN. Suppose the miss rate is <span class="math inline">\(0.4\)</span>. Find the total response time.</strong></p><ol type="1"><li><strong>Given data:</strong><ul><li>Miss rate: <span class="math inline">\(0.4\)</span></li><li>Hit rate: <span class="math inline">\(1 - 0.4 = 0.6\)</span></li><li>Access delay (from part a): <span class="math inline">\(0.611\)</span> seconds</li><li>Internet delay: <span class="math inline">\(3\)</span> seconds</li></ul></li><li><strong>Calculate total response time with caching:</strong> <span class="math display">\[\text{Total response time} = (\text{Hit rate} \times \text{Access delay}) + (\text{Miss rate} \times (\text{Access delay} + \text{Internet delay}))\]</span> Substituting values: <span class="math display">\[\text{Total response time} = 0.6 \times \frac{850000}{100 \times 10^6} + 0.4 \times (0.611 + 3)\]</span> <span class="math display">\[\text{Total response time} = 0.0051 + 0.4 \times 3.611 = 1.4495 \, \text{s}\]</span></li></ol><h2 id="p.15">P.15</h2><p><strong>Question:</strong></p><p>Read RFC <span class="math inline">\(5321\)</span> for SMTP. What does MTA stand for? Consider the following received spam email (modified from a real spam email). Assuming only the originator of this spam email is malacious and all other hosts are honest, identify the malacious host that has generated this spam email.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">From - Fri Nov 07 13:41:30 2008<br>Return-Path: &lt;tennis5@pp33head.com&gt;<br>Received: from barmail.cs.umass.edu<br>(barmail.cs.umass.edu [128.119.240.3]) by cs.umass.edu<br>(8.13.1/8.12.6) for &lt;hg@cs.umass.edu&gt;; Fri, 7 Nov 2008<br>13:27:10 -0500<br>Received: from asusus-4b96 (localhost [127.0.0.1]) by<br>barmail.cs.umass.edu (Spam Firewall) for<br>&lt;hg@cs.umass.edu&gt;; Fri, 7 Nov 2008 13:27:07 -0500<br>(EST)<br>Received: from asusus-4b96 ([58.88.21.177]) by<br>barmail.cs.umass.edu for &lt;hg@cs.umass.edu&gt;; Fri,<br>07 Nov 2008 13:27:07 -0500 (EST)<br>Received: from [58.88.21.177] by<br>inbnd55.exchangeddd.com; Sat, 8 Nov 2008 01:27:07 +0700<br>From: &quot;Jonny&quot; &lt;tennis5@pp33head.com&gt;<br>To: &lt;hg@cs.umass.edu&gt;<br>Subject: How to secure your savings<br></code></pre></td></tr></table></figure><p><strong>Answer:</strong></p><p><strong>最底部的 <code>Received:</code> 记录代表邮件的最初来源</strong>，即发件人最初连接的主机。</p><ul><li><p><strong>What does MTA stand for?</strong><br>MTA stands for <strong>Mail Transfer Agent</strong>. It is a software application used to transfer email messages from one server to another using protocols such as SMTP.</p></li><li><p><strong>Identify the malicious host:</strong><br>To identify the malicious host, we analyze the <code>Received</code> headers in reverse order (from bottom to top), as each <code>Received</code> header represents a hop in the email’s journey.</p><ol type="1"><li><strong><code>Received: from [58.88.21.177] by inbnd55.exchangeddd.com</code></strong><ul><li>This indicates that the email originated from the IP address <code>58.88.21.177</code>.</li></ul></li><li><strong><code>Received: from asusus-4b96 ([58.88.21.177]) by barmail.cs.umass.edu</code></strong><ul><li>This confirms that the email was sent from the same IP address <code>58.88.21.177</code>.</li></ul></li><li><strong><code>Received: from asusus-4b96 (localhost [127.0.0.1]) by barmail.cs.umass.edu</code></strong><ul><li>This shows that the email passed through a local host (<code>127.0.0.1</code>) on the <code>barmail.cs.umass.edu</code> server.</li></ul></li><li><strong><code>Received: from barmail.cs.umass.edu (barmail.cs.umass.edu [128.119.240.3]) by cs.umass.edu</code></strong><ul><li>This indicates that the email was forwarded by <code>barmail.cs.umass.edu</code> to <code>cs.umass.edu</code>.</li></ul></li></ol><p>Based on the analysis, the <strong>malicious host</strong> is the originator of the email, which is the IP address <strong><code>58.88.21.177</code></strong>. This is the source of the spam email.</p></li></ul><h2 id="p.18">P.18</h2><p><strong>Questions and Answers:</strong></p><p><strong>a. What is a whois database?</strong></p><p>A <strong>whois database</strong> is a publicly accessible database that contains information about the registered owners of domain names and IP address blocks. It is maintained by domain registrars and regional internet registries (RIRs). The database provides details such as:</p><ul><li>The name and contact information of the domain owner or organization.</li><li>The domain’s registration and expiration dates.</li><li>The domain’s associated name servers.</li><li>The registrar responsible for the domain.</li></ul><p>The <strong>whois database</strong> is commonly used for administrative purposes, such as verifying domain ownership, resolving technical issues, or investigating malicious activities.</p><p><strong>b. Use various whois databases on the Internet to obtain the names of two DNS servers. Indicate which whois databases you used.</strong></p><p>DNS server 的名字，通常指的是域名形式的主机名。</p><p>通过在 <a href="https://lookup.icann.org/">ICANN Lookup</a> 查询 <code>BiliBili.com</code> 得到其 Nameservers - <code>NS3.DNSV5.COM</code> - <code>NS4.DNSV5.COM</code></p><p>通过在 <a href="https://whois.domaintools.com/">DomainTools</a> 查询 <code>Baidu.com</code> 得到其 Nameservers - <code>NS1.BAIDU.COM (has 805 domains)</code> - <code>NS2.BAIDU.COM (has 805 domains)</code> - <code>NS3.BAIDU.COM (has 805 domains)</code> - <code>NS4.BAIDU.COM (has 805 domains)</code> - <code>NS7.BAIDU.COM (has 805 domains)</code></p><p><strong>c. Use nslookup on your local host to send DNS queries to three DNS servers: your local DNS server and the two DNS servers you found in part (b). Try querying for Type A, NS, and MX reports. Summarize your findings.</strong></p><p>我在终端输入的语句及其显示结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">(base) PS C:\Users\17657\Desktop\Github\HEXO&gt; nslookup<br>默认服务器:  UnKnown<br>Address:  10.3.9.5<br><br>&gt; set type=A<br>&gt; www.baidu.com<br>服务器:  UnKnown<br>Address:  10.3.9.5<br><br>非权威应答:<br>名称:    www.a.shifen.com<br>Addresses:  220.181.111.232<br>          220.181.111.1<br>Aliases:  www.baidu.com<br><br>&gt; set type=NS<br>&gt; baidu.com<br>服务器:  UnKnown<br>Address:  10.3.9.5<br><br>非权威应答:<br>baidu.com       nameserver = ns2.baidu.com<br>baidu.com       nameserver = ns7.baidu.com<br>baidu.com       nameserver = ns3.baidu.com<br>baidu.com       nameserver = dns.baidu.com<br>baidu.com       nameserver = ns4.baidu.com<br><br>ns2.baidu.com   internet address = 220.181.33.31<br>ns7.baidu.com   internet address = 180.76.76.92<br>dns.baidu.com   internet address = 110.242.68.134<br>ns3.baidu.com   internet address = 36.155.132.78<br>ns3.baidu.com   internet address = 153.3.238.93<br>ns4.baidu.com   internet address = 14.215.178.80<br>ns4.baidu.com   internet address = 111.45.3.226<br>&gt; set type=MX<br>&gt; baidu.com<br>服务器:  UnKnown<br>Address:  10.3.9.5<br><br>非权威应答:<br>baidu.com       MX preference = 20, mail exchanger = mx.baidu.com<br>baidu.com       MX preference = 10, mail exchanger = mx.maillb.baidu.com<br>&gt; server ns1.baidu.com<br>默认服务器:  ns1.baidu.com<br>Address:  110.242.68.134<br><br>&gt; set type=A<br>&gt; www.baidu.com<br>服务器:  ns1.baidu.com<br>Address:  110.242.68.134<br><br>非权威应答:<br>名称:    www.a.shifen.com<br>Addresses:  220.181.111.1<br>          220.181.111.232<br>Aliases:  www.baidu.com<br><br>&gt; set type=NS<br>&gt; baidu.com<br>服务器:  ns1.baidu.com<br>Address:  110.242.68.134<br><br>非权威应答:<br>baidu.com       nameserver = dns.baidu.com<br>baidu.com       nameserver = ns3.baidu.com<br>baidu.com       nameserver = ns4.baidu.com<br>baidu.com       nameserver = ns2.baidu.com<br>baidu.com       nameserver = ns7.baidu.com<br><br>ns7.baidu.com   internet address = 180.76.76.92<br>ns4.baidu.com   internet address = 14.215.178.80<br>ns4.baidu.com   internet address = 111.45.3.226<br>ns2.baidu.com   internet address = 220.181.33.31<br>ns3.baidu.com   internet address = 36.155.132.78<br>ns3.baidu.com   internet address = 153.3.238.93<br>dns.baidu.com   internet address = 110.242.68.134<br>&gt; set type=MX<br>&gt; baidu.com<br>服务器:  ns1.baidu.com<br>Address:  110.242.68.134<br><br>非权威应答:<br>baidu.com       MX preference = 20, mail exchanger = mx.baidu.com<br>baidu.com       MX preference = 10, mail exchanger = mx.maillb.baidu.com<br>&gt; server ns3.dnsv5.com<br>默认服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>&gt; set type=A<br>&gt; baidu.com<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    baidu.com<br>Addresses:  182.61.201.211<br>          182.61.244.181<br><br>&gt; set type=NS<br>&gt; baidu.com<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>baidu.com       nameserver = ns4.baidu.com<br>baidu.com       nameserver = ns7.baidu.com<br>baidu.com       nameserver = ns2.baidu.com<br>baidu.com       nameserver = ns3.baidu.com<br>baidu.com       nameserver = dns.baidu.com<br><br>ns7.baidu.com   internet address = 180.76.76.92<br>ns4.baidu.com   internet address = 14.215.178.80<br>ns4.baidu.com   internet address = 111.45.3.226<br>ns2.baidu.com   internet address = 220.181.33.31<br>ns3.baidu.com   internet address = 36.155.132.78<br>ns3.baidu.com   internet address = 153.3.238.93<br>dns.baidu.com   internet address = 110.242.68.134<br>&gt; set type=MX<br>&gt; baidu.com<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>baidu.com       MX preference = 10, mail exchanger = mx.maillb.baidu.com<br>baidu.com       MX preference = 20, mail exchanger = mx.baidu.com<br></code></pre></td></tr></table></figure><p>总结： - <code>www.baidu.com</code> 和 <code>baidu.com</code> 不是同一个东西。具体来说后者涵盖范围更广。 - 一个 Nameserver 能有多个 Internet address。 - <code>type=A</code> 模式返回的是域名的 IPv4 地址。 - <code>type=NS</code> 模式返回的是 Nameserver 的名字和其 internet address。 - <code>type=MS</code> 模式返回的是该域名的邮件服务器主机名及优先级。</p><p><strong>d. Use nslookup to find a Web server that has multiple IP addresses. Does the Web server of your institution (school or company) have multiple IP addresses?</strong></p><p>查询 <code>www.bilibili.com</code> 得到结果如下，其有两个 IP address。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>&gt; set type=A <br>&gt; www.bilibili.com<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    a.w.bilicdn1.com<br>Addresses:  121.194.11.73<br>          121.194.11.72<br>Aliases:  www.bilibili.com<br><br></code></pre></td></tr></table></figure><p>貌似我们学校的 web server 只有一个 IP Address</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>&gt; ucloud.bupt.edu.cn<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    vn.bupt.edu.cn<br>Address:  10.3.19.2<br>Aliases:  ucloud.bupt.edu.cn<br><br>&gt; auth.bupt.edu.cn<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    vn.bupt.edu.cn<br>Address:  10.3.19.2<br>Aliases:  auth.bupt.edu.cn<br><br>&gt; www.bupt.edu.cn<br>服务器:  ns3.dnsv5.com<br>Addresses:  1.12.0.18<br>          1.12.0.17<br>          43.140.237.52<br>          111.13.203.52<br>          36.155.149.211<br>          101.227.168.52<br>          220.196.136.52<br><br>非权威应答:<br>名称:    vn46.bupt.edu.cn<br>Address:  10.3.19.2<br>Aliases:  www.bupt.edu.cn<br></code></pre></td></tr></table></figure><p><strong>e. Use the ARIN whois database to determine the IP address range used by your university.</strong></p><p>操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>nslookup www.bupt.edu.cn<br>服务器:  UnKnown<br>Address:  10.3.9.5<br><br>非权威应答:<br>名称:    vn46.bupt.edu.cn<br>Addresses:  2001:da8:215:4038::161<br>          10.3.19.2<br>Aliases:  www.bupt.edu.cn<br><br></code></pre></td></tr></table></figure><p>这里的 IPv4 地址是子网地址吧？我在 rain 上查询查到了一个美国机构，而且网页也提醒我了 <strong>These addresses are in use by many millions of independently operated networks, which might be as small as a single computer connected to a home gateway, and are automatically configured in hundreds of millions of devices.</strong> 所以我用的是 IPv6 的地址，这个地址能查到，显示：Net Range <code>2001:da8:: - 2001:da8:ffff:ffff:ffff:ffff:ffff:ffff</code>。</p><p><strong>f. Describe how an attacker can use whois databases and the nslookup tool to perform reconnaissance on an institution before launching an attack.</strong></p><p>An attacker 可以用 whois 和 nslookup 干如下的事情：</p><ul><li><strong>whois 数据库</strong>：公开的域名/IP 注册信息数据库，可查询域名所有者、联系方式、DNS 服务器、IP 地址段等信息。</li><li><strong>nslookup 工具</strong>：DNS 查询工具，可用来获取域名解析记录（如 A、NS、MX、CNAME 等），进一步了解目标机构的网络结构和服务部署。</li></ul><p>从而可以：</p><ul><li>查询目标机构的域名，获取注册人、联系方式、注册商、DNS 服务器、IP 地址段等信息。</li><li>通过 whois 查询 IP 地址，了解目标机构的公网 IP 范围、网络归属、可能的子网划分。</li><li>利用这些信息，攻击者可以锁定攻击目标、寻找潜在的弱点（如联系邮箱、技术负责人等）。</li><li>查询目标机构域名的 A 记录，获取 Web 服务器等主机的 IP 地址。</li><li>查询 NS 记录，了解目标机构使用的权威 DNS 服务器，判断是否存在 DNS 攻击面。</li><li>查询 MX 记录，获取邮件服务器信息，可能用于钓鱼邮件、垃圾邮件攻击。</li><li>查询 CNAME、TXT 等记录，发现隐藏的服务、第三方集成、邮件安全策略等。</li><li>通过对不同子域名的批量查询，发现更多内部服务和主机。</li></ul><p>进而：</p><ul><li>绘制目标机构的网络拓扑和服务分布图。</li><li>寻找潜在的攻击入口（如暴露的服务器、邮件系统、DNS 服务等）。</li><li>为后续的漏洞扫描、社工攻击、钓鱼邮件等攻击手段做准备。</li></ul><p><strong>g. Discuss why whois databases should be publicly available.</strong></p><p>whois数据库作为互联网基础设施的重要组成部分，其公开可用性具有多方面的价值与意义：</p><ol type="1"><li><strong>互联网透明度与问责制</strong><ul><li>提供域名和IP地址资源的<strong>所有权透明度</strong>，确保资源分配可追溯</li><li>建立互联网资源使用的<strong>公开记录</strong>，减少匿名滥用可能性</li><li>符合互联网作为<strong>公共资源</strong>的基本属性，保障公众知情权</li></ul></li><li><strong>技术协调与故障排除</strong><ul><li>网络管理员能迅速找到<strong>技术联系人</strong>解决网络问题</li><li>跨组织网络协作时提供必要的<strong>联络信息</strong></li><li>在安全事件、网络中断等紧急情况下提供<strong>快速响应渠道</strong></li></ul></li><li><strong>法律与知识产权保护</strong><ul><li>协助<strong>商标持有者</strong>保护其在线知识产权</li><li>为<strong>域名争议解决</strong>提供必要的所有权信息</li><li>帮助执法机构<strong>打击网络犯罪</strong>和识别不法行为</li></ul></li><li><strong>历史与文化因素</strong><ul><li>符合互联网早期建立的<strong>开放共享精神</strong></li><li>继承了学术网络环境下的<strong>信任与协作文化</strong></li><li>反映了互联网治理中的<strong>多方参与模式</strong></li></ul></li><li><strong>安全与风险的平衡</strong><ul><li>虽然公开信息存在被滥用的风险，但<strong>安全通过隐蔽</strong>不是可持续策略</li><li>现代whois服务已引入<strong>数据隐私保护机制</strong>（如代理注册服务）</li><li>信息公开带来的<strong>集体安全收益</strong>通常超过个体风险</li></ul></li></ol><p>总之，whois数据库的公开可用反映了互联网基于<strong>透明、协作和问责</strong>的核心价值观，在保护隐私和维护网络健康运行之间寻求平衡。尽管存在被攻击者利用的风险，但其对互联网正常运行、问题排除和资源管理的价值仍然超过潜在风险。</p><h2 id="p.20">P.20</h2><p><strong>Question and Answer:</strong> Suppose you can access the caches in the local DNS servers of your department. Can you propose a way to roughly determine the Web servers (outside your department) that are most popular among the users in your department? Explain.</p><p>To determine the most popular external Web servers among the users in my department, I would propose the following method:</p><ol type="1"><li><strong>Access the local DNS server’s cache:</strong><ul><li>The local DNS server maintains a cache of recently resolved domain names and their corresponding IP addresses.</li><li>By accessing this cache, I can retrieve a list of domain names that users in my department have recently accessed.</li></ul></li><li><strong>Filter out internal domain names:</strong><ul><li>Remove any domain names that belong to the local department or organization.</li></ul></li><li><strong>Count the frequency of external domain names:</strong><ul><li>For each external domain name in the cache, count how many times it appears.</li><li>This will give an estimate of how frequently users in the department access each external Web server.</li></ul></li><li><strong>Identify the most popular Web servers:</strong><ul><li>Sort the external domain names by their access frequency.</li><li>The domain names with the highest counts represent the most popular external Web servers among the users in the department.</li></ul></li></ol><p><strong>Explanation:</strong> This method works because the local DNS server’s cache reflects the browsing behavior of users in the department. By analyzing the cache, we can infer which external Web servers are most frequently accessed. However, this method has limitations, as it only provides a rough estimate and may not account for caching mechanisms in user devices or browsers.</p><h2 id="p.22">P.22</h2><p><strong>Question:</strong></p><p>Consider distributing a file of <span class="math inline">\(F = 15\)</span> Gbits to <span class="math inline">\(N\)</span> peers. The server has an upload rate of <span class="math inline">\(u_s = 30\)</span> Mbps, and each peer has a download rate of <span class="math inline">\(d_i = 2\)</span> Mbps and an upload rate of <span class="math inline">\(u\)</span>. For <span class="math inline">\(N = 10\)</span>, <span class="math inline">\(100\)</span>, and <span class="math inline">\(1,000\)</span> and <span class="math inline">\(u = 300\)</span> Kbps, <span class="math inline">\(700\)</span> Kbps, and <span class="math inline">\(2\)</span> Mbps, prepare a chart giving the minimum distribution time for each of the combinations of <span class="math inline">\(N\)</span> and <span class="math inline">\(u\)</span> for both client-server distribution and P2P distribution.</p><p><strong>Answer:</strong></p><p>To calculate the minimum distribution time for both client-server distribution and P2P distribution, we use the following formulas:</p><ol type="1"><li><p><strong>Client-Server Distribution:</strong> <span class="math display">\[t_{cs} = \max \left\{ \frac{N \cdot F}{u_s}, \frac{F}{d_i} \right\}\]</span></p></li><li><p><strong>P2P Distribution:</strong> <span class="math display">\[t_{p2p} = \max \left\{ \frac{F}{u_s}, \frac{F}{d_i}, \frac{N \cdot F}{u_s + \sum_{i} u_i} \right\}\]</span></p></li></ol><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th><span class="math inline">\(N\)</span></th><th><span class="math inline">\(u \, \text{Kbps}\)</span></th><th><span class="math inline">\(t_{cs} \, \text{seconds}\)</span></th><th><span class="math inline">\(t_{p2p} \, \text{seconds}\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(10\)</span></td><td><span class="math inline">\(300\)</span></td><td><span class="math inline">\(\max\{5000, 7500\} = 7500\)</span></td><td><span class="math inline">\(\max\{500, 7500, 4545\} = 7500\)</span></td></tr><tr class="even"><td><span class="math inline">\(10\)</span></td><td><span class="math inline">\(700\)</span></td><td><span class="math inline">\(\max\{5000, 7500\} = 7500\)</span></td><td><span class="math inline">\(\max\{500, 7500, 4054\} = 7500\)</span></td></tr><tr class="odd"><td><span class="math inline">\(10\)</span></td><td><span class="math inline">\(2,000\)</span></td><td><span class="math inline">\(\max\{5000, 7500\} = 7500\)</span></td><td><span class="math inline">\(\max\{500, 7500, 3000\} = 7500\)</span></td></tr><tr class="even"><td><span class="math inline">\(100\)</span></td><td><span class="math inline">\(300\)</span></td><td><span class="math inline">\(\max\{50000, 7500\} = 50000\)</span></td><td><span class="math inline">\(\max\{500, 7500, 25000\} = 25000\)</span></td></tr><tr class="odd"><td><span class="math inline">\(100\)</span></td><td><span class="math inline">\(700\)</span></td><td><span class="math inline">\(\max\{50000, 7500\} = 50000\)</span></td><td><span class="math inline">\(\max\{500, 7500, 15000\} = 15000\)</span></td></tr><tr class="even"><td><span class="math inline">\(100\)</span></td><td><span class="math inline">\(2,000\)</span></td><td><span class="math inline">\(\max\{50000, 7500\} = 50000\)</span></td><td><span class="math inline">\(\max\{500, 7500, 6522\} = 7500\)</span></td></tr><tr class="odd"><td><span class="math inline">\(1,000\)</span></td><td><span class="math inline">\(300\)</span></td><td><span class="math inline">\(\max\{500000, 7500\} = 500000\)</span></td><td><span class="math inline">\(\max\{500, 7500, 45455\} = 45455\)</span></td></tr><tr class="even"><td><span class="math inline">\(1,000\)</span></td><td><span class="math inline">\(700\)</span></td><td><span class="math inline">\(\max\{500000, 7500\} = 500000\)</span></td><td><span class="math inline">\(\max\{500, 7500, 20548\} = 20548\)</span></td></tr><tr class="odd"><td><span class="math inline">\(1,000\)</span></td><td><span class="math inline">\(2,000\)</span></td><td><span class="math inline">\(\max\{500000, 7500\} = 500000\)</span></td><td><span class="math inline">\(\max\{500, 7500, 7389\} = 7500\)</span></td></tr></tbody></table></div><ol type="1"><li><p>当节点数量<strong>较少</strong>（N=10）时，无论使用何种上传速率，<strong>两种分发方式所需时间相同</strong>，均受限于节点的下载速率。</p></li><li><p>当节点数量<strong>增加</strong>时，客户端-服务器模式的分发时间<strong>显著上升</strong>，而P2P模式在节点上传速率足够高时<strong>效率更高</strong>。</p></li><li><p>当节点上传速率达到<strong>2 Mbps</strong>时，P2P模式的分发时间在各种节点数下都可以保持在<strong>较低水平</strong>，这显示了P2P架构在大规模分发时的优势。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Application Layer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>统计学习及监督学习概论</title>
    <link href="/2025/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/"/>
    <url>/2025/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>作为《统计学习方法》一书的开篇内容，本文旨在系统梳理统计学习领域中的基本概念与常见问题，为后续章节的深入学习奠定理论基础。</p><h2 id="模型评估与选择">模型评估与选择</h2><h3 id="训练误差与测试误差">训练误差与测试误差</h3><p>一般而言，统计学习方法具体采用的损失函数未必是评估时使用的损失函数。</p><p>假设学习到的模型是 <span class="math inline">\(Y = \hat{f}(X)\)</span>，<strong>训练误差</strong>是模型 <span class="math inline">\(Y = \hat{f}(X)\)</span> 关于训练数据集的平局损失：</p><p><span class="math display">\[R_{\text{emp}} = \frac{1}{N} \sum_{i = 1}^{N} L(y_i, \hat{f}(x_i))\]</span></p><p>其中 <span class="math inline">\(N\)</span> 是训练样本容量。</p><p><strong>测试误差</strong>是模型 <span class="math inline">\(Y = \hat{f}(X)\)</span> 关于测试数据集的平均损失：</p><p><span class="math display">\[e_{\text{emp}} = \frac{1}{N&#39;} \sum_{i = 1}^{N&#39;} L(y_i, \hat{f}(x_i))\]</span></p><p>其中 <span class="math inline">\(N&#39;\)</span> 是测试样本容量。</p><p>上面所述中的函数 <span class="math inline">\(L\)</span> 是损失函数。</p><p>常见的 <span class="math inline">\(L\)</span> 有指示函数 <span class="math inline">\(I\)</span>，当满足函数内容是取 <span class="math inline">\(1\)</span>。当损失函数是指示函数时，此时测试误差又叫做<strong>测试误差率</strong>：</p><p><span class="math display">\[e_{\text{test}} = \frac{1}{N&#39;} \sum_{i = 1}^{N&#39;} I(y_i \neq \hat{f}(x_i))\]</span></p><h3 id="过拟合">过拟合</h3><p>过拟合是统计学习和机器学习领域中常见且重要的问题之一。它指的是模型在训练数据上表现良好，能够取得较低的训练误差，但在未见过的测试数据或新样本上表现较差，导致<strong>泛化能力下降</strong>的现象。过拟合通常发生在模型复杂度过高、参数数量远大于训练样本数量，或训练过程中对训练数据<strong>记忆</strong>过多而忽略了数据的内在规律时。</p><p>造成过拟合的主要原因包括：模型容量过大、训练数据不足、特征冗余或噪声较多等。为缓解过拟合，常用的方法有：增加训练数据量、选择更简单的模型、采用正则化技术（如L1或L2正则化）、剪枝、交叉验证等。合理地控制模型复杂度和提升数据质量，是提升模型泛化能力、避免过拟合的关键。</p><h3 id="正则化与交叉验证">正则化与交叉验证</h3><h4 id="正则化">正则化</h4><p>正则化是<strong>结构风险最小化策略</strong>的实现，是在<strong>经验风险</strong>上加一个正则化项，一般具有下述形式：</p><p><span class="math display">\[\min_{f \in \mathcal{F}} \quad \frac{1}{N} \sum_{i = 1}^{N}L(y_i, \hat{f}(x_i)) + \lambda J(f)\]</span></p><h4 id="交叉验证">交叉验证</h4><p>如果样本数据不足，此时可以应用交叉验证。</p><h2 id="泛化能力">泛化能力</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Data Link Layer</title>
    <link href="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/"/>
    <url>/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="交换机网络通信原理解析">交换机网络通信原理解析</h1><h2 id="交换机接口mac地址的实际用途">交换机接口MAC地址的实际用途</h2><p>交换机每个接口虽有MAC地址，但<strong>并非用于普通数据转发</strong>，而主要用于： - <strong>管理访问</strong>（Telnet/SSH/Web界面登录） - <strong>协议通信</strong>（STP生成树协议、LLDP等） - <strong>故障诊断和监控</strong></p><h2 id="数据帧如何通过交换机转发">数据帧如何通过交换机转发</h2><p>关键误解在于认为数据帧的目标MAC需要是交换机的MAC。实际上：</p><ol type="1"><li><strong>正常帧转发过程</strong>：<ul><li>主机A发送数据到F时，帧中<strong>目标MAC是路由器的MAC</strong>（不是交换机）</li><li>交换机收到帧后<strong>不检查“这是否发给我”</strong></li><li>交换机仅通过<strong>MAC地址表查询</strong>决定从哪个端口转发出去</li></ul></li><li><strong>交换机的核心工作原理</strong>：<ul><li>交换机维护一个<strong>MAC地址表</strong>，记录“哪个MAC地址在哪个端口”</li><li>收到帧后，查表找到目标MAC对应端口</li><li>从对应端口转发，<strong>不修改帧内容</strong></li></ul></li><li><strong>同网段和跨网段通信区别</strong>：<ul><li><strong>同网段</strong>：源MAC→主机A，目标MAC→主机B</li><li><strong>跨网段</strong>：源MAC→主机A，目标MAC→<strong>路由器</strong>接口</li></ul></li></ol><h2 id="结论">结论</h2><p>交换机处理所有收到的有效帧，<strong>不会因为目标MAC不是自己而丢弃</strong>。这与路由器不同，路由器只处理目标MAC是自己接口MAC的帧。</p><p><strong>正是因为交换机不修改MAC地址并且不以自身MAC为转发判断依据</strong>，才使得以太网能够高效透明地工作。</p><h1 id="introduction-and-service">Introduction and Service</h1><h2 id="some-terminology">Some terminology</h2><p>我们规定：</p><ul><li><strong>Nodes</strong>: hosts and routers;</li><li><strong>Links</strong>: communication <strong>channels</strong> that connect adjacent nodes along communication path;<ul><li>wired links</li><li>wireless links</li><li>LANs</li></ul></li><li>layer-2 packet is a <strong>frame</strong>, encapsulates datagram.</li></ul><blockquote><p>这里就是在说 data link layer 的数据包叫做 frame。</p></blockquote><h2 id="link-layer-context">Link layer: context</h2><p>Datagram transferred by different link protocols over different links, each link protocol provides different services.</p><blockquote><p>不同的 link 用不同的 protocol。</p></blockquote><h2 id="link-layer-services">Link Layer Services</h2><ul><li><strong>framing, link access</strong><ul><li>encapsulate datagram into frame, adding header, trailer.</li><li>channel access if shared medium.</li><li><strong>MAC</strong> addresses used in frame headers to identify source, dest.</li></ul></li><li><strong>reliable delivery between adjacent nodes</strong><ul><li>seldom used on low bit-error link (fiber, some twisted pair).</li></ul></li><li><strong>flow control</strong><ul><li>pacing between adjacent sending and receiving nodes.</li></ul></li><li><strong>error detection</strong><ul><li>errors caused by signal <strong>attenuation, noise</strong>.</li><li>receiver detects presence of errors: signals sender for retransmission or drops frame.</li></ul></li><li><strong>error correction</strong><ul><li>receiver identifies and <strong>corrects</strong> bit error(s) without resorting to retransmission.</li></ul></li><li><strong>half-duplex and full-duplex</strong>（半双工和全双工）<ul><li>with half duplex, nodes at both ends of link can transmit, but not at same time.</li></ul></li></ul><h2 id="where-is-the-link-layer-implemented">Where is the link layer implemented?</h2><ul><li>The <strong>link layer is implemented in every host</strong>.</li><li>It is realized through an <strong>adaptor</strong>, also known as a <strong>Network Interface Card (NIC)</strong>.<ul><li>Examples include: <strong>Ethernet cards</strong>, <strong>PCMCIA cards</strong>, and <strong>802.11 wireless cards</strong>.</li></ul></li><li>The adaptor is responsible for implementing both the <strong>link layer</strong> and the <strong>physical layer</strong>.</li><li>It connects to the host via the <strong>system buses</strong>.</li><li>The adaptor is a <strong>combination of hardware, software, and firmware</strong>.</li></ul><p>In essence, the NIC handles the lower layers of network communication and serves as the interface between the host and the physical network.</p><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/Network%20adapter.png" style="display: block; margin: 0 auto; width: 70%" alt="Network adapter"><figcaption aria-hidden="true">Network adapter</figcaption></figure><h2 id="adaptors-communicating">Adaptors Communicating</h2><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/AdaptorsCommunicating.png" style="display: block; margin: 0 auto; width: 70%" alt="Adaptors Communicating}"><figcaption aria-hidden="true">Adaptors Communicating}</figcaption></figure><h3 id="sending-side">Sending Side</h3><ul><li><strong>Encapsulates the network-layer datagram into a link-layer frame</strong>.</li><li><strong>Adds</strong>:<ul><li><strong>Error checking bits</strong> (e.g., CRC).</li><li><strong>Reliable data transfer (rdt)</strong> mechanisms (if needed).</li><li><strong>Flow control</strong> to manage data rate between sender and receiver.</li></ul></li></ul><h3 id="receiving-side">Receiving Side</h3><ul><li><strong>Checks</strong> the frame for:<ul><li><strong>Errors</strong> using error detection codes.</li><li><strong>Reliable data transfer</strong> mechanisms.</li><li><strong>Flow control</strong> compliance.</li></ul></li><li><strong>Extracts</strong> the datagram from the frame.</li></ul><h1 id="error-detection-and-correction">Error Detection and Correction</h1><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/Error-detectionAnd-correctionScenario.png" style="display: block; margin: 0 auto; width: 70%" alt="Error detection And correction Scenario"><figcaption aria-hidden="true">Error detection And correction Scenario</figcaption></figure><ul><li><strong>EDC (Error Detection and Correction bits)</strong>:<ul><li>Extra <strong>redundant bits</strong> added to data to detect and possibly correct errors during transmission.</li></ul></li><li><strong>D (Data)</strong>:<ul><li>The actual data being protected by error checking.</li><li>May include <strong>header fields</strong> along with the payload.</li></ul></li></ul><blockquote><p>也就是整个 IP datagram。</p></blockquote><ul><li><strong>Important Notes</strong>:<ul><li><strong>Error detection is not 100% reliable</strong>.<ul><li>Some errors may go undetected, though this is <strong>rare</strong>.</li></ul></li><li>A <strong>larger EDC field</strong> generally provides:<ul><li><strong>Better error detection</strong> capability.</li></ul></li></ul></li></ul><h2 id="parity-checks">Parity Checks</h2><ul><li><strong>Even Parity Scheme:</strong> the total number of <span class="math inline">\(1\)</span>s in the $ d + 1 $ bits is even.</li><li><strong>Odd Parity Scheme:</strong> the total number of <span class="math inline">\(1\)</span>s in the $ d + 1 $ bits is odd.</li></ul><blockquote><p>偶校验和奇校验。</p></blockquote><p>If an odd number of <span class="math inline">\(1\)</span>-valued bits are found with an even parity schemes, the receiver knows that at least one bit error has occurred.</p><h3 id="two-dimensional-parity">Two-dimensional Parity</h3><p>The receiver can thus not only <strong>detect</strong> the fact that a single bit error has occurred, but can use the column and row indices of the column and row with parity errors to actually identify the bit that was corrupted and <strong>correct</strong> that error!</p><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/Two-dimensional-even-parity.png" style="display: block; margin: 0 auto; width: 70%" alt="Two dimensional even parity"><figcaption aria-hidden="true">Two dimensional even parity</figcaption></figure><h2 id="cyclic-redundancy-check-crc">Cyclic Redundancy Check (CRC)</h2><p>An error-detection technique used widely in today’s computer networks is based on <strong>cyclic redundancy check (CRC) codes</strong>. CRC codes are also known as <strong>polynomial codes</strong>, since it is possible to view the bit string to be sent as a polynomial whose coefficients are the <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span> values in the bit string, with operations on the bit string interpreted as polynomial arithmetic.</p><ul><li><strong>数据表示</strong>：将要发送的 <span class="math inline">\(d\)</span> 位数据 <span class="math inline">\(D\)</span> 看作一个二进制多项式。</li><li><strong>生成多项式 <span class="math inline">\(G\)</span></strong>：发送方和接收方事先约定一个 <span class="math inline">\(r + 1\)</span> 位的生成多项式 <span class="math inline">\(G\)</span>。</li><li><strong>附加冗余位 <span class="math inline">\(R\)</span></strong>：发送方为 <span class="math inline">\(D\)</span> 选择 <span class="math inline">\(r\)</span> 位冗余位 <span class="math inline">\(R\)</span>，并将其附加到 <span class="math inline">\(D\)</span> 后面，形成 <span class="math inline">\(d + r\)</span> 位的发送数据，使得整个 <span class="math inline">\(d + r\)</span> 位数据能被 <span class="math inline">\(G\)</span> 整除（模 2 运算下）。</li></ul><h3 id="how-the-sender-computes-r">How the Sender Computes <span class="math inline">\(R\)</span>?</h3><p>简单地来讲：</p><ul><li>发送方将 <span class="math inline">\(D\)</span> 左移 <span class="math inline">\(r\)</span> 位（即在 <span class="math inline">\(D\)</span> 后面补 <span class="math inline">\(r\)</span> 个 0），得到 <span class="math inline">\(D \cdot 2^r\)</span>。</li><li>用 <span class="math inline">\(D \cdot 2^r\)</span> 除以 <span class="math inline">\(G\)</span>，得到余数 <span class="math inline">\(R\)</span>。</li><li>将 <span class="math inline">\(R\)</span> 附加到 <span class="math inline">\(D\)</span> 后面，形成最终发送的数据。</li></ul><p><strong>公式表示：</strong> <span class="math display">\[R = \operatorname{remainder} \frac{D \cdot 2^r}{G}\]</span></p><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/CRCSample.png" style="display: block; margin: 0 auto; width: 70%" alt="CRC Sample"><figcaption aria-hidden="true">CRC Sample</figcaption></figure><p>需要注意，<span class="math inline">\(1 - 0 = 1\)</span>，<span class="math inline">\(0 - 1 = 1\)</span>，<span class="math inline">\(1 - 1 =0\)</span>，<span class="math inline">\(0 - 0 = 0\)</span>，没有借位，最后的结果，比如：<span class="math inline">\(11\)</span>，但是 <span class="math inline">\(r = 3\)</span>，则在左侧高位补充 <span class="math inline">\(0\)</span>，也就是 <span class="math inline">\(R = 011\)</span>。</p><h1 id="multiple-access-links-and-protocols">Multiple Access Links and Protocols</h1><h2 id="two-types-of-links">Two Types of Links</h2><h3 id="point-to-point-links"><strong>Point-to-Point Links</strong></h3><ul><li><strong>定义</strong>：点对点链路是指仅有两个设备直接相连的通信链路。</li><li><strong>典型例子</strong>：<ul><li>拨号上网时使用的 PPP（Point-to-Point Protocol）协议。</li><li>以太网交换机与主机之间的连接。</li></ul></li><li><strong>特点</strong>：<ul><li>通信双方唯一，链路专用。</li><li>通常无需考虑信道竞争或冲突问题。</li><li>实现简单，性能稳定。</li></ul></li></ul><h3 id="broadcast-links"><strong>Broadcast Links</strong></h3><ul><li><strong>定义</strong>：广播链路是指多个设备共享同一个物理通信介质的链路，所有设备都能“听到”同一信道上的数据。</li><li><strong>典型例子</strong>：<ul><li>早期以太网（同轴电缆共享）。</li><li>HFC（Hybrid Fiber-Coaxial）上行链路。</li><li>802.11 WiFi（无线局域网）。</li></ul></li><li><strong>特点</strong>：<ul><li>多个节点共享信道，可能发生冲突。</li><li>需要多路访问协议（如CSMA/CD、ALOHA等）协调各节点的发送时机。</li><li>支持广播和组播通信。</li></ul></li></ul><h2 id="multiple-access-protocol">Multiple Access Protocol</h2><ul><li>A <strong>single shared broadcast channel</strong> is used by multiple nodes.<ul><li>If two or more nodes transmit at the same time, their signals interfere, causing a <strong>collision</strong>.</li></ul></li><li>A <strong>multiple access protocol</strong> is needed to coordinate transmissions.<ul><li>This protocol is a distributed algorithm that determines when each node can transmit.</li><li>All coordination and communication about channel sharing must occur over the same channel—there is <strong>no separate control channel</strong>.</li></ul></li></ul><blockquote><p>多个结点共用一条 channel 进行传输，这条 channel 同一时间只能供一个结点传输。应用 multiple access protocol 来协调。</p></blockquote><ul><li><strong>链路（link）</strong> 更强调<strong>连接关系</strong>，即两个节点之间的直接连接。如上文介绍的两种 <strong>links</strong>。</li><li><strong>信道（channel）</strong> 更强调<strong>传输资源</strong>，即数据传输所依赖的物理或逻辑媒介。</li><li>在点对点链路中，link 和 channel 通常是一一对应的。</li><li>在广播链路中，多个 link（设备间的连接）共享同一个 channel（信道）。</li></ul><h3 id="ideal-multiple-access-protocol">Ideal Multiple Access Protocol</h3><ul><li>The broadcast channel has a total rate of <strong><span class="math inline">\(R\)</span> bps</strong>.</li><li>If only one node transmits, it can use the full rate <strong><span class="math inline">\(R\)</span></strong>.</li><li>If <strong><span class="math inline">\(M\)</span></strong> nodes transmit simultaneously, each gets an average rate of <strong><span class="math inline">\(R/M\)</span></strong>.</li><li>The system is <strong>fully decentralized</strong>:<ul><li>No central coordinator.</li><li>No clock or slot synchronization required.</li></ul></li><li>The approach is simple and efficient for sharing the channel.</li></ul><h2 id="mac-protocols-a-taxonomy">MAC Protocols: a taxonomy</h2><h3 id="three-broad-classes-of-mac-protocols">Three Broad Classes of MAC Protocols</h3><ol type="1"><li><strong>Channel Partitioning</strong><ul><li>The channel is divided into smaller pieces (such as time slots, frequency bands, or codes).</li><li>Each node is allocated a piece for exclusive use.</li></ul></li><li><strong>Random Access</strong><ul><li>The channel is not divided; all nodes can transmit at any time.</li><li>Collisions may occur, but protocols are designed to <strong>detect and recover</strong> from collisions.</li></ul></li><li><strong>Taking Turns</strong><ul><li>Nodes take turns using the channel.</li><li>Nodes with more data to send can take longer turns.</li></ul></li></ol><h2 id="channel-partitioning-protocols">Channel Partitioning Protocols</h2><p><strong>TDMA</strong>: Time Division Multiple Access <strong>FDMA</strong>: Frequency Division Multiple Access <strong>CDMA</strong>: Code Division Multiple Access</p><h3 id="tdma">TDMA</h3><ul><li><strong>Mechanism:</strong><ul><li>Divides time into frames, and each frame into <span class="math inline">\(N\)</span> time slots (for <span class="math inline">\(N\)</span> nodes).</li><li>Each node is assigned a specific time slot in each frame.</li><li>When a node has data to send, it transmits only during its assigned slot.</li></ul></li><li><strong>Example:</strong><ul><li>In a four-node TDMA system, each node gets one slot per frame, and the slots repeat in a fixed order.</li></ul></li><li><strong>Advantages:</strong><ul><li>No collisions; perfectly fair (each node gets <span class="math inline">\(R/N\)</span> bps).</li></ul></li><li><strong>Drawbacks:</strong><ul><li>Each node is limited to <span class="math inline">\(R/N\)</span> bps even if others are idle.</li><li>Nodes must wait for their turn, even if they are the only one with data to send.</li></ul></li></ul><blockquote><p>只能用自己的。</p></blockquote><h3 id="fdma">FDMA</h3><ul><li><strong>Mechanism:</strong><ul><li>Divides the total channel bandwidth (<span class="math inline">\(R\)</span> bps) into <span class="math inline">\(N\)</span> frequency bands, each with bandwidth <span class="math inline">\(R/N\)</span>.</li><li>Each node is assigned a <strong>unique frequency band</strong> for exclusive use.</li></ul></li><li><strong>Example:</strong><ul><li>In a four-node FDM system, each node gets a <span class="math inline">\(4\)</span> KHz band out of a total <span class="math inline">\(16\)</span> KHz channel.</li></ul></li><li><strong>Advantages:</strong><ul><li>No collisions; fair bandwidth allocation.</li></ul></li><li><strong>Drawbacks:</strong><ul><li>Each node is limited to R/N bps, even if others are idle (same as TDMA).</li></ul></li></ul><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/TDA-and-FDA-example.png" style="display: block; margin: 0 auto; width: 70%" alt="TDA and FDA example"><figcaption aria-hidden="true">TDA and FDA example</figcaption></figure><h3 id="cdma">CDMA</h3><ul><li><strong>Mechanism:</strong><ul><li>Each node is assigned a unique code.</li><li>Nodes encode their data using their code and transmit simultaneously over the same channel.</li><li>Receivers use the sender’s code to decode the intended message, even in the presence of other transmissions.</li></ul></li><li><strong>Features:</strong><ul><li>Allows multiple nodes to transmit at the same time without collisions, as long as codes are chosen carefully.</li><li>Widely used in wireless and cellular networks due to its anti-jamming properties.</li></ul></li><li><strong>Note:</strong><ul><li>CDMA codes serve a similar role as time slots in TDMA and frequency bands in FDMA, enabling multiple access to the channel.</li></ul></li></ul><blockquote><p>每个节点分配一个唯一的编码，所有节点可同时发送，接收端用对应的码提取目标信号。详细过程参考第六章。</p></blockquote><h2 id="random-access-protocols">Random Access Protocols</h2><ul><li>When a node has a packet to send, it transmits at the full channel data rate <span class="math inline">\(\mathbf{R}\)</span>.</li><li>There is <strong>no prior coordination</strong> among nodes before transmission.（也就是说这个结点传输前不会考虑其它因素）</li><li>If two or more nodes transmit at the same time, a <strong>collision</strong> occurs.</li><li>A <strong>random access MAC protocol</strong> defines:（干了两件事）<ul><li><strong>How to detect collisions</strong>.</li><li><strong>How to recover from collisions (e.g., by delaying and retransmitting)</strong>.（后传和重传）</li><li><strong>Examples:</strong><ul><li>Slotted ALOHA<br></li><li>ALOHA<br></li><li>CSMA, CSMA/CD, CSMA/CA</li></ul></li></ul></li></ul><h3 id="slotted-aloha">Slotted ALOHA</h3><p><strong>Assumptions:</strong> - All frames are the same size. - Time is divided into equal-sized slots (each slot = time to transmit one frame). - Nodes can only begin transmission at the start of a slot. - All nodes are synchronized. - If two or more nodes transmit in the same slot, a collision occurs and is detected by all.</p><p><strong>Operation:</strong> - When a node has a new frame, it transmits in the next available slot. - If there is no collision, the node can send a new frame in the next slot. - If a collision occurs, the node retransmits the frame in each subsequent slot with probability <span class="math inline">\(p\)</span> until successful.</p><p><strong>Pros of Slotted ALOHA:</strong> - A single active node can continuously transmit at the full channel rate. - Highly decentralized; only slot synchronization among nodes is needed. - Simple to implement.</p><p><strong>Cons of Slotted ALOHA:</strong> - Collisions can occur, wasting slots. - Idle slots may occur, reducing efficiency. - <strong>Nodes may detect collisions before a full packet is transmitted</strong>. - <strong>Requires clock synchronization among all nodes</strong>.</p><blockquote><p>前提假设不太现实，要求所有的 frame 大小相同，这样才能确保将时间分为等长的时隙有用。</p></blockquote><p><strong>同步(synchronize)</strong> 指的是：</p><ul><li>所有网络节点<strong>共享一个统一的时钟参考</strong></li><li>每个节点能够<strong>准确识别时隙的开始和结束时刻</strong></li><li>通常通过<strong>集中式时钟信号</strong>或<strong>同步协议</strong>实现</li></ul><p><strong>Slotted Aloha efficiency</strong></p><ul><li><strong>Efficiency</strong> is defined as the long-run fraction of slots that contain a successful transmission (i.e., exactly one node transmits).</li><li>Suppose there are <span class="math inline">\(N\)</span> nodes, each always has frames to send, and each transmits in a slot with probability <span class="math inline">\(p\)</span>.</li><li>The probability that a given node has a successful transmission in a slot:<br><span class="math display">\[p(1-p)^{N-1}\]</span></li><li>The probability that any node has a successful transmission in a slot:<br><span class="math display">\[Np(1-p)^{N-1}\]</span></li><li><strong>Maximum efficiency</strong> is achieved by choosing <span class="math inline">\(p^*\)</span> that maximizes <span class="math inline">\(Np(1-p)^{N-1}\)</span>.</li><li>As <span class="math inline">\(N\)</span> becomes very large, the maximum efficiency approaches:<br><span class="math display">\[\boxed{1/e \approx 0.37}\]</span></li><li><strong>Interpretation:</strong><br>At best, the channel is used for successful transmissions only 37% of the time.</li></ul><blockquote><p>当前时隙有结点传输的概率。</p></blockquote><h1 id="tdma与slotted-aloha对比分析">TDMA与Slotted ALOHA对比分析</h1><p><strong>TDMA和Slotted ALOHA并不矛盾，它们是两种不同设计理念的多址接入协议</strong>，尽管都使用了时间分片的概念。</p><h2 id="关键区别">关键区别</h2><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>特性</th><th>TDMA</th><th>Slotted ALOHA</th></tr></thead><tbody><tr class="odd"><td><strong>时隙分配</strong></td><td><strong>预先固定分配</strong>给特定节点</td><td><strong>动态竞争</strong>，任何节点可使用任何时隙</td></tr><tr class="even"><td><strong>传输决策</strong></td><td>只能在<strong>自己的专属时隙</strong>中传输</td><td>可以在<strong>任何时隙</strong>开始传输</td></tr><tr class="odd"><td><strong>冲突可能性</strong></td><td><strong>无冲突</strong>（每个时隙专属一个节点）</td><td><strong>有冲突</strong>（多节点可能同时选择一个时隙）</td></tr><tr class="even"><td><strong>资源使用</strong></td><td>节点不传输时其时隙<strong>浪费</strong></td><td>任何节点都可以利用空闲时隙</td></tr><tr class="odd"><td><strong>控制方式</strong></td><td><strong>集中式</strong>或预先协调</td><td><strong>分散式</strong>（各节点独立决策）</td></tr><tr class="even"><td><strong>最大效率</strong></td><td>理论上100%（无冲突）</td><td>理论上约37%（1/e）</td></tr></tbody></table></div><h2 id="本质区别">本质区别</h2><ul><li><strong>TDMA</strong>：<strong>预分配固定时隙</strong>的“预约”系统<ul><li>类似于餐厅固定座位：每人只能坐自己的座位</li><li>优点：无冲突，确定性高</li><li>缺点：资源可能浪费，缺乏灵活性</li></ul></li><li><strong>Slotted ALOHA</strong>：<strong>随机竞争时隙</strong>的“抢座”系统<ul><li>类似于餐厅先到先得：谁想坐就尝试坐，有冲突就重试</li><li>优点：简单实现，适应突发流量</li><li>缺点：存在冲突，效率有限</li></ul></li></ul><p>这两种协议代表了多址接入的两种不同设计思路：<strong>静态分配</strong>与<strong>动态竞争</strong>，各有优缺点，适用于不同应用场景。</p><h3 id="pure-unslotted-aloha">Pure (unslotted) ALOHA</h3><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/pure-ALOHA-sample.png" style="display: block; margin: 0 auto; width: 70%" alt="pure ALOHA sample"><figcaption aria-hidden="true">pure ALOHA sample</figcaption></figure><ul><li>Simpler than slotted ALOHA; <strong>no synchronization</strong> required.</li><li>When a frame arrives, the node <strong>transmits immediately</strong>.</li><li><strong>Higher collision probability</strong>:<ul><li>A frame sent at time <span class="math inline">\(t_0\)</span> will collide with any other frame sent in the interval <span class="math inline">\([t_0-1, t_0+1]\)</span>.</li></ul></li></ul><p><strong>Pure (Unslotted) ALOHA Efficiency:</strong></p><ul><li>Probability of success for a given node:<ul><li><span class="math inline">\(P(\text{success}) = P(\text{node transmits}) \times P(\text{no other node transmits in } [t_0-1, t_0]) \times P(\text{no other node transmits in } [t_0, t_0+1])\)</span></li><li><span class="math inline">\(= p \cdot (1-p)^{N-1} \cdot (1-p)^{N-1}\)</span></li><li><span class="math inline">\(= p \cdot (1-p)^{2(N-1)}\)</span></li></ul></li><li><strong>Maximum efficiency</strong> (choosing optimal <span class="math inline">\(p\)</span> and letting <span class="math inline">\(N \to \infty\)</span>):<ul><li><span class="math inline">\(\boxed{1/(2e) \approx 0.18}\)</span></li></ul></li><li><strong>Interpretation:</strong><br>At best, the channel is used for successful transmissions only 18% of the time in pure ALOHA.</li></ul><blockquote><p><span class="math inline">\(t_0, \, t_0 - 1, \, t_0 + 1\)</span> 三个时隙。</p></blockquote><h3 id="carrier-sense-multiple-access-csma">Carrier Sense Multiple Access (CSMA)</h3><p>发送前先侦听，发送时检测碰撞，以太网核心技术</p><p><strong>Carrier Sensing</strong>: a node listens to the channel before transmitting. <strong>If a frame from another node is currently being transmitted into the channel</strong>, a node then waits until it detects no transmissions for a short amount of time and then begins transmission.</p><p>In networks using CSMA (like <strong>traditional Ethernet or wireless</strong>), all nodes communicate over a single shared physical channel. Many network interfaces operating under CSMA protocols are designed for half-duplex communication, meaning they can either transmit OR receive at any given moment, but not both simultaneously. This is why a node can not transmit while receiving.</p><blockquote><p>半双工机制。</p></blockquote><h3 id="csma-with-collision-detection-csmacd">CSMA with collision detection (CSMA/CD)</h3><p><strong>Collision Detection</strong>: a transmitting node listens to the channel while it is transmitting. If it detects that another node is transmitting an interfering frame, it stops transmitting and waits <strong>a random amount</strong> of time before repeating the sense-and-transmit-when-idle cycle.</p><blockquote><p>自己正在传的时候检测到有其他结点开始传了，停止自己的传输，随机等待一段时间后重试。</p></blockquote><h2 id="taking-turns-protocols">Taking-Turns Protocols</h2><h3 id="polling-protocol">Polling Protocol</h3><p><strong>Polling Protocol（轮询协议）</strong>是一种<strong>轮流访问</strong>型的多路访问协议，常用于多个节点共享同一信道的场景。其核心思想是：<br>- 网络中指定一个节点为<strong>主节点（master node）</strong>。 - 主节点按照固定顺序依次<strong>轮询</strong>每个从节点，询问它们是否有数据要发送。 - 只有被轮询到的节点才被允许发送数据。</p><p>这个协议有着如下缺陷： 1. <strong>轮询延迟</strong>：每个节点都要等主节点轮询到自己才能发送数据，可能会有等待延迟，尤其是节点数量多时。 2. <strong>主节点单点故障</strong>：如果主节点出现故障，整个信道就无法正常工作，所有通信都会中断。</p><p><strong><em>Bluetooth protocol</em></strong></p><h3 id="token-passing-protocol">Token-Passing Protocol</h3><p>A small, special-purpose frame known as a <strong>token</strong> is exchanged among the nodes in some fixed order.</p><blockquote><p>When a node receives a token, it holds onto the token only if it has some frames to transmit; otherwise, it immediately forwards the token to the next node. If a node does have frames to transmit when it receives the token, it sends up to a maximum number of frames and then forwards the token to the next node.</p></blockquote><p>But it has its problems as well. For example, the failure of one node can crash the entire channel. Or if a node accidentally neglects to release the token, then some recovery procedure must be invoked to get the token back in circulation.</p><p>将一个特制的 <strong>frame</strong> 视作一个 <strong>token</strong>，这个 token 会在结点中以一个固定的顺序传输，收到 token 的结点可以选择发送自己的 frames 或者立即传给下一个结点。缺陷：时延和崩坏。</p><p><strong><em>fiber distributed data interface (FDDI) protocol</em></strong></p><h1 id="link-layer-addressing-and-arp">Link-Layer Addressing and ARP</h1><h2 id="addressing-in-computer-networks">Addressing in Computer Networks</h2><p>先回顾一下之前学过的 address。</p><h3 id="ip-address-32-bit">IP Address (32-bit)</h3><ul><li><strong>Layer</strong>: Network layer address</li><li><strong>Primary function</strong>: Used to route datagrams to their destination IP subnet</li><li><strong>Scope</strong>: Global addressing for internet-wide routing</li></ul><h3 id="mac-address-48-bit">MAC Address (48-bit)</h3><ul><li><strong>Layer</strong>: Data link layer (physical addressing)</li><li><strong>Primary function</strong>: Used to transfer frames between directly connected interfaces on the same physical network</li><li><strong>Implementation</strong>: Permanently burned into NIC ROM hardware, though sometimes software-configurable</li><li><strong>Scope</strong>: Local addressing limited to a single network segment</li></ul><p>The fundamental distinction is that IP addresses enable routing across multiple networks, while MAC addresses handle the physical delivery between devices on the same network segment.</p><ul><li><strong>IP 地址</strong>：用于在不同网络之间进行路由，确保数据能够跨越多个网络到达最终目标。</li><li><strong>MAC 地址</strong>：用于在同一个网络段（如同一个局域网）内实现设备之间的物理交付。</li><li><strong>IP 地址</strong>负<strong>找路</strong>，确定数据应该到哪个网络。</li><li><strong>MAC 地址</strong>负责<strong>最后一公里</strong>，在本地网络中找到具体的设备。</li><li>路由器转发数据时，每经过一跳，都会用新的 MAC 地址封装数据帧，但 IP 地址保持不变。</li></ul><p>假设主机 A 要给主机 B 发送数据：</p><ol type="1"><li><strong>跨网传输</strong>：数据包通过多个路由器，依靠 IP 地址进行路由选择。</li><li><strong>到达目标网络</strong>：最后一跳，数据包到达 B 所在的局域网。</li><li><strong>本地交付</strong>：A 通过 ARP 协议获取 B 的 MAC 地址，将数据帧封装后，通过以太网物理传输到 B。</li></ol><h2 id="mac-addresses-and-arp">MAC Addresses and ARP</h2><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/MACAddress.png" style="display: block; margin: 0 auto; width: 70%" alt="MAC Address"><figcaption aria-hidden="true">MAC Address</figcaption></figure><p>Broadcast address = <code>FF-FF-FF-FF-FF-FF</code></p><h3 id="mac-address-administration">MAC Address Administration</h3><ul><li><p><strong>分配权威（Allocation Authority）</strong><br>MAC 地址空间由 <strong>IEEE（电气和电子工程师协会）</strong> 统一管理和分配，确保全球唯一性。</p></li><li><p><strong>分配流程（Assignment Process）</strong><br>各网络设备制造商需要向 IEEE 购买一批 MAC 地址块。这样，每个厂商生产的设备都能分配到唯一的 MAC 地址，避免地址冲突。</p></li><li><p><strong>结构（Structure）</strong><br>MAC 地址总长 48 位，<strong>前 24 位</strong>通常用来标识制造商（称为 OUI，Organizationally Unique Identifier，组织唯一标识符），后 24 位由厂商自行分配给各自的设备。</p></li></ul><h3 id="conceptual-comparison">Conceptual Comparison</h3><ul><li><strong>MAC Address</strong>: Similar to a Social Security Number<ul><li>Permanent identifier tied to hardware</li><li>Remains with the device regardless of location</li></ul></li><li><strong>IP Address</strong>: Similar to a postal address<ul><li>Indicates location in the network topology</li><li>Changes when moving between networks</li></ul></li></ul><h3 id="address-structure-implications">Address Structure Implications</h3><ul><li><strong>MAC Address (Flat)</strong>:<ul><li>Provides portability</li><li>LAN card maintains its address when moved between networks</li><li>No inherent network location information</li></ul></li><li><strong>IP Address (Hierarchical)</strong>:<ul><li>Not portable across networks</li><li>Contains network prefix that identifies subnet</li><li>Must change when moving to a different subnet</li><li>Enables efficient routing across internet</li></ul></li></ul><p>This fundamental difference in addressing philosophy reflects the different purposes of each address type: MAC for unique hardware identification, IP for routable network location.</p><h2 id="address-resolution-protocol-arp">Address Resolution Protocol (ARP)</h2><p>The Address Resolution Protocol (ARP) is used to discover the MAC address associated with a known IP address on the same local network:</p><ol type="1"><li><strong>Check Local ARP Table First</strong><ul><li>Every IP-enabled device maintains an ARP table</li><li>The table contains mappings of IP addresses to MAC addresses</li><li>Each entry format: <code>&lt;IP address; MAC address; TTL&gt;</code></li><li>TTL (Time To Live): Typically 20 minutes before entry expires</li></ul></li><li><strong>If MAC Address Not in Table:</strong><ul><li>Device broadcasts an ARP request to all devices on LAN</li><li>Uses broadcast MAC address: FF-FF-FF-FF-FF-FF</li><li>The request asks: “Who has IP address B? Send your MAC address”</li></ul></li><li><strong>Resolution Process:</strong><ul><li>Only the device with IP address B responds</li><li>Device B sends its MAC address directly to requester</li><li>Requester adds the IP-to-MAC mapping to its ARP table</li><li>Communication can now proceed using the discovered MAC address</li></ul></li><li><strong>When Entry Expires:</strong><ul><li>After TTL expires, the mapping is removed from ARP table</li><li>A new ARP request must be sent if communication is needed again</li></ul></li></ol><p>ARP is essential because link-layer delivery requires MAC addresses, while applications and higher protocols use IP addresses.</p><h2 id="arp-protocol-same-lan-network">ARP Protocol: Same LAN (Network)</h2><p>When host A wants to send a datagram to host B on the same local network but doesn’t have B’s MAC address:</p><h3 id="arp-request-process">ARP Request Process</h3><ul><li>Host A broadcasts an ARP query packet containing B’s IP address</li><li>Destination MAC address = <code>FF-FF-FF-FF-FF-FF</code> (broadcast address)</li><li>All machines on the LAN receive the ARP query</li><li>Only host B (with the matching IP address) processes and responds</li></ul><h3 id="arp-response">ARP Response</h3><ul><li>Host B replies to A with its (B’s) MAC address</li><li>Frame is sent directly to A’s MAC address (unicast)</li><li>A adds the IP-to-MAC mapping to its ARP table</li></ul><h3 id="caching-mechanism">Caching Mechanism</h3><ul><li>A caches (saves) the IP-to-MAC address pair in its ARP table</li><li>Mapping remains until the information becomes old (times out)</li><li>This is “soft state”: information expires unless refreshed through use</li></ul><h3 id="key-characteristics">Key Characteristics</h3><ul><li><strong>Self-configuring</strong>: ARP is “plug-and-play”</li><li><strong>Distributed</strong>: Nodes create their ARP tables without intervention from network administrators</li><li><strong>Automatic</strong>: Mappings are created and maintained dynamically as needed</li></ul><blockquote><p>自己也会创建置换表</p></blockquote><h2 id="addressing-routing-to-another-lan">Addressing: routing to another LAN</h2><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/619.png" style="display: block; margin: 0 auto; width: 100%" alt="routing to another LAN"><figcaption aria-hidden="true">routing to another LAN</figcaption></figure><h2 id="routing-between-different-lans-link-layer-process">Routing Between Different LANs: Link-Layer Process</h2><p>When data travels between hosts on different networks, the router plays a critical intermediary role:</p><h3 id="initial-transmission-source-network">Initial Transmission (Source Network)</h3><ol type="1"><li>Host A creates an IP datagram with:<ul><li>Source IP address: Host A’s address</li><li>Destination IP address: Host B’s address (on different LAN)</li></ul></li><li>Host A determines B is on another network, so packet must go through router R:<ul><li>A uses ARP to resolve router interface IP (111.111.111.110) to R’s MAC address</li><li>A creates an Ethernet frame with:<ul><li>Destination: R’s MAC address</li><li>Source: A’s MAC address</li><li>Payload: The A-to-B IP datagram</li></ul></li></ul></li><li>A’s network interface card transmits this frame onto the LAN</li></ol><blockquote><p>从此可以看出，LAN 内部是通过以太网传输数据的，用的是 MAC address。</p></blockquote><h3 id="router-processing">Router Processing</h3><ol start="4" type="1"><li><p>Router R’s interface receives the frame (recognizes its MAC address)</p></li><li><p>R extracts the IP datagram from the frame, examines the IP header:</p><ul><li>Sees destination IP is for host B on another network</li><li>Consults routing table to determine next hop</li></ul></li><li><p>R prepares to forward to the destination network:</p><ul><li>Uses ARP to resolve B’s IP address to B’s MAC address</li><li>Creates a new Ethernet frame with:<ul><li>Destination: B’s MAC address</li><li>Source: R’s MAC address (interface on B’s network)</li><li>Payload: The original A-to-B IP datagram (unchanged)</li></ul></li></ul></li></ol><blockquote><p>R 在不同网络段代表不同的路由器接口。</p></blockquote><h3 id="final-delivery-destination-network">Final Delivery (Destination Network)</h3><ol start="7" type="1"><li><p>Router’s interface on B’s network transmits the new frame</p></li><li><p>Host B receives the frame, extracts and processes the IP datagram</p></li></ol><p>Note: The IP datagram remains unchanged throughout this process, while the frame addressing changes at each network segment.</p><h1 id="ethernet">Ethernet</h1><h2 id="the-dominant-wired-lan-technology">The Dominant Wired LAN Technology</h2><ul><li><strong>Cost-effective</strong>: Extremely affordable - approximately $20 for a Network Interface Card</li><li><strong>Pioneer technology</strong>: First widely used LAN technology, establishing the foundation for modern networks</li><li><strong>Simplicity and economy</strong>: Significantly simpler and more economical than token LANs and ATM alternatives</li><li><strong>Scalable performance</strong>: Successfully kept pace with speed requirements over decades:<ul><li>Started at 10 Mbps</li><li>Evolved through 100 Mbps and 1 Gbps</li><li>Now supports up to 10 Gbps and beyond</li></ul></li></ul><p>Ethernet’s combination of low cost, simplicity, and adaptability to increasing performance demands has secured its position as the predominant wired networking technology in local area networks worldwide.</p><h2 id="ethernet-physical-topologies">Ethernet Physical Topologies</h2><h3 id="historical-evolution">Historical Evolution</h3><ul><li><strong>Bus topology</strong>: Popular through mid-1990s<ul><li>All nodes connected to a common shared cable</li><li><strong>Single collision domain</strong>: All nodes could interfere with each other’s transmissions</li><li>When one node transmitted, all others had to wait</li><li>Limited scalability due to increasing collision probability with more nodes</li></ul></li></ul><blockquote><p>前面提到过</p></blockquote><h3 id="modern-configuration">Modern Configuration</h3><ul><li><strong>Star topology</strong>: Dominant configuration today<ul><li><strong>Central active switch</strong>: Intelligent device at center of network</li><li>Point-to-point links between switch and end devices</li><li><strong>Separate collision domains</strong>: Each link operates as an independent Ethernet segment</li><li>Nodes connected to different switch ports cannot directly collide with each other</li><li>Dramatically improved performance and reliability compared to bus topology</li></ul></li></ul><p>The shift from bus to star topology represents a fundamental advance in Ethernet technology, effectively eliminating the collision problems that limited earlier implementations.</p><h2 id="ethernet-frame-structure">Ethernet frame structure</h2><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/620.png" style="display: block; margin: 0 auto; width: 100%" alt="Ethernet frame structure"><figcaption aria-hidden="true">Ethernet frame structure</figcaption></figure><ul><li><strong>Preamble</strong>:<ul><li>7 bytes with pattern 10101010 followed by one byte with pattern 10101011</li><li>Used to synchronize receiver and sender clock rates</li><li>Allows receivers to “lock onto” the sender’s transmission timing</li></ul></li><li><strong>Addresses</strong>: 6 bytes each<ul><li>Destination MAC address (first)</li><li>Source MAC address (second)</li><li>Processing logic:<ul><li>If adapter receives frame with matching destination address or broadcast address (FF-FF-FF-FF-FF-FF), it passes data to network layer</li><li>Otherwise, adapter <strong>discards the frame</strong></li><li>Broadcast frames (e.g., ARP packets) are processed by all recipients</li></ul></li></ul></li><li><strong>Type</strong>: 2 bytes<ul><li>Indicates the higher layer protocol encapsulated in the frame payload</li><li>Common values:<ul><li>0x0800: IPv4</li><li>0x0806: ARP</li><li>0x86DD: IPv6</li><li>Other protocols: Novell IPX, AppleTalk, etc.</li></ul></li></ul></li><li><strong>CRC</strong>: 4 bytes (32 bits)<ul><li>Cyclic Redundancy Check for error detection</li><li>Checked at receiver</li><li>If error is detected, frame is <strong>immediately dropped</strong></li><li>No error correction or retransmission at Ethernet level</li></ul></li><li><strong>Preamble（前导码）</strong>是以太网帧结构中的一个字段。</li><li>由<strong>7 个字节的 10101010 模式</strong>，后跟<strong>1 个字节的 10101011</strong> 组成。</li><li><strong>时钟同步</strong>：用于同步接收端和发送端的时钟速率。</li><li><strong>锁定信号</strong>：让接收方能够<strong>锁定</strong>到发送方的传输时序，确保后续数据能被准确采样和解析。</li></ul><h2 id="ethernet-key-characteristics">Ethernet: Key Characteristics</h2><h3 id="connectionless-protocol">Connectionless Protocol</h3><ul><li><strong>No handshaking</strong> between transmitting and receiving Network Interface Cards (NICs)</li><li>Each frame is sent independently without establishing a connection first</li><li>Sender simply transmits frames when the medium is available</li><li>No session establishment or termination phases</li></ul><h3 id="unreliable-service">Unreliable Service</h3><ul><li><strong>No acknowledgments (ACKs)</strong> or negative acknowledgments (NACKs) sent by receiving NICs</li><li>Sending NIC has no built-in way to know if frames were successfully delivered</li><li>Corrupted frames are simply discarded by the receiver (detected via CRC)</li><li>No automatic retransmission mechanism at the Ethernet level</li></ul><h3 id="implications-for-data-delivery">Implications for Data Delivery</h3><ul><li>Stream of datagrams passed to the network layer may contain <strong>gaps</strong> (missing datagrams)</li><li>If the application uses TCP (Transport layer):<ul><li>Gaps will be detected and filled through TCP’s reliable delivery mechanisms</li><li>End users won’t see missing data</li></ul></li><li>If using UDP or other unreliable protocols:<ul><li>Application will see the gaps and must handle them if needed</li><li>Responsibility for reliability shifts to the application layer</li></ul></li></ul><h3 id="medium-access-control">Medium Access Control</h3><ul><li>Ethernet’s MAC protocol: <strong>unslotted CSMA/CD</strong> (Carrier Sense Multiple Access with Collision Detection)</li><li>Provides a way to share the communication medium among multiple devices</li><li>Modern switched Ethernet largely eliminates collisions, but the protocol foundation remains</li></ul><h2 id="csmacd-algorithm-in-ethernet">CSMA/CD Algorithm in Ethernet</h2><p>Ethernet’s original medium access control protocol uses CSMA/CD (Carrier Sense Multiple Access with Collision Detection) to handle shared medium access:</p><h3 id="step-by-step-process">Step-by-Step Process</h3><ol type="1"><li><strong>Frame Creation</strong><ul><li>NIC receives datagram from network layer</li><li>Creates an Ethernet frame with appropriate headers</li></ul></li><li><strong>Channel Sensing</strong><ul><li>If NIC senses channel is <strong>idle</strong>: begins frame transmission immediately</li><li>If NIC senses channel is <strong>busy</strong>: waits until channel becomes idle, then transmits</li></ul></li><li><strong>Successful Transmission</strong><ul><li>If NIC transmits the entire frame without detecting another transmission</li><li>Transmission is complete and successful</li></ul></li><li><strong>Collision Handling</strong><ul><li>If NIC detects another transmission while transmitting</li><li>Immediately aborts transmission</li><li><strong>Sends a brief jam signal to ensure all stations recognize the collision</strong></li></ul></li><li><strong>Exponential Backoff</strong><ul><li>After aborting, NIC enters exponential backoff procedure:</li><li>After the mᵗʰ collision, NIC chooses K randomly from {0,1,2,…,2ᵐ-1}</li><li>NIC waits <strong>K·512 bit times</strong> before attempting retransmission</li><li>Returns to Step 2 to attempt transmission again</li></ul></li></ol><p>The exponential backoff mechanism ensures that after repeated collisions, stations spread their retransmission attempts over increasingly longer intervals, reducing the probability of repeated collisions.</p><h2 id="ethernets-csmacd-technical-details">Ethernet’s CSMA/CD: Technical Details</h2><h3 id="collision-handling-components">Collision Handling Components</h3><ul><li><strong>Jam Signal</strong>:<ul><li>48-bit signal transmitted after detecting a collision</li><li>Purpose: Ensures all transmitting stations are aware of the collision</li><li>Small, fixed size makes collision detection efficient</li><li>Contains a deliberate pattern that cannot be mistaken for valid data</li></ul></li><li><strong>Bit Time</strong>:<ul><li>The time required to transmit one bit on the network</li><li><strong>For <span class="math inline">\(10\)</span> Mbps Ethernet: <span class="math inline">\(0.1\)</span> microseconds per bit</strong></li><li>Used as the basic time unit for backoff calculations</li><li>For <strong><span class="math inline">\(K = 1023\)</span> (maximum backoff value)</strong>, wait time is approximately <span class="math inline">\(50\)</span> milliseconds</li></ul></li></ul><h3 id="exponential-backoff-algorithm">Exponential Backoff Algorithm</h3><ul><li><strong>Goal</strong>: Adaptively adjust retransmission timing based on estimated network load<ul><li>Under heavy load conditions, stations wait longer before retrying</li><li>Helps prevent collision cascades when multiple stations are competing for access</li></ul></li><li><strong>Progressive Backoff Process</strong>:<ul><li>After first collision: Choose K randomly from <span class="math inline">\(\{0,1\}\)</span><ul><li>Wait time = <span class="math inline">\(K × 512\)</span> bit transmission times</li></ul></li><li>After second collision: Choose K randomly from <span class="math inline">\(\{0,1,2,3\}\)</span></li><li>After third collision: Choose K randomly from <span class="math inline">\(\{0,1,2,3,4,5,6,7\}\)</span></li><li>Pattern continues: After nth collision, range is <span class="math inline">\(\{0,1,2,...,2^n-1\}\)</span></li><li>After tenth collision: Choose K randomly from <span class="math inline">\(\{0,1,2,...,1023\}\)</span></li><li><strong>Maximum range is capped at <span class="math inline">\(\{0,1,2,...,1023\}\)</span> even after more collisions</strong></li></ul></li></ul><p>This adaptive algorithm ensures efficient channel utilization by dynamically adjusting to network congestion levels, minimizing repeated collisions while maintaining reasonable access times.</p><h2 id="csmacd-efficiency">CSMA/CD efficiency</h2><ul><li><span class="math inline">\(t_{prop}\)</span>: max prop delay between <span class="math inline">\(2\)</span> nodes in LAN;</li><li><span class="math inline">\(t_{trans}\)</span>: time to transmit max-size frame.</li></ul><p><span class="math display">\[\text{efficiency} = \frac{1}{1 + \frac{5 t_{prop}}{t_{trans}}}\]</span></p><h2 id="ethernet-standards-link-physical-layers">Ethernet Standards: Link &amp; Physical Layers</h2><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/621.png" style="display: block; margin: 0 auto; width: 100%" alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure><ul><li><strong>Common Foundation</strong>:<ul><li>All Ethernet variants share the same <strong>MAC protocol</strong> principles</li><li><strong>Frame format</strong> remains consistent across implementations</li><li>Upper layers interact with Ethernet through the same interface regardless of physical medium</li></ul></li><li><strong>Speed Evolution</strong>:<ul><li><strong>2 Mbps</strong>: Early experimental implementations</li><li><strong>10 Mbps</strong>: Original Ethernet standard (10BASE-T)</li><li><strong>100 Mbps</strong>: Fast Ethernet (100BASE-TX, 100BASE-FX)</li><li><strong>1 Gbps</strong>: Gigabit Ethernet (1000BASE-T, 1000BASE-SX/LX)</li><li><strong>10 Gbps</strong>: 10 Gigabit Ethernet (10GBASE-T, 10GBASE-SR/LR)</li><li><strong>Higher speeds</strong>: 40 Gbps, 100 Gbps, 400 Gbps technologies now available</li></ul></li><li><strong>Physical Media Diversity</strong>:<ul><li><strong>Copper cable</strong>:<ul><li>Twisted pair (Cat5e, Cat6, Cat6a, Cat7)</li><li>Coaxial cable (older implementations)</li></ul></li><li><strong>Optical fiber</strong>:<ul><li>Multimode fiber (shorter distances)</li><li>Single-mode fiber (longer distances)</li><li>Various wavelengths and transmission techniques</li></ul></li></ul></li></ul><p>This standardized approach allows equipment from different manufacturers to interoperate while enabling continuous performance improvements through new physical layer technologies.</p><h1 id="link-layer-switches">Link-Layer Switches</h1><h2 id="hubs">Hubs</h2><p>physical-layer (dumb) repeaters: - bits coming in one link go out all other links at same rate - all nodes connected to hub can collide with one another - no frame buffering - no CSMA/CD at hub: host NICs detect collisions</p><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/hub.png" style="display: block; margin: 0 auto; width: 70%" alt="hub"><figcaption aria-hidden="true">hub</figcaption></figure><h2 id="switch">Switch</h2><ul><li><strong>Link-layer intelligence</strong>:<ul><li>Smarter than hubs, taking an active role in network traffic management</li><li>Process frames at the data link layer (Layer 2) rather than merely repeating signals</li><li>Make forwarding decisions based on MAC addresses</li></ul></li><li><strong>Store-and-forward operation</strong>:<ul><li>Receive complete frames before forwarding</li><li>Buffer frames in memory, allowing for collision domain isolation</li><li>Check frames for errors (using CRC) before forwarding, improving network reliability</li></ul></li><li><strong>Selective forwarding</strong>:<ul><li>Examine incoming frame’s destination MAC address</li><li>Forward frame only to the specific port where destination device is connected</li><li>Send to multiple ports only when necessary (broadcasts, unknown destinations)</li><li>When forwarding frames onto a segment, uses CSMA/CD to access the medium</li></ul></li><li><strong>Transparent operation</strong>:<ul><li>Hosts are completely unaware of switches’ presence in the network</li><li>End devices communicate as if directly connected</li><li>No modification of frame content during transit through switch</li></ul></li><li><strong>Plug-and-play functionality</strong>:<ul><li>Self-learning capability builds forwarding tables automatically</li><li>Observes source MAC addresses of incoming frames to learn device locations</li><li>Dynamically updates tables when devices move to different ports</li><li>No manual configuration required for basic operation</li></ul></li></ul><p>These capabilities allow switches to significantly improve network performance by creating separate collision domains for each port while maintaining the same Ethernet protocol standards.</p><h3 id="switch-advanced-link-layer-functionality">Switch: Advanced Link-Layer Functionality</h3><ul><li><strong>Simultaneous transmissions</strong>:<ul><li>Allows multiple pairs of nodes to transmit concurrently</li><li>Different ports can carry independent data streams at the same time</li><li>Dramatically increases total network throughput compared to hubs</li></ul></li><li><strong>Dedicated connections</strong>:<ul><li>Each host has a dedicated, direct connection to the switch</li><li>Full bandwidth of the link is available to each host-switch connection</li><li>No competition for bandwidth between devices on different ports</li></ul></li><li><strong>Frame buffering</strong>:<ul><li>Switches contain memory to store frames temporarily</li><li>Can hold frames when output ports are busy</li><li>Prevents frame loss during periods of network congestion</li><li>Enables handling of traffic between different speed interfaces</li></ul></li><li><strong>Collision elimination</strong>:<ul><li>Ethernet protocol used on each link but without collisions</li><li>Full-duplex operation: simultaneous transmission and reception</li><li>Each link is its own separate collision domain</li><li>CSMA/CD no longer needed on point-to-point links to switch</li></ul></li><li><strong>Parallel communications</strong>:<ul><li>Host A can transmit to host A’ while host B simultaneously transmits to host B’</li><li>No interference between unrelated data flows</li><li>Example: In a network with hosts A, A’, B, and B’ all connected to a switch:<ul><li>A→A’ and B→B’ transmissions occur in parallel</li><li>Network throughput effectively multiplied by number of concurrent transmissions</li></ul></li></ul></li><li><strong>Contrast with hubs</strong>:<ul><li>Hubs force a single shared collision domain among all connected devices</li><li>Only one device can transmit at any given time with a hub</li><li>Switches enable parallel, independent data flows that hubs cannot support</li></ul></li></ul><h2 id="switch-table">Switch Table</h2><p>Q: How does switch know that A’ reachable via interface 4, B’ reachable via interface 5?</p><p>A: Each switch has a switch table, each entry contains</p><ul><li>MAC address of host</li><li>Interface to reach host</li><li>Time stamp</li></ul><p>This structure is similar to a routing table, but operates at Layer 2 (MAC addresses) rather than Layer 3 (IP addresses).</p><p>Q: How are entries created, maintained in switch table? Something like a routing protocol?</p><p>A: Switch tables are built through self-learning</p><ol type="1"><li><strong>Self-learning process</strong>:<ul><li>Initially the switch table is empty</li><li>When a frame arrives, the switch records the sender’s MAC address and the interface on which it arrived</li><li>The switch learns the location of hosts based on the source MAC address of incoming frames</li></ul></li><li><strong>Table maintenance</strong>:<ul><li>Each entry has a time-to-live (typically 20-30 minutes)</li><li>Entries are refreshed when new frames from the same source arrive</li><li>Entries timeout and are removed if not refreshed before TTL expires</li></ul></li><li><strong>Handling unknown destinations</strong>:<ul><li>If destination MAC is unknown (not in table), the switch floods the frame to all interfaces except the one it arrived on</li><li>Once the destination host responds, its location is learned</li></ul></li><li><strong>Key differences from routing protocols</strong>:<ul><li>No explicit protocol messages exchanged between switches for MAC learning</li><li>Learning is passive, based solely on observing normal traffic</li><li>Completely automatic with no configuration required</li></ul></li></ol><h2 id="switch-self-learning">Switch: Self-Learning</h2><h3 id="learning-host-locations">Learning Host Locations</h3><ul><li><strong>Basic principle</strong>: Switches automatically learn which hosts are located on which interfaces</li><li><strong>No configuration required</strong>: Learning happens dynamically as frames traverse the switch</li><li><strong>Process for each incoming frame</strong>:<ol type="1"><li>Switch examines the <strong>source MAC address</strong> in the frame header</li><li>Switch records the <strong>interface</strong> on which the frame arrived</li><li>Switch associates this MAC address with this interface in its table</li><li>Timestamp is recorded for the entry for aging purposes</li></ol></li></ul><h3 id="switch-table-management">Switch Table Management</h3><ul><li><strong>Dynamic updates</strong>: If a host moves to a different port, the switch updates its table when the host transmits</li><li><strong>Aging mechanism</strong>: Each entry includes a time-to-live (typically 20-30 minutes)<ul><li>Entries are refreshed when new frames from the same source arrive</li><li>If no frames are received from a MAC address before TTL expires, entry is removed</li></ul></li><li><strong>Adaptation to network changes</strong>: Tables automatically adjust when:<ul><li>New devices connect to the network</li><li>Existing devices are moved to different switch ports</li><li>Devices are removed from the network</li></ul></li></ul><h3 id="handling-unknown-destinations">Handling Unknown Destinations</h3><ul><li><strong>Initial state</strong>: Empty table when switch boots up</li><li><strong>Flooding</strong>: When destination is unknown (not in table), switch forwards frame out all interfaces except the arrival interface</li><li><strong>Progressive learning</strong>: Table builds up as hosts send frames, gradually reducing the need for flooding</li><li><strong>Self-correcting</strong>: If an entry becomes outdated, flooding will occur until the host location is relearned</li></ul><p>This passive learning approach enables plug-and-play networking with minimal administrative overhead.</p><h2 id="switch-frame-filteringforwarding">Switch: Frame Filtering/Forwarding</h2><h3 id="frame-processing-algorithm">Frame Processing Algorithm</h3><p>When a frame is received by a switch, it follows this decision process:</p><ol type="1"><li><strong>Record source information</strong>:<ul><li>Record the link/interface associated with the sending host</li><li>Update or create switch table entry for source MAC address</li></ul></li><li><strong>Destination lookup</strong>:<ul><li>Index the switch table using the destination MAC address</li></ul></li><li><strong>Forwarding decision</strong>:<ul><li>If destination MAC entry is found in table:<ul><li>If destination is on same segment from which frame arrived:<ul><li>Drop the frame (no need to forward to the same segment)</li></ul></li><li>Else:<ul><li>Forward the frame on the interface indicated in the table entry</li></ul></li></ul></li><li>Else (destination not found in table):<ul><li>Flood the frame (forward on all interfaces except the one on which it arrived)</li></ul></li></ul></li><li><strong>Flooding process</strong>:<ul><li>When flooding is required, the frame is sent out all switch ports</li><li>Exception: Never send the frame back on the interface where it was received</li><li>This ensures the destination will receive the frame if it exists on the network</li><li>Subsequent replies will help the switch learn the destination’s location</li></ul></li></ol><p>This algorithm combines the efficiency of direct forwarding with the reliability of flooding when necessary, while also preventing unnecessary network traffic through frame filtering.</p><h2 id="switches-vs.-routers-key-differences">Switches vs. Routers: Key Differences</h2><h3 id="similarities">Similarities</h3><ul><li>Both are <strong>store-and-forward devices</strong><ul><li>Receive complete packets/frames before processing and forwarding</li><li>Buffer data during processing</li></ul></li></ul><h3 id="fundamental-differences">Fundamental Differences</h3><table><thead><tr class="header"><th>Characteristic</th><th>Switches</th><th>Routers</th></tr></thead><tbody><tr class="odd"><td><strong>OSI Layer</strong></td><td>Link layer (Layer 2)</td><td>Network layer (Layer 3)</td></tr><tr class="even"><td><strong>Addressing</strong></td><td>Use MAC addresses</td><td>Use IP addresses</td></tr><tr class="odd"><td><strong>Header Examination</strong></td><td>Examine frame headers</td><td>Examine packet headers</td></tr><tr class="even"><td><strong>Decision Making</strong></td><td>Simple forwarding based on MAC address</td><td>Complex routing decisions based on network topology</td></tr></tbody></table><h3 id="table-management">Table Management</h3><ul><li><strong>Switches</strong>:<ul><li>Maintain switch tables mapping MAC addresses to interfaces</li><li>Implement self-learning algorithms (passive learning from traffic)</li><li>Use filtering to prevent unnecessary traffic propagation</li><li>Tables built automatically without configuration</li></ul></li><li><strong>Routers</strong>:<ul><li>Maintain routing tables mapping network addresses to next hops</li><li>Implement dynamic routing algorithms (RIP, OSPF, BGP, etc.)</li><li>Exchange routing protocol messages with other routers</li><li>Often require explicit configuration</li></ul></li></ul><h3 id="operational-scope">Operational Scope</h3><ul><li><strong>Switches</strong>: Operate within a single network (broadcast domain)</li><li><strong>Routers</strong>: Connect multiple networks and provide inter-network communication</li></ul><p>These fundamental differences reflect their different roles in network architecture: switches optimize local traffic flow within networks, while routers enable traffic to traverse between different networks.</p><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/624.png" style="display: block; margin: 0 auto; width: 70%" alt="Route"><figcaption aria-hidden="true">Route</figcaption></figure><h2 id="virtual-local-area-networks-vlans">Virtual Local Area Networks (VLANs)</h2><h3 id="q-vlan-frame-format">802.1Q VLAN Frame Format</h3><ul><li>Compares standard 802.1 Ethernet frame with 802.1Q VLAN frame</li><li>802.1Q frame adds a 2-byte Tag Protocol Identifier (value: 81-00)</li><li>Includes Tag Control Information with 12-bit VLAN ID field and 3-bit priority field</li><li>CRC is recomputed to account for the added header fields</li><li>Allows frames to carry VLAN identification information</li></ul><h3 id="vlans-spanning-multiple-switches">VLANs Spanning Multiple Switches</h3><ul><li>VLANs can extend across multiple physical switches</li><li>Trunk ports connect switches and carry frames between VLANs</li><li>Frames forwarded between switches must use 802.1Q protocol to maintain VLAN information</li><li>Example shows Electrical Engineering VLAN (ports 1-8) and Computer Science VLAN (ports 9-15) spanning two switches</li><li>Trunk ports ensure proper VLAN segregation across the extended network</li></ul><h3 id="port-based-vlan">Port-based VLAN</h3><ul><li>Provides traffic isolation between different port groups</li><li>Supports dynamic membership where port</li><li>s can be reassigned to different VLANs</li><li>Communication between VLANs requires routing, similar to separate physical networks</li><li>VLANs can be defined by port numbers or by MAC addresses of endpoints</li><li>Vendors typically offer combined switch/router devices to facilitate inter-VLAN routing</li></ul><h3 id="vlan-concept-overview">VLAN Concept Overview</h3><ul><li>Defines VLANs as virtual networks created on a single physical infrastructure</li><li>A single physical switch operates as multiple virtual switches</li><li>Logically separates networks (e.g., Electrical Engineering from Computer Science)</li><li>Provides network segmentation without requiring separate physical switches</li><li>Increases network flexibility, security, and management capabilities</li></ul><h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1><h2 id="r.8">R.8</h2><p><strong>Question</strong></p><p>How big is the <span class="math inline">\(\text{MAC}\)</span> address space? The <span class="math inline">\(\text{IPv4}\)</span> address space? The <span class="math inline">\(\text{IPv6}\)</span> address space?</p><p><strong>Answer</strong></p><p>The sizes of the three address spaces are:</p><h3 id="mac-address-space">MAC Address Space</h3><ul><li><strong>Size</strong>: <span class="math inline">\(2^{48}\)</span> possible addresses</li><li><strong>Format</strong>: <span class="math inline">\(48\)</span>-bit addresses, typically represented as six groups of two hexadecimal digits (e.g., <code>00:1A:2B:3C:4D:5E</code>)</li></ul><h3 id="ipv4-address-space">IPv4 Address Space</h3><ul><li><strong>Size</strong>: <span class="math inline">\(2^{32}\)</span> possible addresses</li><li><strong>Format</strong>: <span class="math inline">\(32\)</span>-bit addresses, typically represented as four decimal numbers separated by dots (e.g., <code>192.168.1.1</code>)</li></ul><h3 id="ipv6-address-space">IPv6 Address Space</h3><ul><li><strong>Size</strong>: <span class="math inline">\(2^{128}\)</span> possible addresses</li><li><strong>Format</strong>: <span class="math inline">\(128\)</span>-bit addresses, typically represented as eight groups of four hexadecimal digits separated by colons (e.g., <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>)</li></ul><p>The IPv6 address space is vastly larger than both MAC and IPv4 address spaces, which was designed to address the IPv4 address exhaustion problem.</p><h2 id="p.4">P.4</h2><p><strong>Consider the previous problem, but instead of containing the binary of the numbers 0 through 9 suppose these 10 bytes contain.</strong></p><p><strong>Questions and Answers:</strong></p><ol type="a"><li>the binary representation of the numbers 1 through 10.</li><li>the ASCII representation of the letters A through J (uppercase).</li><li>the ASCII representation of the letters a through j (lowercase). Compute the Internet checksum for this data.</li></ol><p>下面按 16-bit 大端顺序（高字节在前）计算 Internet 校验和（ones’complement sum）：</p><ol type="1"><li>每两个字节组成一个 16-bit 字，超出 0xFFFF 时将高位环回加到低位。</li><li>对所有字求和后取反。</li></ol><ol type="a"><li>数值 1 ～ 10（二进制，字节值 0x01～0x0A）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x01 0x02 → 0x0102  <br>0x03 0x04 → 0x0304  <br>0x05 0x06 → 0x0506  <br>0x07 0x08 → 0x0708  <br>0x09 0x0A → 0x090A  <br>Sum = 0x0102+0x0304+0x0506+0x0708+0x090A = 0x191E  <br>Checksum = ~0x191E = 0xE6E1<br></code></pre></td></tr></table></figure><ol start="2" type="a"><li>大写字母 A ～ J（ASCII 0x41～0x4A）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x41 0x42 → 0x4142  <br>0x43 0x44 → 0x4344  <br>0x45 0x46 → 0x4546  <br>0x47 0x48 → 0x4748  <br>0x49 0x4A → 0x494A  <br>Sum = 0x4142+0x4344+0x4546+0x4748+0x494A = 0x5A5F  <br>Checksum = ~0x5A5F = 0xA5A0<br></code></pre></td></tr></table></figure><ol start="3" type="a"><li>小写字母 a ～ j（ASCII 0x61～0x6A）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x61 0x62 → 0x6162  <br>0x63 0x64 → 0x6364  <br>0x65 0x66 → 0x6566  <br>0x67 0x68 → 0x6768  <br>0x69 0x6A → 0x696A  <br>Sum = 0x6162+0x6364+0x6566+0x6768+0x696A = 0xFAFF  <br>Checksum = ~0xFAFF = 0x0500<br></code></pre></td></tr></table></figure><h2 id="p.11">P.11</h2><p>Suppose four active nodes—nodes A, B, C and D—are competing for access to a channel using slotted ALOHA. Assume each node has an infinite number of packets to send. Each node attempts to transmit in each slot with probability p. The first slot is numbered slot 1, the second slot is numbered slot 2, and so on.</p><p><strong>Questions and Answers:</strong></p><p><strong>a. What is the probability that node A succeeds for the first time in slot 5?</strong></p><p>在单个 slot 中成功的概率：<span class="math display">\[P_{\text{succ}} = p (1 - p)^{3}\]</span></p><p>在前 4 个 slot 中都未成功的概率：<span class="math display">\[P_{\text{4s}} = \left(1 - P_{\text{succ}}\right)^{4}\]</span></p><p>也就是：<span class="math display">\[P(\text{first success in slot 5}) = \bigl[1 - p(1-p)^3\bigr]^4 \times p(1-p)^3.\]</span></p><p><strong>b. What is the probability that some node (either A, B, C or D) succeeds in slot 4?</strong></p><p>总共有 <span class="math inline">\(N = 4\)</span> 个结点，某个结点在 slot4 成功的概率为： <span class="math display">\[P_{\text{succ}} = 4 \cdot p \cdot (1 - p)^{3}\]</span></p><p><strong>c. What is the probability that the first success occurs in slot 3?</strong></p><p>第一次成功出现在 slot3 的概率 <span class="math display">\[P = (1-4p(1-p)^3)^2 \cdot 4p(1-p)^3\]</span></p><p><strong>d. What is the efficiency of this four-node system?</strong></p><p>我们需要计算出使得 <span class="math inline">\(Np(1-p)^{N-1}\)</span> 最大的 <span class="math inline">\(p\)</span>，记原式子为 <span class="math inline">\(L(p)\)</span>，最优解为 <span class="math inline">\(p^{\ast}\)</span>。对 <span class="math inline">\(p\)</span> 求偏导： <span class="math display">\[\frac{\partial L(p)}{\partial p} = 4(1 - p)^{3} - 12p(1 - p)^{2}\]</span></p><p>得到 <span class="math display">\[p^{\ast} = 0.25\]</span></p><p>所以，效率为： <span class="math display">\[\text{efficiency} = 4 \times 0.25 \times 0.75^3 = \frac{27}{64}\]</span></p><h2 id="p.17">P.17</h2><p><strong>Question and Answer:</strong></p><p>Recall that with the CSMA/CD protocol, the adapter waits <span class="math inline">\(K \cdot 512\)</span> bit times after a collision, where <span class="math inline">\(K\)</span> is drawn randomly. For <span class="math inline">\(K = 100\)</span>, how long does the adapter wait until returning to Step 2 for a <span class="math inline">\(10\)</span> Mbps Ethernet? For a <span class="math inline">\(100\)</span> Mbps Ethernet?</p><p>等待时间的计算公式为： <span class="math display">\[T = K \cdot 512 \cdot t_{\text{bit}}\]</span></p><p>其中，<span class="math inline">\(t_{\text{bit}}\)</span> 是比特时间，其计算公式为： <span class="math display">\[t_{\text{bit}} = \frac{1}{\text{传输速率}}\]</span></p><p>分别带入 <span class="math inline">\(10\)</span> Mbps 和 <span class="math inline">\(100\)</span> Mbps，解得分别等待时间为 <strong><span class="math inline">\(5.12\)</span> ms</strong> 和 <strong><span class="math inline">\(0.512\)</span> ms</strong>。</p><h2 id="p.18">P.18</h2><p><strong>Question and Answer:</strong></p><p>Suppose nodes A and B are on the same <span class="math inline">\(10\)</span> Mbps Ethernet bus, and the propagation delay between the two nodes is <span class="math inline">\(325\)</span> bit times. Suppose node A begins transmitting a frame and, before it finishes, node B begins transmitting a frame. Can A finish transmitting before it detects that B has transmitted? Why or why not? If the answer is yes, then A incorrectly believes that its frame was successfully transmitted without a collision. <em>Hint</em>: Suppose at time <span class="math inline">\(t = 0\)</span> bit times, A begins transmitting a frame. In the worst case, A transmits a minimum-sized frame of <span class="math inline">\(512 + 64\)</span> bit times. So A would finish transmitting the frame at <span class="math inline">\(t = 512 + 64\)</span> bit times. Thus, the answer is no, if B’s signal reaches A before bit time <span class="math inline">\(t = 512 + 64\)</span> bits. In the worst case, when does B’s signal reach A?</p><ol type="1"><li><strong>传播延迟计算</strong><ul><li>两节点之间的传播延迟为 <span class="math inline">\(325\)</span> 比特时间。</li><li>因此，B 的信号从 B 传播到 A 所需的时间为 <span class="math inline">\(325\)</span> 比特时间。</li></ul></li><li><strong>最小帧传输时间</strong><ul><li>A 传输一个最小帧所需的时间为 <span class="math inline">\(512 + 64 = 576\)</span> 比特时间。</li></ul></li><li><strong>碰撞检测条件</strong><ul><li>如果 B 的信号在 A 完成帧传输之前到达 A，则 A 可以检测到碰撞。</li><li>在最坏情况下，B 在传播延迟的最后一刻（即 <span class="math inline">\(t = 325\)</span> 比特时间）开始传输。</li><li>B 的信号需要 <span class="math inline">\(325\)</span> 比特时间到达 A，因此 B 的信号到达 A 的时间为： <span class="math display">\[t_{\text{到达}} = 325 + 325 = 650 \, \text{比特时间}\]</span></li></ul></li><li><strong>结论</strong><ul><li>A 在 <span class="math inline">\(t = 576\)</span> 比特时间完成帧传输，而 B 的信号在 <span class="math inline">\(t = 650\)</span> 比特时间到达 A。</li><li>因此，A <strong>无法检测到碰撞</strong>，并会错误地认为其帧已成功传输。</li></ul></li></ol><h2 id="p.27">P.27</h2><p><strong>Question and Answer:</strong></p><p>Consider Figure <span class="math inline">\(5.38\)</span> in problem P<span class="math inline">\(14\)</span>. Provide MAC addresses and IP addresses for the interfaces at Host A, both routers, and Host F. Suppose Host A sends a datagram to Host F. Give the source and destination MAC addresses in the frame encapsulating this IP datagram as the frame is transmitted <em>(i)</em> from A to the left router, <em>(ii)</em> from the left router to the right router, <em>(iii)</em> from the right router to F. Also give the source and destination IP addresses in the IP datagram encapsulated within the frame at each of these points in time.</p><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/Three%20subnets,%20interconnected%20by%20routers.png" style="display: block; margin: 0 auto; width: 50%" alt="Figure 5.38"><figcaption aria-hidden="true">Figure 5.38</figcaption></figure><p>Assign IP addresses to all of the interfaces. For Subnet <span class="math inline">\(1\)</span> use addresses of the form <code>192.168.1.xxx</code>; for Subnet <span class="math inline">\(2\)</span> uses addresses of the form <code>192.168.2.xxx</code>; and for Subnet <span class="math inline">\(3\)</span> use addresses of the form <code>192.168.3.xxx</code>. Assign MAC addresses to all of the adapters.</p><p><span class="math inline">\(14\)</span> 和 <span class="math inline">\(27\)</span> 都没有明确说明 IP address 和 MAC address。先分配接口，如下表所示。</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>设备/接口</th><th>子网</th><th>IP 地址</th><th>MAC 地址</th></tr></thead><tbody><tr class="odd"><td>Host A</td><td>Subnet 1</td><td>192.168.1.1</td><td>AA-AA-AA-AA-AA-AA</td></tr><tr class="even"><td>Host B</td><td>Subnet 1</td><td>192.168.1.2</td><td>BB-BB-BB-BB-BB-BB</td></tr><tr class="odd"><td>Router1-接口1</td><td>Subnet 1</td><td>192.168.1.254</td><td>A1-B1-C1-D1-E1-F1</td></tr><tr class="even"><td>Router1-接口2</td><td>Subnet 2</td><td>192.168.2.1</td><td>A1-B2-C2-D2-E2-F2</td></tr><tr class="odd"><td>Router2-接口1</td><td>Subnet 2</td><td>192.168.2.254</td><td>A2-B1-C1-D1-E1-F1</td></tr><tr class="even"><td>Router2-接口2</td><td>Subnet 3</td><td>192.168.3.1</td><td>A2-B2-C2-D2-E2-F2</td></tr><tr class="odd"><td>Host C</td><td>Subnet 2</td><td>192.168.2.2</td><td>CC-CC-CC-CC-CC-CC</td></tr><tr class="even"><td>Host D</td><td>Subnet 2</td><td>192.168.2.3</td><td>DD-DD-DD-DD-DD-DD</td></tr><tr class="odd"><td>Host E</td><td>Subnet 3</td><td>192.168.3.2</td><td>EE-EE-EE-EE-EE-EE</td></tr><tr class="even"><td>Host F</td><td>Subnet 3</td><td>192.168.3.3</td><td>FF-FF-FF-FF-FF-FF</td></tr></tbody></table></div><p><strong><em>(i)</em> from A to the left router</strong> - <strong>Source MAC address</strong>: <code>AA-AA-AA-AA-AA-AA</code>. - <strong>Destination MAC address</strong>: <code>A1-B1-C1-D1-E1-F1</code>.</p><p><strong><em>(ii)</em> from the left router to the right router</strong> - <strong>Source MAC address</strong>: <code>A1-B2-C2-D2-E2-F2</code>. - <strong>Destination MAC address</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</p><p><strong><em>(iii)</em> from the right router to F</strong> - <strong>Source MAC address</strong>: <code>A2-B2-C2-D2-E2-F2</code>. - <strong>Destination MAC address</strong>: <code>FF-FF-FF-FF-FF-FF</code>.</p><h2 id="p.28">P.28</h2><p>Suppose now that the leftmost router in Figure <span class="math inline">\(5.38\)</span> is replaced by a switch. Hosts A, B, C, and D and the right router are all star-connected into this switch. Give the source and destination MAC addresses in the frame encapsulating this IP datagram as the frame is transmitted <em>(i)</em> from A to the switch, <em>(ii)</em> from the switch to the right router, <em>(iii)</em> from the right router to F. Also give the source and destination IP addresses in the IP datagram encapsulated within the frame at each of these points in time.</p><p>首先需要明确的是，switch 的每个接口都有一个 MAC address，但由于 switch 并不会修改经过它的 frame，这里简单地用一个 MAC address 概括。同时，理论上 subnet1 和 subnet2 应该合为一个 subnet，但接下来的结果仍做区分（因为题目要仍在问 MAC address）。</p><p>接上题的接口配置，做简单修改：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>设备/接口</th><th>子网</th><th>IP 地址</th><th>MAC 地址</th></tr></thead><tbody><tr class="odd"><td>Host A</td><td>Subnet 1</td><td>192.168.1.1</td><td>AA-AA-AA-AA-AA-AA</td></tr><tr class="even"><td>Host B</td><td>Subnet 1</td><td>192.168.1.2</td><td>BB-BB-BB-BB-BB-BB</td></tr><tr class="odd"><td>Switch</td><td>Subnet 1 2</td><td>192.168.1.254</td><td>A1-B1-C1-D1-E1-F1</td></tr><tr class="even"><td>Router2-接口1</td><td>Subnet 2</td><td>192.168.2.254</td><td>A2-B1-C1-D1-E1-F1</td></tr><tr class="odd"><td>Router2-接口2</td><td>Subnet 3</td><td>192.168.3.1</td><td>A2-B2-C2-D2-E2-F2</td></tr><tr class="even"><td>Host C</td><td>Subnet 2</td><td>192.168.2.2</td><td>CC-CC-CC-CC-CC-CC</td></tr><tr class="odd"><td>Host D</td><td>Subnet 2</td><td>192.168.2.3</td><td>DD-DD-DD-DD-DD-DD</td></tr><tr class="even"><td>Host E</td><td>Subnet 3</td><td>192.168.3.2</td><td>EE-EE-EE-EE-EE-EE</td></tr><tr class="odd"><td>Host F</td><td>Subnet 3</td><td>192.168.3.3</td><td>FF-FF-FF-FF-FF-FF</td></tr></tbody></table></div><p><strong><em>(i)</em> from A to the switch</strong> - <strong>Source MAC address</strong>: <code>AA-AA-AA-AA-AA-AA</code>. - <strong>Destination MAC address</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</p><p><strong><em>(ii)</em> from the switch to the right router</strong> - <strong>Source MAC address</strong>: <code>A1-B1-C1-D1-E1-F1</code>. - <strong>Destination MAC address</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</p><p><strong><em>(iii)</em> from the right router to F</strong> - <strong>Source MAC address</strong>: <code>A2-B2-C2-D2-E2-F2</code>. - <strong>Destination MAC address</strong>: <code>FF-FF-FF-FF-FF-FF</code>.</p><h2 id="p.32">P.32</h2><figure><img src="/2025/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Data-Link-Layer/A%20link-layer%20switch%20inter-connecting%20six%20nodes.png" style="display: block; margin: 0 auto; width: 60%" alt="A link-layer switch inter-connecting six nodes"><figcaption aria-hidden="true">A link-layer switch inter-connecting six nodes</figcaption></figure><p>Let’s consider the operation of a learning switch in the context of Figure <span class="math inline">\(5.24\)</span>. Suppose that <em>(i)</em> B sends a frame to E, <em>(ii)</em> E replies with a frame to B, <em>(iii)</em> A sends a frame to B, <em>(iv)</em> B replies with a frame to A. The switch table is initially empty. Show the state of the switch table before and after each of these events. For each of these events, identify the link(s) on which the transmitted frame will be forwarded, and briefly justify your answers.</p><p>按字典序从小到大的顺序分配接口，用如下表格总结题目所述过程：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>步骤</th><th>事件</th><th>表项变化</th><th>转发链路</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>1</td><td>B→E</td><td>+B@2</td><td>1,3,4,5,6</td><td>泛洪</td></tr><tr class="even"><td>2</td><td>E→B</td><td>+E@5</td><td>2</td><td>定向转发</td></tr><tr class="odd"><td>3</td><td>A→B</td><td>+A@1</td><td>2</td><td>定向转发</td></tr><tr class="even"><td>4</td><td>B→A</td><td>B@2 刷新</td><td>1</td><td>定向转发</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Data Link Layer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>朴素贝叶斯法</title>
    <link href="/2025/06/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/"/>
    <url>/2025/06/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="textnaive-bayes"><span class="math inline">\(\text{Naive Bayes}\)</span></h2><p><strong>朴素</strong>贝叶斯法基于一个强假设，即特征条件独立性。由条件独立性假设可将公式 <span class="math inline">\((2)\)</span> 化简为公式 <span class="math inline">\((3)\)</span>。此外，朴素贝叶斯法是对输入进行<strong>分类</strong>，这其中的机理涉及到两个概念：<strong>先验概率</strong>和<strong>后验概率</strong>；先验概率是类别的先验分布 <span class="math inline">\(P(Y)\)</span>，条件概率 <span class="math inline">\(P(X |Y)\)</span> 是在类别条件下输入的分布，后验概率 <span class="math inline">\(P(Y |X)\)</span> 是在输入条件下类的分布；最后我们选择后验概率最大的分类情况作为输入的类标签。</p><h2 id="朴素贝叶斯法的学习与分类">朴素贝叶斯法的学习与分类</h2><h3 id="基本方法">基本方法</h3><p>设输入空间 <span class="math inline">\(\mathcal{X} \in \mathbb{R}^n\)</span> 为 <span class="math inline">\(n\)</span> 维向量的集合，输出空间类标记集合 <span class="math inline">\(\mathcal{Y} = \{c_1, c_2, \cdots, c_K \}\)</span>。训练数据集</p><p><span class="math display">\[T = \{(x_1, y_1), (x_2, y_2), \dots, (x_N, y_N)\}\]</span></p><p>由 <span class="math inline">\(P(X, Y)\)</span> 独立同分布产生。</p><p>朴素贝叶斯法通过训练数据集学习联合概率分布 <span class="math inline">\(P(X, Y)\)</span>。具体地，学习以下先验概率分布及条件概率分布。先验概率分布</p><p><span class="math display">\[P(Y = c_k), \quad k = 1, 2, \cdots K \tag{1}\]</span></p><p>条件概率分布</p><p><span class="math display">\[P(X = x |Y = c_k) = P(X^{(1)} = x^{(1)}, \cdots, X^{(n)} = x^{(n)} |Y = c_k), \quad k = 1, 2, \cdots, K \tag{2}\]</span></p><p>于是学习到联合概率分布 <span class="math inline">\(P(X, Y)\)</span>。</p><p>由条件独立性假设得</p><p><span class="math display">\[P(X = x |Y = c_k) = \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k) \tag{3}\]</span></p><p>朴素贝叶斯法分类时，对给定的输入 <span class="math inline">\(x\)</span>，通过学习到的模型计算后验概率分布 <span class="math inline">\(P(Y = c_k |X = x)\)</span>，将后验概率最大的类作为 <span class="math inline">\(x\)</span> 的类输出。后验概率计算如下：</p><p><span class="math display">\[P(Y = c_k |X = x) = \frac{P(X = x |Y = c_k) P(Y = c_k)}{\sum_{k} P(X = x |Y = c_k) P(Y = c_k)} \tag{4}\]</span></p><p>也就是：</p><p><span class="math display">\[P(Y = c_k |X = x) = \frac{P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)}{\sum_{k} P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)} \tag{5}\]</span></p><p>这是朴素贝叶斯法分类的基本公式。于是，朴素贝叶斯分类器可表示为</p><p><span class="math display">\[y = f(x) = \operatorname{arg} \max_{c_k} \frac{P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)}{\sum_{k} P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)} \tag{6}\]</span></p><p>注意到分母对所有 <span class="math inline">\(c_k\)</span> 都是相同的，所以，</p><p><span class="math display">\[y = f(x) = \operatorname{arg} \max_{c_k} P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k) \tag{7}\]</span></p><h3 id="后验概率最大化的含义">后验概率最大化的含义</h3><p>朴素贝叶斯法将实例分到后验概率最大的类中。这等价于期望风险最小化。假设选择 0-1 损失函数：</p><p><span class="math display">\[L(Y, f(X)) =  \begin{cases}1, &amp;Y \neq f(X)\\[10pt]0, &amp;Y = f(X)\end{cases}\]</span></p><p>式中 <span class="math inline">\(f(X)\)</span> 是分类决策函数。这时，期望风险函数为</p><p><span class="math display">\[R_{\exp}(f) = \mathbf{E}[L(Y, f(X))]\]</span></p><p>期望是对联合分布 <span class="math inline">\(P(X, Y)\)</span>取的。由此取条件期望：</p><p><span class="math display">\[R_{\exp}(f) = \mathbf{E_{X}} \sum_{k = 1}^{K}[L(c_k, f(X))] P(c_k |X)\]</span></p><p>为了使期望风险最小化，只需对 <span class="math inline">\(X = x\)</span> 逐个极小化，由此得到：</p><p><span class="math display">\[f(x) = \operatorname{arg} \max_{y \in \mathcal{Y}} P(y = c_k |X = x)\]</span></p><h2 id="朴素贝叶斯法的参数估计">朴素贝叶斯法的参数估计</h2><h3 id="学习与分类算法">学习与分类算法</h3><p>输入：训练数据 <span class="math inline">\(T = \{(x_1, y_1), (x_2, y_2), \dots, (x_N, y_N)\}\)</span>，其中 <span class="math inline">\(x_i = (x_i^{(1)}, x_i^{(2)}, \dots, x_i^{(n)})\)</span>，<span class="math inline">\(x_i^{(j)}\)</span> 是第 <span class="math inline">\(i\)</span> 个样本的第 <span class="math inline">\(j\)</span> 个特征，<span class="math inline">\(x_i^{(j)} \in \{a_{j1}, a_{j2}, \cdots, a_{jS_j}\}\)</span> 是特征 <span class="math inline">\(x_i^{(j)}\)</span> 的可能取值，<span class="math inline">\(y_i \in \{c_1, c_2, \cdots, c_K\}\)</span>。 输出：实例 <span class="math inline">\(x\)</span> 的分类。</p><p><strong>（1）计算先验概率及条件概率</strong> <span class="math display">\[\begin{align*}P(Y = c_k) &amp;= \frac{\sum_{i = 1}^{N} I(y_i = ck)}{N}, \quad k = 1, 2, \cdots, K\\[10pt]P(X^{(j)} = a_{jl} |Y = c_k) &amp;= \frac{\sum_{i = 1}^{N} I(x_i^{(j)} = a_{jl}, y_i = c_k)}{\sum_{i = 1}^{N} I(y_i = c_k)}\\[10pt]j = 1, 2, \cdots, n; \quad l &amp;= 1, 2, \cdots, S_j; \quad k = 1, 2, \cdots, K\end{align*}\]</span> <strong>（2）对于给定实例 <span class="math inline">\(x = (x^{(1)}, x^{(2)}, \dots, x^{(n)})\)</span>，计算：</strong> <span class="math display">\[P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k), \quad k = 1, 2, \cdots, K\]</span> <strong>（3）确定实例 <span class="math inline">\(x\)</span> 的类</strong> <span class="math display">\[y = \operatorname{arg} \max_{c_k} P(Y = c_k) \prod_{j = 1}^{n} P(X^{(j)} = x^{(j)} |Y = c_k)\]</span></p><h3 id="贝叶斯估计">贝叶斯估计</h3><p>用极大似然估计可能会出现所要估计的概率值为 <span class="math inline">\(0\)</span> 的情况。这是采用贝叶斯估计。</p><p><span class="math display">\[\begin{align*}P_{\lambda}(X^{(j)} = a_{jl} |Y = c_k) &amp;= \frac{\sum_{i = 1}^{N} I(x_i^{(j)} = a_{jl}, y_i = c_k) + \lambda}{\sum_{i = 1}^{N} I(y_i = c_k) + S_j \lambda} \tag{8}\\[10pt]P_{\lambda}(Y = c_k) &amp;= \frac{\sum_{i = 1}^{N} I(y_i = c_k) + \lambda}{N + K \lambda} \tag{9}\end{align*}\]</span></p><p>常取 <span class="math inline">\(\lambda = 1\)</span></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>期望极大</title>
    <link href="/2025/06/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%9C%9F%E6%9C%9B%E6%9E%81%E5%A4%A7/"/>
    <url>/2025/06/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%9C%9F%E6%9C%9B%E6%9E%81%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="em-算法">EM 算法</h2><p><span class="math inline">\(\operatorname{EM}\)</span> 算法通过迭代求 <span class="math inline">\(L(\theta) = \log P(Y | \theta)\)</span> 的极大似然估计。每次迭代包含两步：<span class="math inline">\(\operatorname{E}\)</span> 步，求期望；<span class="math inline">\(\operatorname{M}\)</span> 步，求极大化。</p><h3 id="算法步骤">算法步骤</h3><p>输入：观测变量数据 <span class="math inline">\(Y\)</span>，隐变量数据 <span class="math inline">\(Z\)</span>，联合分布 <span class="math inline">\(P(Y, Z | \theta)\)</span>，条件分布 <span class="math inline">\(P(Z | Y, \theta)\)</span>； 输出：模型参数<span class="math inline">\(\theta\)</span>。</p><p><strong>（1）选择参数初始值 <span class="math inline">\(\theta^{(0)}\)</span>，开始迭代；</strong></p><p><strong>（2）<span class="math inline">\(\operatorname{E}\)</span> 步：计算 Q 函数值</strong></p><p><span class="math display">\[Q(\theta, \theta^{(i)}) = \sum_{Z} \log P(Y, Z | \theta) P(Z | Y, \theta^{(i)}) \tag{1}\]</span></p><p>这里，<span class="math inline">\(P(Z | Y, \theta^{(i)})\)</span> 是在给定观测数据 <span class="math inline">\(Y\)</span> 和当前的参数估计 <span class="math inline">\(\theta^{(i)}\)</span> 下隐变量数据 <span class="math inline">\(Z\)</span> 条件概率分布；</p><p><strong>（3）<span class="math inline">\(\operatorname{M}\)</span> 步：求使 <span class="math inline">\(Q(\theta, \theta^{(i)})\)</span> 极大化的 <span class="math inline">\(\theta\)</span>，确定第 <span class="math inline">\(i + 1\)</span> 次迭代的参数估计值 <span class="math inline">\(\theta^{(i + 1)}\)</span></strong></p><p><span class="math display">\[\theta^{(i + 1)} = \operatorname{arg} \max_{\theta} Q(\theta, \theta^{(i)}) \tag{2}\]</span></p><p><strong>（4）重复（2）（3）步直到收敛</strong></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>感知机</title>
    <link href="/2025/06/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <url>/2025/06/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="perceptron">Perceptron</h2><p>感知机用于<strong>二分类线性问题</strong>，这说明感知机只能用于二分类问题，同时样本数据线性可分。</p><p>接下来会介绍感知机的<strong>数学定义</strong>，也就是感知机的输入输出映射；然后介绍感知机的学习算法，学习什么？学习的是感知机数学定义中提及到的<strong>参数</strong>；如何学习？会介绍两种方法，第一种是基于原始<strong>损失函数</strong>的迭代算法，另一种是基于原始损失函数的<strong>对偶形式</strong>的迭代算法，这两种算法本质上等价。</p><span id="more"></span><h2 id="感知机的数学定义">感知机的数学定义</h2><p>假设输入空间 <span class="math inline">\(\mathcal{X} \subseteq \mathbb{R}^n\)</span>，输出空间是 <span class="math inline">\(\mathcal{Y} = \{+1, -1\}\)</span>。由输入空间到输出空间的如下函数：</p><p><span class="math display">\[f(x) = \operatorname{sign} (\mathbf{w} \cdot \mathbf{x} + b) \tag{1}\]</span></p><p>称为感知机。其中，<span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 为感知机模型参数，前者叫权值 <strong>weight</strong>，后者叫偏置 <strong>bias</strong>，点乘运算为<strong>向量内积</strong>。<span class="math inline">\(\operatorname{sign}\)</span> 是符号函数，具体定义如下：</p><p><span class="math display">\[\operatorname{sign}(x) =\begin{cases}+1,&amp; x \geq 0\\[10pt]-1,&amp; x &lt; 0 \tag{2}\end{cases}\]</span></p><h2 id="感知机学习策略">感知机学习策略</h2><p>假设数据集<strong>线性可分</strong>，定义感知机学习的损失函数为：</p><p><span class="math display">\[L(\mathbf{w}, b) = -\sum_{\mathbf{x}_i \in M} y_i(\mathbf{w} \cdot \mathbf{x}_i + b) \tag{3}\]</span></p><p>其中，<span class="math inline">\(M\)</span> 是<strong>误分类点的集合</strong>，我们的目标是极小化 <span class="math inline">\(L(\mathbf{w}, b)\)</span>。</p><h3 id="感知机学习算法的原始形式">感知机学习算法的原始形式</h3><p>随机初始化 <span class="math inline">\(\mathbf{w}\)</span> 和 <span class="math inline">\(b\)</span>，分别记为 <span class="math inline">\(\mathbf{w}_0\)</span> 和 <span class="math inline">\(b_0\)</span>，然后在训练数据集中选取数据 <span class="math inline">\((\mathbf{x}_i, y_i)\)</span>；如果 <span class="math inline">\(y_i(\mathbf{w} \cdot \mathbf{x}_i + b) \leq 0\)</span>,</p><p><span class="math display">\[\begin{align*}&amp;\mathbf{w} \leftarrow \mathbf{w} + \eta y_i \mathbf{x}_i\\[10pt]&amp;b \leftarrow b + \eta y_i\end{align*}\]</span></p><p>重复上述选择更新过程直至没有误分类点。</p><blockquote><p>这个更新过程，根据《统计学习方法》的例题，需要这样更新。假设我有一训练数据集 <span class="math inline">\(x_1, x_2, \cdots, x_N\)</span>，我初始化完 <span class="math inline">\(\mathbf{w}\)</span> 和 <span class="math inline">\(b\)</span> 后，我从 <span class="math inline">\(x_1\)</span> 开始，每次更新后都要从 <span class="math inline">\(1 \to N\)</span> 的顺序进行验证。</p></blockquote><h3 id="感知机学习算法的对偶形式">感知机学习算法的对偶形式</h3><p>与原始形式不同，对原始形式使用拉格朗日对偶化，得到相应的对偶形式。首先初始化系数和偏置 <span class="math inline">\(\mathbf{\alpha} \leftarrow \mathbf{0}, b \leftarrow 0\)</span>。再在训练集中选取数据 <span class="math inline">\((\mathbf{x}_i, y_i)\)</span>；如果 <span class="math inline">\(y_i \left(\sum_{j = 1}^{N} \alpha_j y_j (\mathbf{x}_j \cdot \mathbf{x}_i) + b \right) \leq 0\)</span>，则更新</p><p><span class="math display">\[\begin{align*}&amp;\alpha_i \leftarrow \alpha_i + \eta\\[10pt]&amp;b \leftarrow b + \eta y_i\end{align*}\]</span></p><p><strong>tips</strong></p><p>可以预处理出所有输入实例间的内积，并将其存为一个矩阵，这个矩阵叫做 Gram 矩阵，</p><p><span class="math display">\[\mathbf{G} = [\mathbf{x}_i \cdot \mathbf{x}_j]_{N \times N}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上下文无关文法</title>
    <link href="/2025/06/03/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/"/>
    <url>/2025/06/03/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="上下文无关文法的定义">上下文无关文法的定义</h2><p>定义文法 <span class="math inline">\(G = (V, T, P, S)\)</span>，其中产生式，除了空产生式外，有如下特点：</p><p><span class="math display">\[\forall \alpha \to \beta \in P, \quad \beta \in (V \cup T)^{\ast}, \quad \text{All have } |\beta| \geq |\alpha|, \text{and } \alpha \in V\]</span></p><h2 id="派生树">派生树</h2><p>设有 CFG $ G = (V, T, P, S)<span class="math inline">\(，\)</span>G$ 的派生树是满足如 下条件的有序树。</p><ol type="1"><li>树的每个顶点有一个标记 <span class="math inline">\(X\)</span>，且 <span class="math inline">\(X \in V \cup T \cup \{\epsilon\}\)</span>；</li><li>树根的标记为 <span class="math inline">\(S\)</span>；</li><li>如果非叶子顶点 <span class="math inline">\(v\)</span> 标记为 <span class="math inline">\(A\)</span>，<span class="math inline">\(v\)</span> 的儿子从左到右依次为 <span class="math inline">\(v_1, v_2, \dots, v_n\)</span>，并且它们分别标记为<span class="math inline">\(X_1, X_2, \dots, X_n\)</span>，则 <span class="math inline">\(A \to X_1 X_2 \cdots X_n \in P\)</span>；</li><li>如果 <span class="math inline">\(X\)</span> 是一个<strong>非叶子顶点</strong>的标记，则 <span class="math inline">\(X \in V\)</span>；</li><li>如果顶点 <span class="math inline">\(v\)</span> 标记为 <span class="math inline">\(\epsilon\)</span>，则 <span class="math inline">\(v\)</span> 是该树的叶子，并且 <span class="math inline">\(v\)</span> 是其父顶点的<strong>惟一儿子</strong>。</li></ol><p>派生树都是 CFG 的派生树。</p><h2 id="顶点的结果">顶点的结果</h2><p>派生树 <span class="math inline">\(T\)</span> 的所有叶子结点从左到右的符号串为 <span class="math inline">\(X_1 X_2 \cdots X_n\)</span>是 <span class="math inline">\(T\)</span> 的结果。</p><h1 id="cfg-的化简">CFG 的化简</h1><h2 id="删除无用符号">删除无用符号</h2><p><strong>无用符号</strong></p><h1 id="cnf乔姆斯基范式文法">CNF：乔姆斯基范式文法</h1><p>CFG <span class="math inline">\(G = (V, T, P, S)\)</span> 中的产生式形式为：<span class="math inline">\(A \to BC, \, A\to a\)</span>，其中 <span class="math inline">\(A,B,C \in V,\, a \in T\)</span>，需要注意的是此 CFG 已完成化简。</p><p>利用 CNF 范式派生长度为 <span class="math inline">\(n\)</span> 的串，刚好需要 <span class="math inline">\(2n-1\)</span> 步。</p><h1 id="上下文无关文法的性质">上下文无关文法的性质</h1><h2 id="cfl-的泵引理">CFL 的泵引理</h2><p>对于任意的 CFL <span class="math inline">\(L\)</span>，存在仅仅依赖于 <span class="math inline">\(L\)</span> 的正整数 <span class="math inline">\(N\)</span>，对于任意的 <span class="math inline">\(z \in L\)</span>，当 <span class="math inline">\(|z| \geq N\)</span> 时，存在 <span class="math inline">\(u, v, w, x, y\)</span>，使得 <span class="math inline">\(z = uvwxy\)</span>，同时满足：</p><ol type="1"><li><span class="math inline">\(|vwx| \leq N\)</span>；</li><li><span class="math inline">\(|vx| \geq 1\)</span>；</li><li>对于任意的非负整数 <span class="math inline">\(i\)</span>，<span class="math inline">\(u v^i w x^i y \in L\)</span>。</li></ol><h3 id="利用-cfl-泵引理证明一个语言不是-cfl">利用 CFL 泵引理证明一个语言不是 CFL</h3><ol type="1"><li>首先假设该语言是 CFL，则其满足泵引理，任选 <span class="math inline">\(N\)</span>；</li><li>找到语言中的句子 <span class="math inline">\(z \in L\)</span> 且 <span class="math inline">\(|z| \geq N\)</span>；</li><li>分析 <span class="math inline">\(v\)</span>、<span class="math inline">\(x\)</span> 的各种取值，当满足 <span class="math inline">\(z = uvwxy\)</span>，且 <span class="math inline">\(|vwx| \leq N\)</span>，<span class="math inline">\(|vx| \geq 1\)</span> 时，均能找到 <span class="math inline">\(i \geq 0\)</span>，使得 <span class="math inline">\(i\)</span>，<span class="math inline">\(u v^i w x^i y \notin L\)</span>。</li></ol><h2 id="ogden-引理">Ogden 引理</h2><p>对于任意的 CFL <span class="math inline">\(L\)</span>，存在仅仅依赖于 <span class="math inline">\(L\)</span> 的正整数 <span class="math inline">\(N\)</span>，对于任意的 <span class="math inline">\(z \in L\)</span>，当 <span class="math inline">\(z\)</span> 中至少含有 <span class="math inline">\(N\)</span> 个特异点时，存在 <span class="math inline">\(u, v, w, x, y\)</span>，使得 <span class="math inline">\(z = uvwxy\)</span>，同时满足：</p><ol type="1"><li><span class="math inline">\(|vwx|\)</span> 中的特异点的数目 <span class="math inline">\(\leq N\)</span>；</li><li><span class="math inline">\(|vx|\)</span> 中的特异点的数目 <span class="math inline">\(\geq 1\)</span>；</li><li>对于任意的非负整数 <span class="math inline">\(i\)</span>，<span class="math inline">\(u v^i w x^i y \in L\)</span>。</li></ol><h2 id="cfl-在并乘积闭包运算下是封闭的但在交运算下不封闭">CFL 在并、乘积、闭包运算下是封闭的，但在交运算下不封闭</h2><h2 id="cyk-algorithm">CYK Algorithm</h2><p>输入：CNF <span class="math inline">\(G = (V, T, P, S)\)</span>，<span class="math inline">\(x\)</span>； 输出：<span class="math inline">\(x \in L\)</span> 或者 <span class="math inline">\(x \notin L\)</span>；</p><p><span class="math inline">\(V_{i,k}\)</span>：可以派生出子串 <span class="math inline">\(x_{i,k}\)</span> 的变量集合，<span class="math inline">\(x_{i,k}\)</span> 表示从 <span class="math inline">\(i\)</span> 开始，长度为 <span class="math inline">\(k\)</span> 的子串。</p><ol type="1"><li><code>for i = 1 in |x|</code> <span class="math inline">\(V_{i,1} = \{A \mid A \to x_{i,1} \in P\}\)</span></li><li><code>for k = 2 in |x| &#123;for i = 1 to |x| - k + 1&#125;</code> $V_{i,k} = $<ol type="1"><li><code>for j = 1 to k - 1</code> <span class="math inline">\(V_{i,k} = V_{i,k} \cup \{A \mid A \to BC \text{ and } B \in V_{i,j} \text{ and } C \in V_{i + j,k - j}\}\)</span></li></ol></li></ol><h2 id="hw13">hw13</h2><p><strong>题目1：</strong> 使用CFL的泵引理证明 <span class="math inline">\(L = \{ ww \mid w \in \{a, b\}^{\ast} \}\)</span> 不是上下文无关语言.</p><p><strong>解答1：</strong></p><p>我们使用 CFL 的泵引理来证明 <span class="math inline">\(L = \{ ww \mid w \in \{a, b\}^\ast \}\)</span> 不是上下文无关语言。</p><p>假设 <span class="math inline">\(L\)</span> 是一个上下文无关语言，则它满足 CFL 的泵引理。</p><p>设 <span class="math inline">\(N\)</span> 为泵引理中的 <span class="math inline">\(N\)</span>，取句子 $ z = a^{N} b^{N} a^{N} b^{N} L $</p><p>接下来分析 <span class="math inline">\(vwx\)</span> 的各种取值：</p><ol type="1"><li>因为 <span class="math inline">\(|vwx| \leq N\)</span>，不妨先假设 <span class="math inline">\(vwx \subseteq a^{N}\)</span> 或者 <span class="math inline">\(b^{N}\)</span>，显然对于 <span class="math inline">\(\forall i &gt; 0\)</span>，都会破坏 <span class="math inline">\(L\)</span> 的结构，即要求 <span class="math inline">\(ww \in L\)</span>。<br><br></li><li>然后再分析 <span class="math inline">\(vwx\)</span> 跨越了 <span class="math inline">\(a\)</span> 部分或者 <span class="math inline">\(b\)</span> 部分，由于 <span class="math inline">\(|vwx| \leq N\)</span>，可以证明 <span class="math inline">\(vwx\)</span> 最多横跨一个 <span class="math inline">\(a\)</span> 和一个 <span class="math inline">\(b\)</span>，也即是类似 <span class="math inline">\(a \cdots ab \cdots b\)</span> 和 <span class="math inline">\(b \cdots ba \cdots a\)</span> 的结构；<br><br><ol type="1"><li>假设 <span class="math inline">\(vwx\)</span> 横跨第一个 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>。设 $ v = a^{m}, , x = b^{n}$，则 <span class="math inline">\(\forall i &gt; 0\)</span>，<span class="math inline">\(u a^{im} w b^{in} y \notin L\)</span>，这很好证明：此时 <span class="math inline">\(u a^{im} w b^{in} y\)</span> 可以写成 <span class="math inline">\(a^{N + im} b^{N + in} a^{N} b^{N}\)</span> 的形式，为了保证 <span class="math inline">\(ww\)</span> 的结构，只能如此分割 <span class="math inline">\(a^{N + im} b^{N + in}\)</span> 和 <span class="math inline">\(a^{N} b^{N}\)</span>，因为 <span class="math inline">\(|vx| \geq 1\)</span>，所以不存在 <span class="math inline">\(i\)</span> 使得分割后得两个句子相等；<br><br></li><li>同理可以证明 <span class="math inline">\(vwx\)</span> 横跨第二个 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 时同样不满足泵引理；<br><br></li><li>对于 <span class="math inline">\(vwx\)</span> 横跨第一个 <span class="math inline">\(b\)</span> 和 第二个 <span class="math inline">\(a\)</span> 的情况，此时 <span class="math inline">\(u a^{im} w b^{in} y\)</span> 可以写成 <span class="math inline">\(a^{N} b^{N + im} a^{N + in} b^{N}\)</span> 的形式，同样为了保证 <span class="math inline">\(ww\)</span> 的结构，只能如此分割 <span class="math inline">\(a^{N} b^{N + im}\)</span> 和 <span class="math inline">\(a^{N + in} b^{N}\)</span>，显然分割后的句子不相等，也就是不满足泵引理。<br><br></li></ol></li></ol><p>综上，<span class="math inline">\(L\)</span> 不是 CFL。</p><p><strong>题目2：</strong> 给定文法 <span class="math inline">\(G\)</span> 如下：</p><p>[ <span class="math display">\[\begin{align*}&amp;S \to AB \,|\, AA \,|\, BC \\&amp;A \to CD \,|\, a \\&amp;B \to BD \,|\, SB \,|\, b \\&amp;C \to c \\&amp;D \to DB \,|\, b\end{align*}\]</span> ]</p><p>根据算法 CYK 算法，请识别字符串“aabbc”是否属于 <span class="math inline">\(L(G)\)</span>?</p><p><strong>解答2：</strong> <span class="math inline">\(x = \text{&quot;aabbc&quot;}\)</span>，长度 <span class="math inline">\(|x| = 5\)</span>。</p><p>构造一个二维表 <span class="math inline">\(V_{i,k}\)</span>，其中 <span class="math inline">\(V_{i,k}\)</span> 表示从位置 <span class="math inline">\(i\)</span> 开始，长度为 <span class="math inline">\(k\)</span> 的子串可以由哪些非终结符生成。</p><ol type="1"><li><strong>第一步：处理长度为 1 的子串</strong><br>根据文法的终结符规则，填充 <span class="math inline">\(V_{i,1}\)</span>：<ul><li><span class="math inline">\(x_1 = a \implies V_{1,1} = \{A\}\)</span></li><li><span class="math inline">\(x_2 = a \implies V_{2,1} = \{A\}\)</span></li><li><span class="math inline">\(x_3 = b \implies V_{3,1} = \{B, D\}\)</span></li><li><span class="math inline">\(x_4 = b \implies V_{4,1} = \{B, D\}\)</span></li><li><span class="math inline">\(x_5 = c \implies V_{5,1} = \{C\}\)</span></li></ul></li><li><strong>第二步：处理长度为 2 的子串</strong><br>根据文法的组合规则，填充 <span class="math inline">\(V_{i,2}\)</span>：<ul><li><span class="math inline">\(x_{1,2} = &quot;aa&quot; \implies V_{1,2} = \{S\}\)</span> （因为 <span class="math inline">\(A \to AA\)</span>）</li><li><span class="math inline">\(x_{2,2} = &quot;ab&quot; \implies V_{2,2} = \{B\}\)</span> （因为 <span class="math inline">\(S \to AB\)</span>）</li><li><span class="math inline">\(x_{3,2} = &quot;bb&quot; \implies V_{3,2} = \{B, D\}\)</span> （因为 <span class="math inline">\(B \to BD\)</span> 和 <span class="math inline">\(D \to DB\)</span>）</li><li><span class="math inline">\(x_{4,2} = &quot;bc&quot; \implies V_{4,2} = \{S\}\)</span> （因为 <span class="math inline">\(S \to BC\)</span>）</li></ul></li><li><strong>第三步：处理长度为 3 的子串</strong><br>根据文法的组合规则，填充 <span class="math inline">\(V_{i,3}\)</span>：<ul><li><span class="math inline">\(x_{1,3} = &quot;aab&quot; \implies V_{1,3} = \{B\}\)</span> （因为 <span class="math inline">\(S \to AB\)</span>）</li><li><span class="math inline">\(x_{2,3} = &quot;abb&quot; \implies V_{2,3} = \{S\}\)</span> （因为 <span class="math inline">\(S \to AB\)</span> 和 <span class="math inline">\(B \to SB\)</span>）</li><li><span class="math inline">\(x_{3,3} = &quot;bbc&quot; \implies V_{3,3} = \{S\}\)</span> （因为 <span class="math inline">\(S \to BC\)</span>）</li></ul></li><li><strong>第四步：处理长度为 4 的子串</strong><br>根据文法的组合规则，填充 <span class="math inline">\(V_{i,4}\)</span>：<ul><li><span class="math inline">\(x_{1,4} = &quot;aabb&quot; \implies V_{1,4} = \{S\}\)</span> （因为 <span class="math inline">\(S \to AB\)</span> 和 <span class="math inline">\(B \to SB\)</span>）</li><li><span class="math inline">\(x_{2,4} = &quot;abbc&quot; \implies V_{2,4} = \{S\}\)</span> （因为 <span class="math inline">\(S \to BC\)</span>）</li></ul></li><li><strong>第五步：处理长度为 5 的子串</strong><br>根据文法的组合规则，填充 <span class="math inline">\(V_{1,5}\)</span>：<ul><li><span class="math inline">\(x_{1,5} = &quot;aabbc&quot; \implies V_{1,5} = \{S\}\)</span> （因为 <span class="math inline">\(S \to AB\)</span> 和 <span class="math inline">\(B \to SB\)</span>）</li></ul></li></ol><p>最终，<span class="math inline">\(V_{1,5}\)</span> 包含 <span class="math inline">\(S\)</span>，因此字符串 “aabbc” 属于文法 <span class="math inline">\(G\)</span> 的语言 <span class="math inline">\(L(G)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>形式语言与自动机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大熵模型</title>
    <link href="/2025/06/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/06/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="logistic-regression">Logistic Regression</h2><h3 id="logistic-distribution">Logistic Distribution</h3><p>设<span class="math inline">\(X\)</span>是连续随机变量，<span class="math inline">\(X\)</span>服从 <strong>logistic distribution</strong> 是指<span class="math inline">\(X\)</span>具有下列分布函数和密度函数：</p><p><span class="math display">\[\begin{align}F(x) &amp;= P(X \leq x) = \frac{1}{1 + e^{-(x-\mu)/\gamma}} \tag{1}\\f(x) &amp;= F&#39;(x) = \frac{e^{-(x-\mu)/\gamma}}{\gamma\left(1 + e^{-(x-\mu)/\gamma}\right)^2} \tag{2}\end{align}\]</span></p><h3 id="binomial-logistic-regression-model">Binomial Logistic Regression Model</h3><p>这是一种二分类模型，这里规定模型输出 <span class="math inline">\(Y \in \{0, 1\}\)</span>， 也就是 <span class="math inline">\(y_i \in \{0, 1\}\)</span></p><p><span class="math display">\[\begin{align}P(Y = 0 | \mathbf{x}) &amp;= \frac{1}{1 + \exp (\mathbf{w} \cdot \mathbf{x} + b)} \tag{3}\\P(Y = 1 | \mathbf{x}) &amp;= \frac{\exp (\mathbf{w} \cdot \mathbf{x} + b)}{1 + \exp (\mathbf{w} \cdot \mathbf{x} + b)} \tag{4}\end{align}\]</span></p><p>其中，<span class="math inline">\(\mathbf{x} \in \mathbb{R}^n\)</span> 是输入，<span class="math inline">\(\mathbf{w} \in \mathbb{R}^n\)</span> 和 $ b $ 分别是权值向量和偏置，<span class="math inline">\(\mathbf{w} \cdot \mathbf{x}\)</span> 是向量内积运算。</p><h3 id="evaluation-of-model-parameters">Evaluation of Model Parameters</h3><p>采用极大似然估计法估计模型参数，从而得到 <strong><em>logistics regression model</em></strong>。</p><p>我们设</p><p><span class="math display">\[P(Y = 1 | x) = \pi(x) \tag{5}\]</span></p><p>则得到似然函数为</p><p><span class="math display">\[\prod_{i=1}^{N}[\pi(x_i)]^{y_i}[1 - \pi(x_i)]^{1 - y_i} \tag{6}\]</span></p><p>经过计算，对数似然函数为</p><p><span class="math display">\[L(w) = \sum_{i=1}^{N} [y_i(\vec{w} \cdot \vec{x_i}) - \ln (1 + \exp (\vec{w} \cdot \vec{x_i}))] \tag{7}\]</span></p><p>对 <span class="math inline">\(L(w)\)</span> 求极大值，得到 <span class="math inline">\(w\)</span> 的估计值 <span class="math inline">\(\hat{w}\)</span></p><hr><h2 id="maximum-entropy-model">Maximum Entropy Model</h2><h3 id="the-principle-of-maximum-entropy">The Principle of Maximum Entropy</h3><p>最大熵原理的核心在于，使得整个概率模型的熵最大。</p><h3 id="maxentropy-model">MaxEntropy Model</h3><p>模型输入 <span class="math inline">\(X \in \mathcal{X} \subseteq \mathbb{R}^n\)</span>，输出 <span class="math inline">\(Y \in \mathcal{Y}\)</span>，条件概率分布 <span class="math inline">\(P(Y | X)\)</span> 表示对于给定输入 <span class="math inline">\(X\)</span> 以该条件概率输出 <span class="math inline">\(Y\)</span>。</p><p>给定训练数据集，可以确定联合分布 <span class="math inline">\(P(X, Y)\)</span> 的经验分布和边缘分布。</p><p><span class="math display">\[\begin{align}\tilde{P}(X = x, Y = y) &amp;= \frac{\nu(X = x, Y = y)}{N} \tag{8}\\\tilde{P}(X = x) &amp;= \frac{\nu(X = x)}{N} \tag{9}\end{align}\]</span></p><p>其中 <span class="math inline">\(\nu(X = x, Y = y)\)</span> 是样本 <span class="math inline">\((x, y)\)</span> 出现的频数。</p><p>接下来介绍特征函数 <strong><em>feature function</em></strong> <span class="math inline">\(f(x,y)\)</span>，<span class="math inline">\(f()\)</span> 描述输入 <span class="math inline">\(x\)</span> 与输出 <span class="math inline">\(y\)</span> 之间的某一个事实。</p><p><span class="math display">\[f(x, y) =\begin{cases}1, &amp;\text{satisfying}\\0, &amp;\text{otherwise} \tag{10}\end{cases}\]</span></p><p>特征函数关于经验分布的期望值</p><p><span class="math display">\[E_{\tilde{P}}(f) = \sum_{x,y} \tilde{P}(x,y) f(x,y) \tag{11}\]</span></p><p>特征函数关于模型与经验分布的期望值</p><p><span class="math display">\[E_P(f) = \sum_{x,y} \tilde{P}(x) P(y|x) f(x,y) \tag{12}\]</span></p><p>如果模型能够获得训练数据中的信息，则可以认为上述两个期望值相等，即</p><p><span class="math display">\[E_{\tilde{P}}(f) = E_P(f) \tag{13}\]</span></p><p>综上，我们引出最大熵模型。</p><p>假设满足所有约束条件的模型集合为</p><p><span class="math display">\[\mathcal{C} \equiv \{P \in \mathcal{P} \mid E_{\tilde{P}}(f_i) = E_P(f_i), \quad i=1,2,\dots,n\} \tag{14}\]</span></p><p>定义在条件概率分布 <span class="math inline">\(P(Y|X)\)</span> 上的条件熵为</p><p><span class="math display">\[H(P) = -\sum_{x,y} \tilde{P}(x) P(y|x) \ln P(y|x) \tag{15}\]</span></p><p>则模型集合 <span class="math inline">\(\mathcal{C}\)</span> 中条件熵 <span class="math inline">\(H(P)\)</span> 最大的模型称为最大熵模型。</p><h3 id="training-a-maximum-entropy-model">Training a Maximum Entropy Model</h3><p>类似 <strong>SVM</strong> 的学习过程。给定训练数据集 <span class="math inline">\(T = \{(x_1,y_1),(x_2,y_2),\dots,(x_N,y_N)\}\)</span> 以及特征函数 <span class="math inline">\(f_i(x,y), \quad i = 1, 2, \dots, n\)</span>，最大熵模型的学习等价于约束最优化问题：</p><p><span class="math display">\[\begin{align*}\max_{P \in \mathcal{C}} \quad &amp; H(P) = -\sum_{x, y} \tilde{P}(x) P(y \mid x) \ln P(y \mid x)\\\text{subject to} \quad &amp; E_{\tilde{P}}[f_i] = E_P[f_i], \quad i = 1, 2, \dots, n\\&amp; \sum_{y} P(y \mid x) = 1\end{align*}\]</span></p><p>将其换为等价的最小化问题</p><p><span class="math display">\[\begin{align*}\min_{P \in \mathcal{C}} \quad -&amp;H(P) = \sum_{x, y} \tilde{P}(x) P(y \mid x) \ln P(y \mid x) \tag{16}\\\text{subject to} \quad &amp; E_{\tilde{P}}[f_i] - E_P[f_i]= 0, \quad i = 1, 2, \dots, n \tag{17}\\&amp; \sum_{y} P(y \mid x) = 1 \tag{18}\end{align*}\]</span></p><p>将约束最优化问题转换为无约束最优化的对偶问题。引入拉格朗日乘子 <span class="math inline">\(w_0, w_1, \dots, w_n\)</span>，定义拉格朗日函数 <span class="math inline">\(L(P, w)\)</span>：</p><p><span class="math display">\[\begin{align*}L(P, w) &amp;\equiv -H(P) + w_0 \left(1 - \sum_{y} P(y | x)\right) + \sum_{i = 1}^{n} w_i (E_{\tilde{P}}(f_i) - E_{P}(f_i)) \tag{19}\\&amp;= \sum_{x,y} \tilde{P}(x) P(y | x) \ln P(y | x) + w_0\left(1 - \sum_{y} P(y | x)\right) +\\&amp;\sum_{i = 1}^{n} w_i\left(\sum_{x, y} \tilde{P}(x, y) f_i(x, y) - \sum_{x, y} \tilde{P}(x) P(y | x) f_i(x, y) \right)\end{align*}\]</span></p><p>最优化的原始问题是</p><p><span class="math display">\[\min_{P \in \mathcal{C}} \max_{w} L(P, w) \tag{20}\]</span></p><p>对偶问题是</p><p><span class="math display">\[\max_{w} \min_{P \in \mathcal{C}} L(P, w) \tag{21}\]</span></p><p>先解决极小化问题， 记</p><p><span class="math display">\[\Psi(w) = \min_{P \in \mathcal{C}} L(P, w) = L(P_w, w) \tag{22}\]</span></p><p>求 <span class="math inline">\(L(P, w)\)</span> 对 <span class="math inline">\(P(y | x)\)</span> 的偏导数</p><p><span class="math display">\[\begin{align*}\frac{\partial L(P, w)}{\partial P(y | x)} &amp;= \sum_{x, y} \tilde{P}(x)(\ln P(y | x) + 1) - \sum_{y}w_0 - \sum_{x, y} \left(\tilde{P}(x) \sum_{i = 1}^{n} w_i f_i(x, y) \right)\\&amp;= \sum_{x, y} \tilde{P}(x) \left(\ln P(y | x) + 1 - w_0 - \sum_{i = 1}^{n} w_i f_i(x, y) \right)\end{align*}\]</span></p><p>令偏导数等于 <span class="math inline">\(0\)</span>， 在 <span class="math inline">\(\tilde{P} &gt; 0\)</span> 的情况下，解得</p><p><span class="math display">\[P_w(y | x) = \frac{1}{Z_w(x)} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right) \tag{23}\]</span></p><p>其中</p><p><span class="math display">\[Z_w(x) = \sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right) \tag{24}\]</span></p><p>称 <span class="math inline">\(Z_w(x)\)</span> 为归一化因子。</p><p>最后求解对偶问题外部的极大化问题</p><p><span class="math display">\[\max_{w} \Psi(w) \tag{25}\]</span></p><h3 id="improved-iterative-scaling">Improved Iterative Scaling</h3><p>已知最大熵模型</p><p><span class="math display">\[P_w(y | x) = \frac{1}{Z_w(x)} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)\]</span></p><p>其中</p><p><span class="math display">\[Z_w(x) = \sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)\]</span></p><p>对数似然函数为</p><p><span class="math display">\[L(w) = \sum_{x, y} \tilde{P}(x, y) \sum_{i = 1}^{n} w_i f_i(x, y) - \sum_{x} \tilde{P}(x) \ln Z_w(x)\]</span></p><p>改进迭代算法的思路是，假设最大熵模型当前的参数向量是 <span class="math inline">\(w = (w_1, w_2, \dots, w_n)^{T}\)</span>，我们希望找到一个新的参数向量 <span class="math inline">\(w + \delta = (w_1 + \delta_1, \dots, w_n + \delta_n)^{T}\)</span>，使得模型的对数似然函数增值。</p><p><strong>算法步骤</strong></p><p><strong>输入</strong>：特征函数 <span class="math inline">\(f_1, f_2, \dots, f_n\)</span>；经验分布 <span class="math inline">\(\tilde{P}(X, Y)\)</span>；模型 <span class="math inline">\(P_w(y | x)\)</span></p><p><strong>输出</strong>：最优参数值 <span class="math inline">\(w_i^{\ast}\)</span>；最优模型 <span class="math inline">\(P_{w^{\ast}}\)</span></p><p><strong>步骤1</strong>：对所有 <span class="math inline">\(i \in \{1, 2, \dots, n\}\)</span>，取初值 <span class="math inline">\(w_i = 0\)</span>。</p><p><strong>步骤2</strong>：对每一 <span class="math inline">\(i \in \{1, 2, \dots, n\}\)</span>，执行以下操作：</p><p>首先，令 <span class="math inline">\(\delta_i\)</span> 为下列方程的解：</p><p><span class="math display">\[\sum_{x, y} \tilde{P}(x) P(y | x) f_i(x, y) \exp \left(\delta_i f^{\Sigma}(x, y) \right) = E_{\tilde{P}}(f_i)\]</span></p><p>其中，<span class="math inline">\(f^{\Sigma}(x, y)\)</span> 定义为：</p><p><span class="math display">\[f^{\Sigma}(x, y) = \sum_{i = 1}^{n} f_i(x, y)\]</span></p><p>然后，更新 <span class="math inline">\(w_i\)</span> 的值：</p><p><span class="math display">\[w_i \leftarrow w_i + \delta_i\]</span></p><p><strong>步骤3</strong>：如果不是所有 <span class="math inline">\(w_i\)</span> 都收敛，则重复步骤2。</p><h3 id="quasi-newton-method-bfgs">Quasi-Newton Method : BFGS</h3><p>对最大熵模型而言，</p><p><span class="math display">\[P_w(y | x) = \frac{\exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)}{\sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right)}\]</span></p><p>目标函数：</p><p><span class="math display">\[\min_{w \in \mathbb{R}^n} f(w) = \sum_{x} \tilde{P}(x) \ln \sum_{y} \exp \left(\sum_{i = 1}^{n} w_i f_i(x, y) \right) - \sum_{x, y} \tilde{P}(x, y) \sum_{i = 1}^{n} w_i f_i(x, y)\]</span></p><p>相应 <span class="math inline">\(i\)</span> 的梯度有，</p><p><span class="math display">\[\frac{\partial f(w)}{\partial w_i} = \sum_{x, y} \tilde{P}(x) P_w(y | x) f_i(x, y) - E_{\tilde{p}}(f_i)\]</span></p><p>定义 <span class="math inline">\(g()\)</span></p><p><span class="math display">\[g(w) = \left(\frac{\partial f(x)}{\partial w_1}, \frac{\partial f(x)}{\partial w_2}, \dots,\frac{\partial f(x)}{\partial w_n} \right)^T\]</span></p><p><strong>算法步骤</strong></p><p><strong>输入</strong>：特征函数 <span class="math inline">\(f_1, f_2, \dots, f_n\)</span>；经验分布 <span class="math inline">\(\tilde{P}(X, Y)\)</span>；目标函数 <span class="math inline">\(f(w)\)</span>；梯度 <span class="math inline">\(g(w) = \nabla f(w)\)</span>；精度要求 <span class="math inline">\(\epsilon\)</span>； <strong>输出</strong>：最优参数值 <span class="math inline">\(w_i^{\ast}\)</span>；最优模型 <span class="math inline">\(P_{w^{\ast}}\)</span></p><ol type="1"><li>选定初始点 <span class="math inline">\(w^{(0)}\)</span>，取 <span class="math inline">\(B_0\)</span> 为正定对称矩阵，置 <span class="math inline">\(k = 0\)</span>。</li><li>计算 <span class="math inline">\(g_k = g(w^{(k)})\)</span>。<br>若 <span class="math inline">\(\lVert g_k \rVert &lt; \epsilon\)</span>，则停止计算，得 <span class="math inline">\(w^{*} = w^{(k)}\)</span>；否则转第 3 步。</li><li>由 <span class="math inline">\(B_k p_k = -g_k\)</span> 求出 <span class="math inline">\(p_k\)</span>。</li><li>一维搜索，求 <span class="math inline">\(\lambda_k\)</span> 使得 <span class="math display">\[ f(w^{(k)} + \lambda_k p_k) = \min_{\lambda \geq 0} f(w^{(k)} + \lambda p_k) \]</span></li><li>置 <span class="math inline">\(w^{(k + 1)} = w^{(k)} + \lambda_k p_k\)</span>。</li><li>计算 <span class="math inline">\(g_{k + 1} = g(w^{(k + 1)})\)</span>。<br>若 <span class="math inline">\(\lVert g_{k + 1} \rVert &lt; \epsilon\)</span>，则停止计算，得 <span class="math inline">\(w^{*} = w^{(k + 1)}\)</span>；否则，按下式求出 <span class="math inline">\(B_{k + 1}\)</span>： <span class="math display">\[ B_{k + 1} = B_k + \frac{y_k y_k^T}{y_k^T \delta_k} - \frac{B_k \delta_k \delta_k^T B_k}{\delta_k^T B_k \delta_k} \]</span> 其中， <span class="math display">\[ y_k = g_{k + 1} - g_k, \quad \delta_k = w^{(k + 1)} - w^{(k)} \]</span></li><li>置 <span class="math inline">\(k = k + 1\)</span>，转第 3 步。</li></ol><p><strong>补充说明</strong></p><p>在 BFGS 算法中，<span class="math inline">\(B_k\)</span> 是对目标函数 <strong><em>Hessian</em></strong> 矩阵的近似。初始时 <span class="math inline">\(B_0\)</span> 通常取为单位矩阵或其他对称正定矩阵。每次迭代后，<span class="math inline">\(B_k\)</span> 按如下公式更新：</p><p><span class="math display">\[B_{k + 1} = B_k + \frac{y_k y_k^T}{y_k^T \delta_k} - \frac{B_k \delta_k \delta_k^T B_k}{\delta_k^T B_k \delta_k}\]</span></p><p>其中， - <span class="math inline">\(\delta_k = w^{(k + 1)} - w^{(k)}\)</span> 表示参数的变化， - <span class="math inline">\(y_k = g_{k + 1} - g_k\)</span> 表示梯度的变化。</p><p><span class="math inline">\(B_k\)</span> 的更新保证了其对称正定性，并逐步逼近真实的 Hessian 矩阵，从而提升搜索方向的准确性和收敛速度。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件随机场</title>
    <link href="/2025/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/"/>
    <url>/2025/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>本章仅讨论条件随机场在 <strong>标注问题（tagging problem）</strong> 的应用，因此主要讲述 <strong>线性链（linear chain）</strong> 条件随机场。</p><h2 id="概率无向图模型">概率无向图模型</h2><h3 id="成对马尔可夫性">成对马尔可夫性</h3><p>节点 <span class="math inline">\(u\)</span>、<span class="math inline">\(v\)</span> 和所有其他节点 <span class="math inline">\(O\)</span>，对应的随机变量分别为 <span class="math inline">\(Y_u\)</span>、<span class="math inline">\(Y_v\)</span>、<span class="math inline">\(Y_O\)</span>（<span class="math inline">\(Y\)</span> 表示随机变量）。它们具有以下概率关系： <span class="math display">\[P(Y_u, Y_v | Y_O) = P(Y_u | Y_O) P(Y_v | Y_O)\]</span></p><h3 id="局部马尔可夫性">局部马尔可夫性</h3><p>节点 <span class="math inline">\(v\)</span>，<span class="math inline">\(W\)</span> 是与 <span class="math inline">\(v\)</span> 相邻的所有节点，<span class="math inline">\(O\)</span> 是其余节点。它们具有以下概率关系： <span class="math display">\[P(Y_v, Y_O | Y_W) = P(Y_v | Y_W) P(Y_O | Y_W)\]</span></p><h3 id="全局马尔可夫性">全局马尔可夫性</h3><p>节点集合 <span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>、<span class="math inline">\(C\)</span>，其中 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 被 <span class="math inline">\(C\)</span> 分离。它们具有以下概率关系： <span class="math display">\[P(Y_A, Y_B | Y_C) = P(Y_A | Y_C) P(Y_B | Y_C)\]</span></p><h3 id="definition-概率无向图模型">Definition: 概率无向图模型</h3><p>如果联合概率分布 <span class="math inline">\(P(Y)\)</span> 满足上述三个马尔可夫性质，就称此联合概率分布为概率无向图模型。</p><h3 id="definition-团与最大团">Definition: 团与最大团</h3><p><strong>团（Clique）：</strong> 图中的一个子集，其中任意两个节点都相邻连接。</p><p><strong>最大团（Maximum Clique）：</strong> 不能再添加其他节点的团，即包含所有可能相邻节点的最大子集。</p><h3 id="概率无向图模型的因子分解">概率无向图模型的因子分解</h3><p><span class="math display">\[\begin{align}P(Y) &amp;= \frac{1}{Z} \prod_{C} \psi_{C}(Y_C), \quad C \text{ is a maximum clique}\\Z &amp;= \sum_{Y} \prod_{C} \psi_{C}(Y_C), \quad Z \text{ is normalization factor}\\\psi_{C}(Y_C) &amp;= \exp\{-E(Y_C) \}\end{align}\]</span></p><p>其中，<span class="math inline">\(\psi\)</span> 函数称为<strong>势函数</strong>，常用<strong>指数函数</strong>定义势函数。</p><p><span class="math display">\[\psi_{C}(Y_{C}) = e ^{- H_{C}(Y_{C})}\]</span></p><p><span class="math inline">\(H_{C}(Y_{C})\)</span> 是一个定义在变量 <span class="math inline">\(Y_{C}\)</span> 上的实值函数，常见形式为</p><p><span class="math display">\[H_{C}(Y_{C}) = \sum_{u,v \in C, u \neq v} \alpha_{uv} x_u x_v + \sum_{v \in C} \beta_v x_v\]</span></p><p>其中，<span class="math inline">\(\alpha_{uv}\)</span> 和 <span class="math inline">\(\beta_{v}\)</span> 是参数。</p><hr><h2 id="crf">CRF</h2><h3 id="definition-线性链条件随机场">Definition: 线性链条件随机场</h3><p>我们假设 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是随机变量。如果随机变量 <span class="math inline">\(Y\)</span> 是一个马尔可夫随机场，即满足： <span class="math display">\[P(Y_v | X, Y_w, w \neq v) = P(Y_v | X, Y_w, w \sim v)\]</span> 其中 <span class="math inline">\(w \sim v\)</span> 表示节点 <span class="math inline">\(v\)</span> 与节点 <span class="math inline">\(w\)</span> 相邻。</p><blockquote><p>通常情况下，我们认为 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 具有相同的结构。</p></blockquote><p>我们有如下概率关系。 <span class="math display">\[P(Y_i | X, Y_1, \dots, Y_{i-1}, Y_{i+1}, \dots, Y_n) = P(Y_i | X, Y_{i - 1}, Y_{i + 1})\]</span></p><h3 id="条件随机场的参数化形式">条件随机场的参数化形式</h3><p><span class="math display">\[P(\mathbf{y} | \mathbf{x}) = \frac{1}{Z(\mathbf{x})} \exp \left(\sum_{i,k}\lambda_k t_k(y_{i -1}, y_i, \mathbf{x}, i) + \sum_{i,l}\mu_l s_l(y_i, \mathbf{x}, i))\right)\]</span></p><p>其中，</p><p><span class="math display">\[Z(\mathbf{x}) = \sum_{\mathbf{y}} \exp \left(\sum_{i,k}\lambda_k t_k(y_{i -1}, y_i, \mathbf{x}, i) + \sum_{i,l}\mu_l s_l(y_i, \mathbf{x}, i)\right)\]</span></p><p>其中，<span class="math inline">\(t_k\)</span> 和 <span class="math inline">\(s_l\)</span> 是特征函数，<span class="math inline">\(\lambda_k\)</span> 和 <span class="math inline">\(\mu_l\)</span> 是对应的权重参数。</p><p><strong>Simplification</strong></p><p><span class="math display">\[f_k(y_{i-1}, y_i, \mathbf{x}, i) =\begin{cases}t_k(y_{i-1}, y_i, \mathbf{x}, i), \quad &amp;k = 1,2, \dots,K_1 \\\\s_l(y_i, \mathbf{x}, i), \quad &amp;k = K_1 + l; \text{ } l = 1,2,\dots, K_2\end{cases}\]</span></p><p><span class="math display">\[f_k(\mathbf{y}, \mathbf{x}) = \sum_{i=1}^{n} f_k(y_{i-1}, y_i, \mathbf{x}, i), \quad k = 1,2,\dots,K\]</span></p><p><span class="math display">\[w_k =\begin{cases}\lambda_k, &amp;k = 1,2,\dots,K_1 \\\\\mu_l, &amp;k = K_1 + l; \text{ } l = 1, 2, \dots, K_2\end{cases}\]</span> 即，</p><p><span class="math display">\[\begin{align*}P(\mathbf{y} \mid \mathbf{x}) &amp;= \frac{1}{Z(\mathbf{x})} \exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right) \\\\Z(\mathbf{x}) &amp;= \sum_{\mathbf{y}} \exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right)\end{align*}\]</span> 注意，这里的 <span class="math inline">\(\sum_{\mathbf{y}}\)</span> 是在对所有可能的标签序列求和，而不仅仅是一个确定的标签序列。</p><p>最后，</p><p><span class="math display">\[\begin{align}P_{\mathbf{w}}(\mathbf{y} \mid \mathbf{x}) = \frac{\exp(\vec{w} \cdot \vec{F}(\mathbf{y}, \mathbf{x}))}{Z_{\mathbf{w}}(\mathbf{x})}\end{align}\]</span></p><p><span class="math display">\[Z_{\mathbf{w}}(\mathbf{x}) = \sum_{\mathbf{y}} \exp(\vec{w} \cdot \vec{F}(\mathbf{y}, \mathbf{x}))\]</span></p><h3 id="矩阵形式">矩阵形式</h3><p>对于每个标签序列，我们引入特殊的起始点和结束点标签，<span class="math inline">\(y_0 = \text{start}\)</span> 和 <span class="math inline">\(y_{n+1} = \text{stop}\)</span>。对于观测序列 <span class="math inline">\(\mathbf{x}\)</span> 中的每个位置 <span class="math inline">\(i = 1,2,\dots,n+1\)</span>，我们可以定义一个矩阵 <span class="math inline">\(M_i \in \mathbb{R}^{m \times m}\)</span>：</p><p><span class="math display">\[\begin{align*}M_i(\mathbf{x}) &amp;= [M_i(y_{i-1}, y_i | \mathbf{x})]\\\\M_i(y_{i-1}, y_i |\mathbf{x}) &amp;= \exp \left(W_i(y_{i-1}, y_i | \mathbf{x})\right)\\\\W_i(y_{i-1}, y_i |\mathbf{x}) &amp;= \sum_{k=1}^{K}w_kf_k(y_{i-1},y_i,\mathbf{x},i)\end{align*}\]</span></p><p>因此： <span class="math display">\[P_w(\mathbf{y} |\mathbf{x}) = \frac{1}{Z_w(\mathbf{x})} \prod_{i=1}^{n+1} M_i(y_{i-1}, y_i |\mathbf{x})\]</span></p><p>特别地： <span class="math display">\[Z_w(\mathbf{x}) = [M_1(\mathbf{x})M_2(\mathbf{x}) \cdots M_{n+1}(\mathbf{x})]_{\text{start},\text{stop}}\]</span></p><p>也就是矩阵 <span class="math inline">\((\text{start}, \text{stop})\)</span> 位置上的元素。</p><p>矩阵形式不难理解，CRF 中的 <span class="math inline">\(M_i(\mathbf{x})\)</span> 矩阵就是在每个位置 <span class="math inline">\(i\)</span> 上，枚举所有可能的标签对 <span class="math inline">\((y_{i-1}, y_i)\)</span>，并计算它们的转移得分。例如 <span class="math inline">\(m = 2\)</span>，<span class="math inline">\(Y = \{A, B\}\)</span>，则 <span class="math inline">\(M_1\)</span> 为：</p><p><span class="math display">\[M_1(\mathbf{x}) =\begin{bmatrix}M_1(A, A \mid \mathbf{x}) &amp; M_1(A, B \mid \mathbf{x}) \\\\M_1(B, A \mid \mathbf{x}) &amp; M_1(B, B \mid \mathbf{x})\end{bmatrix}\]</span></p><hr><h2 id="计算">计算</h2><p>接下来给出计算 <span class="math inline">\(P(Y_i = y_i |\mathbf{x})\)</span>、<span class="math inline">\(P(Y_{i - 1} = y_{i - 1}, Y_i = y_i |\mathbf{x})\)</span> 以及相应数学期望的解决方法。</p><h3 id="前向-后向算法">前向-后向算法</h3><p>对于每个索引 <span class="math inline">\(i = 0, 1, \dots, n + 1\)</span>，我们定义前向列向量 <span class="math inline">\(\alpha_i(x)\)</span>：</p><p><span class="math display">\[\alpha_0(y|\mathbf{x}) =\begin{cases}1, &amp;y = \text{start}\\\\0, &amp;\text{其他情况}\end{cases}\]</span></p><p>递推公式为：</p><p><span class="math display">\[\alpha_i^T(y_i|\mathbf{x}) = \alpha_{i-1}^T (y_{i-1}|\mathbf{x}) [M_i(y_{i-1},y_i|\mathbf{x})],\quad i = 1,2,\dots,n+1 \tag{forward}\]</span></p><p>同样地，我们定义后向行向量：</p><p><span class="math display">\[\begin{align}\beta_{n+1}(y_{n+1}|\mathbf{x}) &amp;=\begin{cases}1, &amp;y_{n+1} = \text{stop}\\\\0, &amp;\text{其他情况}\end{cases}\\\\\beta_i(y_i|\mathbf{x})&amp; = [M_{i+1}(y_i,y_{i+1}|\mathbf{x})] \beta_{i+1}(y_{i+1}|\mathbf{x}) \tag{backward}\end{align}\]</span></p><h3 id="概率计算">概率计算</h3><p><span class="math display">\[P(Y_i = y_i | \mathbf{x}) = \frac{\alpha_i^T(y_i | \mathbf{x}) \beta_i(y_i | \mathbf{x})}{Z(\mathbf{x})}\]</span></p><p><span class="math display">\[P(Y_{i-1} = y_{i-1}, Y_i = y_i |\mathbf{x}) = \frac{\alpha_{i-1}^T(y_{i-1} |\mathbf{x}) M_i(y_{i-1},y_i |\mathbf{x}) \beta_i(y_i |\mathbf{x})}{Z(\mathbf{x})}\]</span></p><p>其中：</p><p><span class="math display">\[Z(\mathbf{x}) = \alpha_n^T(\mathbf{x})\mathbf{1} = \mathbf{1}^T \beta_1(\mathbf{x})\]</span></p><p><strong>可以仿照隐马尔科夫模型计算相似问题时引入 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 矩阵</strong>，</p><h4 id="前向向量矩阵-alpha">前向向量矩阵 <span class="math inline">\(\alpha\)</span></h4><p><span class="math display">\[\alpha = \begin{bmatrix}\alpha_0(A) &amp; \alpha_0(B) &amp; \cdots &amp; \alpha_0(N) \\\\[10pt]\alpha_1(A) &amp; \alpha_1(B) &amp; \cdots &amp; \alpha_1(N) \\\\[10pt]\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\[10pt]\alpha_{n+1}(A) &amp; \alpha_{n+1}(B) &amp; \cdots &amp; \alpha_{n+1}(N)\end{bmatrix}^{T} \tag{CRF-1}\]</span></p><p>每一行表示在位置 <span class="math inline">\(i\)</span> 的前向向量 <span class="math inline">\(\alpha_i\)</span>，每一列对应一个标签 <span class="math inline">\(y_i \in \mathcal{Y}\)</span>。</p><h4 id="后向向量矩阵-beta">后向向量矩阵 <span class="math inline">\(\beta\)</span></h4><p><span class="math display">\[\beta = \begin{bmatrix}\beta_0(A) &amp; \beta_0(B) &amp; \cdots &amp; \beta_0(N) \\\\[10pt]\beta_1(A) &amp; \beta_1(B) &amp; \cdots &amp; \beta_1(N) \\\\[10pt]\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\[10pt]\beta_{n+1}(A) &amp; \beta_{n+1}(B) &amp; \cdots &amp; \beta_{n+1}(N)\end{bmatrix} \tag{CRF-2}\]</span></p><p>每一行表示在位置 <span class="math inline">\(i\)</span> 的后向向量 <span class="math inline">\(\beta_i\)</span>，每一列对应一个标签 <span class="math inline">\(y_i \in \mathcal{Y}\)</span>。</p><h3 id="期望值计算">期望值计算</h3><p>比较复杂，详情参考《统计学习方法》</p><hr><h2 id="优化学习算法">优化学习算法</h2><p>优化学习算法涉及改进迭代尺度法、梯度下降法以及拟牛顿法。这些方法曾在最大熵的学习算法中提及，可以比对学习。</p><h3 id="改进的迭代尺度法">改进的迭代尺度法</h3><p>已知训练数据集，由此可知经验概率分布 <span class="math inline">\(\tilde{P}(X, Y)\)</span>。可以通过极大化训练数据的对数似然函数来求模型参数。</p><p>训练数据的对数似然函数为：</p><p><span class="math display">\[L(w) = L_{\tilde{P}}(P_{w}) = \sum_{\mathbf{x} ,\mathbf{y}} \tilde{P}(\mathbf{x} ,\mathbf{y}) \log P_{w}(\mathbf{y} |\mathbf{x})\]</span></p><p>若</p><p><span class="math display">\[\begin{align*}P(\mathbf{y} \mid \mathbf{x}) &amp;= \frac{1}{Z(\mathbf{x})} \exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right) \\\\Z(\mathbf{x}) &amp;= \sum_{\mathbf{y}} \exp\left(\sum_{k=1}^{K} w_k f_k(\mathbf{y}, \mathbf{x})\right)\end{align*}\]</span></p><p>则</p><p><span class="math display">\[L(w) = \sum_{j = 1}^{N} \sum_{k = 1}^{K} w_{k} f_{k}(y_j, x_j) - \sum_{j = 1}^{N} \log Z_w(x_j)\]</span></p><h3 id="拟牛顿法">拟牛顿法</h3><p>这里介绍的拟牛顿法是 <span class="math inline">\(\mathbf{BFGS}\)</span> 算法。</p><p><strong>输入</strong>：特征函数 <span class="math inline">\(f_1, f_2, \cdots, f_n\)</span>；经验分布 <span class="math inline">\(\tilde{P}(X, Y)\)</span>；精度要求 <span class="math inline">\(\epsilon\)</span>； <strong>输出</strong>：最优参数值 <span class="math inline">\(\hat{w}\)</span>；最优模型 <span class="math inline">\(P_{\hat{w}}(\mathbf{y} |\mathbf{x})\)</span>。</p><ol type="1"><li>选定初始点 <span class="math inline">\(w^{(0)}\)</span>，取 <span class="math inline">\(B_0\)</span> 为正定对称矩阵，置 <span class="math inline">\(k = 0\)</span>。</li><li>计算 <span class="math inline">\(g_k = g(w^{(k)})\)</span>。 若 <span class="math inline">\(\lVert g_k \rVert &lt; \epsilon\)</span>，则停止计算，得 <span class="math inline">\(w^{*} = w^{(k)}\)</span>；否则转第 3 步。</li><li>由 <span class="math inline">\(B_k p_k = -g_k\)</span> 求出 <span class="math inline">\(p_k\)</span>。</li><li>一维搜索，求 <span class="math inline">\(\lambda_k\)</span> 使得 <span class="math display">\[ f(w^{(k)} + \lambda_k p_k) = \min_{\lambda \geq 0} f(w^{(k)} + \lambda p_k) \]</span></li><li>置 <span class="math inline">\(w^{(k + 1)} = w^{(k)} + \lambda_k p_k\)</span>。</li><li>计算 <span class="math inline">\(g_{k + 1} = g(w^{(k + 1)})\)</span>。 若 <span class="math inline">\(\lVert g_{k + 1} \rVert &lt; \epsilon\)</span>，则停止计算，得 <span class="math inline">\(w^{*} = w^{(k + 1)}\)</span>；否则，按下式求出 <span class="math inline">\(B_{k + 1}\)</span>： <span class="math display">\[ B_{k + 1} = B_k + \frac{y_k y_k^T}{y_k^T \delta_k} - \frac{B_k \delta_k \delta_k^T B_k}{\delta_k^T B_k \delta_k} \]</span> 其中， <span class="math display">\[ y_k = g_{k + 1} - g_k, \quad \delta_k = w^{(k + 1)} - w^{(k)} \]</span></li><li>置 <span class="math inline">\(k = k + 1\)</span>，转第 3 步。</li></ol><h2 id="条件随机场的预测算法">条件随机场的预测算法</h2><p>采用隐马尔科夫模型相似的预测算法</p><h3 id="维特比算法">维特比算法</h3><p><strong>输入</strong>：</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Network Layer</title>
    <link href="/2025/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Network-Layer/"/>
    <url>/2025/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Network-Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>网络层有如下功能： - 将从 transport layer 传来的 <strong>segment</strong> 打包成 <strong>datagram</strong>，再将 <strong>datagram</strong> 中的 <strong>segment</strong> 分离开传给 transport layer。 - 网络层协议应用在 <strong>host</strong> 和 <strong>router</strong> 中。</p><p><strong>Router</strong> 和 <strong>Switch</strong> 都属于 <strong>packet switch</strong>。</p><p>尽管路由器和链路层交换机都被称为<strong>packet switches</strong>（分组交换机），但它们有以下根本区别：</p><ol type="1"><li><strong>工作层次不同</strong>：<ul><li>路由器（Router）：工作在<strong>网络层</strong>（第3层）</li><li>链路层交换机：工作在<strong>链路层</strong>（第2层）</li></ul></li><li><strong>转发决策依据</strong>：<ul><li>路由器：基于<strong>IP地址</strong>（网络层地址）做出转发决策</li><li>链路层交换机：基于<strong>MAC地址</strong>（物理地址）做出转发决策</li></ul></li><li><strong>功能范围</strong>：<ul><li>路由器：能够连接<strong>不同网络</strong>，执行<strong>路由决策</strong>和<strong>网络互联</strong></li><li>链路层交换机：主要在<strong>同一网络内</strong>转发帧</li></ul></li><li><strong>网络视角</strong>：<ul><li>路由器：能看到网络的<strong>拓扑结构</strong>，具有全局视野</li><li>链路层交换机：仅限于<strong>局部链路</strong>的连接情况</li></ul></li></ol><p>路由器拥有的IP地址数量<strong>通常等于其活跃网络接口的数量</strong>。这是因为：</p><ul><li>路由器的<strong>每个接口</strong>都需要一个IP地址来参与其所连接网络的通信</li><li>不同接口连接到不同的网络，因此需要不同的IP地址</li></ul><h2 id="forwarding-and-routing">Forwarding and Routing</h2><p>这两个功能十分好理解： - <strong>Forwarding：</strong> 一个 router 中，决定如何移动 datagram 到正确的输出。 - <strong>Routing：</strong> 决定 datagram 在整个网络中的传输路线。</p><h2 id="network-service-model">Network Service Model</h2><p>需要保证，对 <strong>individual datagram</strong>：正确传输和传输时间；对 <strong>a flow of datagrams</strong>： 顺序接受，完整传输和传输最小带宽。</p><h1 id="virtual-circuit-and-datagram-networks">Virtual Circuit and Datagram Networks</h1><p>网络层有两种服务：<strong>connectionless service</strong> 和 <strong>connection service</strong>；这两种服务分别应用在 <strong>datagram network</strong> 和 <strong>virtual circuit network</strong>。</p><h2 id="datagram-network">Datagram Network</h2><p>数据包网络使用的是<strong>动态路由</strong>，每一个数据包可以根据当前的网络状况独立地选择路径。</p><h3 id="forwarding-table">Forwarding Table</h3><p><strong>Forwarding table</strong> 应用在 <strong>router</strong> 中，决定如何移动 datagram 到正确的输出。</p><p>具体形式如下表格所示，可以看到就是一个简单的地址到接口的映射</p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr class="header"><th style="text-align: center;"><strong>Destination Address Range</strong></th><th style="text-align: center;"><strong>Link Interface</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\sim\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\sim\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td></tr><tr class="odd"><td style="text-align: center;">otherwise</td><td style="text-align: center;"><span class="math inline">\(2\)</span></td></tr></tbody></table></div><p><strong>需要注意的是</strong>：表格中的 <strong>Destination Address Range</strong> 可以不是完整的 IP address，而是其的一个前缀；比如 <strong>00111000</strong>，对应的地址范围是 <strong>00111000 00000000 00000000 00000000</strong> 到 <strong>00111000 11111111 11111111 11111111 11111111</strong>。这时 forwarding table 变成：</p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr class="header"><th style="text-align: center;"><strong>Header</strong></th><th style="text-align: center;"><strong>Link Interface</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\sim\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\sim\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td></tr><tr class="odd"><td style="text-align: center;">otherwise</td><td style="text-align: center;"><span class="math inline">\(2\)</span></td></tr></tbody></table></div><h1 id="whats-inside-a-router">What’s inside a Router</h1><p>有两个重要的路由功能： - 运行路由算法。 - 推送 datagram。</p><h2 id="input-port">Input Port</h2><div data-align="center"><pre><code class=" mermaid">flowchart LR    A[Line Termination &lt;br&gt; bit-level reception] --&gt; B[Data Link Processing]    B --&gt; C[Look up and Forwarding &lt;br&gt; Queueing]    C --&gt; D[Switch Fabric]</code></pre></div><p>这里涉及到的 <strong>look up and forwarding</strong> 的方式是 <strong>decentralized switching</strong>，也就是 <strong>forwarding table</strong> 已经存入到了 input port 的 <strong>memory</strong> 中。</p><h2 id="switching-fabric">Switching Fabric</h2><p>有三种 <strong>switching fabrics</strong>。</p><h3 id="switching-via-memory">Switching via Memory</h3><p>这时可以把路由器看作是一个 <strong>computer</strong>。使用电脑的 <strong>CPU</strong> 来 switching。</p><p>这个流程是，先把 datagram 拷贝到电脑 <strong>memory</strong> 中，在从 memory 传到相应的 output port。</p><p>可以分析的是：<strong>memory bandwidth</strong> 是限制 <strong>switching rate</strong> 的主要因素。同时需要注意的是，每个 datagram 会经过两次 <strong>system bus</strong>。</p><h3 id="switching-via-bus">Switching via Bus</h3><p>其中只用到一个 bus。bus bandwidth 限制了 <strong>switching speed</strong>。</p><h3 id="switching-via-interconnection-network">Switching via Interconnection Network</h3><p>网状结构。先 <strong>fragmenting datagram</strong> into fixed length cells，再 switch cells through the fabric。</p><h2 id="output-port">Output Port</h2><div data-align="center"><pre><code class=" mermaid">flowchart LR    A[Switch Fabric] --&gt; B[Queueing: Buffer Management]    B --&gt; C[Data Link Processing]    C --&gt; D[Line Termination]</code></pre></div><h3 id="output-port-queueing">Output Port Queueing</h3><p>Buffering when arrival rate via switch <strong>exceeds</strong> output line speed. Queueing (<strong>delay</strong>) and loss due to output port buffer overflows.</p><p>所以，需要多大的 buffer？假设 <strong>typical <span class="math inline">\(\text{RTT}\)</span></strong>（一般是 <span class="math inline">\(250\)</span> ms），link capacity <span class="math inline">\(C\)</span>，有 <span class="math inline">\(N\)</span> 个 datagram flow。则： <span class="math display">\[\text{buffering} = \frac{\text{RTT} \cdot C}{\sqrt{N}}\]</span></p><h3 id="input-port-queueing">Input Port Queueing</h3><p>同样，输入端也会堵塞。应用了名叫 <strong>Head-of-the-Line (HOL) blocking</strong> 的机制，这个机制很好理解：就是排在前面的 datagram 传输了，其后面的 datagram 才能传输。</p><h1 id="internet-protocol">Internet Protocol</h1><p>这个协议干了三件事：<strong>addressing conventions</strong>（地址约定），<strong>datagram format</strong>，<strong>packet handling conventions</strong>（分组处理约定）。</p><h2 id="ip-datagram-format">IP Datagram Format</h2><h3 id="ipv4">IPv4</h3><figure><img src="/2025/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Network-Layer/IPv4%20datagram%20format.png" style="display: block; margin: 0 auto; width: 60%" alt="IPv4 datagram format"><figcaption aria-hidden="true">IPv4 datagram format</figcaption></figure><p><strong>总结表格：</strong></p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr class="header"><th>字段名</th><th>长度</th><th>作用/说明</th></tr></thead><tbody><tr class="odd"><td>Version</td><td>4 位</td><td>IP 协议版本号</td></tr><tr class="even"><td>Header Length</td><td>4 位</td><td>首部长度（单位：<span class="math inline">\(4\)</span> 字节，最少 <span class="math inline">\(5\)</span> ）</td></tr><tr class="odd"><td>Type of Service</td><td>8 位</td><td>服务类型/QoS</td></tr><tr class="even"><td>Datagram Length</td><td>16 位</td><td>数据报总长度（单位：<span class="math inline">\(1\)</span> 字节）</td></tr><tr class="odd"><td>Identifier</td><td>16 位</td><td>分片标识符</td></tr><tr class="even"><td><strong>Flags</strong></td><td>3 位</td><td>分片控制标志</td></tr><tr class="odd"><td><strong>Fragmentation Offset</strong></td><td>13 位</td><td>分片偏移量（单位：<span class="math inline">\(8\)</span> 字节）</td></tr><tr class="even"><td>Time-to-Live (TTL)</td><td>8 位</td><td>生存时间/最大跳数</td></tr><tr class="odd"><td>Upper-layer Protocol</td><td>8 位</td><td>上层协议类型</td></tr><tr class="even"><td>Header Checksum</td><td>16 位</td><td>首部校验和</td></tr><tr class="odd"><td>Source IP Address</td><td>32 位</td><td>源 IP 地址</td></tr><tr class="even"><td>Destination IP Address</td><td>32 位</td><td>目的 IP 地址</td></tr><tr class="odd"><td>Options</td><td>可变</td><td>可选字段</td></tr><tr class="even"><td>Data</td><td>可变</td><td>负载数据</td></tr></tbody></table></div><p><strong>补充</strong>： - <strong>Flags</strong> 有 <span class="math inline">\(3\)</span> 位，第一位恒为 <span class="math inline">\(0\)</span>，第二位表示 <strong>Don’t fragment</strong>（不可分片），第三位表示 <strong>More fragments</strong>（后续有分片）。为 <span class="math inline">\(1\)</span> 的时候相应功能开启。</p><h3 id="ip-fragmentation-and-reassembly">IP Fragmentation and Reassembly</h3><p>从 IPv4 的 datagram format 中可以发现，必要时会对 datagram 切片。</p><p><strong>MTU</strong>：max transfer size。这是对 <strong>link</strong> 而言，也就是说不同的 <strong>link</strong> 有不同的 <strong>MTU</strong>。</p><p><strong>Fragmentation and Reassembly</strong> 的过程很简单，就是需要时切分 datagram，最后在最终目的主机的网络层进行：只有当所有分片都到达后，网络层才会将完整的数据报交给上层（如传输层）。</p><p>假设原 IP datagram 总长度为 <span class="math inline">\(L\)</span>，待转发链路的 MTU 为 <span class="math inline">\(M\)</span>，若 <span class="math inline">\(L &gt; M\)</span> 且 DF 为 <span class="math inline">\(0\)</span>，则需要分片。 - 先复制 <strong>Identifier</strong>。 - 一个切片可封装的数据为：<span class="math display">\[d = \left \lfloor \frac{M - 20}{8} \right \rfloor \times 8\]</span> - 需要的总片数为：<span class="math display">\[n = \left \lceil \frac{L - 20}{d} \right \rceil\]</span></p><h2 id="ipv4-addressing">IPv4 Addressing</h2><h3 id="subnet">Subnet</h3><p><strong>IP address</strong>: subnet part (high order bits) <span class="math inline">\(+\)</span> host part (low order bits).</p><p>在一个 subnet 中的所有设备都可以直接<strong>物理意义上</strong>地连接。</p><p><strong>Subnet mask</strong>：用类似 <code>/24</code> 的形式表示。也就是说，前 <span class="math inline">\(24\)</span> 相同的 IP address 在同一个 subnet 中。</p><h4 id="classes-inter-domain-routing-cidr">Classes Inter Domain Routing: CIDR</h4><p>规定了 address format 为 <code>a.b.c.d/x</code>。</p><h4 id="dynamic-host-configuration-protocol-dhcp">Dynamic Host Configuration Protocol: DHCP</h4><p><strong>Goal</strong>: allow host to dynamically get his IP address from a server when it joins network. - Can renew its lease on address in use. - Allows reuse of address. - Support for mobile users who want to join network.</p><p><strong>DHCP</strong>（Dynamic Host Configuration Protocol，动态主机配置协议）是一个<strong>网络管理协议</strong>，用于在IP网络中<strong>自动分配IP地址和其他网络配置参数</strong>给网络设备。DHCP运行在<strong>应用层</strong>，使用<strong>UDP协议</strong>，客户端使用<strong>端口68</strong>，服务器使用<strong>端口67</strong>。</p><figure><img src="/2025/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Network-Layer/DHCP%20client-server%20interaction.png" style="display: block; margin: 0 auto; width: 50%" alt="DHCP client-server interaction"><figcaption aria-hidden="true">DHCP client-server interaction</figcaption></figure><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>步骤</th><th>消息类型</th><th>发送者</th><th>接收者</th><th>主要内容</th></tr></thead><tbody><tr class="odd"><td>1</td><td>DISCOVER</td><td>客户端</td><td>广播</td><td>“我需要一个IP地址”</td></tr><tr class="even"><td>2</td><td>OFFER</td><td>服务器</td><td>客户端</td><td>“你可以使用这个IP”</td></tr><tr class="odd"><td>3</td><td>REQUEST</td><td>客户端</td><td>广播</td><td>“我想使用这个IP”</td></tr><tr class="even"><td>4</td><td>ACK</td><td>服务器</td><td>客户端</td><td>“IP已分配，租期为X”</td></tr></tbody></table></div><p><strong>yiaddr</strong>（your IP address）是DHCP协议中表示<strong>服务器提供给客户端的IP地址</strong>的字段。</p><p><strong>补充</strong>：DHCP 还可以 return <strong>address of first-hop router for client</strong>，<strong>name and IP address of DNS server</strong>，<strong>network mask</strong>。</p><h3 id="network-address-translation-nat">Network Address Translation: NAT</h3><figure><img src="/2025/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Network-Layer/Network%20address%20translation.png" style="display: block; margin: 0 auto; width: 90%" alt="Network address translation"><figcaption aria-hidden="true">Network address translation</figcaption></figure><p>右边：局域网内通信，使用内部地址：<code>10.0.0/24</code>；左边：局域网外通信，共用唯一地址。注意，没有共用同一个端口号，因为端口号是用来区分的。比如：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">WAN 侧 (对外显示)</th><th style="text-align: center;">LAN 侧 (实际主机)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">203.0.113.5:50001</td><td style="text-align: center;">192.168.1.10:3345</td></tr><tr class="even"><td style="text-align: center;">203.0.113.5:50002</td><td style="text-align: center;">192.168.1.10:3346</td></tr><tr class="odd"><td style="text-align: center;">203.0.113.5:50003</td><td style="text-align: center;">192.168.1.11:3345</td></tr></tbody></table></div><p>这样布置有一个比较好的优势：可以更换 ISP 的同时不改变局域网内的地址。</p><p>注意到中间的 <strong>NAT router</strong>。它的功能如下： - 对 <strong>outgoing datagrams</strong>，把原始 IP address 和 port 更换为自己的 IP address 和 port。 - 再把上述转换记下来记为 <strong>NAT translation table</strong>。 - 对 <strong>incoming datagrams</strong>，更换。</p><p>现在回顾 NAT，不难察觉几个问题： - 如果 LAN 中的 host 想要通过 P2P 进行 communication，此时该怎么办？ - 如果一个服务器是 NAT 的 LAN 地址，怎么办？</p><h2 id="internet-control-message-protocol-icmp">Internet Control Message Protocol: ICMP</h2><p>这个协议 used by hosts and routers to communicate network-level information。具体包括： - Error reporting. - Echo request and reply.</p><p><strong>ICMP message</strong> 的结构包括：<strong>type</strong>、<strong>code</strong>、<strong>checksum</strong> 以及数据部分。</p><p>具体用来干什么？ - 通过发送 UDP segment，在 IP datagram header 内设置适当的 TTL，来计算 <span class="math inline">\(\text{RTT}\)</span>。 - 还可以用来停止 source 持续发送 UDP segment。</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>字段名</th><th>长度</th><th>作用/说明</th></tr></thead><tbody><tr class="odd"><td><strong>Type</strong></td><td>8位</td><td>消息类型（如0=回显回复，3=目的不可达，8=回显请求）</td></tr><tr class="even"><td><strong>Code</strong></td><td>8位</td><td>消息子类型（进一步说明类型）</td></tr><tr class="odd"><td><strong>Checksum</strong></td><td>16位</td><td>校验和（覆盖整个ICMP消息）</td></tr><tr class="even"><td><strong>Rest of Header</strong></td><td>32位</td><td>取决于Type和Code的其他信息</td></tr><tr class="odd"><td><strong>Data</strong></td><td>可变</td><td>负载数据（例如原始数据包的片段）</td></tr></tbody></table></div><h2 id="ipv6">IPv6</h2><p>为了解决 IPv4 地址不足。具体 format 不讲，但要注意 header 大小为 <span class="math inline">\(40\)</span> bytes，只有 address 大小变为 <span class="math inline">\(128\)</span> bits。</p><h3 id="transition-from-ipv4-to-ipv6">Transition from IPv4 to IPv6</h3><figure><img src="/2025/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Network-Layer/Tunneling.png" style="display: block; margin: 0 auto; width: 90%" alt="Tunneling"><figcaption aria-hidden="true">Tunneling</figcaption></figure><p><strong>Tunneling</strong>: IPv6 carried as payload in IPv4 datagram among Ipv4 routers.</p><h1 id="routing-algorithms">Routing Algorithms</h1><h2 id="software-defined-networking-sdn">Software-Defined Networking: SDN</h2><p>实际上，network layer 可以分为 <strong>data plane</strong> 和 <strong>control plane</strong>，在 <strong>control plane</strong> 有一个 logically centralized routing controller，由它 compute paths。</p><h2 id="link-state-algorithm">Link State Algorithm</h2><h3 id="dijkstras-link-state-algorithm">Dijkstra’s Link-State Algorithm</h3><p>伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">N = &#123;u&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : nodes) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isAdjacent</span>(u, a)) &#123;<br>      D[a] = <span class="hljs-built_in">Cost</span>(u, a);<br>      P[a] = u;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      D[a] = INF;<br>      P[a] = a;<br>      &#125;<br>&#125;<br><span class="hljs-keyword">while</span> (! all nodes in N) &#123;<br>    D[a] = <span class="hljs-built_in">min</span>(D)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> b : nodes) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isAdjacent</span>(b ,a)) &#123;<br>          D[b] = <span class="hljs-built_in">min</span>(D[b], <span class="hljs-built_in">Cost</span>(b, a) + D[a])<br>          <span class="hljs-keyword">if</span> (D[b] == <span class="hljs-built_in">Cost</span>(b, a) + D[a]) P[b] = a;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际做题的时候可以参考书上的风格：</p><p>记 <span class="math inline">\(N&#39;\)</span> 为<strong>已找到最短路径</strong>的点集合，函数 <span class="math inline">\(D(x)\)</span> 为到点 <span class="math inline">\(x\)</span> 的最短路径，函数 <span class="math inline">\(P(x)\)</span> 为点 <span class="math inline">\(x\)</span> 的父母结点。可以规范化求解过程如下，其中 <span class="math inline">\(0\)</span> 轮初始化。</p><div style="display: block; margin: 0 auto; width: fit-content;"><table><thead><tr class="header"><th style="text-align: center;"><strong>Step</strong></th><th style="text-align: center;"><strong><span class="math inline">\(N&#39;\)</span></strong></th><th style="text-align: center;"><strong><span class="math inline">\(D()\,P()\)</span></strong></th><th style="text-align: center;"><strong><span class="math inline">\(D()\,P()\)</span></strong></th><th style="text-align: center;"><strong><span class="math inline">\(\cdots\)</span></strong></th><th style="text-align: center;"><strong><span class="math inline">\(D()\,P()\)</span></strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(u\)</span></td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(uv\)</span></td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(2\)</span></td><td style="text-align: center;"><span class="math inline">\(uvw\)</span></td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\cdots\)</span></td><td style="text-align: center;"><span class="math inline">\(\cdots\)</span></td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(N\)</span></td><td style="text-align: center;"><span class="math inline">\(uvw \cdots l\)</span></td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td><td style="text-align: center;">dis node</td></tr></tbody></table></div><p>这样可以求出从起点到图中其它点的所有最短路径。可以用来制作 forwarding table。</p><p>可以用<strong>优先队列</strong>优化时间复杂度。</p><p>这里需要提到一个概念 <strong>Oscillation possible</strong>，指的是网络路由状态可能出现反复波动、难以稳定的现象，是网络设计和协议实现中需要重点关注和避免的问题。这可能会导致在 Link State Algorithm 中计算到无穷的结果。</p><h2 id="distance-vector-algorithm">Distance Vector Algorithm</h2><p><strong>Distributed Bellman-Ford equation</strong>: <span class="math display">\[D(x \to y) = \min_{v} \{\text{Cost}_{x \to v} + D(v \to y), \, D(x \to y)\}\]</span></p><p>其中，<span class="math inline">\(v\)</span> 是 <span class="math inline">\(x\)</span> 的邻居。</p><p>这是一个 <strong>iterative</strong> 算法，需要多次计算，直到收敛。计算过程可以参考课本，如下表所述，结点 <span class="math inline">\(z\)</span> 的 table。</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(z\)</span></th><th style="text-align: center;">cost to</th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(y\)</span></td><td style="text-align: center;"><span class="math inline">\(z\)</span></td><td style="text-align: center;"><span class="math inline">\(u\)</span></td><td style="text-align: center;"><span class="math inline">\(v\)</span></td></tr><tr class="even"><td style="text-align: center;">from <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(2\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span></td></tr><tr class="odd"><td style="text-align: center;">from <span class="math inline">\(y\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(2\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td style="text-align: center;">from <span class="math inline">\(z\)</span></td><td style="text-align: center;"><span class="math inline">\(2\)</span></td><td style="text-align: center;"><span class="math inline">\(5\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span></td><td style="text-align: center;"><span class="math inline">\(5\)</span></td></tr><tr class="odd"><td style="text-align: center;">from <span class="math inline">\(u\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(2\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(2\)</span></td></tr><tr class="even"><td style="text-align: center;">from <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr></tbody></table></div><h1 id="hierarchical-routing">Hierarchical Routing</h1><p><strong>Internet approach to scalable routing</strong>: aggregate routers into regions known as <strong>autonomous system (AS)</strong></p><figure><img src="/2025/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Network-Layer/AS%20structure.jpg" style="display: block; margin: 0 auto; width: 100%" alt="AS structure"><figcaption aria-hidden="true">AS structure</figcaption></figure><h2 id="intra-as-routing-protocol">Intra-AS Routing Protocol</h2><ol type="1"><li>RIP: Routing Information Protocol (wasted).</li><li>OSPF: Open Shortest Path First (Link-State).</li><li>EIGRP: Enhanced Interior Gateway Routing Protocol.</li></ol><h3 id="ospf-open-shortest-path-first">OSPF: Open Shortest Path First</h3><p>classic link-state: 1. Each router floods <strong>OSPF</strong> link-state advertisements (over IP) to all routers. 2. Multiple link costs metrics possible: bandwidth, delay. 3. Each router has full topology, Dijkstra algorithm.</p><p>Security: all OSPF messages authenticated</p><figure><img src="/2025/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Network-Layer/Hierarchical%20OSPF.png" style="display: block; margin: 0 auto; width: 80%" alt="Hierarchical OSPF"><figcaption aria-hidden="true">Hierarchical OSPF</figcaption></figure><h2 id="inter-as-protocol">Inter-AS Protocol</h2><h3 id="bgp-border-gateway-protocol">BGP: Border Gateway Protocol</h3><p>BGP provides each AS a means to: - obtain destination network reachability information form neighboring ASes eBGP. - determine routers to other networks based on reachability information and policy. - propagate reachability information to all AS-internal routers: iBGP. - advertise (to neighboring networks) destination reachability information.</p><figure><img src="/2025/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Network-Layer/eBGP%20and%20iBGP%20sessions.png" style="display: block; margin: 0 auto; width: 90%" alt="eBGP and iBGP sessions"><figcaption aria-hidden="true">eBGP and iBGP sessions</figcaption></figure><ul><li>BGP对等体（BGP peers）通过<strong>半永久TCP连接</strong>（BGP会话）交换路由信息。</li><li>BGP会话不一定对应物理链路。</li><li>当AS2向AS1通告前缀时：<ul><li>AS2 <strong>承诺</strong>会为该前缀转发数据报。</li><li>AS2可以在通告中聚合前缀。</li></ul></li><li>通过eBGP会话，AS3将前缀可达性信息发送给AS1。</li><li>AS1内部的路由器（如1c）通过iBGP将新前缀信息分发给AS1内所有路由器。</li><li>AS1的1b路由器可以通过eBGP会话将新前缀信息再通告给AS2。</li><li>路由器学到新前缀后，会在转发表中为该前缀创建条目。</li><li>BGP通告的前缀包含<strong>BGP属性</strong>，前缀+属性即为<strong>路由</strong>。</li><li>两个重要属性：<ul><li><strong>AS-PATH</strong>：记录前缀通告经过的AS序列（如AS 67, AS 17）。</li><li><strong>NEXT-HOP</strong>：指明到下一个AS的具体内部路由器（可能有多条链路）。</li></ul></li><li>当网关路由器收到路由通告时，会根据<strong>import policy</strong>（导入策略）决定是否接受该路由。</li></ul><p>假设有以下网络拓扑结构：</p><div style="display: block; margin: 0 auto; width: fit-content"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">        +------+<br>        | AS65 |<br>        +------+<br>       /        \<br>      /          \<br>+------+        +------+<br>| AS23 |--------| AS17 |<br>+------+        +------+<br>   |                |<br>+------+        +------+<br>| AS45 |        | AS78 |<br>+------+        +------+<br>                 /<br>             +------+<br>             | AS99 |---前缀：192.168.99.0/24<br>             +------+<br></code></pre></td></tr></table></figure></div><p>AS-PATH传播过程</p><p>假设AS99宣告前缀192.168.99.0/24，我们跟踪这个前缀在网络中的传播：</p><ol type="1"><li><strong>AS99向AS78通告前缀</strong>：<ul><li>AS99向AS78发送BGP更新：<code>192.168.99.0/24, AS-PATH=&#123;99&#125;</code></li><li>AS78收到前缀后，将其存入路由表</li></ul></li><li><strong>AS78向AS17通告前缀</strong>：<ul><li>AS78在转发前，将自己的AS号添加到AS-PATH</li><li>AS78发送BGP更新：<code>192.168.99.0/24, AS-PATH=&#123;78, 99&#125;</code></li></ul></li><li><strong>AS17向多个AS传播</strong>：<ul><li>AS17向AS23发送：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li><li>AS17向AS65发送：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li></ul></li><li><strong>AS23收到两种路径</strong>：<ul><li>从AS17：<code>192.168.99.0/24, AS-PATH=&#123;17, 78, 99&#125;</code></li><li>从AS45（假设AS45也与AS99间接相连）：<code>192.168.99.0/24, AS-PATH=&#123;45, ..., 99&#125;</code></li><li>AS23基于AS-PATH长度和其他策略选择最佳路径</li></ul></li><li><strong>AS65收到更新后</strong>：<ul><li>获得路由：<code>192.168.99.0/24, AS-PATH=&#123;65, 17, 78, 99&#125;</code></li><li>若之后收到AS23的路由通告，也会比较两条路径</li></ul></li></ol><h1 id="subnetprefix和bgp-route的对比分析">Subnet、Prefix和BGP Route的对比分析</h1><h2 id="subnet子网">Subnet（子网）</h2><p><strong>子网</strong>是指<strong>物理网络的逻辑划分</strong>，具有以下特征： - 由<strong>共享相同网络前缀</strong>的IP地址集合组成 - 通过<strong>网络地址</strong>和<strong>子网掩码</strong>定义（如192.168.1.0/24） - 子网内设备可<strong>直接通信</strong>，无需路由器转发 - 代表<strong>单一广播域</strong>内的网络段 - 通常属于<strong>单一管理实体</strong></p><h2 id="prefix前缀">Prefix（前缀）</h2><p><strong>前缀</strong>是<strong>IP地址空间中的地址块</strong>，具有以下特征： - 用<strong>CIDR表示法</strong>表示（如10.0.0.0/8） - 表示IP地址中固定的<strong>网络部分位数</strong> - 是<strong>路由表聚合</strong>的基础单位 - 可以表示<strong>不同大小</strong>的地址块 - 是<strong>地址分配和路由通告</strong>的基本单位</p><h2 id="bgp-routebgp路由">BGP Route（BGP路由）</h2><p><strong>BGP路由</strong>是<strong>互联网核心路由系统</strong>中的路由条目： - 包含<strong>目的地前缀</strong>和<strong>完整路径属性</strong> - 核心属性包括<strong>AS_PATH</strong>（自治系统路径）、<strong>NEXT_HOP</strong>等 - 反映了<strong>网络政策</strong>和<strong>商业关系</strong> - 用于<strong>自治系统间</strong>的路由决策 - 通过BGP协议在全球互联网中<strong>传播和交换</strong></p><p>NEXT-HOP属性在BGP中用于<strong>指明到达目标网络的下一跳路由器IP地址</strong>，具体使用方式如下：</p><ol type="1"><li><strong>路由转发决策</strong><ul><li>当路由器接收到目标数据包时，通过查询BGP表中的NEXT-HOP属性确定<strong>实际转发目标</strong></li><li>路由器必须能够通过IGP协议(如OSPF)到达NEXT-HOP地址</li></ul></li><li><strong>BGP会话中的传递规则</strong><ul><li><strong>eBGP传递</strong>：设置为发送更新的BGP对等体的IP地址</li><li><strong>iBGP传递</strong>：保持NEXT-HOP值不变（除非明确配置修改）</li><li><strong>多出口AS</strong>：帮助选择最佳出口点</li></ul></li><li><strong>策略实现</strong><ul><li>通过修改NEXT-HOP实现<strong>流量工程</strong></li><li>支持热备份和负载均衡策略</li><li>可设置为特定接口地址或第三方路由器地址</li></ul></li></ol><p>AS-PATH属性记录了<strong>路由通告经过的AS序列</strong>，在BGP中具有多重重要功能：</p><ol type="1"><li><strong>路由选择依据</strong><ul><li>作为BGP决策过程中的<strong>关键指标</strong>之一</li><li><strong>AS-PATH越短</strong>的路径通常被优先选择</li><li>影响决策优先级：Local Preference &gt; AS-PATH长度 &gt; Origin &gt; MED等</li></ul></li><li><strong>环路检测机制</strong><ul><li>当路由器在AS-PATH中发现<strong>自己的AS号</strong>时，自动拒绝该路由</li><li>避免路由环路产生，确保BGP路由收敛性</li><li>例如：AS17收到路径“AS23, AS45, AS17, AS78”会直接丢弃</li></ul></li><li><strong>路径操纵技术</strong><ul><li>通过<strong>AS-PATH预置</strong>(prepending)增加路径长度</li><li>例如：“AS78, AS78, AS78, AS99”使路径看起来更长</li><li>降低特定路径被选择的可能性，实现出站流量控制</li></ul></li><li><strong>路由过滤依据</strong><ul><li>基于AS-PATH中的特定AS创建<strong>过滤策略</strong></li><li>可拒绝包含竞争对手或不信任AS的路由</li><li>实现复杂的路由策略控制和商业关系维护</li></ul></li></ol><h2 id="三者关系对比">三者关系对比</h2><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>特性</th><th>Subnet</th><th>Prefix</th><th>BGP Route</th></tr></thead><tbody><tr class="odd"><td><strong>范围</strong></td><td>局部网段</td><td>地址块</td><td>全球路由</td></tr><tr class="even"><td><strong>用途</strong></td><td>网络分段</td><td>地址分配与聚合</td><td>域间路由决策</td></tr><tr class="odd"><td><strong>包含信息</strong></td><td>网络地址+掩码</td><td>地址块+长度</td><td>前缀+路径属性</td></tr><tr class="even"><td><strong>管理层次</strong></td><td>单一管理域内</td><td>可跨域使用</td><td>多AS协作</td></tr><tr class="odd"><td><strong>通告机制</strong></td><td>不直接通告</td><td>内部路由协议</td><td>BGP协议</td></tr><tr class="even"><td><strong>聚合能力</strong></td><td>固定大小</td><td>可变大小</td><td>可聚合或特定</td></tr></tbody></table></div><h2 id="层次关系">层次关系</h2><p>这三个概念形成了一个层次结构： - <strong>Subnet</strong>：最基础，表示<strong>实际网络分段</strong> - <strong>Prefix</strong>：中间层，表示<strong>可路由的地址块</strong> - <strong>BGP Route</strong>：最高层，表示<strong>如何到达特定前缀的完整路径信息</strong></p><p>一个BGP路由可以指向一个前缀，而一个前缀可以包含多个子网。</p><h1 id="end-of-chapter-exercises">End-of-chapter exercises</h1><h2 id="p.6">P.6</h2><p><strong>Questions:</strong></p><p>In the text we have used the term connection-oriented service to describe a transport-layer service and connection service for a network-layer service. Why the subtle shades in terminology?</p><p><strong>Answer:</strong></p><p>The subtle difference in terminology reflects the distinct roles and responsibilities of the transport and network layers:</p><ul><li><p><strong>Connection-oriented service (Transport Layer):</strong><br>At the transport layer, a connection-oriented service (such as TCP) establishes, maintains, and terminates a logical end-to-end connection. This connection is defined <strong>between two processes</strong> on the end hosts (e.g., two TCP sockets). This service ensures reliable, ordered, and error-checked delivery of data across the entire network path, directly between the communicating applications.</p></li><li><p><strong>Connection service (Network Layer):</strong><br>At the network layer, a connection service (such as a virtual circuit) refers to the establishment of a logical path through the network, typically between routers or switches. This connection is defined <strong>between two hosts</strong> (and their intervening routers in the case of virtual-circuit networks). This path helps guide packets from source to destination but does not necessarily guarantee reliability or ordering. The focus here is on the route and forwarding of packets within the network infrastructure.</p></li></ul><p><strong>In summary:</strong><br>The term “connection-oriented service” at the transport layer emphasizes end-to-end reliability and communication, while “connection service” at the network layer highlights the setup of a path through the network, without necessarily providing full end-to-end guarantees. The nuanced terminology helps clarify the different scopes and guarantees provided by each layer.</p><h2 id="p.9">P.9</h2><p><strong>Consider a datagram network using 32-bit host addresses. Suppose a router has four links, numbered 0 through 3, and packets are to be forwarded to the link interfaces as follows:</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">Destination Address Range</th><th style="text-align: center;">Link Interface</th></tr></thead><tbody></tbody></table>|<div data-align="center">11100000 00000000 00000000 00000000<br><strong>through</strong><br>11100000 00111111 11111111 11111111</div><pre><code class="hljs">                           |       0        |</code></pre>|<div data-align="center">11100000 01000000 00000000 00000000<br><strong>through</strong><br>11100000 01000000 11111111 11111111</div><pre><code class="hljs">                           |       1        |</code></pre>|<div data-align="center">11100000 01000001 00000000 00000000<br><strong>through</strong><br>11100001 01111111 11111111 11111111</div><pre><code class="hljs">                           |       2        |</code></pre>|<div data-align="center">otherwise</div><pre><code class="hljs">                                                                                                                        |       3        |</code></pre></div><p><strong>Questions and Answers:</strong></p><p><strong>a. Provide a forwarding table that has four entries, uses longest prefix matching, and forwards packets to the correct link interfaces.</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th>Header</th><th style="text-align: center;">Link Interface(output)</th></tr></thead><tbody><tr class="odd"><td>11100000 00</td><td style="text-align: center;">0</td></tr><tr class="even"><td>11100000 01000000</td><td style="text-align: center;">1</td></tr><tr class="odd"><td>1110000</td><td style="text-align: center;">2</td></tr><tr class="even"><td>otherwise</td><td style="text-align: center;">3</td></tr></tbody></table></div><p><strong>Explanation:</strong><br>- Each entry uses the longest prefix that matches the given address range. - The router checks the destination address against each prefix, starting from the longest, and forwards the packet to the corresponding interface.</p><p><strong>b. Describe how your forwarding table determines the appropriate link interface for datagrams with destination addresses</strong>:</p><div data-align="center">11001000 10010001 01010001 01010101</div><div data-align="center">11100001 01000000 11000011 00111100</div><div data-align="center">11100001 10000000 00010001 01110111</div><ol type="1"><li><strong>11001000 10010001 01010001 01010101</strong><ul><li>This address does <strong>not</strong> match any of the specified prefixes (does not start with 111…), so it is forwarded to <strong>interface 3</strong>.</li></ul></li><li><strong>11100001 01000000 11000011 00111100</strong><ul><li>This address matches the third entry:<ul><li>Prefix: <code>1110000</code></li><li>So, it is forwarded to <strong>interface 2</strong>.</li></ul></li></ul></li><li><strong>11100001 10000000 00010001 01110111</strong><ul><li>This address matches the third entry:<ul><li>Prefix: <code>1110000</code></li><li>So, it is forwarded to <strong>interface 2</strong>.</li></ul></li></ul></li></ol><h2 id="p.10">P.10</h2><p><strong>Consider a datagram network using 8-bit host addresses. Suppose a router uses longest-prefix matching and has the following forwarding table:</strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">Prefix Match</th><th style="text-align: center;">Interface</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">00</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">010</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">011</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;">10</td><td style="text-align: center;">2</td></tr><tr class="odd"><td style="text-align: center;">11</td><td style="text-align: center;">3</td></tr></tbody></table></div><p><strong>Question and Answer:</strong></p><p>For each of the four interfaces, give the associated range of destination host addresses and the number of addresses in the range.</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">Interface</th><th style="text-align: center;">Destination Address Range</th><th style="text-align: right;">Number of Addresses</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">00000000 - 00111111</td><td style="text-align: right;">64</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">01000000 - 01011111</td><td style="text-align: right;">32</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">01100000 - 01111111<br>10000000 - 10111111</td><td style="text-align: right;">96</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">11000000 - 11111111</td><td style="text-align: right;">64</td></tr></tbody></table></div><h2 id="p.17">P.17</h2><p><strong>Question and Answer:</strong></p><p>Consider sending a 2400-byte datagram into a link that has an MTU of 700 bytes. Suppose the original datagram is stamped with the identification number 422. How many fragments are generated? What are the values in the various fields in the IP datagram(s) generated related to fragmentation?</p><p>According to IPv4 datagram format, each fragment includes a 20-bytes header.</p><p>先计算数据大小 <span class="math inline">\(d = \lfloor \frac{700 - 20}{8} \rfloor \times 8 = 680\)</span> bytes。</p><p>所以需要分成 <span class="math inline">\(n = \lceil \frac{2400 - 20}{d} \rceil = 4\)</span></p><p>主要变化在 <code>Offset</code> 和 <code>Flag</code>，所以：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">Fragment</th><th style="text-align: center;">Datagram length</th><th style="text-align: center;">Offset</th><th style="text-align: center;">Flag</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">700</td><td style="text-align: center;">0</td><td style="text-align: center;">001</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">700</td><td style="text-align: center;">85</td><td style="text-align: center;">001</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">700</td><td style="text-align: center;">170</td><td style="text-align: center;">001</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">360</td><td style="text-align: center;">255</td><td style="text-align: center;">000</td></tr></tbody></table></div><h2 id="p.18">P.18</h2><p><strong>Question and Answer:</strong></p><p>Suppose datagrams are limited to 1,500 bytes (including header) between source Host A and destination Host B. Assuming a 20-byte IP header, how many datagrams would be required to send an MP3 consisting of 5 million bytes? Explain how you computed your answer.</p><p>MTU 为 <span class="math inline">\(1500\)</span> bytes，一个 datagram 的 data 大小为 <span class="math inline">\(d = \lfloor \frac{1500 -20}{8} \rfloor \times 8 = 1480\)</span> bytes。</p><p>最终，datagram 的数目为 <span class="math inline">\(n = \lceil \frac{5 \times 10^6}{d} \rceil = 3379\)</span> 个。</p><h2 id="p.19">P.19</h2><p><strong>Consider the network setup in Figure 4.22. Suppose that the ISP instead assigns the router the address 24.34.112.235 and that the network address of the home network is 192.168.1/24</strong>.</p><figure><img src="/2025/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Network-Layer/Network%20address%20translation.png" style="display: block; margin: 0 auto; width: 80%" alt="Network address translation"><figcaption aria-hidden="true">Network address translation</figcaption></figure><p><strong>Questions and Answers:</strong></p><p><strong>a. Assign addresses to all interfaces in the home network.</strong></p><p>也即是说，中间的 router WAN 的 IP address 是 <code>24.34.112.235</code>，LAN 的是 <code>192.168.1/24</code>，不妨和原图一样，设为 <code>192.168.1.4</code>。则右边的三个 host 的 LAN IP address 分别为：</p><ul><li>Host 1 address is 192.168.1.1</li><li>Host 2 address is 192.168.1.2</li><li>Host 3 address is 192.168.1.3</li></ul><p><strong>b. Suppose each host has two ongoing TCP connections, all to port 80 at host 128.119.40.86. Provide the six corresponding entries in the NAT translation table.</strong></p><p>总共有 <span class="math inline">\(6\)</span> 个 TCP connection，随便分几个端口号：</p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;">WAN side</th><th style="text-align: center;">LAN side</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">24.34.112.235, 50001</td><td style="text-align: center;">192.168.1.1, 3345</td></tr><tr class="even"><td style="text-align: center;">24.34.112.235, 50002</td><td style="text-align: center;">192.168.1.1, 3346</td></tr><tr class="odd"><td style="text-align: center;">24.34.112.235, 50003</td><td style="text-align: center;">192.168.1.2, 3345</td></tr><tr class="even"><td style="text-align: center;">24.34.112.235, 50004</td><td style="text-align: center;">192.168.1.2, 3346</td></tr><tr class="odd"><td style="text-align: center;">24.34.112.235, 50005</td><td style="text-align: center;">192.168.1.3, 3345</td></tr><tr class="even"><td style="text-align: center;">24.34.112.235, 50006</td><td style="text-align: center;">192.168.1.3, 3346</td></tr></tbody></table></div><h2 id="p.24">P.24</h2><figure><img src="/2025/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Network-Layer/P24.jpg" style="display: block; margin: 0 auto; width: 80%" alt="Graph P.24"><figcaption aria-hidden="true">Graph P.24</figcaption></figure><p><strong>Question:</strong></p><p>Consider the following network. With the indicated link costs, use Dijkstra’s shortest-path algorithm to compute the shortest path from x to all network nodes. Show how the algorithm works by computing a table similar to Table 4.3.</p><p><strong>Answer:</strong></p><p><span class="math inline">\(N&#39; = \{x\}\)</span></p><table><thead><tr class="header"><th style="text-align: center;">step</th><th style="text-align: center;"><span class="math inline">\(D(x)\)</span> <span class="math inline">\(P(x)\)</span></th><th style="text-align: center;"><span class="math inline">\(D(y)\)</span> <span class="math inline">\(P(y)\)</span></th><th style="text-align: center;"><span class="math inline">\(D(z)\)</span> <span class="math inline">\(P(z)\)</span></th><th style="text-align: center;"><span class="math inline">\(D(v)\)</span> <span class="math inline">\(P(v)\)</span></th><th style="text-align: center;"><span class="math inline">\(D(u)\)</span> <span class="math inline">\(P(u)\)</span></th><th style="text-align: center;"><span class="math inline">\(D(w)\)</span> <span class="math inline">\(P(w)\)</span></th><th style="text-align: center;"><span class="math inline">\(D(t)\)</span> <span class="math inline">\(P(t)\)</span></th><th style="text-align: center;"><span class="math inline">\(N&#39;\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(0\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><strong><span class="math inline">\(3\)</span></strong> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(x\)</span></td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(0\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><strong><span class="math inline">\(6\)</span></strong> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span> <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(xv\)</span></td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(0\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><strong><span class="math inline">\(6\)</span></strong> <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span> <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(xvy\)</span></td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(0\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(v\)</span></td><td style="text-align: center;"><strong><span class="math inline">\(6\)</span></strong> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span> <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(xvyu\)</span></td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(0\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><strong><span class="math inline">\(7\)</span></strong> <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(xvyuw\)</span></td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;"><span class="math inline">\(0\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><strong><span class="math inline">\(8\)</span></strong> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span> <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(xvyuwt\)</span></td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;"><span class="math inline">\(0\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span> <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span> <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(xvyuwtz\)</span></td></tr></tbody></table><p>So the shortest path from <span class="math inline">\(x\)</span> to all nodes is follow.</p><table><thead><tr class="header"><th style="text-align: center;">Destination</th><th style="text-align: center;">Shortest Distance</th><th style="text-align: center;">Path</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(x\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td style="text-align: center;"><span class="math inline">\(x \to v\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(y\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span></td><td style="text-align: center;"><span class="math inline">\(x \to y\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(w\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span></td><td style="text-align: center;"><span class="math inline">\(x \to w\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(u\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span></td><td style="text-align: center;"><span class="math inline">\(x \to v \to u\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(t\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span></td><td style="text-align: center;"><span class="math inline">\(x \to v \to t\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(z\)</span></td><td style="text-align: center;"><span class="math inline">\(8\)</span></td><td style="text-align: center;"><span class="math inline">\(x \to z\)</span></td></tr></tbody></table><h2 id="p.26">P.26</h2><figure><img src="/2025/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/The-Network-Layer/P26.png" style="display: block; margin: 0 auto; width: 80%" alt="Graph P.26"><figcaption aria-hidden="true">Graph P.26</figcaption></figure><p><strong>Question:</strong></p><p>Consider the network shown below, and assume that each node initially knows the costs to each of its neighbors. Consider the distance-vector algorithm and show the distance table entries at node z.</p><p><strong>Answer:</strong></p><p><strong>Node z table:</strong></p><p><strong><em>First round</em></strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">cost to</th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">x</td><td style="text-align: center;">y</td><td style="text-align: center;">z</td><td style="text-align: center;">u</td><td style="text-align: center;">v</td></tr><tr class="even"><td style="text-align: center;">from x</td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr><tr class="odd"><td style="text-align: center;">from y</td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td style="text-align: center;">from z</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;">6</td></tr><tr class="odd"><td style="text-align: center;">from u</td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td style="text-align: center;">from v</td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr></tbody></table></div><p><strong><em>Second round</em></strong></p><div style="display: block; margin: 0 auto; width: fit-content"><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">cost to</th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"><span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(y\)</span></td><td style="text-align: center;"><span class="math inline">\(z\)</span></td><td style="text-align: center;"><span class="math inline">\(u\)</span></td><td style="text-align: center;"><span class="math inline">\(v\)</span></td></tr><tr class="even"><td style="text-align: center;">from <span class="math inline">\(x\)</span></td><td style="text-align: center;"><span class="math inline">\(2\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span></td></tr><tr class="odd"><td style="text-align: center;">from <span class="math inline">\(y\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(2\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td style="text-align: center;">from <span class="math inline">\(z\)</span></td><td style="text-align: center;"><span class="math inline">\(2\)</span></td><td style="text-align: center;"><span class="math inline">\(5\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(7\)</span></td><td style="text-align: center;"><span class="math inline">\(5\)</span></td></tr><tr class="odd"><td style="text-align: center;">from <span class="math inline">\(u\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(2\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(2\)</span></td></tr><tr class="even"><td style="text-align: center;">from <span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(3\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td><td style="text-align: center;"><span class="math inline">\(6\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(\infty\)</span></td></tr></tbody></table></div><p>Because the question only asks to show the distance table entries at node z, we do not need to compute the full routing tables for all nodes. The Second round result about node z is also the finial result. 到这一步 from z to other 的 cost 表就收敛了，题目也只问了 node z。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Network Layer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>提升方法</title>
    <link href="/2025/05/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/"/>
    <url>/2025/05/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="adaboost-算法">AdaBoost 算法</h2><p><strong><em>Data Information</em></strong>： <strong>二分类</strong>训练数据集 <span class="math inline">\(T\)</span> <span class="math display">\[\begin{align}T&amp; = \{(x_1, y_1), (x_2, y_2), \ldots, (x_N, y_N)\}\\x_i \in \mathcal{X}&amp; = \mathbb{R}^n, \quad y_i \in \mathcal{Y} = \{+1, -1\}, \quad i = 1, 2, \ldots, N\end{align}\]</span></p><p><strong><em>Algorithm Process</em></strong> 1. 初始化训练数据的权值分布： <span class="math display">\[   D_1 = (w_{11}, w_{12}, \dots, w_{1N}), \quad w_{1i} = \frac{1}{N}, \quad i = 1, 2, \dots, N   \]</span></p><ol start="2" type="1"><li>用权值分布 <span class="math inline">\(D_i\)</span><ol type="a"><li><p>计算不正确率： <span class="math display">\[ e_m = \sum_{i=1}^{N} P(G_m(x_i) \neq y_i) = \sum_{i=1}^{N} w_{mi} I(G_m(x_i) \neq y_i) \]</span></p></li><li><p>计算 <span class="math inline">\(\alpha_m\)</span>: <span class="math display">\[ \alpha_m = \frac{1}{2} \ln \frac{1 - e_m}{e_m} \]</span></p></li><li><p>更新权值分布: <span class="math display">\[ D_{m+1} = (w_{m+1,1}, \dots, w_{m+1, N}) \]</span> <span class="math display">\[ w_{m+1,i} = \frac{w_{mi}}{Z_m} \exp(-\alpha_m y_i G_m(x_i)) \]</span> <span class="math inline">\(Z_m\)</span> 是归一化因子。 <span class="math display">\[ Z_m = \sum_{i=1}^{N} w_{mi} \exp(-\alpha_m y_i G_m(x_i)) \]</span></p></li></ol></li><li>构造基本分类器的线性组合 <span class="math display">\[ f(x) = \sum_{m=1}^{M} \alpha_m G_m(x) \]</span></li><li>得到最终分类器 <span class="math display">\[ G(x) = \operatorname{sign}\left( \sum_{m=1}^{M} \alpha_m G_m(x) \right) \]</span></li></ol><h2 id="回归问题的提升树算法">回归问题的提升树算法</h2><p><strong><em>Algorithm Process</em></strong> 输入：训练数据集 <span class="math inline">\(T = \{(x_1, y_1),(x_2, y_2), \cdots, (x_N, y_N)\}\)</span>； 输出：提升树 <span class="math inline">\(f_M(x)\)</span>。 （1）初始化 <span class="math inline">\(f_0(x) = 0\)</span>。 （2）对 <span class="math inline">\(m = 1, 2, \cdots, M\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>支持向量机</title>
    <link href="/2025/05/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2025/05/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="线性可分支持向量机">线性可分支持向量机</h2><p><strong>训练数据</strong> <span class="math display">\[T = \{(x_1, y_1), (x_2, y_2), \ldots, (x_N, y_N)\}\]</span></p><p><span class="math display">\[x_i \in \mathcal{X} = \mathbb{R}^n, \quad y_i \in \mathcal{Y} = \{+1, -1\}, \quad i = 1, 2, \ldots, N\]</span></p><p><strong>分离超平面</strong></p><p><span class="math display">\[w^* \cdot x + b^* = 0\]</span></p><p><strong>分类决策函数</strong></p><p><span class="math display">\[f(x) = \operatorname{sign}(w^* \cdot x + b^*)\]</span></p><p><strong>函数间隔</strong></p><p><span class="math display">\[\begin{align*}\hat{\gamma}_i &amp;= y_i (w \cdot x_i + b)\\\\\hat{\gamma} &amp;= \min_{i = 1, 2, \ldots, N} \hat{\gamma}_i\end{align*}\]</span></p><p>规范化函数间隔得到<strong>几何间隔</strong></p><p><span class="math display">\[\begin{align*}\gamma_i &amp;= y_i \times \left(\frac{w \cdot x_i + b}{\lVert w \rVert}\right)\\\\\gamma &amp;= \min_{i=1, \ldots, N} \gamma_i\end{align*}\]</span></p><p><span class="math inline">\(\lVert w \rVert\)</span> is <span class="math inline">\(L_2\)</span> 范数，也就是：</p><p><span class="math display">\[\lVert w \rVert _{2} = \sqrt{w_1^2 + w_2^2 + \cdots + w_n^2}\]</span></p><p>可以得到几何间隔和函数间隔之间的关系：</p><p><span class="math display">\[\gamma_i = \frac{\hat{\gamma}_i}{\lVert w \rVert}\]</span></p><h3 id="间隔最大化">间隔最大化</h3><p>原始问题如下：</p><p><span class="math display">\[\begin{align*}&amp;\max_{w, b} \quad \gamma\\\\&amp;s.t. \quad y_i\left(\frac{w}{\lVert w \rVert} \cdot x_i + \frac{b}{\lVert w \rVert}\right) \geq \gamma, \quad i = 1, 2, \ldots ,N\end{align*}\]</span></p><p>我们可以将原始问题转换为一个<strong>凸二次规划问题</strong>。</p><p><span class="math display">\[\begin{align*}&amp;\min_{w, b} \quad \frac{1}{2} \lVert w \rVert ^2\\\\&amp;s.t. \quad y_i(w \cdot x_i + b) - 1 \geq 0, \quad i = 1, 2, \ldots, N\end{align*}\]</span></p><p><strong>支持向量</strong>满足如下关系：</p><p><span class="math display">\[y_i(w \cdot x_i + b) - 1 = 0\]</span></p><p><strong>间隔</strong>的定义如下：</p><p><span class="math display">\[d = \frac{2}{\lVert w \rVert}\]</span></p><h4 id="学习的对偶算法">学习的对偶算法</h4><p>如何解上述的<strong>凸二次规划</strong>问题？应用拉格朗日对偶性得到原始问题的对偶问题：</p><p><span class="math display">\[L(w, b, \alpha) = \frac{1}{2} \lVert w \rVert ^2 - \sum_{i = 1}^{N} \alpha_i y_i (w \cdot x_i + b) + \sum_{i = 1}^{N} \alpha_i\]</span></p><p>在求极大极小问题，先求极小问题 <span class="math inline">\(\min_{w, b} L(w, b, \alpha)\)</span></p><p>分别对 <span class="math inline">\(w\)</span>，<span class="math inline">\(b\)</span> 求偏导，并令偏导为 <span class="math inline">\(0\)</span> 得：</p><p><span class="math display">\[\begin{align*}\nabla_{w} L(w, b, \alpha) &amp;= w - \sum_{i = 1}^{N} \alpha_i y_i x_i = 0\\\\\nabla_b L(w, b, \alpha) &amp;= -\sum_{i = 1}^{N} \alpha_i y_i = 0\end{align*}\]</span></p><p>也就是</p><p><span class="math display">\[\begin{align*}&amp;w = \sum_{i = 1}^{N} \alpha_i y_i x_i\\\\&amp;\sum_{i = 1}^{N} \alpha_i y_i = 0\end{align*}\]</span></p><p>回代，得到</p><p><span class="math display">\[\min_{w, b} L(w, b, \alpha) = -\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) + \sum_{i = 1}^{N} \alpha_i\]</span></p><p>再求极大问题</p><p><span class="math display">\[\max_{\alpha} \quad -\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) + \sum_{i = 1}^{N} \alpha_i\]</span></p><p>去掉负号，也就是</p><p><span class="math display">\[\begin{align*}\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i\\\\\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0\\&amp;\alpha_i \geq 0, \quad i = 1, 2, \cdots, N\end{align*}\]</span></p><h3 id="学习算法">学习算法</h3><ul><li><p><strong>输入</strong>：<span class="math inline">\(T\)</span></p></li><li><p><strong>输出</strong>：分离超平面和分类决策函数</p><ul><li>构造并求解约束最优化问题。</li></ul><p><span class="math display">\[\begin{align*}\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i\\\\\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0\\&amp;\alpha_i \geq 0, \quad i = 1, 2, \cdots, N\\\\&amp;\alpha^* = (\alpha_1^{\ast}, \alpha_2^{\ast}, \ldots, \alpha_N^{\ast})\end{align*}\]</span></p><ul><li>计算</li></ul><p><span class="math display">\[\begin{align*}w^{\ast} &amp;= \sum_{i=1}^{N} \alpha_i^{\ast} y_i x_i\\\\\forall y_j &gt; 0, \quad b^\ast &amp;= y_j - \sum_{i=1}^{N}\alpha_i^\ast y_i(x_i \cdot x_j)\end{align*}\]</span></p></li></ul><hr><h2 id="线性支持向量机">线性支持向量机</h2><p>引进一个松弛变量 <span class="math inline">\(\xi_i \geq 0\)</span>，</p><p><span class="math display">\[y_i (w \cdot x_i + b) \geq 1 - \xi_i\]</span></p><p>相应的原始最优化问题变为：</p><p><span class="math display">\[\begin{align*}\min_{w, b, \xi} \quad &amp;\frac{1}{2} \lVert w \rVert^2 + C \sum_{i = 1}^{N} \xi_i\\\\s.t. \quad &amp;y_i(w \cdot x_i + b) \geq 1 - \xi_i\\\\&amp;i = 1, 2, \ldots, N, \quad \xi_i \geq 0\end{align*}\]</span></p><p>这里 <span class="math inline">\(C \geq 0\)</span> 称为惩罚变量，值越大，对误分类的惩罚越大。</p><p>求解原始问题的拉格朗日对偶问题得到</p><p><span class="math display">\[\begin{align*}\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i\\\\\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0\\&amp;C \geq \alpha_i \geq 0, \quad i = 1, 2, \cdots, N\end{align*}\]</span></p><h3 id="学习算法-1">学习算法</h3><ul><li><p><strong>输入</strong>：<span class="math inline">\(T\)</span></p></li><li><p><strong>输出</strong>：分离超平面和分类决策函数</p><ul><li>选择惩罚参数，构造并求解： <span class="math display">\[\begin{align*}\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j \left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i\\\\\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0\\&amp;C \geq \alpha_i \geq 0, \quad i = 1, 2, \cdots, N\end{align*}\]</span></li></ul><p>得到最优解 <span class="math inline">\(\alpha^* = (\alpha_1^{\ast}, \alpha_2^{\ast}, \ldots, \alpha_N^{\ast})\)</span>。</p><ul><li>计算</li></ul><p><span class="math display">\[\begin{align*}w^{\ast} &amp;= \sum_{i=1}^{N} \alpha_i^{\ast} y_i x_i\\\\\forall C &gt; \alpha_j^{\ast} &gt; 0, \quad b^\ast &amp;= y_j - \sum_{i=1}^{N}\alpha_i^\ast y_i(x_i \cdot x_j)\end{align*}\]</span></p></li></ul><hr><h2 id="荷叶损失函数">荷叶损失函数</h2><p>这是对线性支持向量机学习的一种解释，就是最小化以下目标函数：</p><p><span class="math display">\[\min_{w, b} \quad \sum_{i = 1}^{N} [1 - y_i(w \cdot x_i + b)]_+ + \lambda \lVert w \rVert^2\]</span></p><hr><h2 id="非线性支持向量机">非线性支持向量机</h2><p><strong>正定核函数</strong></p><p><span class="math inline">\(K :\mathcal{X} \times \mathcal{X} \to \mathbb{R}\)</span> 是对称函数，<span class="math inline">\(K(x, z)\)</span> 是正定核函数 <span class="math inline">\(\Leftrightarrow\)</span> 对于任意 <span class="math inline">\(x_i \in \mathcal{X}, \quad i = 1, 2, 3, \dots, m\)</span>，<span class="math inline">\(K(x, z)\)</span> 对应的格拉姆矩阵是半正定的。</p><p><strong><span class="math inline">\(Gram\)</span> 矩阵</strong></p><p><span class="math display">\[K = [K(x_i, x_j)]_{m \times m}\]</span></p><p>如何判别这个矩阵是半正定的，可以采用<strong>特征值判别法</strong>，如果一个矩阵的所有特征值都 <span class="math inline">\(\geq 0\)</span>，则这个矩阵是半正定的。</p><h3 id="学习算法-2">学习算法</h3><ul><li><p><strong>输入</strong>：<span class="math inline">\(T\)</span></p></li><li><p><strong>输出</strong>：分离超平面和分类决策函数</p><ul><li>选择惩罚参数，构造并求解： <span class="math display">\[\begin{align*}\min_{\alpha} \quad &amp;\frac{1}{2} \sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_i \alpha_j y_i y_j K\left(x_i \cdot x_j\right) - \sum_{i = 1}^{N} \alpha_i\\\\\operatorname{s.t.} \quad &amp;\sum_{i = 1}^{N} \alpha_i y_i = 0\\&amp;C \geq \alpha_i \geq 0, \quad i = 1, 2, \cdots, N\end{align*}\]</span></li></ul><p>得到最优解 <span class="math inline">\(\alpha^* = (\alpha_1^{\ast}, \alpha_2^{\ast}, \ldots, \alpha_N^{\ast})\)</span>。</p><ul><li>计算</li></ul><p><span class="math display">\[\begin{align*}w^{\ast} &amp;= \sum_{i=1}^{N} \alpha_i^{\ast} y_i x_i\\\\\forall C &gt; \alpha_j^{\ast} &gt; 0, \quad b^\ast &amp;= y_j - \sum_{i=1}^{N}\alpha_i^\ast y_i K(x_i \cdot x_j)\end{align*}\]</span></p></li></ul><h2 id="序列最小最优化算法">序列最小最优化算法</h2><p><strong>两个变量二次规划的求解方式</strong></p><p><span class="math display">\[\begin{align}&amp;\min_{\alpha} \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}\alpha_i \alpha_j y_i y_j K(x_i \cdot x_j) - \sum_{i=1}^{N} \alpha_i \\\\&amp;s.t. \quad \sum_{i = 1}^{N} \alpha_i y_i = 0, \quad C \geq \alpha_i \geq 0, \quad i = 1, 2, \ldots, N\end{align}\]</span></p><p>我们选择 <span class="math inline">\(\alpha_1，\alpha_2\)</span>，规定其他 <span class="math inline">\(\alpha_i (i = 3, 4, \dots, N)\)</span>。</p><h3 id="学习算法-3">学习算法</h3><p>下面只给出<strong>应试过程</strong></p><p>我们的<strong>目标</strong>是，求解下述最小化问题：</p><p><span class="math display">\[\begin{align}&amp;\min_{\alpha_1, \alpha_2} W(\alpha_1, \alpha_2) = \frac{1}{2} K_{11}\alpha_1^2 +  \frac{1}{2} K_{22}\alpha_2^2 +y_1y_2K_{12}\alpha_1\alpha_2 - (\alpha_1 + \alpha_2) + y_1\alpha_1\sum_{i=3}^{N}y_i\alpha_iK_{i1} + y_2\alpha_2\sum_{i=3}^{N}y_i\alpha_iK_{i2} \tag{1}\\\\&amp;s.t. \quad \alpha_1y_1 + \alpha_2y_2 = \sum_{i=3}^{N}y_i\alpha_i = \zeta, \quad 0 \leq \alpha_i \leq C, \quad i = 1, 2 \tag{2}\end{align}\]</span></p><p><span class="math inline">\(K_{ij} = K(x_i, x_j),i,j = 1,2, \dots, N\)</span>，<span class="math inline">\(\zeta\)</span> 是一个常数。同时需要注意的是，公式 <span class="math inline">\((1)\)</span> 缺少了常数项</p><p><span class="math display">\[\text{const} = \sum_{i=3}^N \alpha_i - \frac{1}{2} \sum_{i=3}^N \sum_{j=3}^N \alpha_i \alpha_j y_i y_j K(x_i, x_j)\]</span></p><p>但这个常数项<strong>不会</strong>影响优化 <span class="math inline">\(\alpha_1\)</span> 和 <span class="math inline">\(\alpha_2\)</span> 的结果，故可以省略。</p><p>我们考虑 <span class="math inline">\(\alpha_2\)</span> 的最优化问题。</p><p>如果 $ y_1 y_2 $</p><p><span class="math display">\[L = \max(0, \alpha_2^{old} - alpha_1^{old}), \quad H = \min(C, C + \alpha_2^{old} - alpha_1^{old}) \tag{3}\]</span></p><p>否则</p><p><span class="math display">\[L = \max(0, \alpha_2^{old} + alpha_1^{old} - C), \quad H = \min(C, \alpha_2^{old} + alpha_1^{old}) \tag{4}\]</span></p><p>为了叙述简单，记</p><p><span class="math display">\[g(x) = \sum_{i=1}^{N}\alpha_i y_i K(x_i, x) + b\]</span></p><p>令</p><p><span class="math display">\[E_i = g(x_i) - y_i = \sum_{j=1}^{N}\alpha_j y_j K(x_j, x_i) + b - y_i, \quad i = 1, 2\]</span></p><p>接下来我们更新 <span class="math inline">\(\alpha_2\)</span></p><p><span class="math display">\[\alpha_2^{new,unc} = \alpha_2^{old} + \frac{y_2(E_1 - E_2)}{\eta}, \quad \eta = K_{11} + K_{22} - 2K_{12}\]</span></p><p><span class="math display">\[\alpha_2^{new} =\begin{cases}H, &amp;\alpha_2^{new,unc} &gt; H\\\\\alpha_2^{new,unc}, &amp;L \leq \alpha_2^{new,unc} \leq H\\\\L, &amp;\alpha_2^{new,unc} &lt; L\end{cases}\]</span></p><p>N然后再更新 <span class="math inline">\(\alpha_1\)</span></p><p><span class="math display">\[\alpha_1^{new} = \alpha_1^{old} + y_1 y_2(\alpha_2^{old} - \alpha_2^{new})\]</span></p><p><strong>如何选择 <span class="math inline">\(\alpha_1\)</span> 和 <span class="math inline">\(\alpha_2\)</span></strong></p><ol type="1"><li>在所有节点中选择具有最大 <span class="math inline">\(E_i\)</span> 值的节点作为 <span class="math inline">\(\alpha_1\)</span>。</li><li>选择使得 <span class="math inline">\(|E_1 - E_2|\)</span> 最大的节点作为 <span class="math inline">\(\alpha_2\)</span>。</li></ol><p><strong>求解阈值 b 和 E 的计算方法</strong></p><p><span class="math display">\[b_1^{new} = -E_1 - y_1 K_{11} (\alpha_1^{new} - \alpha_1^{old}) - y_2 K_{21} (\alpha_2^{new} - \alpha_2^{old}) + b^{old}\]</span></p><p><span class="math display">\[b_2^{new} = -E_2 - y_1 K_{12} (\alpha_1^{new} - \alpha_1^{old}) - y_2 K_{22} (\alpha_2^{new} - \alpha_2^{old}) + b^{old}\]</span></p><p><span class="math display">\[b^{new} = \frac{b_1^{new} + b_2^{new}}{2}\]</span></p><p><strong>此外</strong></p><p>更新 <span class="math inline">\(E\)</span>：</p><p><span class="math display">\[E_i^{new} = \sum_{\mathcal{S}}y_j \alpha_j K(x_i, x_j) + b^{new} - y_i\]</span></p><p>其中 <span class="math inline">\(\mathcal{S}\)</span> 包含所有支持向量 <span class="math inline">\(x_i\)</span>。样本 <span class="math inline">\(x_i\)</span> 是支持向量 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(0 &lt; \alpha_i^* &lt; C\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下推自动机</title>
    <link href="/2025/05/28/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2025/05/28/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="背景知识">背景知识</h1><h2 id="pda形式化描述">PDA形式化描述</h2><p><span class="math display">\[\text{PDA} \quad M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F) \tag{1}\]</span> - <span class="math inline">\(Q\)</span>：状态集合 - <span class="math inline">\(\Sigma\)</span>：字母表 - <span class="math inline">\(\Gamma\)</span>：栈符号表 - <span class="math inline">\(\delta\)</span>：状态转移函数 - <span class="math inline">\(q_0\)</span>：开始状态 - <span class="math inline">\(Z_0\)</span>：栈底符号 - <span class="math inline">\(F\)</span>：终态集合</p><p>其中状态转移函数为</p><p><span class="math display">\[\delta : Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow 2^{Q \times \Gamma^*} \tag{2}\]</span></p><h2 id="即时描述">即时描述</h2><p><span class="math display">\[(q, w, \gamma) \in Q \times \Sigma^* \times \Gamma^* \tag{3}\]</span></p><ul><li>当前状态是 <span class="math inline">\(q\)</span></li><li>未处理的输入字符串是 <span class="math inline">\(w\)</span></li><li>栈中符号串是 <span class="math inline">\(\gamma\)</span></li></ul><h2 id="接受语言">接受语言</h2><p>有两种方式描述：</p><p><span class="math display">\[L(M) = \{w \mid (q_0, w, Z_0)  \vdash ^* (p, \epsilon, \beta) \text{ and } p \in F \} \tag{4}\]</span></p><p><span class="math display">\[L(M) = \{w \mid (q_0, w, Z_0) \vdash ^* (p, \epsilon, \epsilon) \} \tag{5}\]</span></p><h1 id="构造pda">构造PDA</h1><pre><code class=" mermaid">graph LR    A[&quot;Get Grammar&quot;] --&gt; B[&quot;CFG&quot;]    B[&quot;CFG&quot;] --&gt; C[&quot;GNF&quot;]    C[&quot;GNF&quot;] --&quot;finial states&quot;--&gt; D[&quot;PDA&quot;]    C[&quot;GNF&quot;] --&quot;empty stack&quot;--&gt; D[&quot;PDA&quot;]</code></pre><h1 id="pda转换">PDA转换</h1><h2 id="终态换为空栈">终态换为空栈</h2><p>已知终态接受的 PDA <span class="math inline">\(M_1\)</span>，公式化构造空战接受的 PDA <span class="math inline">\(M_2\)</span>，具体过程如下： <span class="math display">\[\text{PDA } M_1 = (Q, \Sigma, \Gamma, \delta_1, q_0, F) \tag{6}\]</span></p><p><span class="math display">\[\text{PDA } M_2 = (Q \cup \{q_{02}, q_e \}, \Sigma, \Gamma \cup \{Z_{02} \}, \delta_2, q_{02}, Z_{02}, F) \tag{7}\]</span></p><p>We construct PDA <span class="math inline">\(M_2\)</span> to simulates PDA <span class="math inline">\(M_1&#39;s\)</span> function. And first step, we need to get in PDA <span class="math inline">\(M_1\)</span>.</p><p><span class="math display">\[\delta_2(q_{02}, \epsilon, Z_{02}) = \{(q_{01}, Z_{01}Z_{02})\} \tag{8}\]</span></p><p>PDA <span class="math inline">\(M_2\)</span> simulates each none <span class="math inline">\(\epsilon\)</span> step of PDA <span class="math inline">\(M_1\)</span>.</p><p><span class="math display">\[\forall (q, a, Z) \in Q \times \Sigma \times \Gamma, \delta_2(q, a, Z) = \delta_1(q, a, Z) \tag{9}\]</span></p><p>PDA <span class="math inline">\(M_2\)</span> completely simulates PDA <span class="math inline">\(M_1\)</span> transition function in none finial states.</p><p><span class="math display">\[\forall (q, Z) \in (Q - F) \times \Gamma, \delta_2(q, \epsilon, Z) = \delta_1(q, \epsilon, Z) \tag{10}\]</span></p><p>In <span class="math inline">\(M_1&#39;s\)</span> finial states, not only should <span class="math inline">\(M_2\)</span> simulates <span class="math inline">\(M_1&#39;s\)</span> <span class="math inline">\(\epsilon\)</span> moves, but also simulates accepting moves.</p><p><span class="math display">\[\forall (q, Z) \in F \times \Gamma, \delta_2(q, \epsilon, Z) = \delta_1(q, \epsilon, Z) \cup \\{(q_e, \epsilon)\\} \tag{11}\]</span></p><p><span class="math inline">\(M_1&#39;s\)</span> stacks having been empty and in finial states, <span class="math inline">\(M_2\)</span> begins to cleat stack.</p><p><span class="math display">\[\forall q \in F, \delta_2(q, \epsilon, Z_{02}) = \{(q_e, \epsilon) \} \tag{12}\]</span></p><p><span class="math display">\[\forall q \in \Gamma \cup \{Z_{02} \}, \delta_2(q_e, \epsilon, Z) = \{(q_e, \epsilon) \}\]</span></p><h3 id="empty-stack-to-finial-state">Empty Stack to Finial State</h3><p>已知空栈接受的 PDA <span class="math inline">\(M_1\)</span>，要构造一个与之等价终态接受的 PDA <span class="math inline">\(M_2\)</span>，核心思路在于<strong>只要 <span class="math inline">\(M_2\)</span> 发现 <span class="math inline">\(M_1\)</span> 在运行过程中将栈弹空，就可以进入终止状态</strong>。</p><p><strong>公式化构造</strong></p><p>设 PDA <span class="math inline">\(M_1\)</span> 为</p><p><span class="math display">\[\text{PDA } M_1 =\left(Q, \Sigma, \Gamma, \delta_1, q_{01}, Z_{01}, \Phi\right)\]</span></p><p>公式化构造 PDA <span class="math inline">\(M_2\)</span></p><p><span class="math display">\[\text{PDA } M_2 = \left(Q \cup \{q_0, q_f\}, \Sigma, \Gamma \cup \{Z_{02} \}, \delta_2, q_{02}, Z_{02}, \{q_f\} \right)\]</span></p><p>其中状态转移函数 <span class="math inline">\(\delta_2\)</span> 为</p><p><span class="math display">\[\begin{align*}&amp;\delta_2(q_{02}, \epsilon, Z_{02}) = \{(q_{01}, Z_{01} Z_{02})\}\\&amp;\forall(q, a, Z) \in Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma, \quad \delta_2(q, a ,Z) = \delta_1(q, a, Z)\\&amp;\delta_2(q, \epsilon, Z_{02}) = \{(q_f, \epsilon)\}\end{align*}\]</span></p><h3 id="cfg-to-empty-stack">CFG to Empty Stack</h3><p>先考虑 <span class="math inline">\(L\)</span> 为不含 <span class="math inline">\(\epsilon\)</span> 的 CFL。<span class="math inline">\(G\)</span> 是该语言对应的 GNF 文法，考虑用 PDA 模拟 GNF 的最左派生。</p><p><strong>公式化构造</strong></p><p>设 GNF <span class="math inline">\(G = (V, T, P, S)\)</span>。</p><p>取 PDA <span class="math inline">\(M = (\{q\}, T, V, \delta, q, S, \Phi)\)</span></p><p><span class="math inline">\(\forall A \in V, \quad a \in T, \quad \gamma \in V^{\ast}\)</span> 我们有 <span class="math inline">\(\delta(q, a, A) = \{(q, \gamma) \mid A \to a\gamma \in P\}\)</span></p><p><strong>补充 <span class="math inline">\(\{\epsilon\}\)</span></strong></p><p>在 <span class="math inline">\(M\)</span> 的基础上，构造 <span class="math inline">\(M_1\)</span>，具体是</p><p><span class="math display">\[M_1 = (\{q, q_0\}, T, V \cup \{Z\}, \delta_1, q_0, Z, \Phi)\]</span></p><p>对于状态转移函数 <span class="math inline">\(\delta_1\)</span>，定义如下：</p><p><span class="math display">\[\begin{align*}\delta_1(q_0, \epsilon, Z) &amp;= \{(q_0, \epsilon), (q, S)\}\\\delta_1(q, a, A) &amp;= \delta(q, a, A)\end{align*}\]</span></p><h3 id="empty-stack-to-cfg">Empty Stack to CFG</h3><p><strong>公式化构造</strong></p><p>设 PDA <span class="math inline">\(M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, \Phi)\)</span>，取 CFG <span class="math inline">\(G = (V, \Sigma, P, S)\)</span>，其中： <span class="math display">\[\begin{align*}V &amp;= \{S\} \cup Q \times \Gamma \times Q，\text{特别地我们用$[q_i, A, q_j]$来表示变量}\\P &amp;= \{S \to [q_0, Z_0, q] \mid q \in Q\}\\&amp; \cup \{[q, A, q_{n + 1}] \to a[q_1, A_1, q_2][q_2, A_2, q_3] \dots [q_n, A_n, q_{n + 1} \mid (q_1, A_1A_2 \dots A_n) \in \delta(q, a, A) \text{且} a \in \Sigma \cup \{\epsilon\}, n \geq 1\}\\&amp; \cup \{[q, A, q_1] \to a \mid (q_1, \epsilon) \in \delta(q, a, A)\}\end{align*}\]</span></p><h2 id="课后习题解答">课后习题解答</h2><h3 id="构造空栈接受的-pda">8.(2) 构造空栈接受的 PDA</h3><p><span class="math display">\[\begin{align*}S &amp;\to aBcB | bAAd\\B &amp;\to aBa | Da | \epsilon\\A &amp;\to bbA | \epsilon\\D &amp;\to d\\\end{align*}\]</span></p><h3 id="补充题">补充题</h3><p><strong>Question:</strong> PDA <span class="math inline">\(\to\)</span> CFG 绘制此PDA状态转移图，按照定理7-4所述的文法构造方法进行转换。并对所得到的文法进行化简。</p><p><span class="math display">\[\begin{align*}\delta(q_0, a, Z) &amp;= \{(q_0, AZ)\} \tag{1}\\\delta(q_0, a, A) &amp;= \{(q_0, A)\} \tag{2}\\\delta(q_0, b, A) &amp;= \{(q_1, \epsilon)\} \tag{3}\\\delta(q_1, \epsilon, Z) &amp;= \{(q_2, \epsilon)\} \tag{4}\end{align*}\]</span></p><p><strong>Answer:</strong></p><p>根据 <span class="math inline">\((4)\)</span> 式，可以判断这是一个空栈接受的 PDA。</p><p>设 PDA <span class="math inline">\(M = (Q, \Sigma, \Gamma, \delta, q_0, Z, \Phi)\)</span></p><p>公式化构造 CFG。</p><p><strong>首先</strong></p>]]></content>
    
    
    <categories>
      
      <category>形式语言与自动机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>决策树</title>
    <link href="/2025/05/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2025/05/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="决策树">决策树</h2><p>本文章中，总数据集是 <span class="math inline">\(D\)</span>，属性集是 <span class="math inline">\(a\)</span>，其中 <span class="math inline">\(a = \{a^1, a^2, \ldots, a^V \}\)</span>，表示属性 <span class="math inline">\(a\)</span> 有 <span class="math inline">\(V\)</span> 种取值；<span class="math inline">\(D^v = \{D(\text{attribute}(a) = a^v)\}\)</span> 则表示总数据集 <span class="math inline">\(D\)</span> 中满足属性 <span class="math inline">\(a = a^v\)</span> 的数目。</p><p>决策树是一种分类算法，本文将介绍三种决策树算法，包括三种决策树算法涉及到的多个概念，比如信息熵、信息增益、信息增益比等等。</p><h2 id="信息熵">信息熵</h2><p><span class="math display">\[p_k = \frac{\sum(sort = k)}{|D|} \quad (k = 1,2,\ldots,|\mathscr{Y}|)\]</span></p><p>用符号 <strong><span class="math inline">\(\operatorname{Ent}\)</span></strong> 表示信息熵</p><p><span class="math display">\[\text{Ent}(D) = -\sum_{k=1}^{|\mathscr{Y}|}p_k\log_2p_k\]</span></p><h2 id="信息增益">信息增益</h2><p>用符号 <strong><span class="math inline">\(\text{Gain}\)</span></strong> 表示信息增益</p><p><span class="math display">\[\text{Gain}(D, a) = \text{Ent}(D) - \sum_{v = 1}^{V} \frac{|D^v|}{|D|}\text{Ent}(D^v)\]</span></p><h2 id="信息增益比">信息增益比</h2><p>用符号 <strong><span class="math inline">\(\text{Gain\_ratio}\)</span></strong> 表示信息增益比</p><p><span class="math display">\[\text{Gain\_ratio}(D,a) = \frac{\text{Gain}(D,a)}{\text{IV}(a)}\]</span></p><p>其中，</p><p><span class="math display">\[\text{IV}(a) = -\sum_{v = 1}^{V}\frac{|D^v|}{|D|} \log_2 \frac{|D^v|}{|D|}\]</span></p><h2 id="基尼指数">基尼指数</h2><p>用符号 <strong><span class="math inline">\(\text{Gini\_index}\)</span></strong> 表示基尼指数</p><p><span class="math display">\[\begin{align*}\text{Gini}(D^v) &amp;= \sum_{k = 1}^{|\mathscr{Y}|}\sum_{k&#39; \neq k}p_k p_{k&#39;}\\\text{Gini}(D^v) &amp;= 1 - \sum_{k = 1}^{|\mathscr{Y}|}p_k^{2}\\\text{Gini\_index}(D,a) &amp;= \sum_{v = 1}^{V} \frac{|D^v|}{|D|} \text{Gini}(D^v)\end{align*}\]</span></p><h2 id="剪枝">剪枝</h2><h3 id="损失函数">损失函数</h3><p>假设决策树 <span class="math inline">\(T\)</span> 有 <span class="math inline">\(|T|\)</span> 个叶节点，每个叶节点 <span class="math inline">\(t\)</span> 有 <span class="math inline">\(N_t\)</span> 个样本，其中类别 <span class="math inline">\(k = 1, 2, \ldots, K\)</span> 的样本数为 <span class="math inline">\(N_{tk}\)</span>。</p><p><strong>损失函数</strong></p><p><span class="math display">\[C_\alpha(T) = \sum_{t=1}^{|T|}N_t \operatorname{Ent}(D_t) + \alpha |T|\]</span></p><p>其中 <span class="math inline">\(\operatorname{Ent}(D_t)\)</span> 是叶节点 <span class="math inline">\(t\)</span> 上样本集合 <span class="math inline">\(D_t\)</span> 的信息熵，</p><p><span class="math display">\[\operatorname{Ent}(D_t) = -\sum_{k=1}^{|\mathscr{Y}|} p_{tk} \log_2 p_{tk}\]</span></p><p>其中 <span class="math inline">\(p_{tk} = \frac{N_{tk}}{N_t}\)</span>，<span class="math inline">\(N_{tk}\)</span> 为叶节点 <span class="math inline">\(t\)</span> 上第 <span class="math inline">\(k\)</span> 类样本数，<span class="math inline">\(N_t\)</span> 为叶节点 <span class="math inline">\(t\)</span> 的样本总数。</p><p>所以可以将损失函数写成：</p><p><span class="math display">\[\begin{align*}C(T) &amp;= -\sum_{t=1}^{|T|} N_t \sum_{k=1}^{|\mathscr{Y}|} p_{tk} \log_2 p_{tk}\\\\C_\alpha(T) &amp;= C(T) + \alpha |T|\end{align*}\]</span></p><p>我们的<strong>目的</strong>就是最小化损失函数</p><p><span class="math display">\[\min_{T} \quad C_\alpha(T) = \sum_{t=1}^{|T|}N_t \operatorname{Ent}(D_t) + \alpha |T|\]</span></p><h4 id="算法步骤">算法步骤</h4><p>我们可以定义一个DP[]数组，并使用动态规划的思想来找到最优剪枝</p><ul><li>输入数据 <span class="math inline">\(X = \{(\vec{x}_1, y_1), (\vec{x}_2, y_2), \ldots, (\vec{x}_N, y_N) \}\)</span></li><li>输出 <span class="math inline">\(T_\alpha\)</span></li></ul><ol type="1"><li>对于树T中的每个节点t，计算 <span class="math inline">\(H_t(T)\)</span></li><li>从树的叶节点开始递归地向上回溯，比较 <span class="math inline">\(C_\alpha(T_A)\)</span> 和 <span class="math inline">\(C_\alpha(T_B)\)</span></li><li>返回步骤2</li></ol><h2 id="cart">CART</h2><h3 id="回归树">回归树</h3><p>回归树对应于输入空间的分割和分割单元内的输出值。</p><p>输入空间 <span class="math inline">\(M = R_1, R_2, \ldots, R_M\)</span>，每个空间 <span class="math inline">\(R_m\)</span> 有一个输出值 <span class="math inline">\(c_m\)</span>，我们可以定义回归树模型如下：</p><p><strong>回归树模型</strong> <span class="math display">\[f(x) = \sum_{m=1}^{M} c_m I (x \in R_m)\]</span></p><p><strong>均方误差</strong> <span class="math display">\[\sum_{x_i \in R_m} (y_i - f(x_i))^2\]</span></p><p><span class="math display">\[\hat{c}_m = \text{ave}(y_i \mid x_i \in R_m)\]</span></p><h4 id="分割算法">分割算法</h4><ul><li>输入：训练数据 <span class="math inline">\(D\)</span></li><li>输出：回归树 <span class="math inline">\(f(x)\)</span></li></ul><ol type="1"><li>选择 <span class="math inline">\(x_j\)</span>，其输出为 <span class="math inline">\(s\)</span>。空间 <span class="math inline">\(R_1(j, s) = \{x \mid x^{(j)} \leq s\}\)</span>，空间 <span class="math inline">\(R_2(j, s) = \{x \mid x^{(j)} &gt; s\}\)</span></li><li><span class="math display">\[\min_{j,s}\left[\min_{c_1} \sum_{x_i \in R_1(j,s)} (y_i - c_1)^2 + \min_{c_2} \sum_{x_i \in R_2(j,s)} (y_i - c_2)^2 \right]\]</span></li><li><span class="math display">\[\frac{1}{N_m} \sum_{x_i \in R_m(j,s)} y_i, \quad x_i \in R_m, \quad m = 1, 2\]</span></li><li>重复步骤2和3，直至满足停止条件。</li></ol><h3 id="分类树">分类树</h3><p>根据<strong>基尼指数</strong>进行分类即可</p><p><span class="math display">\[\begin{aligned}\text{Gini}(D^v) &amp;= \sum_{k = 1}^{|\mathscr{Y}|}\sum_{k&#39; \neq k}p_k p_{k&#39;}\\\text{Gini}(D^v) &amp;= 1 - \sum_{k = 1}^{|\mathscr{Y}|}p_k^{2}\\\text{Gini\_index}(D,a) &amp;= \sum_{v = 1}^{V} \frac{|D^v|}{|D|} \text{Gini}(D^v)\end{aligned}\]</span></p><h3 id="textcart-剪枝"><span class="math inline">\(\text{CART}\)</span> 剪枝</h3><p><span class="math inline">\(\text{CART}\)</span> 剪枝算法由两步组成：手下从省城算法产生的决策树 <span class="math inline">\(T_0\)</span> 底端开始不断简直，直到 <span class="math inline">\(T_0\)</span> 的根节点，形成一个子树序列 <span class="math inline">\(\{T_0, T_1, \cdots T_n\}\)</span>；然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</p><h4 id="textcart-剪枝算法"><span class="math inline">\(\text{CART}\)</span> 剪枝算法</h4><p><strong>输入</strong>：<span class="math inline">\(\text{CART}\)</span> 算法生成的决策树 <span class="math inline">\(T_0\)</span>； <strong>输出</strong>：最优决策树 <span class="math inline">\(T_{\alpha}\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>隐马尔科夫模型</title>
    <link href="/2025/05/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/05/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="隐马尔科夫模型的定义">隐马尔科夫模型的定义</h2><p>隐马尔科夫模型有如下两个假设：任意状态只依赖于前一时刻状态和任意时刻的观测只依赖于该时刻的马尔科夫链的状态。 设 <span class="math inline">\(Q\)</span> 是所有可能的状态的集合，<span class="math inline">\(V\)</span>是所有可能的观测的集合：</p><p><span class="math display">\[Q =\{q_1, q_2, \dots, q_N\}, \quad V = \{v_1, v_2, \dots, v_M\}\]</span></p><p>其中，<span class="math inline">\(N\)</span> 是可能的状态数，<span class="math inline">\(M\)</span> 是可能的观测数。 <span class="math inline">\(I\)</span> 是长度为 <span class="math inline">\(T\)</span> 的状态序列，<span class="math inline">\(O\)</span> 是对应的观测序列：</p><p><span class="math display">\[I = (i_1, i_2, \dots, i_T), \quad O =(o_1, o_2, \dots, o_T)\]</span></p><p><span class="math inline">\(A\)</span> 是状态转移概率矩阵：</p><p><span class="math display">\[A = [a_{ij}]_{N \times N} \tag{1}\]</span></p><p>其中，</p><p><span class="math display">\[a_{ij} = P(i_{t + 1} = q_j | i_t = q_i), \quad i = 1, 2, \dots, N; \quad j = 1, 2, \dots, N \tag{2}\]</span></p><p><span class="math inline">\(B\)</span> 是观测概率矩阵：</p><p><span class="math display">\[B = [b_j(k)]_{N \times N} \tag{3}\]</span></p><p>其中，</p><p><span class="math display">\[b_j(k) = P(o_t = v_k | i_t = q_j), \quad k = 1, 2, \dots, M; \quad j = 1, 2, \dots, N \tag{4}\]</span></p><p><span class="math inline">\(\pi\)</span> 是初始状态概率向量：</p><p><span class="math display">\[\pi = (\pi_i) \tag{5}\]</span></p><p>其中，</p><p><span class="math display">\[\pi_i = P(i_1 = q_i), \quad i = 1, 2, \dots, N \tag{6}\]</span></p><p>综上，可以将隐马尔科夫模型用三元符号表示，即</p><p><span class="math display">\[\lambda = (A, B, \pi) \tag{7}\]</span></p><h2 id="隐马尔科夫模型的3个基本问题">隐马尔科夫模型的3个基本问题</h2><h3 id="概率计算问题">概率计算问题</h3><p>给定模型 <span class="math inline">\(\lambda = (A, B, \pi)\)</span> 和观测序列 <span class="math inline">\(O = (o_1, o_2, \dots, o_T)\)</span>，计算在模型 <span class="math inline">\(\lambda\)</span> 下观测序列 <span class="math inline">\(O\)</span> 出现的概率 <span class="math inline">\(P(O | \lambda)\)</span>。</p><h4 id="前向算法">前向算法</h4><p>输入：隐马尔科夫模型 <span class="math inline">\(\lambda\)</span>，观测序列 <span class="math inline">\(O\)</span>； 输出：观测序列概率 <span class="math inline">\(P(O | \lambda)\)</span>。</p><p>（1）初值</p><p><span class="math display">\[\alpha_1(i) = \pi_i b_i(o_1), \quad i = 1, 2, \dots, N \tag{8}\]</span></p><p>（2）递推，对 <span class="math inline">\(t = 1, 2, \dots, T - 1\)</span>，</p><p><span class="math display">\[\alpha_{t + 1}(i) = \left[\sum_{j = 1}^{N} \alpha_t(j) a_{ji}\right]b_i(o_{t + 1}), \quad i = 1, 2, \dots, N \tag{9}\]</span></p><p>（3）终止</p><p><span class="math display">\[P(O | \lambda) = \sum_{i = 1}^{N} \alpha_T(i) \tag{10}\]</span></p><p>这个算法中的 <span class="math inline">\(\alpha\)</span> 可以用一个矩阵表示，其中下标表示行号，括号内表示列号</p><p><span class="math display">\[\alpha = \begin{bmatrix}\alpha_1(1) &amp; \alpha_1(2) &amp; \alpha_1(3) &amp; \cdots &amp; \alpha_1(N) \\\\[10pt]\alpha_2(1) &amp; \alpha_2(2) &amp; \alpha_2(3) &amp; \cdots &amp; \alpha_2(N) \\\\[10pt]\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\[10pt]\alpha_T(1) &amp; \alpha_T(2) &amp; \alpha_T(3) &amp; \cdots &amp; \alpha_T(N)\end{bmatrix} \tag{11}\]</span> 每次迭代就是在一次计算行内容。</p><h4 id="后向算法">后向算法</h4><p>输入：隐马尔科夫模型 <span class="math inline">\(\lambda\)</span>，观测序列 <span class="math inline">\(O\)</span>； 输出：观测序列概率 <span class="math inline">\(P(O | \lambda)\)</span>。</p><p>（1） <span class="math display">\[\beta_T(i) = 1, \quad i = 1, 2, \dots, N \tag{12}\]</span></p><p>（2）对 <span class="math inline">\(t = T - 1, T - 2, \dots, 1\)</span></p><p><span class="math display">\[\beta_t(i) = \sum_{j = 1}^{N} a_{ij} b_j(o_{t + 1})\beta_{t + 1}(j) \tag{13}\]</span> （3）</p><p><span class="math display">\[P(O | \lambda) = \sum_{i = 1}^{N} \pi_i b_i(o_1) \beta_1(i) \tag{14}\]</span></p><p><span class="math inline">\(\beta\)</span> 矩阵</p><p><span class="math display">\[\beta = \begin{bmatrix}\beta_1(1) &amp; \beta_1(2) &amp; \beta_1(3) &amp; \cdots &amp; \beta_1(N) \\\\[10pt]\beta_2(1) &amp; \beta_2(2) &amp; \beta_2(3) &amp; \cdots &amp; \beta_2(N) \\\\[10pt]\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\\[10pt]\beta_T(1) &amp; \beta_T(2) &amp; \beta_T(3) &amp; \cdots &amp; \beta_T(N)\end{bmatrix} \tag{15}\]</span></p><h3 id="一些概率与期望值的计算">一些概率与期望值的计算</h3><h4 id="单个状态的计算公式">单个状态的计算公式</h4><p>给定模型 <span class="math inline">\(\lambda\)</span> 和观测 <span class="math inline">\(O\)</span>，在时刻 <span class="math inline">\(t\)</span> 处于状态 <span class="math inline">\(q_i\)</span> 的概率。记</p><p><span class="math display">\[\gamma_t(i) = P(i_t = q_i |O, \lambda) \tag{16}\]</span></p><p>可以通过前向后向概率计算：</p><p><span class="math display">\[\gamma_t(i) = \frac{\alpha_t(i) \beta_t(i)}{P(O |\lambda)} = \frac{\alpha_t(i) \beta_t(i)}{\sum_{j = 1}^{N} \alpha_t(j) \alpha_t(j)} \tag{17}\]</span></p><h4 id="两个状态的计算公式">两个状态的计算公式</h4><p>给定模型 <span class="math inline">\(\lambda\)</span> 和观测 <span class="math inline">\(O\)</span>，在时刻 <span class="math inline">\(t\)</span> 处于状态 <span class="math inline">\(q_i\)</span>，在时刻 <span class="math inline">\(t + 1\)</span> 处于 <span class="math inline">\(q_j\)</span> 的概率。记</p><p><span class="math display">\[\xi_t(i, j) = \frac{\alpha_t(i)a_{ij}b_j(o_{t + 1})\beta_{t + 1}(j)}{\sum_{i = 1}^{N} \sum_{j = 1}^{N} \alpha_t(i) a_{ij} b_j(o_{t + 1}) \beta_{t + 1}(j)} \tag{18}\]</span></p><h4 id="在观测-o-下状态-i-出现的期望值">在观测 <span class="math inline">\(O\)</span> 下状态 <span class="math inline">\(i\)</span> 出现的期望值</h4><p><span class="math display">\[\sum_{t = 1}^{T} \gamma_t(i) \tag{19}\]</span></p><h4 id="在观测-o-下由状态-i-转移的期望值">在观测 <span class="math inline">\(O\)</span> 下由状态 <span class="math inline">\(i\)</span> 转移的期望值</h4><p><span class="math display">\[\sum_{t = 1}^{T - 1} \gamma_t(i) \tag{20}\]</span></p><h4 id="在观测-o-下由状态-i-转移到状态-j-的期望值">在观测 <span class="math inline">\(O\)</span> 下由状态 <span class="math inline">\(i\)</span> 转移到状态 <span class="math inline">\(j\)</span> 的期望值</h4><p><span class="math display">\[\sum_{t = 1}^{T - 1} \xi_t(i, j) \tag{21}\]</span></p><h2 id="学习算法">学习算法</h2><p>前文的内容是都和概率计算有关，那如何根据训练集训练一个隐马尔科夫模型模型呢？</p><h3 id="监督学习方法">监督学习方法</h3><p>如果已给训练数据集包含 <span class="math inline">\(S\)</span> 个长度相同的观测序列和对应的状态序列，我们可以用极大似然估计法来估计参数。分别的有：</p><p><span class="math display">\[\begin{align*}\hat{a_{ij}} &amp;= \frac{A_{ij}}{\sum_{j = 1}^{N} A_{ij}}, \quad i = 1, 2, \dots, N; \quad j = 1, 2, \dots, N \tag{22}\\[10pt]\hat{b_{j}}(k) &amp;= \frac{B_{jk}}{\sum_{k = 1}^{M} B_{jk}}, \quad j = 1, 2, \dots, N; \quad k = 1, 2, \dots, M \tag{23}\\[10pt]\hat{\pi_{i}} &amp;= \frac{\sum \text{初始状态为$q_i$} }{S} \tag{24}\end{align*}\]</span></p><p>其中 <span class="math inline">\(A_{ij}\)</span> 表示在训练数据中，从状态 <span class="math inline">\(q_i\)</span> 转移到状态 <span class="math inline">\(q_j\)</span> 的<strong>次数总和</strong>。<span class="math inline">\(B_{jk}\)</span> 表示在状态 <span class="math inline">\(q_j\)</span> 下，观测到符号 <span class="math inline">\(v_k\)</span> 的<strong>次数总和</strong>。</p><h3 id="baum-welch-算法">Baum-Welch 算法</h3><p>假定训练数据只包含 <span class="math inline">\(S\)</span> 个长度为 <span class="math inline">\(T\)</span> 的观测序列 <span class="math inline">\(\{O_1, O_2, \dots, O_S\}\)</span>，我们将观测序列数据看作观测数据 <span class="math inline">\(O\)</span>，状态序列数据看做不可观测的隐数据 <span class="math inline">\(I\)</span>，那么存在如下概率模型</p><p><span class="math display">\[P(O | \lambda) = \sum_{I} P(O |I, \lambda) P(I |\lambda) \tag{25}\]</span></p><p>实际上，这个模型的参数学习可由 EM 算法实现。</p><p>（1）确定完全数据的对数似然函数。完全数据是<span class="math inline">\((O, I) = (o_1, o_2, \dots, o_T, i_1, i_2, \dots, i_T)\)</span>。</p><p><span class="math display">\[\log P(O, T |\lambda) \tag{26}\]</span></p><p>（2）E步</p><p><span class="math display">\[Q(\lambda, \bar{\lambda}) = \sum_{I} \log P(O, I |\lambda) P(O, I |\bar{\lambda}) \tag{27}\]</span></p><p>其中 <span class="math inline">\(\bar{\lambda}\)</span> 是当前模型参数的估计值，<span class="math inline">\(\lambda\)</span> 是要极大化的模型参数。</p><p><span class="math display">\[P(O, I |\lambda) = \pi_{i_1}b_{i_1}(o_1)a_{i_1i_2}b_{i_2}(o_2) \cdots a_{i_{T-1}i_{T}}b_{i_{T}}(o_T) \tag{28}\]</span></p><p>于是，函数 <span class="math inline">\(Q\)</span> 可以写成：</p><p><span class="math display">\[\begin{align*}Q(\lambda, \bar{\lambda}) = &amp;\sum_{I} \log \pi_{i_1} P(O, I |\bar{\lambda}) + \sum_{I} \left(\sum_{t = 1}^{T - 1} \log a_{i_t i_{t + 1}} \right) P(O, I |\bar{\lambda}) +\\[10pt]&amp;\sum_{I} \left(\sum_{t = 1}^{T} \log b_{i_t}(o_t) \right) P(O, I |\bar{\lambda})\end{align*}\]</span></p><h4 id="算法步骤">算法步骤</h4><p>（1）初始化。对 <span class="math inline">\(n = 0\)</span>，随机初始化 <span class="math inline">\(\lambda^{(0)}\)</span>。 （2）递推。对 <span class="math inline">\(n = 1, 2, \dots\)</span>，</p><p><span class="math display">\[\begin{align*}\alpha_{ij}^{(n + 1)} &amp;= \frac{\sum_{t = 1}^{T - 1} \xi_t(i, j)}{\sum_{t = 1}^{T - 1} \gamma_t(i)}\\[10pt]b_{j}(k)^{(n + 1)} &amp;= \frac{\sum_{t = 1, o_t = v_k}^{T} \gamma_t(j)}{\sum_{t= 1}^{T} \gamma_t(j)}\\[10pt]\pi_{i}^{(n + 1)} &amp;= \gamma_1(i)\end{align*}\]</span></p><h2 id="预测算法">预测算法</h2><h3 id="近似算法">近似算法</h3><p>由公式： <span class="math display">\[\gamma_t(i) = \frac{\alpha_t(i) \beta_t(i)}{P(O |\lambda)} = \frac{\alpha_t(i) \beta_t(i)}{\sum_{j = 1}^{N} \alpha_t(j) \alpha_t(j)}\]</span> 知，在每一时刻 <span class="math inline">\(t\)</span> 最有可能的状态 <span class="math inline">\(i_t^{\ast}\)</span> 是 <span class="math display">\[i_t^{\ast} = \operatorname{arg} \max_{1 \leq i \leq N} [\gamma_t(i)], \quad t = 1, 2, \dots, T \tag{29}\]</span></p><h3 id="维特比算法">维特比算法</h3><p>维特比算法是用动态规划解隐马尔科夫模型的预测问题。</p><h4 id="算法步骤-1">算法步骤</h4><p>输入：模型 <span class="math inline">\(\lambda = (A, B, \pi)\)</span> 和观测序列 <span class="math inline">\(O = (o_1, o_2, \dots, o_T)\)</span>； 输出：最优路径 <span class="math inline">\(I^{\ast} = (i_1^{\ast}, i_2^{\ast}, \dots, i_T^{\ast})\)</span>。</p><p>（1）初始化</p><p><span class="math display">\[\begin{align*}\delta_1(i) = \pi_i b_i(o_1), \quad i = 1, 2, \dots, N\\[10pt]\Psi_1(i) = 0, \quad i = 1, 2, \dots, N\end{align*}\]</span></p><p>（2）递推。对 <span class="math inline">\(t = 2, 3, \cdots, T\)</span></p><p><span class="math display">\[\begin{align*}\delta_t(i) &amp;= \max_{1 \leq j \leq N} [\delta_{t - 1}(j) a_{ji}] b_i(o_t), \quad i = 1, 2, \cdots, N\\[10pt]\Psi_t(i) &amp;= \operatorname{arg} \max_{1 \leq j \leq N}[\delta_{t - 1} a_{ji}], \quad i = 1, 2, \cdots, N\end{align*}\]</span></p><p>（3）终止</p><p><span class="math display">\[\begin{align*}P^{\ast} &amp;= \max_{1 \leq i \leq N} \delta_{T}(i)\\[10pt]i_{T}^{\ast} &amp;= \operatorname{arg} \max_{1 \leq i \leq N} [\delta_{T}(i)]\end{align*}\]</span></p><p>（4）最优路径回溯。对 <span class="math inline">\(t = T - 1, T - 2, \cdots, 1\)</span></p><p><span class="math display">\[i_t^{\ast} = \Psi_{t + 1}(i_{t + 1}^{\ast})\]</span></p><p>求得最优路径 <span class="math inline">\(I^{\ast} = (i_1^{\ast}, i_2^{\ast}, \dots, i_T^{\ast})\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
