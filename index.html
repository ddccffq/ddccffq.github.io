<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ddccffq.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
<meta property="og:type" content="website">
<meta property="og:title" content="ddccffq的技术博客">
<meta property="og:url" content="https://ddccffq.github.io/index.html">
<meta property="og:site_name" content="ddccffq的技术博客">
<meta property="og:description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ddccffq">
<meta property="article:tag" content="机器学习,计算机网络,算法,统计学习">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ddccffq.github.io/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ddccffq的技术博客</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","per_page":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ddccffq的技术博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">机器学习与计算机网络</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ddccffq"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">ddccffq</p>
  <div class="site-description" itemprop="description">专注于机器学习、计算机网络、统计学习方法的技术分享</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ddccffq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ddccffq" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1765752538@qq.com" title="E-Mail → mailto:1765752538@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/17/Wireshark-Homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/17/Wireshark-Homework/" class="post-title-link" itemprop="url">Wireshark Homework</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-17 13:21:04 / 修改时间：14:54:02" itemprop="dateCreated datePublished" datetime="2025-06-17T13:21:04+08:00">2025-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Wireshark/" itemprop="url" rel="index"><span itemprop="name">Wireshark</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="提取的请求信息"><a href="#提取的请求信息" class="headerlink" title="提取的请求信息"></a>提取的请求信息</h2><p><img src="/Wireshark-Homework/my%20ipconfig.png" alt="my ipconfig"></p>
<p><img src="/Wireshark-Homework/a%20request%20and%20its%20response.png" alt="a request and its response"></p>
<p><img src="/Wireshark-Homework/get%20request.png" alt="get request"></p>
<p><img src="/Wireshark-Homework/request%20right.png" alt="request right"></p>
<p><img src="/Wireshark-Homework/response.png" alt="response"></p>
<p><img src="/Wireshark-Homework/response%20more%20details.png" alt="response more details"></p>
<p><img src="/Wireshark-Homework/response%20right.png" alt="response right"></p>
<h3 id="源和目标IP地址"><a href="#源和目标IP地址" class="headerlink" title="源和目标IP地址"></a>源和目标IP地址</h3><ul>
<li><strong>源IP地址</strong>: 10.21.205.40（本机IP，如ipconfig截图所示）</li>
<li><strong>目标IP地址</strong>: 104.110.191.133（服务器IP）</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><ul>
<li><strong>源端口</strong>: 54283（随机分配的客户端端口）</li>
<li><strong>目标端口</strong>: 80（标准HTTP端口）</li>
</ul>
<h3 id="Host字段"><a href="#Host字段" class="headerlink" title="Host字段"></a>Host字段</h3><ul>
<li><strong>Host</strong>: <code>www.msftconnecttest.com</code></li>
</ul>
<h3 id="User-Agent字段"><a href="#User-Agent字段" class="headerlink" title="User-Agent字段"></a>User-Agent字段</h3><ul>
<li><strong>User-Agent</strong>: Microsoft NCSI</li>
</ul>
<h2 id="提取的响应信息"><a href="#提取的响应信息" class="headerlink" title="提取的响应信息"></a>提取的响应信息</h2><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul>
<li><strong>状态码</strong>: 200 OK</li>
</ul>
<h3 id="Content-Type字段"><a href="#Content-Type字段" class="headerlink" title="Content-Type字段"></a>Content-Type字段</h3><ul>
<li><strong>Content-Type</strong>: text&#x2F;plain</li>
</ul>
<h3 id="Server字段"><a href="#Server字段" class="headerlink" title="Server字段"></a>Server字段</h3><ul>
<li>在提供的截图中没有明确显示Server字段，该字段可能不存在于此HTTP响应中，或位于未捕获到的响应头部分</li>
</ul>
<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><h3 id="HTTP请求的目标端口通常是多少？"><a href="#HTTP请求的目标端口通常是多少？" class="headerlink" title="HTTP请求的目标端口通常是多少？"></a>HTTP请求的目标端口通常是多少？</h3><p>HTTP请求的<strong>标准目标端口是80</strong>，如截图中所示。HTTPS则使用443端口。</p>
<h3 id="报文中的字段形式是怎样的？"><a href="#报文中的字段形式是怎样的？" class="headerlink" title="报文中的字段形式是怎样的？"></a>报文中的字段形式是怎样的？</h3><p>HTTP报文使用<strong>纯文本格式</strong>，以”字段名: 字段值”的形式组织，每行一个字段，如截图中所示：</p>
<ul>
<li><code>Host: www.msftconnecttest.com</code></li>
<li><code>User-Agent: Microsoft NCSI</code> </li>
<li><code>Content-Type: text/plain</code></li>
</ul>
<p>Wireshark同时提供了三种查看方式：</p>
<ol>
<li><strong>解析后的纯文本视图</strong>（HTTP协议字段被解析为易读形式）</li>
<li><strong>十六进制原始数据视图</strong>（数据包的二进制表现形式）</li>
<li><strong>结构化协议树</strong>（按协议层级组织的视图）</li>
</ol>
<p>在Wireshark中可以看到，虽然在网络上传输时是二进制字节流，但HTTP协议本身是<strong>基于文本</strong>的协议。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p><img src="/Wireshark-Homework/%E5%9B%9B%E6%9D%A1%E4%BF%A1%E6%81%AF.png" alt="四条信息"></p>
<p><img src="/Wireshark-Homework/config.png" alt="config"></p>
<p><img src="/Wireshark-Homework/A%20request.png" alt="A request"></p>
<p><img src="/Wireshark-Homework/AAAA%20request.png" alt="AAAA request"></p>
<p><img src="/Wireshark-Homework/A%20response.png" alt="A response"></p>
<p><img src="/Wireshark-Homework/AAAA%20response.png" alt="AAAA response"></p>
<h2 id="清除DNS缓存"><a href="#清除DNS缓存" class="headerlink" title="清除DNS缓存"></a>清除DNS缓存</h2><p>从终端截图可以看到，已使用命令<code>ipconfig /flushdns</code>成功清除了DNS缓存：</p>
<ul>
<li>终端显示：<strong>“已成功刷新 DNS 解析缓存”</strong></li>
<li>使用<code>nslookup</code>确认DNS服务器为<strong>10.3.9.5</strong></li>
</ul>
<h2 id="DNS查询与响应报文分析"><a href="#DNS查询与响应报文分析" class="headerlink" title="DNS查询与响应报文分析"></a>DNS查询与响应报文分析</h2><h3 id="查询报文分析"><a href="#查询报文分析" class="headerlink" title="查询报文分析"></a>查询报文分析</h3><p>根据截图，可以看到多个DNS查询：</p>
<ol>
<li><strong>查询域名</strong>：<a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a></li>
<li><strong>查询类型</strong>：<ul>
<li>A记录查询（IPv4地址）- Type: A (1)</li>
<li>AAAA记录查询（IPv6地址）- Type: AAAA (28)</li>
</ul>
</li>
<li><strong>查询特征</strong>：<ul>
<li>Transaction ID: 0x8d99（A记录查询）和0xaa7c（AAAA记录查询）</li>
<li>源端口：55570、59624（随机客户端端口）</li>
<li>目标端口：<strong>53</strong>（标准DNS端口）</li>
<li>使用<strong>UDP协议</strong>传输</li>
</ul>
</li>
</ol>
<h3 id="响应报文分析"><a href="#响应报文分析" class="headerlink" title="响应报文分析"></a>响应报文分析</h3><ol>
<li><strong>查询域名</strong>：<code>www.163.com</code></li>
<li><strong>响应IP地址</strong>：多个IP地址返回，包括：<ul>
<li><strong>IPv4地址</strong>（A记录）：<ul>
<li>220.181.171.126</li>
<li>220.181.10.69</li>
<li>220.181.10.67</li>
<li>220.181.10.70</li>
<li>220.181.10.66</li>
<li>等多个IP地址</li>
</ul>
</li>
<li><strong>CNAME记录</strong>：<ul>
<li><code>www.163.com.163jiasu.com</code></li>
<li><code>www.163.com.w.kunluncan.com</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="DNS协议特性分析"><a href="#DNS协议特性分析" class="headerlink" title="DNS协议特性分析"></a>DNS协议特性分析</h2><h3 id="DNS使用的端口号"><a href="#DNS使用的端口号" class="headerlink" title="DNS使用的端口号"></a>DNS使用的端口号</h3><p>从截图中可以明确看到：</p>
<ul>
<li><strong>服务器端口</strong>：53（固定标准端口）</li>
<li><strong>客户端端口</strong>：随机高位端口（如55570、59624）</li>
</ul>
<h3 id="DNS使用的传输协议"><a href="#DNS使用的传输协议" class="headerlink" title="DNS使用的传输协议"></a>DNS使用的传输协议</h3><p>截图中可以看到：</p>
<ul>
<li><strong>主要使用UDP协议</strong>，因为：<ul>
<li>数据包标识为”User Datagram Protocol”</li>
<li>相比TCP更快速，适合简短的DNS查询</li>
<li>标准DNS查询通常小于512字节，适合UDP传输</li>
</ul>
</li>
</ul>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>DNS特性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>查询域名</td>
<td><code>www.163.com</code></td>
<td>中国网易公司网站</td>
</tr>
<tr>
<td>查询类型</td>
<td>A 和 AAAA</td>
<td>分别查询IPv4和IPv6地址</td>
</tr>
<tr>
<td>客户端端口</td>
<td>55570、59624等</td>
<td>随机高位端口</td>
</tr>
<tr>
<td>服务器端口</td>
<td>53</td>
<td>DNS标准端口</td>
</tr>
<tr>
<td>传输协议</td>
<td>UDP</td>
<td>无连接、快速、适合短查询</td>
</tr>
<tr>
<td>查询事务ID</td>
<td>0x8d99、0xaa7c</td>
<td>确保请求和响应匹配的唯一标识符</td>
</tr>
</tbody></table>
</div>

<p><strong>补充说明</strong>：虽然本次抓包显示使用UDP，但DNS协议在某些情况下也会使用TCP：</p>
<ul>
<li>当响应大小超过512字节时</li>
<li>进行区域传送(AXFR)等操作时</li>
<li>需要可靠连接时</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/10/Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/10/Introduction/" class="post-title-link" itemprop="url">Introduction</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-10 08:43:49" itemprop="dateCreated datePublished" datetime="2025-06-10T08:43:49+08:00">2025-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-17 09:39:18" itemprop="dateModified" datetime="2025-06-17T09:39:18+08:00">2025-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/" itemprop="url" rel="index"><span itemprop="name">Computer Network</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/Introduction/" itemprop="url" rel="index"><span itemprop="name">Introduction</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Network-Edge"><a href="#Network-Edge" class="headerlink" title="Network Edge"></a>Network Edge</h1><p>applications and hosts</p>
<h1 id="Client-Program-and-Server-Program"><a href="#Client-Program-and-Server-Program" class="headerlink" title="Client Program and Server Program"></a>Client Program and Server Program</h1><p>一般而言，客户端程序是 <strong>发送请求</strong> 的，而服务器端程序是 <strong>接受请求</strong> 的。</p>
<h1 id="Access-Technologies"><a href="#Access-Technologies" class="headerlink" title="Access Technologies"></a>Access Technologies</h1><div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>接入技术</th>
<th>分类</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>数字用户线（DSL）</td>
<td>居家接入</td>
<td>通过电话线为家庭用户提供宽带互联网接入</td>
</tr>
<tr>
<td>电缆调制解调器</td>
<td>居家接入</td>
<td>通过有线电视网络为家庭用户提供互联网接入</td>
</tr>
<tr>
<td>光纤到户（FTTH）</td>
<td>居家接入&#x2F;公司接入</td>
<td>通过光纤直接连接家庭或公司，提供高速接入</td>
</tr>
<tr>
<td>以太网</td>
<td>公司接入</td>
<td>企业内部常用的局域网接入方式</td>
</tr>
<tr>
<td>Wi-Fi</td>
<td>居家接入&#x2F;公司接入</td>
<td>无线局域网，常用于家庭和公司内部无线接入</td>
</tr>
<tr>
<td>蜂窝移动网络（3G&#x2F;4G&#x2F;5G）</td>
<td>移动接入</td>
<td>通过移动运营商网络为移动设备提供互联网接入</td>
</tr>
</tbody></table>
</div>

<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>接入技术</th>
<th>典型速率范围</th>
<th>速率共享性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>拨号调制解调器</td>
<td>最高 56 Kbps</td>
<td>专用</td>
<td>每户独占电话线</td>
</tr>
<tr>
<td>HFC</td>
<td>10 Mbps ~ 1 Gbps（下行）</td>
<td>共享</td>
<td>同轴电缆段内用户共享带宽</td>
</tr>
<tr>
<td>DSL</td>
<td>256 Kbps ~ 100 Mbps（下行）</td>
<td>专用</td>
<td>每户独占电话线，汇聚点可能有瓶颈</td>
</tr>
<tr>
<td>FTTH</td>
<td>100 Mbps ~ 10 Gbps</td>
<td>通常专用</td>
<td>部分PON架构下分光器后带宽被共享</td>
</tr>
</tbody></table>
</div>

<h1 id="HFC-hybrid-fiber-coax"><a href="#HFC-hybrid-fiber-coax" class="headerlink" title="HFC: hybrid fiber coax"></a>HFC: hybrid fiber coax</h1><div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody><tr>
<td>HFC 传输速率是专用还是共享？</td>
<td>共享</td>
</tr>
<tr>
<td>下行 HFC 信道是否可能发生冲突？</td>
<td>不会</td>
</tr>
<tr>
<td>原因</td>
<td>只有头端设备发送，无多发冲突</td>
</tr>
</tbody></table>
</div>

<h1 id="Ethernet-LANs"><a href="#Ethernet-LANs" class="headerlink" title="Ethernet LANs"></a>Ethernet LANs</h1><div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>以太网类型</th>
<th>典型速率</th>
<th>每用户能否持续满速发送？</th>
</tr>
</thead>
<tbody><tr>
<td>10BASE-T</td>
<td>10 Mbps</td>
<td>否</td>
</tr>
<tr>
<td>100BASE-TX</td>
<td>100 Mbps</td>
<td>否</td>
</tr>
<tr>
<td>1000BASE-T</td>
<td>1 Gbps</td>
<td>否</td>
</tr>
<tr>
<td>10GBASE-T</td>
<td>10 Gbps</td>
<td>否</td>
</tr>
</tbody></table>
</div>

<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>物理介质类型</th>
<th>典型应用场景</th>
<th>传输距离</th>
<th>传输速率</th>
</tr>
</thead>
<tbody><tr>
<td>双绞线</td>
<td>局域网、办公、家庭</td>
<td>最远可达100米</td>
<td>10 Mbps ~ 40 Gbps</td>
</tr>
<tr>
<td>光纤</td>
<td>数据中心、骨干网</td>
<td>数百米至数十公里</td>
<td>100 Mbps ~ 400 Gbps</td>
</tr>
<tr>
<td>同轴电缆</td>
<td>早期局域网</td>
<td>数百米</td>
<td>10 Mbps</td>
</tr>
</tbody></table>
</div>

<h1 id="Wireless-Internet-Access-Technologies"><a href="#Wireless-Internet-Access-Technologies" class="headerlink" title="Wireless Internet Access Technologies"></a>Wireless Internet Access Technologies</h1><div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>技术类型</th>
<th>典型速率范围</th>
<th>覆盖范围</th>
<th>主要应用场景</th>
<th>延迟</th>
<th>主要优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Wi-Fi</td>
<td>数十 Mbps ~ 数 Gbps</td>
<td>局部（几十米）</td>
<td>家庭、办公、热点</td>
<td>低</td>
<td>速率高、成本低、覆盖范围有限</td>
</tr>
<tr>
<td>蜂窝网络（4G&#x2F;5G）</td>
<td>数十 Mbps ~ 数 Gbps</td>
<td>广域（城市&#x2F;乡村）</td>
<td>移动设备、车载、物联网</td>
<td>低（5G更优）</td>
<td>覆盖广、速率高、需付流量费用</td>
</tr>
<tr>
<td>卫星互联网</td>
<td>数十 Mbps ~ 数百 Mbps</td>
<td>全球（含偏远区）</td>
<td>偏远地区、应急通信</td>
<td>中~高</td>
<td>覆盖广、不依赖地面设施、延迟较高</td>
</tr>
</tbody></table>
</div>

<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>设备类型</th>
<th align="center">物理层</th>
<th align="center">链路层</th>
<th align="center">网络层</th>
<th align="center">传输层</th>
<th align="center">应用层</th>
</tr>
</thead>
<tbody><tr>
<td>路由器</td>
<td align="center">$$\surd$$</td>
<td align="center">$$\surd$$</td>
<td align="center">$$\surd$$</td>
<td align="center">$$\times$$</td>
<td align="center"></td>
</tr>
<tr>
<td>链路层交换机</td>
<td align="center">$$\surd$$</td>
<td align="center">$$\surd$$</td>
<td align="center">$$\times$$</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>主机</td>
<td align="center">$$\surd$$</td>
<td align="center">$$\surd$$</td>
<td align="center">$$\surd$$</td>
<td align="center">$$\surd$$</td>
<td align="center">$$\surd$$</td>
</tr>
</tbody></table>
</div>

<h1 id="Packet-Switching-and-Circuit-Switching"><a href="#Packet-Switching-and-Circuit-Switching" class="headerlink" title="Packet Switching and Circuit Switching"></a>Packet Switching and Circuit Switching</h1><ul>
<li><strong>带宽保证</strong>：电路交换网络（如传统电话网）在通信双方建立连接时，会为其分配一条固定的物理路径和带宽，整个通信期间该带宽专属使用，不会被其他用户占用。</li>
<li><strong>通信延迟低且稳定</strong>：由于路径和带宽在会话期间独占，数据传输延迟固定且可预测，适合对实时性要求高的应用（如语音通话）。</li>
<li><strong>无拥塞丢包</strong>：通信过程中不会因网络拥塞导致丢包或重传，通信质量有保障。</li>
</ul>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>网络类型</th>
<th>主要优势</th>
</tr>
</thead>
<tbody><tr>
<td>电路交换网络</td>
<td>带宽独占、延迟稳定、无拥塞丢包</td>
</tr>
<tr>
<td>分组交换网络</td>
<td>资源利用率高、灵活、适合突发性数据传输</td>
</tr>
</tbody></table>
</div>

<h2 id="Statistical-Multiplexing"><a href="#Statistical-Multiplexing" class="headerlink" title="Statistical Multiplexing"></a>Statistical Multiplexing</h2><p>分组交换（Packet Switching）中，网络资源（如链路带宽）是<strong>按需动态分配</strong>给各个数据流的。每个用户的数据被分成分组（包），这些分组在网络中独立传输，多个用户的分组在同一链路上<strong>交错传输</strong>。<br>由于不是每个用户都持续发送数据，链路带宽可以被“活跃”的用户动态共享，这种方式称为<strong>统计复用（Statistical Multiplexing）</strong>。</p>
<ul>
<li><strong>核心思想</strong>：利用用户流量的突发性和不均匀性，通过动态分配资源，提高链路利用率。</li>
<li><strong>资源分配</strong>：没有为每个用户预留固定带宽，资源按需分配。</li>
</ul>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>复用方式</th>
<th>资源分配方式</th>
<th>利用率</th>
<th>适用场景</th>
<th>主要特点</th>
</tr>
</thead>
<tbody><tr>
<td>统计复用</td>
<td>动态分配，按需使用</td>
<td>高</td>
<td>分组交换网络</td>
<td>用户多时可能拥塞，利用率高</td>
</tr>
<tr>
<td>TDM（时分复用）</td>
<td>固定分配，每用户固定时隙</td>
<td>低（有空闲浪费）</td>
<td>电路交换网络</td>
<td>时隙空闲时无法被他人利用</td>
</tr>
</tbody></table>
</div>

<h2 id="Store-and-Forward-Packet-Switching"><a href="#Store-and-Forward-Packet-Switching" class="headerlink" title="Store-and-Forward Packet Switching"></a>Store-and-Forward Packet Switching</h2><p><strong>存储转发</strong>：交换机必须在收到整个分组后，才能开始向下一个链路转发。</p>
<h1 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h1><div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>ISP 类型</th>
<th>互联方式</th>
<th>是否需购买上网带宽</th>
<th>网络覆盖范围</th>
</tr>
</thead>
<tbody><tr>
<td>Tier-1 ISP</td>
<td>与其他 Tier-1 ISP 结算互免互联</td>
<td>否</td>
<td>全球骨干</td>
</tr>
<tr>
<td>Tier-2 ISP</td>
<td>部分互联+向上级 ISP 购买带宽</td>
<td>是</td>
<td>区域&#x2F;国家级</td>
</tr>
</tbody></table>
</div>

<h1 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h1><ul>
<li>Processing Delay：每个路由器或主机在接收到分组时进行首部检查、差错检测等处理所需的时间。</li>
<li>Queuing Delay：分组在路由器的输出队列中等待转发的时间，取决于当前队列的长度和网络拥塞状况。</li>
<li>Transmission Delay： 分组所有比特从路由器或主机的输出端口“上线”所需的时间，计算公式为<br>$$<br>\text{传输时延} &#x3D; \frac{L}{R}<br>$$<br>其中，$L$ 为分组长度（比特），$R$ 为链路带宽（比特&#x2F;秒）。</li>
<li>Propagation Delay：   分组在物理链路上传播所需的时间，计算公式为：<br>$$<br>\text{传播时延} &#x3D; \frac{d}{s}<br>$$<br>其中，$d$ 为链路长度，$s$ 为信号在介质中的传播速率。</li>
</ul>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>时延类型</th>
<th>公式</th>
<th>是否依赖分组长度 L</th>
<th>是否依赖传输速率 R</th>
</tr>
</thead>
<tbody><tr>
<td>传播时延</td>
<td>$$\frac{d}{s}$$</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>传输时延</td>
<td>$$\frac{L}{R}$$</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>总时延</td>
<td>$$\frac{L}{R} + \frac{d}{s}$$</td>
<td>部分依赖</td>
<td>部分依赖</td>
</tr>
</tbody></table>
</div>

<h1 id="Throughput"><a href="#Throughput" class="headerlink" title="Throughput"></a>Throughput</h1><p>吞吐量：传输速率，单位 $\text{bits} &#x2F; \text{time}$。</p>
<p>每一个用于传输比特流的 <strong>pipe</strong> 的吞吐量可能不一致，这时如何计算端到端的吞吐量？<br>$$<br>\min , {R_C, R_S, \dots}<br>$$</p>
<p>这种情况下，端到端的吞吐量取决于整个传输路径中最慢的通道</p>
<h1 id="Layer-Structure"><a href="#Layer-Structure" class="headerlink" title="Layer Structure"></a>Layer Structure</h1><div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>任务名称</th>
<th>可能涉及的层级</th>
<th>是否可多层实现</th>
</tr>
</thead>
<tbody><tr>
<td>分段与重组</td>
<td>传输层、网络层</td>
<td>是</td>
</tr>
<tr>
<td>差错检测与纠正</td>
<td>数据链路层、传输层</td>
<td>是</td>
</tr>
<tr>
<td>流量控制</td>
<td>数据链路层、传输层</td>
<td>是</td>
</tr>
<tr>
<td>寻址与路由选择</td>
<td>网络层</td>
<td>否（主要网络层）</td>
</tr>
<tr>
<td>封装与解封装</td>
<td>各层均有</td>
<td>是</td>
</tr>
</tbody></table>
</div>

<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>层级</th>
<th>数据单元名称</th>
<th>主要内容说明</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用层消息</td>
<td>应用协议数据（如HTTP请求、邮件内容等）</td>
</tr>
<tr>
<td>传输层</td>
<td>报文段（Segment）</td>
<td>传输层首部 + 应用层消息</td>
</tr>
<tr>
<td>网络层</td>
<td>数据报（Datagram）</td>
<td>网络层首部 + 传输层报文段</td>
</tr>
<tr>
<td>链路层</td>
<td>帧（Frame）</td>
<td>链路层首部 + 网络层数据报 + 链路层尾部</td>
</tr>
</tbody></table>
</div>

<h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>类型</th>
<th align="center">是否自我复制</th>
<th align="center">是否依附宿主</th>
<th align="center">是否主动传播</th>
<th>主要危害方式</th>
</tr>
</thead>
<tbody><tr>
<td>病毒</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">否</td>
<td>破坏文件、传播感染</td>
</tr>
<tr>
<td>蠕虫</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">是</td>
<td>网络传播、资源消耗</td>
</tr>
<tr>
<td>特洛伊木马</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td>窃密、远控、伪装攻击</td>
</tr>
</tbody></table>
</div>

<ul>
<li><strong>僵尸网络（Botnet）</strong>：由大量被恶意控制的设备组成的分布式网络。</li>
<li><strong>DDoS攻击（分布式拒绝服务攻击）</strong>：利用僵尸网络同时发起大规模攻击，瘫痪目标服务。</li>
</ul>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>恶意软件传播</td>
<td>通过多种方式感染大量设备</td>
</tr>
<tr>
<td>设备感染与控制</td>
<td>感染设备与C&amp;C服务器建立联系，成为“僵尸”</td>
</tr>
<tr>
<td>集中管理</td>
<td>攻击者统一管理所有僵尸设备</td>
</tr>
<tr>
<td>发起DDoS攻击</td>
<td>僵尸设备同时向目标发起流量，导致目标服务瘫痪</td>
</tr>
</tbody></table>
</div>

<h1 id="End-of-chapter-exercises"><a href="#End-of-chapter-exercises" class="headerlink" title="End-of-chapter exercises"></a>End-of-chapter exercises</h1><h2 id="R-15"><a href="#R-15" class="headerlink" title="R.15"></a>R.15</h2><p>Suppose users share a $2$ Mbps link. Also suppose each user transmits continuously at $1$ Mbps when transmitting, but each user transmits only $20$ percent of the time. (See the discussion of statistical multiplexing in Section $1.3$.)</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. When circuit switching is used, how many users can be supported?</strong></p>
<p>在电路交换中，每个用户需要预留 $1$ Mbps 的带宽，而链路总带宽为 $2$ Mbps。因此，最多可以支持：</p>
<p>$$<br>\text{用户数} &#x3D; \frac{\text{总带宽}}{\text{每用户带宽}} &#x3D; \frac{2 , \text{Mbps}}{1 , \text{Mbps}} &#x3D; 2 , \text{用户}<br>$$</p>
<p><strong>b. For the remainder of this problem, suppose packet switching is used. Why will there be essentially no queuing delay before the link if two or fewer users transmit at the same time? Why will there be a queuing delay if three users transmit at the same time?</strong></p>
<ul>
<li>如果两名或更少的用户同时传输，每个用户的传输速率为 $1$ Mbps，总传输速率为 $2$ Mbps 或更少，等于链路的总带宽。因此，数据可以立即通过链路传输，不会产生排队延迟。</li>
<li>如果三名用户同时传输，总传输速率为 $3 , \text{Mbps}$，超过了链路的总带宽 $2 , \text{Mbps}$。此时，链路无法立即传输所有数据，导致数据在队列中等待，从而产生排队延迟。</li>
</ul>
<p><strong>c. Find the probability that a given user is transmitting.</strong></p>
<p>每个用户有 $20%$ 的时间在传输数据，因此某个用户正在传输的概率为：</p>
<p>$$<br>P(\text{用户传输}) &#x3D; 0.2<br>$$</p>
<p><strong>d. Suppose now there are three users. Find the probability that at any given time, all three users are transmitting simultaneously. Find the fraction of time during which the queue grows.</strong></p>
<ul>
<li>每个用户独立传输的概率为 $0.2$，因此三名用户同时传输的概率为：</li>
</ul>
<p>$$<br>P(\text{三名用户同时传输}) &#x3D; P(\text{用户1传输}) \cdot P(\text{用户2传输}) \cdot P(\text{用户3传输}) &#x3D; 0.2 \cdot 0.2 \cdot 0.2 &#x3D; 0.008<br>$$</p>
<ul>
<li>队列增长的时间比例等于三名用户同时传输的概率，因为只有在这种情况下，传输速率超过链路带宽：</li>
</ul>
<p>$$<br>\text{队列增长的时间比例} &#x3D; 0.008<br>$$</p>
<h2 id="R-19"><a href="#R-19" class="headerlink" title="R.19"></a>R.19</h2><p>Suppose Host A wants to send a large file to Host B. The path from Host A to Host B has three links, of rates $R_1$ &#x3D; $500$ Kbps, $R_2$ &#x3D; $2$ Mbps, and $R_3$ &#x3D; $1$ Mbps.</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. Assuming no other traffic in the network, what is the throughput for the file transfer.</strong></p>
<ul>
<li>用公式 $\min {R_i}$ 计算得到实际吞吐量是 $500$ Kbps。</li>
</ul>
<p><strong>b. Suppose the file is 4 million bytes. Dividing the file size by the throughput, roughly how long will it take to transfer the file to Host B?</strong></p>
<ul>
<li>$$\text{传输时间} &#x3D; \frac{4 \times 10^{6} \times 8}{500 \times 1000} &#x3D; 64 , \text{s}$$</li>
</ul>
<p><strong>c. Repeat (a) and (b), but now with R2 reduced to 100 Kbps.</strong></p>
<ul>
<li>用公式 $\min {R_i}$ 计算得到实际吞吐量是 $100$ Kbps。</li>
<li>$$\text{传输时间} &#x3D; \frac{4 \times 10^{6} \times 8}{100 \times 1000} &#x3D; 320 , \text{s}$$</li>
</ul>
<h2 id="R-23"><a href="#R-23" class="headerlink" title="R.23"></a>R.23</h2><p><strong>Questions and Answers:</strong></p>
<p><strong>What are the five layers in the Internet protocol stack? What are the principal responsibilities of each of these layers?</strong></p>
<p>There are application layer, transport layer, network layer, data link layer and physical layer. Their principal responsibilities are as follow:</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th><strong>层级</strong></th>
<th><strong>名称</strong></th>
<th><strong>主要职责</strong></th>
<th><strong>典型协议举例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>第5层</strong></td>
<td>应用层 (Application)</td>
<td>提供<strong>网络服务的接口</strong>，支持应用程序间的通信</td>
<td>HTTP, FTP, SMTP, DNS</td>
</tr>
<tr>
<td><strong>第4层</strong></td>
<td>传输层 (Transport)</td>
<td>提供<strong>端到端的传输服务</strong>，负责分段、重组、流量控制和差错恢复</td>
<td>TCP, UDP</td>
</tr>
<tr>
<td><strong>第3层</strong></td>
<td>网络层 (Network)</td>
<td>负责<strong>数据包的路由和转发</strong>，实现<strong>端到端的寻址和路径选择</strong></td>
<td>IP, ICMP, OSPF, BGP</td>
</tr>
<tr>
<td><strong>第2层</strong></td>
<td>数据链路层 (Data Link)</td>
<td>提供<strong>相邻节点间可靠传输</strong>，处理帧的封装、寻址、差错检测和媒体访问控制</td>
<td>Ethernet, PPP, HDLC, Wi-Fi</td>
</tr>
<tr>
<td><strong>第1层</strong></td>
<td>物理层 (Physical)</td>
<td>负责<strong>比特流的传输</strong>，定义物理介质、信号编码和传输速率等物理特性</td>
<td>RS-232, USB, SONET, 以太网物理标准</td>
</tr>
</tbody></table>
</div>

<h2 id="P-8"><a href="#P-8" class="headerlink" title="P.8"></a>P.8</h2><p>Consider the discussion in Section $1.3$ of statistical multiplexing in which an example is provided with a $1$ Mbps link. Users are generating data at a rate of $100$ Kbps when busy, but are busy generating data only with probability $p &#x3D; 0.1$. Suppose that the $1$ Mbps link is replaced by a $1$ Gbps link.</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. What is $N$, the maximum number of users that can be supported simultaneously under circuit switching?</strong></p>
<p>$$<br>N &#x3D; \frac{1 , \text{Gbps}}{100 , \text{Kbps}} &#x3D; 10000<br>$$</p>
<p><strong>b. Now consider packet switching and a user population of $M$ users. Give a formula (in terms of $p$, $M$, $N$) for the probability that more than $N$ users are sending data.</strong></p>
<p>假设用户的发送行为是独立的，则发送数据的用户数目服从二项分布，只考虑 $M \geq N$：<br>$$<br>P_{ &gt; N} &#x3D; 1 - \sum_{k &#x3D; 0}^{N} \binom{M}{k} p^k (1 - p)^{M - k}<br>$$</p>
<h2 id="P-22"><a href="#P-22" class="headerlink" title="P.22"></a>P.22</h2><p>Consider Figure $1.19(a)$. Assume that we know the bottleneck link along the path from the server to the client is the first link with rate $R_s$ $\text{bits&#x2F;sec}$. Suppose we send a pair of packets back to back from the server to the client, and there is no other traffic on this path. Assume each packet of size $L$ $\text{bits}$, and both links have the same propagation delay $d_{prop}$.</p>
<p><img src="/Introduction/Throughput%20for%20a%20file%20transfer%20from%20server%20to%20client.png" alt="Figure $1.19(a)$">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p>back-to-back 指的是一组数据包在没有间隔的情况下连续发送</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. What is the packet inter-arrival time at the destination? That is, how much time elapses from when the last bit of the first packet arrives until the last bit of the second packet arrives?</strong></p>
<p>从图中我们可以看到有两条 <strong>link</strong>，速率分别是 $R_s$ 和 $R_c$，前者导致瓶颈，也就是 $R_c$ &gt; $R_s$。所以，<strong>inter-arrival time</strong>：<br>$$<br>t &#x3D; \frac{L}{R_s}<br>$$</p>
<p><strong>b. Now assume that the second link is the bottleneck link (i.e., $R_c$ &lt; $R_s$). Is it possible that the second packet queues at the input queue of the second link? Explain. Now suppose that the server sends the second packet $T$ seconds after sending the first packet. How large must $T$ be to ensure no queuing before the second link? Explain.</strong></p>
<p>有可能第二个包在第二条 link 输入处排队，因为 $R_c$ &lt; $R_s$ 导致，第一包仍在传输。只要保证当第二个包到达第二条 link 输入时，第一个包已经传完了，也就是：<br>$$<br>T &#x3D; \frac{L}{R_c}<br>$$</p>
<h2 id="P-28"><a href="#P-28" class="headerlink" title="P.28"></a>P.28</h2><p>Suppose there is a $10$ $\text{Mbps}$ microwave link between a geostationary satellite and its base station on Earth. Every minute the satellite takes a digital photo and sends it to the base station. Assume a propagation speed of $2.4 \cdot 10^8$ $\text{meters&#x2F;sec}$.</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. What is the propagation delay of the link?</strong></p>
<p>地球静止卫星轨道高度约为 $d \approx 3.5786 \times 10^7 , \text{m}$，再由公式 $d_{prop} &#x3D; \frac{d}{s}$ 得到 $d_{prop} \approx 150 , \text{ms}$</p>
<p><strong>b. What is the bandwidth-delay product, $R \cdot d_{prop}$?</strong></p>
<p>这个乘式中的 $R$ 是 link 的传输速率，表示的是因延迟而没有传输的数据大小。结果是 $10 \times 10^6 \times 0.15 &#x3D; 1.5 \times 10^6 , \text{bits}$。</p>
<p><strong>c. Let $x$ denote the size of the photo. What is the minimum value of $x$ for the microwave link to be continuously transmitting?</strong></p>
<p>设照片大小为 $x$（单位：$\text{bits}$），要使链路持续发送，需满足传输时间 $\frac{x}{R}$ 不小于拍照间隔 $60,\text{s}$，即<br>$$<br>\frac{x}{R} \geq 60 , \Longrightarrow ; x \geq R \times 60 &#x3D; 10\times10^6\ \text{bps} \times 60\ \text{s} &#x3D; 600\times10^6\ \text{bits} &#x3D; 75\ \text{MB}.<br>$$</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/09/Wireless-and-Mobile-Networks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/09/Wireless-and-Mobile-Networks/" class="post-title-link" itemprop="url">Wireless and Mobile Networks</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-09 08:02:04" itemprop="dateCreated datePublished" datetime="2025-06-09T08:02:04+08:00">2025-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-17 13:18:59" itemprop="dateModified" datetime="2025-06-17T13:18:59+08:00">2025-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/" itemprop="url" rel="index"><span itemprop="name">Computer Network</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/Wireless-and-Mobile-Networks/" itemprop="url" rel="index"><span itemprop="name">Wireless and Mobile Networks</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="Elements-of-a-Wireless-Networks"><a href="#Elements-of-a-Wireless-Networks" class="headerlink" title="Elements of a Wireless Networks"></a>Elements of a Wireless Networks</h2><ul>
<li><strong>Wireless Hosts:</strong> laptop, PDA, IP phone.</li>
<li><strong>Base Station:</strong><ul>
<li>connected to a <strong>wired network</strong>.</li>
<li><strong>relays</strong><ul>
<li>responsible for sending packets between wired network and wireless hosts in its area.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Wireless Link:</strong><ul>
<li>typically used to connect mobiles to bas stations.</li>
<li><strong>multiple access protocol</strong> coordinates link access.</li>
</ul>
</li>
<li><strong>Infrastructure Mode:</strong><ul>
<li><strong>handoff:</strong> mobile changes base station providing connection into wired network.</li>
</ul>
</li>
<li><strong>Ad Hoc Mode:</strong><ul>
<li>no base stations.</li>
<li>nodes can only transmit to other nodes within link coverage.</li>
<li>nodes organize themselves into a network: route among themselves.</li>
</ul>
</li>
</ul>
<h2 id="Wireless-Network-Taxonomy"><a href="#Wireless-Network-Taxonomy" class="headerlink" title="Wireless Network Taxonomy"></a>Wireless Network Taxonomy</h2><div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th><strong>Infrastructure</strong></th>
<th><strong>Single Hop</strong></th>
<th><strong>Multiple Hops</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>With Infrastructure</strong></td>
<td>Host connects to base station (WiFi, WiMAX, cellular) which connects to larger Internet.</td>
<td>Host relays through several wireless nodes to connect to larger Internet (mesh net).</td>
</tr>
<tr>
<td><strong>Without Infrastructure</strong></td>
<td>No base station, no connection to larger Internet (e.g., Bluetooth, ad hoc nets).</td>
<td>No base station, no connection to larger Internet. Nodes relay to reach other nodes (e.g., MANET, VANET).</td>
</tr>
</tbody></table>
</div>

<h1 id="Wireless-Link-Characteristics"><a href="#Wireless-Link-Characteristics" class="headerlink" title="Wireless Link Characteristics"></a>Wireless Link Characteristics</h1><blockquote>
<p>从下文可以分析出，这里的 link 不能翻译成<strong>链路</strong>而应该翻译成<strong>连接</strong>。</p>
</blockquote>
<ul>
<li><strong>decreased signal strength</strong></li>
<li><strong>interference from other sources</strong></li>
<li><strong>multipath propagation</strong></li>
</ul>
<p>Multiple wireless senders and receivers create additional problems (beyond multiple access):</p>
<ul>
<li><strong>Hidden Terminal Problem:</strong> A and C can not hear each other means A and C are unaware of their interference B.</li>
</ul>
<blockquote>
<p>这里是在讲，A 和 C 因为障碍物的问题而无法直接通信从而无法协调，但他们都能和 B 进行通信，如果 A 和 C 同时向 B 通信会导致冲突。</p>
</blockquote>
<ul>
<li><strong>SNR (Signal-to-Noise Ratio):</strong><ul>
<li>larger SNR, easier to extract signal from noise.</li>
<li>increases power $\to$ increases SNR $\to$ decreases <strong>BER (Bit Error Rate)</strong>.</li>
<li>Given SNR, choose physical layer that meets BER requirement, giving highest throughput.</li>
</ul>
</li>
</ul>
<blockquote>
<p>SNR 是信噪比，顾名思义是一个比值，具体计算公式为<br>$$<br>\mathrm{SNR} &#x3D; \frac{P_{\text{signal}}}{P_{\text{noise}}}<br>$$<br>实际中用单位 db 表示。SNR 越大，说明信号越容易从噪声中分辨出来，通信质量越好。</p>
</blockquote>
<h2 id="Code-Division-Multiple-Access-CDMA"><a href="#Code-Division-Multiple-Access-CDMA" class="headerlink" title="Code Division Multiple Access (CDMA)"></a>Code Division Multiple Access (CDMA)</h2><blockquote>
<p>码分多址，这个我们在 data link layer 提到过，类似的有 TDMA 和 FDMA。需要注意的是 CDMA 是一个 physical layer protocol。所以下文用的是 channel 而不是 link。</p>
</blockquote>
<p>A kind of <strong>channel partitioning protocol</strong>.</p>
<ul>
<li><strong>Usage</strong>: Used in <strong>wireless broadcast channels</strong> (e.g., cellular, satellite).</li>
<li><strong>Code Assignment</strong>: Each user is assigned a <strong>unique “code”</strong> (code set partitioning).</li>
<li><strong>Frequency Sharing</strong>: All users share the same frequency but use distinct <strong>“chipping”</strong> sequences to encode data.</li>
<li><strong>Signal Encoding</strong>:  <ul>
<li>Encoded signal &#x3D; (original data)  (chipping sequence).</li>
</ul>
</li>
<li><strong>Signal Decoding</strong>:  <ul>
<li>Decoding is done using the inner product of the encoded signal and the chipping sequence.</li>
</ul>
</li>
<li><strong>Advantage</strong>: Allows multiple users to coexist and transmit simultaneously with minimal interference (if codes are orthogonal).<blockquote>
<p>这里提到的 unique code 和 chipping sequence 是同一个事物。</p>
</blockquote>
</li>
</ul>
<h3 id="CDMA-Encode-Decode-Process"><a href="#CDMA-Encode-Decode-Process" class="headerlink" title="CDMA Encode&#x2F;Decode Process"></a>CDMA Encode&#x2F;Decode Process</h3><h4 id="Sender"><a href="#Sender" class="headerlink" title="Sender:"></a><strong>Sender:</strong></h4><ol>
<li><p><strong>Data Encoding</strong>:</p>
<ul>
<li>Each sender has a unique code (chipping sequence) <code>c_m</code>.</li>
<li>Encoded signal for each data bit:<br>$$ Z_{i,m} &#x3D; d_i \cdot c_m $$<ul>
<li><code>d_i</code>: Original data bit.</li>
<li><code>c_m</code>: Chipping sequence.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Channel Output</strong>:</p>
<ul>
<li>Encoded signals are transmitted over the shared channel.</li>
<li>Channel output combines signals from all senders.</li>
</ul>
</li>
</ol>
<h4 id="Receiver"><a href="#Receiver" class="headerlink" title="Receiver:"></a><strong>Receiver:</strong></h4><ol>
<li><p><strong>Signal Decoding</strong>:</p>
<ul>
<li>Receiver uses the inner product of the received signal and its own chipping sequence to decode data:<br>$$ D_i &#x3D; \frac{\sum_{m&#x3D;1}^{M} Z_{i,m} \cdot c_m}{M} $$<ul>
<li><code>D_i</code>: Decoded data bit.</li>
<li><code>Z_&#123;i,m&#125;</code>: Received signal.</li>
<li><code>c_m</code>: Receiver’s chipping sequence.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Output</strong>:</p>
<ul>
<li>Decoded data bits are extracted from the combined channel output.</li>
</ul>
</li>
</ol>
<blockquote>
<p>每个发送端都被分配一个唯一的码字（chipping sequence），码字的长度应该足够长，按理来讲，如果有 $N$ 个用户，码字长度 $M \geq N$。码字具体为：用 $+1$ 和 $-1$ 分别代表 $1$ 和 $0$。发送者将发送数据与码字相乘，这里指的是位对码字相乘。发送后数据会和其他所有发送者的信息在 channel 中叠加。解码公式有一个前提：要求 user 使用的码字之间正交。除以 M 是为保证归一化。</p>
<p>还要补充的是，CDMA 的核心思想是：所有用户在 <strong>same frequency</strong> 和 <strong>same time</strong> 的情况下发送信息。此时应用 CDMA。如果 frequency 不一致，也不会发生信号叠加，此时应该用 FDMA。</p>
</blockquote>
<h1 id="WiFi-802-11-Wireless-LANs"><a href="#WiFi-802-11-Wireless-LANs" class="headerlink" title="WiFi: 802.11 Wireless LANs"></a>WiFi: 802.11 Wireless LANs</h1><blockquote>
<p>前部分介绍了 wireless link 及其用到的 CDMA protocol，</p>
</blockquote>
<ul>
<li>all use <strong>CSMA&#x2F;CA</strong> for multiple access.<blockquote>
<p>data link layer 部分我们讲过了 CSMA&#x2F;CD。</p>
</blockquote>
</li>
<li>all have base-station and ad-hoc network versions.</li>
</ul>
<h2 id="The-802-11-LAN-Architecture"><a href="#The-802-11-LAN-Architecture" class="headerlink" title="The 802.11 LAN Architecture"></a>The 802.11 LAN Architecture</h2><ul>
<li><p>wireless host communicates with base station (base station &#x3D; access point (AP))</p>
</li>
<li><p>Basic Service Set (BSS) (aka “cell”一片区域) in infrastructure mode contains:</p>
<ul>
<li>wireless hosts</li>
<li>access point (AP): base station</li>
<li>ad hoc mode: hosts only</li>
</ul>
</li>
<li><p><strong>层次关系</strong>：一个 subnet 可以包含<strong>多个 BSS</strong>，多个无线主机通过不同接入点接入同一子网</p>
</li>
<li><p><strong>切换过程</strong>：</p>
<ul>
<li>当移动设备在<strong>同一子网内</strong>的不同 BSS 之间移动时，只需改变 BSS 关联（链路层切换），IP 地址<strong>保持不变</strong></li>
<li>当移动设备跨子网移动时，除了需要切换 BSS，还需要获取新子网的 IP 地址（通常通过 DHCP）</li>
</ul>
</li>
<li><p><strong>地址分配</strong>：BSS 关注 MAC 地址，而 Subnet 关注 IP 地址</p>
</li>
<li><p><strong>管理机制</strong>：BSS 由 AP 管理，Subnet 由路由器管理</p>
</li>
</ul>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>BSS</strong></th>
<th><strong>Subnet</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所属网络层次</strong></td>
<td>物理层和数据链路层 (OSI 第 1、2 层)</td>
<td>网络层 (OSI 第 3 层)</td>
</tr>
<tr>
<td><strong>定义标准</strong></td>
<td>IEEE 802.11 标准</td>
<td>IP 协议标准</td>
</tr>
<tr>
<td><strong>标识符</strong></td>
<td>BSSID (MAC 地址)</td>
<td>IP 地址前缀和子网掩码</td>
</tr>
<tr>
<td><strong>地址范围</strong></td>
<td>单个无线接入点覆盖范围</td>
<td>可跨多个接入点，由路由器定义</td>
</tr>
<tr>
<td><strong>关注点</strong></td>
<td>无线媒体访问和信号传输</td>
<td>IP 数据包的寻址和路由</td>
</tr>
<tr>
<td><strong>设备组织方式</strong></td>
<td>围绕单个接入点的无线主机集合</td>
<td>共享同一网络前缀的主机集合</td>
</tr>
<tr>
<td><strong>移动特性</strong></td>
<td>设备在 BSS 间移动需要进行<strong>切换 (handoff)</strong></td>
<td>在同一子网内的移动不需要更改 IP 地址</td>
</tr>
</tbody></table>
</div>

<h2 id="802-11-Channels-Association"><a href="#802-11-Channels-Association" class="headerlink" title="802.11: Channels, Association"></a>802.11: Channels, Association</h2><ul>
<li><strong>Frequency Spectrum</strong>: 2.4GHz-2.485GHz (802.11b) divided into 11 channels.</li>
<li><strong>AP Configuration</strong>: Admin selects frequency for AP; interference may occur if neighboring APs use the same channel.</li>
<li><strong>Host Association</strong>:<ul>
<li>Scans channels for beacon frames with AP’s SSID and MAC address.</li>
<li>Selects an AP to associate with.</li>
<li>May perform authentication.</li>
<li>Typically runs <strong>DHCP</strong> to obtain an IP address in the AP’s subnet.<blockquote>
<p>前文我们讲 CDMA 的时候提到了： CDMA 的所有用户使用相同的 frequency。通常情况下，一个 AP 在同一时刻只工作在一个信道（即一个频率范围），只能收发该信道上的无线信号。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="802-11-Passive-Active-Scanning"><a href="#802-11-Passive-Active-Scanning" class="headerlink" title="802.11: Passive&#x2F;Active Scanning"></a>802.11: Passive&#x2F;Active Scanning</h2><blockquote>
<p>Beacon Frame（信标帧） 是 IEEE 802.11 无线局域网（WiFi）协议中由接入点（AP, Access Point）周期性广播的一种管理帧。</p>
</blockquote>
<ul>
<li><p><strong>Passive Scanning</strong>:</p>
<ul>
<li>APs send <strong>beacon frames</strong>.</li>
<li>Host (H1) sends Association Request frame to selected AP.</li>
<li>Selected AP sends Association Response frame to H1.</li>
</ul>
</li>
<li><p><strong>Active Scanning</strong>:</p>
<ul>
<li>Host (H1) broadcasts Probe Request frame.</li>
<li>APs respond with Probe Response frames.</li>
<li>Host (H1) sends Association Request frame to selected AP.</li>
<li>Selected AP sends Association Response frame to H1.</li>
</ul>
</li>
</ul>
<blockquote>
<p>这两种方式最后两步都是一样的。</p>
</blockquote>
<h2 id="IEEE-802-11-Multiple-Access"><a href="#IEEE-802-11-Multiple-Access" class="headerlink" title="IEEE 802.11: Multiple Access"></a>IEEE 802.11: Multiple Access</h2><blockquote>
<p>data link layer</p>
</blockquote>
<h3 id="Collision-Avoidance-in-802-11"><a href="#Collision-Avoidance-in-802-11" class="headerlink" title="Collision Avoidance in 802.11"></a>Collision Avoidance in 802.11</h3><ul>
<li><strong>Problem</strong>: Collisions occur when $2$ more nodes transmit simultaneously.</li>
<li><strong>Solution</strong>:<ul>
<li><strong>CSMA</strong>: Sense the channel before transmitting to avoid collisions with ongoing transmissions.</li>
<li><strong>No Collision Detection</strong>:<ul>
<li>Difficult to sense collisions while transmitting due to weak received signals (fading).</li>
<li><strong>Hidden terminal</strong> and <strong>fading issues</strong> prevent sensing all collisions.</li>
</ul>
</li>
<li><strong>Goal</strong>: Use <strong>CSMA&#x2F;CA (Collision Avoidance)</strong> to minimize collisions.</li>
</ul>
</li>
</ul>
<h2 id="IEEE-802-11-MAC-Protocol-CSMA-CA"><a href="#IEEE-802-11-MAC-Protocol-CSMA-CA" class="headerlink" title="IEEE 802.11 MAC Protocol: CSMA&#x2F;CA"></a>IEEE 802.11 MAC Protocol: CSMA&#x2F;CA</h2><blockquote>
<p>DIFS 是<strong>分布式帧间间隔</strong>（Distributed Inter-Frame Space）的缩写。SIFS 是<strong>短帧间间隔</strong>（Short Inter-Frame Space）的缩写。<strong>Link（链路）</strong>：在有线网络中，通常指两个节点之间的物理连接。<strong>Channel（信道）</strong>：在无线网络中，指的是一段特定频率范围内的无线传输资源，多个节点可以共享同一个信道。</p>
</blockquote>
<h3 id="802-11-Sender"><a href="#802-11-Sender" class="headerlink" title="802.11 Sender"></a><strong>802.11 Sender</strong></h3><ol>
<li><strong>Channel Idle</strong>:<ul>
<li>If the channel is idle for DIFS, transmit the entire frame (no collision detection).</li>
</ul>
</li>
<li><strong>Channel Busy</strong>:<ul>
<li>Start a random backoff timer.</li>
<li>Timer counts down while the channel is idle.</li>
<li>Transmit when the timer expires.</li>
<li>If no ACK is received, increase the random backoff interval and repeat step $2$.</li>
</ul>
</li>
</ol>
<h3 id="802-11-Receiver"><a href="#802-11-Receiver" class="headerlink" title="802.11 Receiver"></a><strong>802.11 Receiver</strong></h3><ul>
<li>If the frame is received correctly:<ul>
<li>Return an ACK after SIFS (ACK is needed to address the hidden terminal problem).</li>
</ul>
</li>
</ul>
<h3 id="Avoiding-Collisions-RTS-CTS-Mechanism"><a href="#Avoiding-Collisions-RTS-CTS-Mechanism" class="headerlink" title="Avoiding Collisions: RTS&#x2F;CTS Mechanism"></a>Avoiding Collisions: RTS&#x2F;CTS Mechanism</h3><ul>
<li><strong>Idea</strong>: Allow sender to reserve the channel to avoid collisions of long data frames.</li>
<li><strong>Process</strong>:<ol>
<li>Sender transmits a small <strong>Request-to-Send (RTS)</strong> packet to the base station (BS) using CSMA.</li>
<li>RTS packets may collide, but they are short.</li>
<li>BS responds with a <strong>Clear-to-Send (CTS)</strong> packet, broadcast to all nodes.</li>
<li>Sender transmits the data frame.</li>
<li>Other stations defer their transmissions upon hearing the CTS.</li>
</ol>
</li>
<li><strong>Advantage</strong>: Completely avoids collisions of long data frames by using small reservation packets.</li>
</ul>
<ol>
<li><strong>发送预约请求（RTS）</strong><ul>
<li>发送方先发送一个很短的 RTS（Request to Send）帧给基站（或接入点，AP），请求占用信道。</li>
</ul>
</li>
<li><strong>接收预约确认（CTS）</strong><ul>
<li>基站收到 RTS 后，如果信道空闲，则广播一个 CTS（Clear to Send）帧，通知所有节点允许该发送方发送数据。</li>
</ul>
</li>
<li><strong>数据发送</strong><ul>
<li>发送方收到 CTS 后，立即发送长数据帧。</li>
</ul>
</li>
<li><strong>其他节点监听</strong><ul>
<li>网络中其他节点收到 CTS 后，会在指定时间内暂停发送，避免与当前数据帧发生冲突。</li>
</ul>
</li>
</ol>
<h2 id="802-11-Addressing"><a href="#802-11-Addressing" class="headerlink" title="802.11 Addressing"></a>802.11 Addressing</h2><p>下表总结了 802.11 帧的各字段及其作用：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>字段名</th>
<th>长度（字节）</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td>frame control</td>
<td>2</td>
<td>帧控制字段，指示帧类型、控制信息等</td>
</tr>
<tr>
<td>duration</td>
<td>2</td>
<td>持续时间字段，指示信道预留时间</td>
</tr>
<tr>
<td>address 1</td>
<td>6</td>
<td>接收方 MAC 地址（无线主机或 AP）</td>
</tr>
<tr>
<td>address 2</td>
<td>6</td>
<td>发送方 MAC 地址（无线主机或 AP）</td>
</tr>
<tr>
<td>address 3</td>
<td>6</td>
<td>路由器接口的 MAC 地址（AP 所连接的路由器接口）</td>
</tr>
<tr>
<td>seq control</td>
<td>2</td>
<td>序列控制字段，帧编号等</td>
</tr>
<tr>
<td>address 4</td>
<td>6</td>
<td>仅在 ad hoc 模式下使用的地址</td>
</tr>
<tr>
<td>payload</td>
<td>0 - 2312</td>
<td>数据负载部分</td>
</tr>
<tr>
<td>CRC</td>
<td>4</td>
<td>循环冗余校验，用于差错检测</td>
</tr>
</tbody></table>
</div>

<p><strong>说明：</strong></p>
<ul>
<li>address 1：接收方 MAC 地址</li>
<li>address 2：发送方 MAC 地址</li>
<li>address 3：AP 所连接的路由器接口的 MAC 地址</li>
<li>address 4：仅 ad hoc 模式下使用</li>
</ul>
<h2 id="Mobility-within-Same-Subnet"><a href="#Mobility-within-Same-Subnet" class="headerlink" title="Mobility within Same Subnet"></a>Mobility within Same Subnet</h2><p>Host 在统一子网下不同 BSS 移动，switch 如何得知 host 当前在哪个 BSS 内？实际上 switch 能通过 self-learning：switch will see frame from H1 and remember which switch port can be used to reach H1。</p>
<h2 id="Power-Management"><a href="#Power-Management" class="headerlink" title="Power Management"></a>Power Management</h2><ul>
<li><strong>定时唤醒机制</strong>：<br>休眠节点在进入省电模式（Power Save Mode）时，会本地保存下一个 beacon frame 的预计到达时间，并设置定时器（timer）。</li>
<li><strong>硬件支持</strong>：<br>无线网卡硬件通常具备低功耗计时功能，可以在主机休眠时保持计时，确保在 beacon frame 到来前自动唤醒。</li>
<li><strong>唤醒流程</strong>：<br>节点休眠后，定时器到达设定时间，节点自动唤醒，监听并接收 AP 广播的 beacon frame，判断是否有待接收的数据。</li>
<li><strong>节能的核心在于节点休眠</strong>：<br>节能的关键不是 AP 是否省电，而是<strong>无线终端（如手机、笔记本）可以长时间休眠，仅在 beacon frame 到来时短暂唤醒</strong>，大大减少无线网卡的活跃时间和能耗。</li>
<li><strong>AP 通常为插电设备</strong>：<br>AP 持续广播 beacon frame 对其本身能耗影响不大，因为 AP 通常是接入电源的设备，不依赖电池。</li>
<li><strong>终端省电效果显著</strong>：<br>终端设备在无数据通信时可以关闭大部分无线模块，仅保留低功耗计时和唤醒功能，只有在需要接收数据或发送数据时才唤醒主模块，极大延长了电池续航。</li>
</ul>
<h2 id="802-15-Personal-Area-Network"><a href="#802-15-Personal-Area-Network" class="headerlink" title="802.15: Personal Area Network"></a>802.15: Personal Area Network</h2><p>个人热点。使用 ad hoc mode，参考 bluetooth protocol。</p>
<h2 id="802-16-WiMAX"><a href="#802-16-WiMAX" class="headerlink" title="802.16: WiMAX"></a>802.16: WiMAX</h2><h1 id="Cellular-Internet-Access"><a href="#Cellular-Internet-Access" class="headerlink" title="Cellular Internet Access"></a>Cellular Internet Access</h1><p>介绍几个概念：</p>
<ul>
<li><strong>Cell</strong>：一个区域，里面有一个 base station，mobile users 通过这个基站连接到 network。</li>
<li><strong>MCS</strong>：Mobile Switching Center。连接 base station 和 wired network。</li>
</ul>
<h2 id="The-First-Hop"><a href="#The-First-Hop" class="headerlink" title="The First Hop"></a>The First Hop</h2><p>第一跳为 users 到 base station。显然是一个 multiple senders 的场景，可以用 FDMA、TDMA 和 CDMA 分离数据。</p>
<h2 id="Cellular-standards-brief-survey"><a href="#Cellular-standards-brief-survey" class="headerlink" title="Cellular standards: brief survey"></a>Cellular standards: brief survey</h2><h3 id="2G-Systems"><a href="#2G-Systems" class="headerlink" title="2G Systems"></a><strong>2G Systems</strong></h3><ul>
<li><strong>Voice Channels</strong>:<ul>
<li><strong>IS-136 TDMA</strong>: Combined FDMA&#x2F;TDMA (North America).</li>
<li><strong>GSM</strong>: Global System for Mobile Communications, combined FDMA&#x2F;TDMA (most widely deployed).</li>
<li><strong>IS-95 CDMA</strong>: Code Division Multiple Access.</li>
</ul>
</li>
</ul>
<h3 id="2-5G-Systems"><a href="#2-5G-Systems" class="headerlink" title="2.5G Systems"></a><strong>2.5G Systems</strong></h3><ul>
<li><strong>Voice and Data Channels</strong>:<ul>
<li><strong>GPRS</strong>: Evolved from GSM, data sent on multiple channels.</li>
<li><strong>EDGE</strong>: Enhanced modulation, data rates up to 384K.</li>
<li><strong>CDMA-2000 (Phase 1)</strong>: Data rates up to 144K, evolved from IS-95.</li>
</ul>
</li>
</ul>
<h3 id="3G-Systems"><a href="#3G-Systems" class="headerlink" title="3G Systems"></a><strong>3G Systems</strong></h3><ul>
<li><strong>Voice&#x2F;Data</strong>:<ul>
<li><strong>UMTS</strong>: High-Speed Uplink&#x2F;Downlink Packet Access (HSDPA&#x2F;HSUPA), 3 Mbps.</li>
<li><strong>CDMA-2000</strong>: Data service (1xEVDO), up to 14 Mbps.</li>
</ul>
</li>
</ul>
<h3 id="4G-Systems"><a href="#4G-Systems" class="headerlink" title="4G Systems"></a><strong>4G Systems</strong></h3><ul>
<li><strong>Voice&#x2F;Data</strong>:<ul>
<li><strong>LTE</strong>: Employs OFDM and MIMO techniques, 100 Mbps for downlink, 50 Mbps for uplink.</li>
</ul>
</li>
</ul>
<h1 id="Principles-Addressing-and-Routing-to-Mobile-Users"><a href="#Principles-Addressing-and-Routing-to-Mobile-Users" class="headerlink" title="Principles: Addressing and Routing to Mobile Users"></a>Principles: Addressing and Routing to Mobile Users</h1><p><strong>mobile user, passing through multiple access point while maintaining ongoing connections (like cell phone)</strong></p>
<h2 id="Mobility-Vocabulary"><a href="#Mobility-Vocabulary" class="headerlink" title="Mobility: Vocabulary"></a>Mobility: Vocabulary</h2><h3 id="Home-Network"><a href="#Home-Network" class="headerlink" title="Home Network"></a><strong>Home Network</strong></h3><ul>
<li>Permanent “home” of the mobile device (e.g., 128.119.40&#x2F;24).</li>
<li><strong>Permanent Address</strong>: Address in the home network, always used to reach the mobile (e.g., 128.119.40.186).</li>
<li><strong>Home Agent</strong>: Entity in the home network that performs mobility functions for the mobile when it is remote.</li>
</ul>
<h3 id="Visited-Network"><a href="#Visited-Network" class="headerlink" title="Visited Network"></a><strong>Visited Network</strong></h3><ul>
<li>Network where the mobile device currently resides (e.g., 79.129.13&#x2F;24).</li>
<li><strong>Care-of-Address</strong>: Temporary address assigned to the mobile in the visited network (e.g., 79.129.13.2).</li>
<li><strong>Foreign Agent</strong>: Entity in the visited network that performs mobility functions on behalf of the mobile.</li>
</ul>
<h3 id="Correspondent"><a href="#Correspondent" class="headerlink" title="Correspondent"></a><strong>Correspondent</strong></h3><ul>
<li>The entity that wants to communicate with the mobile device.</li>
</ul>
<h3 id="Consider-friend-frequently-changing-addresses-how-do-you-find-her"><a href="#Consider-friend-frequently-changing-addresses-how-do-you-find-her" class="headerlink" title="Consider friend frequently changing addresses, how do you find her?"></a>Consider friend frequently changing addresses, how do you find her?</h3><p><strong>let end-systems handle it:</strong></p>
<ul>
<li>indirect routing: communication from correspondent to mobile goes through home agent, then forwarded to remote</li>
<li>direct routing: correspondent gets foreign address of mobile, sends directly to mobile</li>
</ul>
<p><img src="/Wireless-and-Mobile-Networks/Indirect%20routing%20to%20a%20mobile%20node.png" alt="Indirect routing">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p>第一种 indirect routing，见上图所示，当你的朋友移动到其它 <strong>foreign</strong> 网络，他会得到一个 <strong>Care-of-Address</strong>，这个地址是临时的，用于在当前所在子网下通信，但他有一个 <strong>Permanent Address</strong>，可以通过联系他的 <strong>Home agent</strong>，从而联系到他所在子网的 <strong>Foreign agent</strong>，从而联系到他。</p>
<p><img src="/Wireless-and-Mobile-Networks/Direct%20routing%20to%20a%20mobile%20user.png" alt="Direct routing">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p>第二种是 direct routing，这种是先通过联系他的 Home agent，得到他所在子网的 IP address，从联系到他。</p>
<p>需要补充两点：</p>
<ol>
<li><strong>correspondent 如何得到 friend 的 permanent address</strong>.</li>
</ol>
<ul>
<li><strong>permanent address（永久地址）</strong> 是 friend 在 home network 的固定 IP 地址，通常是 friend 在 home network 注册时分配的。</li>
<li><strong>correspondent（通信对端）</strong> 想要联系 friend 时，通常会通过 DNS 查询等方式获得 friend 的 permanent address（即 home address）。</li>
<li>这个 permanent address 是公开的、长期有效的，类似于家庭住址，所有通信发起者都可以通过标准方式获得。</li>
</ul>
<ol start="2">
<li><strong>home agent 如何维护 friend 所在子网的 agent 和 IP address</strong>.</li>
</ol>
<ul>
<li><strong>home agent（归属代理）</strong> 是部署在 friend 的 home network 内的一个特殊节点，负责跟踪 friend 的当前位置。</li>
<li>当 friend 移动到新的 visited network 并获得新的 care-of address 时，会向 home agent 注册自己的新位置（即 care-of address 和 foreign agent 的信息）。</li>
<li>home agent 会维护一个映射表，记录每个移动节点的 permanent address 与其当前的 care-of address（以及 foreign agent 的信息，如果有）。</li>
<li>当有数据包发往 friend 的 permanent address 时，home agent 会将这些数据包<strong>隧道转发</strong>（tunnel）到 friend 当前的 care-of address（即 friend 所在子网的 foreign agent 或直接到 friend 本身）。</li>
</ul>
<h1 id="Mobile-IP-agent-discovery"><a href="#Mobile-IP-agent-discovery" class="headerlink" title="Mobile IP: agent discovery"></a>Mobile IP: agent discovery</h1><p>Agent advertisement: foreign&#x2F;home agents advertise service by broadcasting ICMP messages (<code>typefield = 9</code>)</p>
<h1 id="End-of-chapter-exercises"><a href="#End-of-chapter-exercises" class="headerlink" title="End-of-chapter exercises"></a>End-of-chapter exercises</h1><h2 id="R-1"><a href="#R-1" class="headerlink" title="R.1"></a>R.1</h2><p><strong>Question and Answer:</strong></p>
<p>What does it mean for a wireless network to be operating in “infrastructure mode”? If the network is not in infrastructure mode, what mode of operation is it in, and what is the different between that mode of operation and infrastructure mode?</p>
<p>在无线网络中，”基础设施模式”（infrastructure mode）指的是网络中存在一个基站（如接入点，AP），无线主机通过基站连接到有线网络或更大的互联网。在这种模式下，基站负责在无线主机和有线网络之间中继数据。如果网络不处于基础设施模式，则它处于”自组织模式”（ad hoc mode）。在自组织模式中，没有基站，节点只能与其链路覆盖范围内的其他节点通信，节点之间通过自组织的方式形成网络并相互路由。两者的主要区别在于是否依赖基站：基础设施模式依赖基站，而自组织模式则完全由节点自主协作。</p>
<h2 id="R-2"><a href="#R-2" class="headerlink" title="R.2"></a>R.2</h2><p><strong>Question and Answer:</strong></p>
<p>What are the four type of wireless networks identified in our taxonomy in Section $6.1$? Which of these types of wireless networks have you used?</p>
<p>Section $6.1$ 中提到的 $4$ 种无线网络结构如下：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th><strong>Infrastructure</strong></th>
<th><strong>Single Hop</strong></th>
<th><strong>Multiple Hops</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>With Infrastructure</strong></td>
<td>Host connects to base station (WiFi, WiMAX, cellular) which connects to larger Internet.</td>
<td>Host relays through several wireless nodes to connect to larger Internet (mesh net).</td>
</tr>
<tr>
<td><strong>Without Infrastructure</strong></td>
<td>No base station, no connection to larger Internet (e.g., Bluetooth, ad hoc nets).</td>
<td>No base station, no connection to larger Internet. Nodes relay to reach other nodes (e.g., MANET, VANET).</td>
</tr>
</tbody></table>
</div>
其中像 WiFi 和 Bluetooth 经常使用。

<h2 id="R-3"><a href="#R-3" class="headerlink" title="R.3"></a>R.3</h2><p><strong>Question and Answer:</strong></p>
<p>What are the differences between the following types of wireless channel impairments: path loss, multipath propagation, interference from other sources?</p>
<p>下面是对三种信道损伤的解释：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th><strong>损伤类型</strong></th>
<th><strong>详细解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>路径损耗 (path loss)</strong></td>
<td>信号随<strong>传播距离增加</strong>而自然衰减的现象。遵循<strong>平方反比或更高次幂</strong>衰减规律，与距离和频率相关。主要包括<strong>自由空间损耗</strong>、<strong>大气吸收</strong>、<strong>障碍物衰减</strong>等，是无线通信中的<strong>基础衰减现象</strong>。</td>
</tr>
<tr>
<td><strong>多径传播 (multipath propagation)</strong></td>
<td>信号通过<strong>多个不同路径</strong>同时到达接收器的现象。由信号在建筑物、地面等物体表面的<strong>反射</strong>、<strong>散射</strong>、<strong>折射</strong>和<strong>绕射</strong>导致。产生<strong>相位差异</strong>使信号彼此<strong>增强或抵消</strong>，造成<strong>信号衰落</strong>、<strong>时延扩展</strong>和<strong>符号间干扰</strong>。</td>
</tr>
<tr>
<td><strong>外部干扰 (interference from other sources)</strong></td>
<td>来自<strong>其他发射源</strong>的电磁波对当前通信的干扰。包括<strong>同频干扰</strong>（相同频道上的其他发射器）、<strong>相邻频道干扰</strong>和<strong>电子设备噪声</strong>等。干扰与当前信号混合，<strong>降低信噪比</strong>和通信质量。</td>
</tr>
</tbody></table>
</div>

<h2 id="R-4"><a href="#R-4" class="headerlink" title="R.4"></a>R.4</h2><p><strong>Question and Answer:</strong></p>
<p>As a mobile node gets farther and farther away from a base station, what are two actions that a base station could take to ensure that the loss probability of a transmitted frame does not increase?</p>
<ol>
<li><p><strong>Wireless Link Characteristics</strong> 部分提到：</p>
<ul>
<li><strong>SNR (Signal-to-Noise Ratio)</strong>：增大信号强度可以提高信噪比，从而降低误码率（BER）。</li>
<li><strong>decreased signal strength</strong>：信号强度的降低会影响通信质量。</li>
</ul>
</li>
<li><p><strong>IEEE 802.11 MAC Protocol: CSMA&#x2F;CA</strong> 部分提到：</p>
<ul>
<li><strong>Collision Avoidance</strong>：通过避免冲突来提高传输成功率。</li>
</ul>
</li>
<li><p><strong>Cellular Internet Access</strong> 部分提到：</p>
<ul>
<li><strong>LTE</strong> 使用了 <strong>OFDM</strong> 和 <strong>MIMO</strong> 技术，这些技术可以提高信号覆盖范围和传输效率。</li>
</ul>
</li>
</ol>
<p>结合这些内容，可以得出以下两种可能的措施：</p>
<ul>
<li><strong>增大发射功率</strong>：提高信号强度以补偿路径损耗。</li>
<li><strong>使用多天线技术（如 MIMO）</strong>：通过空间分集技术提高信号质量和覆盖范围。</li>
</ul>
<h2 id="R-10"><a href="#R-10" class="headerlink" title="R.10"></a>R.10</h2><p><strong>Question and Answer:</strong></p>
<p>Suppose the IEEE $802.11$ RTS and CTS frames were as long as the standard DATA and ACK frames. Would there be any advantage to using the CTS and RTS frames? Why or why not?</p>
<ul>
<li><strong>Avoiding Collisions: RTS&#x2F;CTS Mechanism</strong> 部分提到：<ul>
<li>RTS 和 CTS 的主要作用是 <strong>避免长数据帧的冲突</strong>。</li>
<li>RTS 和 CTS 包较小，即使发生冲突，影响也较小。</li>
<li>使用 RTS&#x2F;CTS 机制可以通过小型的预留包来减少长数据帧的冲突。</li>
</ul>
</li>
<li>如果 RTS 和 CTS 包与标准的 DATA 和 ACK 包一样长，那么它们的优势将丧失，因为：<ol>
<li><strong>冲突成本增加</strong>：长 RTS 和 CTS 包的冲突会导致更大的资源浪费。</li>
<li><strong>效率降低</strong>：长 RTS 和 CTS 包会增加额外的开销，降低整体网络效率。</li>
</ol>
</li>
</ul>
<h2 id="R-16"><a href="#R-16" class="headerlink" title="R.16"></a>R.16</h2><p><strong>Question and Answer:</strong></p>
<p>If a node has a wireless connection to the Internet, does that node have to be mobile? Explain. Suppose that a user with a laptop walks around her house with her laptop, and always accesses the Internet through the same access point. Is this user mobile from a network standpoint? Explain.</p>
<p>一个节点拥有无线连接，并不意味着它是<strong>移动的</strong>。无线连接只是物理层和链路层的接入方式，只要设备通过无线方式接入网络，无论它是否实际移动，都可以称为无线节点，但不一定是<strong>移动节点</strong>。用户在家中携带笔记本，始终通过同一个 AP 上网，这说明用户始终在同一个 subnet 和 BSS 内，所以不认为用户发生了网络层的移动。</p>
<h2 id="R-17"><a href="#R-17" class="headerlink" title="R.17"></a>R.17</h2><p><strong>Question and Answer:</strong></p>
<p>What is the difference between a permanent address and a care-of address? Who assigns a care-of address?</p>
<ul>
<li><p><strong>permanent address（永久地址）</strong></p>
<ul>
<li>也称为 home address（归属地址），是移动节点在其<strong>归属网络</strong>（home network）中的固定 IP 地址。</li>
<li>这个地址在移动节点无论身处何地都不会改变，始终用于标识该节点的身份。</li>
<li>例如：移动节点在家乡网络的 IP 地址 128.119.40.186。</li>
</ul>
</li>
<li><p><strong>care-of address（临时地址）</strong></p>
<ul>
<li>是移动节点在<strong>访问网络</strong>（visited network）中临时获得的 IP 地址。</li>
<li>当移动节点离开归属网络，进入其他网络时，会在该访问网络中分配一个新的 IP 地址，这个地址用于在当前网络中进行通信。</li>
<li>例如：移动节点在外地网络获得的 IP 地址 79.129.13.2。</li>
</ul>
</li>
<li><p>care-of address 通常由<strong>访问网络 visited network</strong> 分配，具体来说：</p>
<ul>
<li>可以由访问网络中的<strong>外部代理 Foreign Agent</strong> 分配；</li>
<li>也可以通过 DHCP 等自动分配协议由访问网络的路由器分配。</li>
</ul>
</li>
</ul>
<h2 id="R-19"><a href="#R-19" class="headerlink" title="R.19"></a>R.19</h2><p><strong>Question and Answer:</strong></p>
<p>What are the purposes of the HLR and VLR in GSM networks? What elements of mobile IP are similar to the HLR and VLR?</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>GSM 网络</th>
<th>Mobile IP 协议</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>HLR</td>
<td>Home Agent</td>
<td>记录永久信息和当前位置</td>
</tr>
<tr>
<td>VLR</td>
<td>Foreign Agent</td>
<td>临时管理当前区域内的用户&#x2F;节点信息</td>
</tr>
</tbody></table>
</div>

<h2 id="P-5"><a href="#P-5" class="headerlink" title="P.5"></a>P.5</h2><p><strong>Question and Answer:</strong></p>
<p>Suppose there are two ISPs providing WiFi access in a particular café, with each ISP operating its own AP and having its own IP address block. a. Further suppose that by accident, each ISP has configured its AP to operate over channel 11. Will the 802.11 protocol completely break down in this situation? Discuss what happens when two stations, each associated with a different ISP, attempt to transmit at the same time. b. Now suppose that one AP operates over channel 1 and the other over channel 11. How do your answers change?</p>
<p><strong>a.</strong>：802.11 协议不会完全失效，但两个 AP 及其关联的 hosts 会在 physical layer 竞争同一个信道的使用权。如果两个 hosts 同时发送数据，此时会产生 collision，尽管 CSMA&#x2F;CA 协议会尽可能避免冲突，但由于信号干扰，冲突仍会发生，导致通信变得不稳定。</p>
<p><strong>b.</strong>：此时两个 AP 用不同的信道，互不干扰，通信正常。</p>
<h2 id="P-13"><a href="#P-13" class="headerlink" title="P.13"></a>P.13</h2><p><strong>Question and Answer:</strong></p>
<p>In mobile IP, what effect will mobility have on end-to-end delays of datagrams between the source and destination?</p>
<ol>
<li><p><strong>间接路由（Indirect Routing）增加路径长度</strong></p>
<ul>
<li>在移动 IP 的典型实现中，数据报首先被发送到移动节点的 home agent（归属代理），然后由 home agent 转发（隧道）到移动节点当前的 care-of address（临时地址）。</li>
<li>这种绕路导致数据报的实际传输路径比直接路由更长，<strong>增加了端到端延迟</strong>。</li>
<li>例如，源主机 → home agent → foreign agent → 移动节点。</li>
</ul>
</li>
<li><p><strong>切换期间的延迟抖动</strong></p>
<ul>
<li>当移动节点从一个网络切换到另一个网络时（如切换 AP 或基站），需要重新获取 care-of address 并向 home agent 注册新位置。</li>
<li>在切换和注册期间，可能会出现短暂的不可达或数据包丢失，<strong>导致延迟波动或瞬时增加</strong>。</li>
</ul>
</li>
<li><p><strong>三角路由问题</strong></p>
<ul>
<li>在 indirect routing 下，通信对端（correspondent）始终将数据包发往 permanent address，导致所有流量都要经过 home agent，形成所谓的三角路由。</li>
<li>这进一步增加了端到端的传输时延，尤其当 home agent 距离通信双方较远时影响更明显。</li>
</ul>
</li>
<li><p><strong>优化路由（Direct Routing）可减少延迟</strong></p>
<ul>
<li>如果采用 direct routing（如移动节点的当前位置被通知给通信对端），数据报可以直接从源主机发往移动节点当前的 care-of address，<strong>端到端延迟会降低</strong>。</li>
<li>但 direct routing 需要额外的机制来保证安全和地址同步。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/08/The-Transport-Layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/08/The-Transport-Layer/" class="post-title-link" itemprop="url">The Transport Layer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-08 15:04:40" itemprop="dateCreated datePublished" datetime="2025-06-08T15:04:40+08:00">2025-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-17 10:58:02" itemprop="dateModified" datetime="2025-06-17T10:58:02+08:00">2025-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/" itemprop="url" rel="index"><span itemprop="name">Computer Network</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/Transport-Layer/" itemprop="url" rel="index"><span itemprop="name">Transport Layer</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Transport-Layer-Services"><a href="#Transport-Layer-Services" class="headerlink" title="Transport-Layer Services"></a>Transport-Layer Services</h1><p>Transport protocols run in <strong>end systems</strong>:</p>
<ul>
<li>Sending side: breaks app messages into <strong>segments</strong>, passes to  network layer.</li>
<li>Receiving side: reassembles segments into <strong>messages</strong>, passes to app layer.</li>
</ul>
<h1 id="Multiplexing-and-Demultiplexing"><a href="#Multiplexing-and-Demultiplexing" class="headerlink" title="Multiplexing and Demultiplexing"></a>Multiplexing and Demultiplexing</h1><p><strong>Multiplexing at sending host:</strong> gather data from multiple sockets, enveloping data with <strong>header</strong>(later used for demultiplexing).<br><strong>demultiplexing at receiving host:</strong> deliver segments to correct socket.</p>
<h2 id="Demultiplexing"><a href="#Demultiplexing" class="headerlink" title="Demultiplexing"></a>Demultiplexing</h2><p>Hosts receives <strong>IP datagrams</strong>. Each IP datagram has source IP address and destination IP address. Each IP datagram carries a transport-layer segment. Each segment has source port numbers and destination port numbers.</p>
<p><img src="/The-Transport-Layer/a-transport-layer-segment.png" alt="A transport layer segment">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<blockquote>
<p>将 segment 传到目标 host，host 再将 segment 通过 socket 传给对应的 application。</p>
</blockquote>
<h3 id="Connectionless-Demultiplexing"><a href="#Connectionless-Demultiplexing" class="headerlink" title="Connectionless Demultiplexing"></a>Connectionless Demultiplexing</h3><p>在 <strong>UDP</strong> 协议中使用。</p>
<p>Creates socket with <strong>port numbers</strong>. Each UDP socket identified with <code>(dest IP address, dest port numbers)</code>.</p>
<blockquote>
<p>当终端收到 IP datagrams 中是 UDP segment 时。 The host will check destination port in the segment and then directs the segment to corresponding socket。发生在 transport layer。</p>
</blockquote>
<h3 id="Connection-oriented-Demultiplexing"><a href="#Connection-oriented-Demultiplexing" class="headerlink" title="Connection-oriented Demultiplexing"></a>Connection-oriented Demultiplexing</h3><p><strong>Used in TCP protocol</strong>.</p>
<p>TCP socket identified by <strong>4</strong>-tuple: <code>(source IP address, source port numbers, dest IP address, dest port numbers)</code>.</p>
<h1 id="Connectionless-Transport-UDP"><a href="#Connectionless-Transport-UDP" class="headerlink" title="Connectionless Transport: UDP"></a>Connectionless Transport: UDP</h1><h2 id="UDP-Segment-Structure"><a href="#UDP-Segment-Structure" class="headerlink" title="UDP Segment Structure"></a>UDP Segment Structure</h2><p><img src="/The-Transport-Layer/UDP-segment-structure.png" alt="UDP segment structure">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<h2 id="UDP-Checksum"><a href="#UDP-Checksum" class="headerlink" title="UDP Checksum"></a>UDP Checksum</h2><p><strong>Goal</strong>: detect “errors” (e.g., flipped bits) in transmitted segment. 指的是位比特发生了 $01$ 翻转。</p>
<p>“Calculation:”</p>
<ol>
<li><p><strong>Group Data</strong>:</p>
<ul>
<li>Divide all fields of the UDP segment (including header and data) into 16-bit blocks. If the data length is odd, pad with a zero byte. 这里要注意，不同的比特排序方式会影响到最终结果，数据通常以<strong>大端序</strong>（高位字节在前）表示。</li>
</ul>
</li>
<li><p><strong>Compute Sum</strong>:</p>
<ul>
<li>Perform a 1’s complement sum of all 16-bit blocks。就是二进位加法。</li>
<li>If overflow occurs (exceeds 16 bits), wrap the overflow back into the result.</li>
</ul>
</li>
<li><p><strong>Take Complement</strong>:</p>
<ul>
<li>Take the 1’s complement of the computed sum to get the final checksum。这里可以看作进行了一次<strong>同位全 $1$</strong> 加法。</li>
</ul>
</li>
<li><p><strong>Fill Checksum Field</strong>:</p>
<ul>
<li>Place the computed checksum into the checksum field of the UDP segment.</li>
</ul>
</li>
</ol>
<h1 id="Principles-of-Reliable-Data-Transfer"><a href="#Principles-of-Reliable-Data-Transfer" class="headerlink" title="Principles of Reliable Data Transfer"></a>Principles of Reliable Data Transfer</h1><p><strong>应用程序即使运行在 UDP 之上，也可以实现可靠数据传输</strong>。虽然 UDP 本身是无连接、无保证的协议，不提供诸如数据包重传、顺序保证、丢包检测等机制，但<strong>应用层可以自行实现这些功能</strong>，从而达到可靠传输的目的。</p>
<p><img src="/The-Transport-Layer/Reliable-data-transfer.png" alt="Reliable data transfer: Service model and service implementation">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<h2 id="Reliable-Data-Transfer-over-a-Perfectly-Reliable-Channel-rdt-1-0"><a href="#Reliable-Data-Transfer-over-a-Perfectly-Reliable-Channel-rdt-1-0" class="headerlink" title="Reliable Data Transfer over a Perfectly Reliable Channel: rdt 1.0"></a>Reliable Data Transfer over a Perfectly Reliable Channel: rdt 1.0</h2><p><img src="/The-Transport-Layer/rdt1.png" alt="rdt1.0 - A protocol for a completely reliable channel">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>Unrealistic:</strong> underlying channel perfectly reliable</p>
<ul>
<li>no bit errors</li>
<li>no loss of packets</li>
</ul>
<h2 id="Reliable-Data-Transfer-over-a-Channel-with-Bit-Errors-rdt-2-0"><a href="#Reliable-Data-Transfer-over-a-Channel-with-Bit-Errors-rdt-2-0" class="headerlink" title="Reliable Data Transfer over a Channel with Bit Errors: rdt 2.0"></a>Reliable Data Transfer over a Channel with Bit Errors: rdt 2.0</h2><p>增添检查错误机制：checksum 和 ACK。</p>
<p><img src="/The-Transport-Layer/rdt2.png" alt="rdt 2.0 - A protocol for a channel with bit errors">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>New mechanism in rdt 2.0 (beyond rdt 1.0)</strong></p>
<ul>
<li>Error detection;<ul>
<li><strong>Checksum</strong>.</li>
</ul>
</li>
<li>Receiver feedback.<ul>
<li><strong>ACKs and NAKs</strong>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>rdt 2.0 有一个致命问题：如果 ACK&#x2F;NAK 出错导致信息改变。</p>
</blockquote>
<h2 id="rdt-2-1"><a href="#rdt-2-1" class="headerlink" title="rdt 2.1"></a>rdt 2.1</h2><p><img src="/The-Transport-Layer/rdt2-1-sender.png" alt="rdt 2.1 sender">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><img src="/The-Transport-Layer/rdt2-1-receiver.png" alt="rdt 2.1 receiver">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<blockquote>
<p>可以看到 rdt 2.1 新增了一个 sequence number。在 rdt 2.0 中提到过其有着一个致命的问题，这个问题可能会导致两个问题：重传和丢失。从 Figure P.6 和 Figure P.7 可以看到 rdt 2.1 能解决重传的问题，但是不能解决丢失的问题。</p>
</blockquote>
<h2 id="rdt-2-2"><a href="#rdt-2-2" class="headerlink" title="rdt 2.2"></a>rdt 2.2</h2><p><img src="/The-Transport-Layer/rdt2-2-sender.png" alt="rdt2.2 sender">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><img src="/The-Transport-Layer/rdt2-2-receiver.png" alt="rdt2.2 receiver">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<blockquote>
<p>rdt 2.1 的机制是：如果是 NAK 或者 checksum 出错就重传。从 Figure P.8 和 Figure P.9 可以看出，receiver 收了什么序号的包就回什么序号，如果是自己要的包就 extract，然后 sender 发下个序号的包，如果重传导致 duplicate，那么只需要 delete 然后给 sender 发送 ACK。显然，receiver 回什么序号，sender 都会发下一个序号的包，也就是 rdt 2.2 没有使用 NAK 就解决了重传的问题。</p>
</blockquote>
<p>补充：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>变量&#x2F;语句</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>oncethru == 1</code></td>
<td>是否第一次进入该状态</td>
</tr>
<tr>
<td><code>udt_send(sndpkt)</code></td>
<td>发送 ACK 包</td>
</tr>
<tr>
<td>结合使用</td>
<td>首次进入状态时主动重发 ACK，防止因 ACK 丢失而死锁</td>
</tr>
</tbody></table>
</div>

<h2 id="rdt-3-0"><a href="#rdt-3-0" class="headerlink" title="rdt 3.0"></a>rdt 3.0</h2><p><img src="/The-Transport-Layer/rdt3-0-receiver.png" alt="rdt3.0 sender">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<blockquote>
<p>增加了一个计时器，可以解决包丢失的问题，如果超时就重传，</p>
</blockquote>
<h2 id="Pipelined-Reliable-Data-Transfer-Protocols"><a href="#Pipelined-Reliable-Data-Transfer-Protocols" class="headerlink" title="Pipelined Reliable Data Transfer Protocols"></a>Pipelined Reliable Data Transfer Protocols</h2><p><strong>rdt 3.0 stop-and-wait operation</strong>: rdt 3.0 can work, but its performance stinks.</p>
<blockquote>
<p>这里是说 rdt 3.0 的机制一轮就处理一个包而效率低下。</p>
</blockquote>
<p>For example, we suppose condition with 1 Gbps link, 15 ms propagation delay, 8000 bits packet.</p>
<p>$$<br>\text{d}_{trans} &#x3D; \frac{L}{R} &#x3D; \frac{8000 \text{bits}}{10^9 \text{bps}} &#x3D; 8 \text{microseconds}<br>$$</p>
<p>$$<br>\text{Utilization} &#x3D; \frac{\frac{L}{R}}{\text{RTT} + \frac{L}{R}} &#x3D; 0.00027<br>$$</p>
<p>So, we use <strong>Pipelined Reliable Data Transfer Protocols</strong> to increase utilization!</p>
<p><strong>Pipelining:</strong> sender allows multiple, “in-flight”,yet-to-be-acknowledged pkts.</p>
<ul>
<li>Range of sequence numbers must be <strong>increased</strong>.</li>
<li><strong>Buffering</strong> at sender and&#x2F;or receiver.</li>
</ul>
<h3 id="Go-Back-N-GBN-Protocol"><a href="#Go-Back-N-GBN-Protocol" class="headerlink" title="Go-Back-N (GBN) Protocol"></a>Go-Back-N (GBN) Protocol</h3><p><img src="/The-Transport-Layer/Sender's-view-of-sequence-numbers-in-Go-Back-N.png" alt="Sender&#39;s view of sequence numbers in Go-Back-N">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>Timeout(n):</strong> retransmit pkt <code>n</code> and all higher seq <code>#</code> pkts in window</p>
<p><img src="/The-Transport-Layer/GBN-sender.png.png" alt="GBN sender">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><img src="/The-Transport-Layer/GBN-receiver.png.png" alt="GBN receiver">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p>需要注意的是，上述图片中是<strong>覆盖确认</strong>：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>协议类型</th>
<th>ACK 处理方式</th>
<th>base 变化方式</th>
</tr>
</thead>
<tbody><tr>
<td>累计确认（GBN）</td>
<td>只确认按序最大已收到的包</td>
<td>base 只前进不回退</td>
</tr>
<tr>
<td>覆盖确认（图中）</td>
<td>收到哪个 ACK 就直接覆盖 base</td>
<td>base 可能跳跃前进</td>
</tr>
</tbody></table>
</div>

<h3 id="Selective-Repeat-SR"><a href="#Selective-Repeat-SR" class="headerlink" title="Selective Repeat (SR)"></a>Selective Repeat (SR)</h3><p>Sender only <strong>resends</strong> pkts for which ACK not received.</p>
<p><img src="/The-Transport-Layer/RS-sender-receiver-view.png" alt="Selective-repeat (SR) sender and receiver views of sequence-number space">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p>$$<br>\text{window size} \leq \frac{1}{2} \text{seq}<br>$$</p>
<h4 id="Sender"><a href="#Sender" class="headerlink" title="Sender"></a>Sender</h4><ul>
<li><strong>Data from above</strong>:<ul>
<li>If next available sequence number is within the window, send the packet.</li>
</ul>
</li>
<li><strong>Timeout(n)</strong>:<ul>
<li>Resend packet <code>n</code>, restart the timer.</li>
</ul>
</li>
<li><strong>ACK(n) in [sendbase, sendbase $+$ $N$]</strong>:<ul>
<li>Mark packet <code>n</code> as received.</li>
<li>If <code>n</code> is the smallest unACKed packet, <strong>advance</strong> the window base to the next unACKed sequence number.</li>
</ul>
</li>
</ul>
<h4 id="Receiver"><a href="#Receiver" class="headerlink" title="Receiver"></a>Receiver</h4><ul>
<li><strong>Packet <code>n</code> in [rcvbase, rcvbase $+$ $N$ $-$ $1$]</strong>:<ul>
<li>Send ACK(n).</li>
<li><strong>Out-of-order</strong>: Buffer the packet.</li>
<li><strong>In-order</strong>: Deliver the packet (also deliver buffered, in-order packets), advance the window to the next not-yet-received packet.</li>
</ul>
</li>
<li><strong>Packet <code>n</code> in [rcvbase $-$ $N$, rcvbase $-$ $1$]</strong>:<ul>
<li>Send ACK(n). 解决 duplicate。</li>
</ul>
</li>
<li><strong>Otherwise</strong>:<ul>
<li>Ignore the packet.</li>
</ul>
</li>
</ul>
<h1 id="Connection-oriented-transport-TCP"><a href="#Connection-oriented-transport-TCP" class="headerlink" title="Connection-oriented transport: TCP"></a>Connection-oriented transport: TCP</h1><h2 id="TCP-Segment-Structure"><a href="#TCP-Segment-Structure" class="headerlink" title="TCP Segment Structure"></a>TCP Segment Structure</h2><p><img src="/The-Transport-Layer/TCP-segment-structure.png" alt="TCP segment structure">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>How to set sequence number and acknowledgment number?</strong></p>
<ul>
<li><strong>sequence number</strong>: represents the byte stream number of the first byte in the segment’s data.</li>
<li><strong>ACKs</strong>: indicates the sequence number of the next byte expected from the sender. Using cumulative acknowledgment.</li>
</ul>
<h2 id="TCP-Round-Trip-Time-and-Timeout"><a href="#TCP-Round-Trip-Time-and-Timeout" class="headerlink" title="TCP Round Trip Time and Timeout"></a>TCP Round Trip Time and Timeout</h2><p><strong>How to estimate $\mathbf{RTT}$?</strong></p>
<p>$$<br>\text{EstimateRTT} &#x3D; (1 - \alpha) \cdot \text{EstimateRTT} + \alpha \cdot \text{SampleRTT}, \quad \text{Typically } \alpha &#x3D; 0.125<br>$$</p>
<p><strong>How to set TCP timeout value?</strong></p>
<p>Longer than $\text{RTT}$, but $\text{RTT}$ varies.<br>$$<br>\text{DevRTT} &#x3D; (1 - \beta) \cdot \text{DevRTT} + \beta \cdot |\text{SampleRTT} - \text{EstimateRTT}|, \quad \text{Typically } \beta &#x3D; 0.25<br>$$</p>
<p>$$<br>\text{TimeOutInterval} &#x3D; \text{EstimateRTT} + 4 \cdot \text{DevRTT}<br>$$</p>
<h2 id="TCP-Reliable-Data-Transfer"><a href="#TCP-Reliable-Data-Transfer" class="headerlink" title="TCP Reliable Data Transfer"></a>TCP Reliable Data Transfer</h2><h3 id="Fast-Retransmit"><a href="#Fast-Retransmit" class="headerlink" title="Fast  Retransmit"></a>Fast  Retransmit</h3><p>If sender receives $3$ ACKs for same data, it assumes that segment after ACKed data was lost.</p>
<h2 id="Flow-control"><a href="#Flow-control" class="headerlink" title="Flow control"></a>Flow control</h2><p>Receiver side of TCP connection has a <strong>receive buffer</strong>.</p>
<p><img src="/The-Transport-Layer/rwnd-buffer.png" alt="The receive window (rwnd) and the receive buffer (RcvBuffer)">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<h3 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works?"></a>How it works?</h3><ul>
<li><strong>Receiver:</strong> advertises unused buffer space by including $\text{rwnd}$ value in segment header.</li>
<li><strong>Sender:</strong> limits unAcked bytes to $\text{rwnd}$.</li>
</ul>
<p>$$<br>\text{rwnd} &#x3D; \text{RcvBuffer} - \left[\text{LastByteRcvd} - \text{LastByteRead} \right]<br>$$</p>
<p><strong>字节编号</strong>的问题。在TCP中：</p>
<ul>
<li>如果初始序列号为0，发送50字节后：<ul>
<li>这些字节的序号为：0, 1, 2, …, 49</li>
<li><strong>最后一个字节</strong>的序号为49，即 LastByteRcvd &#x3D; 49</li>
<li>根据公式 $y &#x3D; \text{LastByteRcvd} + 1$，得到确认号 y &#x3D; 50</li>
</ul>
</li>
</ul>
<p>其中 y 是 ACK。</p>
<h2 id="Connection-Management"><a href="#Connection-Management" class="headerlink" title="Connection Management"></a>Connection Management</h2><h3 id="Three-Way-Handshake"><a href="#Three-Way-Handshake" class="headerlink" title="Three Way Handshake"></a>Three Way Handshake</h3><p><strong>握手协议（Handshaking Protocol）</strong> 是指在两个通信实体（如客户端和服务器）之间建立通信连接之前，双方通过一系列消息的交换，协商通信参数、确认彼此身份、同步状态等，从而为后续的数据传输做好准备的过程。</p>
<ol>
<li><p><strong>Step 1</strong>:</p>
<ul>
<li>Client sends TCP <code>SYN</code> segment to server, specifying initial seq. No data.</li>
</ul>
</li>
<li><p><strong>Step 2</strong>:</p>
<ul>
<li>Server host receives <code>SYN</code>, replies with <code>SYNACK</code> segment. Server allocates buffers and specifies server initial seq.</li>
</ul>
</li>
<li><p><strong>Step 3</strong>:</p>
<ul>
<li>Client receives <code>SYNACK</code>, replies with ACK segment, which may contain data</li>
</ul>
</li>
</ol>
<h3 id="Closing-a-Connection"><a href="#Closing-a-Connection" class="headerlink" title="Closing a Connection"></a>Closing a Connection</h3><ol>
<li><p><strong>Step 1</strong>:</p>
<ul>
<li>Client sends TCP <code>FIN</code> segment to server, specifying initial seq. No data.</li>
</ul>
</li>
<li><p><strong>Step 2</strong>:</p>
<ul>
<li>Server receives <code>FIN</code>, replies with ACK. Closes connection, sends <code>FIN</code>.</li>
</ul>
</li>
<li><p><strong>Step 3</strong>:</p>
<ul>
<li>Client receives <code>FIN</code>, replies with ACK.</li>
</ul>
</li>
<li><p><strong>Step 4</strong>:</p>
<ul>
<li>Server, receives ACK.  Connection closed.</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">客户端A                                      服务器B</span><br><span class="line">   | ----------- SYN, Seq=1000 ------------&gt; |</span><br><span class="line">   |                                         |</span><br><span class="line">   | &lt;------ SYN+ACK, Seq=2000, Ack=1001 --- |</span><br><span class="line">   |                                         |</span><br><span class="line">   | ----------- ACK, Seq=1001, Ack=2001 --&gt; |</span><br></pre></td></tr></table></figure>

<p>上面所说的 <code>SYN</code> 和 <code>FIN</code> 都在 TCP segment 结构 header 中。</p>
<h1 id="Principles-of-Congestion-control"><a href="#Principles-of-Congestion-control" class="headerlink" title="Principles of Congestion control"></a>Principles of Congestion control</h1><p>Too many sources sending too much data too fast for <strong>network (router)</strong> to handle.</p>
<h2 id="Approaches-towards-Congestion-Control"><a href="#Approaches-towards-Congestion-Control" class="headerlink" title="Approaches towards Congestion Control"></a>Approaches towards Congestion Control</h2><ul>
<li><strong>end-end congestion control</strong>: congestion inferred from end-system observed loss, delay.</li>
<li><strong>network-assisted congestion control</strong>: routers provide feedback to end systems.</li>
</ul>
<h1 id="TCP-Congestion-Control"><a href="#TCP-Congestion-Control" class="headerlink" title="TCP Congestion Control"></a>TCP Congestion Control</h1><p><strong>Goal:</strong>  TCP sender should transmit as fast as possible, but without congesting network</p>
<p><strong>probing for bandwidth:</strong> increase transmission rate on receipt of ACK, until eventually loss occurs, then decrease transmission rate. &#x2F;&#x2F;一种贪心策略</p>
<p>Sender limits rate by limiting number of unACKed bytes “in pipeline”:<br>$$<br>\text{LastByteSent} - \text{LastByteAcked} \leq \min {\text{cwnd}, \text{rwnd} }<br>$$</p>
<p>$$<br>\text{rate} \approx \frac{\text{cwnd}}{\text{RTT}}<br>$$</p>
<h2 id="Slow-Start-Phase"><a href="#Slow-Start-Phase" class="headerlink" title="Slow Start Phase"></a>Slow Start Phase</h2><p>When connection begins, $\text{cwnd} &#x3D; 1 , \text{MSS}$.</p>
<blockquote>
<p>$$ \text{MSS} &#x3D; \text{MTU} - \text{IP头部大小} - \text{TCP头部大小} $$</p>
</blockquote>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>特性</th>
<th>MSS</th>
<th>MTU</th>
</tr>
</thead>
<tbody><tr>
<td>所属协议层</td>
<td>传输层 (TCP)</td>
<td>数据链路层</td>
</tr>
<tr>
<td>计量对象</td>
<td>TCP 数据部分</td>
<td>整个数据包（包括所有头部）</td>
</tr>
<tr>
<td>设置目的</td>
<td>避免 IP 分片</td>
<td>适应物理媒介的限制</td>
</tr>
<tr>
<td>典型值</td>
<td>1460 字节 (以太网)</td>
<td>1500 字节 (以太网)</td>
</tr>
<tr>
<td>协商方式</td>
<td>TCP 三次握手时协商</td>
<td>网络设备固定或自动发现</td>
</tr>
</tbody></table>
</div>

<p>Increase rate exponentially until first <strong>loss event</strong> or when <strong>threshold reached</strong>.</p>
<ul>
<li><strong>Double</strong> cwnd every RTT. 没有发生 loss 就以指数函数增长。</li>
<li>Done by incrementing cwnd by $1$ for every ACK received. 超过 $\text{ssthresh}$ 后线性增长。</li>
</ul>
<h2 id="Congestion-Avoidance"><a href="#Congestion-Avoidance" class="headerlink" title="Congestion Avoidance"></a>Congestion Avoidance</h2><p>When $\text{cwnd} \geq \text{ssthresh}$, increase $\text{cwnd}$ by $1$ $\text{MSS}$ per $\text{RTT}$.</p>
<h2 id="TCP-RENO"><a href="#TCP-RENO" class="headerlink" title="TCP RENO"></a>TCP RENO</h2><p><strong>Fast recovery</strong>: When triple duplicate ACKs occurs, $\text{ssthresh}$ sets to $\frac{\text{cwnd}}{2}$, $\text{cwnd}$ sets to $\text{ssthresh}$. 传快了，适当减小。</p>
<p>But when <strong>timeout</strong> occurs, $\text{ssthresh}$ sets to $\frac{\text{cwnd}}{2}$, $\text{cwnd}$ sets to $1$ $\text{MSS}$. 丢包。</p>
<h2 id="TCP-throughput"><a href="#TCP-throughput" class="headerlink" title="TCP throughput"></a>TCP throughput</h2><p><strong>Question:</strong> What’s the average throughput of TCP as a function of window size and RTT?</p>
<p><strong>Assumptions:</strong></p>
<ul>
<li>Ignoring slow start.</li>
<li>Let <code>W</code> be the window size when loss occurs.</li>
</ul>
<p><strong>Throughput Analysis:</strong></p>
<ol>
<li><p><strong>When window size is <code>W</code></strong>:</p>
<ul>
<li>Throughput &#x3D; $\frac{W}{\text{RTT}}$.</li>
</ul>
</li>
<li><p><strong>Just after loss</strong>:</p>
<ul>
<li>Window size drops to $\frac{W}{2}$.</li>
<li>Throughput &#x3D; $\frac{W}{2 \cdot \text{RTT}}$.</li>
</ul>
</li>
<li><p><strong>Average throughput</strong>:</p>
<ul>
<li>Average throughput &#x3D; $0.75 \cdot \frac{W}{\text{RTT}}$.</li>
</ul>
</li>
</ol>
<h1 id="End-of-chapter-exercises"><a href="#End-of-chapter-exercises" class="headerlink" title="End-of-chapter exercises"></a>End-of-chapter exercises</h1><h2 id="R-4"><a href="#R-4" class="headerlink" title="R.4"></a>R.4</h2><p><strong>Question:</strong></p>
<p>Describe why an application developer might choose to run an application over UDP rather than TCP.</p>
<p><strong>Answer:</strong></p>
<p>An application developer might choose to run an application over UDP rather than TCP for the following reasons:</p>
<ol>
<li><p><strong>Low Latency</strong>: UDP is a connectionless protocol, meaning it does not establish a connection before sending data. This reduces latency, making it suitable for real-time applications like video streaming, online gaming, and voice over IP (VoIP).</p>
</li>
<li><p><strong>No Overhead for Reliability</strong>: Unlike TCP, UDP does not provide reliability mechanisms such as retransmissions, acknowledgments, or congestion control. This reduces overhead and allows applications to handle reliability themselves if needed.</p>
</li>
<li><p><strong>Broadcast&#x2F;Multicast Support</strong>: UDP supports broadcasting and multicasting, which is useful for applications like live video streaming or network discovery.</p>
</li>
<li><p><strong>Simple Protocol</strong>: UDP is simpler and requires fewer resources, making it ideal for lightweight applications or systems with limited processing power.</p>
</li>
<li><p><strong>Custom Error Handling</strong>: Some applications prefer to implement their own error handling and flow control mechanisms tailored to their specific needs, which is easier with UDP.</p>
</li>
<li><p><strong>Unordered Data Delivery</strong>: For applications where the order of data packets is not critical (e.g., DNS queries), UDP is a better choice as it does not enforce packet ordering.</p>
</li>
</ol>
<h2 id="P-4"><a href="#P-4" class="headerlink" title="P.4"></a>P.4</h2><p><strong>Question:</strong><br>a. Suppose you have the following $2$ bytes: $01011100$ and $01010110$. What is the $1$s complement of the sum of these $2$ bytes?<br>b. Suppose you have the following $2$ bytes: $11011010$ and $00110110$. What is the $1$s complement of the sum of these $2$ bytes?<br>c. For the bytes in part (a), give an example where one bit is flipped in each of the $2$ bytes and yet the $1$s complement doesn’t change.</p>
<p><strong>Answer:</strong></p>
<ul>
<li><strong>a.</strong> $10110010$.</li>
<li><strong>b.</strong> $00010001$.</li>
<li><strong>c.</strong> $01011110$ and $01010100$.</li>
</ul>
<h2 id="P-11"><a href="#P-11" class="headerlink" title="P.11"></a>P.11</h2><p><strong>Question:</strong></p>
<p>The sender side of $\text{rdt}3.0$ simply ignores (that is, takes no action on) all received packets that are either in error or have the wrong value in the acknum field of an acknowledgment packet. Suppose that in such circumstances, $\text{rdt}3.0$ were simply to retransmit the current data packet. Would the protocol still work? (Hint: Consider what would happen if there were only bit errors; there are no packet losses but premature timeouts can occur. Consider how many times the $n^{th}$ packet is sent, in the limit as $n$ approaches infinity.)</p>
<p><strong>Answer:</strong></p>
<p>在这种情况下，rdt $3.0$ 仍然是有效的。首先，该协议接收方可以通过检查 <strong>sequence number</strong> 来判断当前的包是否重复，这个检查方式一直有效。原本的 $\text{rdt}3.0$ 协议在超时后会重传，但现在只要检查出 <strong>acknowledgment packet</strong> 中出错就重传，这显然会增加网络负载，比如：在极端情况下，发送方可能会多次重传一个包，若 ACK 错误率为 $p$，则每个数据包平均需要发送 $1&#x2F;(1-p)$ 次，直到接受到正确的 <strong>ACKs</strong>。总结：$\text{rdt}3.0$ 协议在这种情况下仍然是可靠的，但立即重传错误数据包会导致性能问题，因此这种修改并不是一个好的设计选择。</p>
<h2 id="P-14"><a href="#P-14" class="headerlink" title="P.14"></a>P.14</h2><p><strong>Question:</strong></p>
<p>Consider the cross-country example shown in Figure $3.17$. How big would the window size have to be for the channel utilization to be greater than $95$ percent? Suppose that the size of a packet is $1,500$ bytes, including both header fields and data.</p>
<p><strong>Complement:</strong> $1$ Gbps link. RTT, is approximately $30$ milliseconds.</p>
<p><strong>Answer:</strong></p>
<p>$$<br>\text{d}_{trans} &#x3D; \frac{L}{R} &#x3D; \frac{1500 \times 8}{1 \times 10^9} &#x3D; 1.2 \times 10^{-5} , \text{s}<br>$$</p>
<p>$$<br>\text{Utilization} &#x3D; \frac{\text{rwnd} \times \frac{L}{R}}{\text{RTT} + \text{rwnd} \times \frac{L}{R}} \geq 0.95<br>$$</p>
<p>解得，$\text{rwnd} \geq 4750$。</p>
<h2 id="P-22"><a href="#P-22" class="headerlink" title="P.22"></a>P.22</h2><p><strong>Questions and Answers:</strong></p>
<p>Answer true or false to the following questions and briefly justify your answer:</p>
<p><strong>a. With the SR protocol, it is possible for the sender to receive an ACK for a packet that falls outside of its current window.</strong></p>
<p><strong>True</strong>; 在 <strong>SR</strong> 协议中，由于网络延迟等原因，发送方可能收到对应于已经滑出当前窗口的数据包的 ACK。</p>
<p><strong>b. With GBN, it is possible for the sender to receive an ACK for a packet that falls outside of its current window.</strong></p>
<p><strong>False</strong>; 在 <strong>GBN</strong> 协议中，<strong>ACK</strong> 是累积的，表示所有序列号小于等于 ACK 的包已经被正确接收。</p>
<p><strong>c. The alternating-bit protocol is the same as the SR protocol with a sender and receiver window size of $1$.</strong></p>
<p><strong>True</strong>; 交替位协议是 SR 协议的一个特例，其中发送方和接收方的窗口大小均为 $1$。它只允许发送一个未确认的包，并通过序列号（$0$ 或 $1$）来区分包。</p>
<p><strong>d. The alternating-bit protocol is the same as the GBN protocol with a sender and receiver window size of $1$.</strong></p>
<p><strong>True</strong>; 交替位协议也可以看作是 GBN 协议的一个特例，其中发送方和接收方的窗口大小均为 $1$。在这种情况下，GBN 的行为与交替位协议完全一致，因为它只允许发送一个未确认的包，并在超时或收到 NAK 时重传该包。</p>
<h2 id="P-24"><a href="#P-24" class="headerlink" title="P.24"></a>P.24</h2><p><strong>Questions and Answers:</strong></p>
<p>Consider transferring an enormous file of $L$ bytes from Host A to Host B. Assume an MSS of $536$ bytes.</p>
<p><strong>a. What is the maximum value of $L$ such that TCP sequence numbers are not exhausted? Recall that the TCP sequence number field has $4$ bytes.</strong></p>
<p>TCP segment structure 中 sequence number 有 $32$ bits，从 $0$ 开始。所以最大的 $L &#x3D; 2^{32} - 1$。</p>
<p><strong>b. For the $L$ you obtain in (a), find how long it takes to transmit the file. Assume that a total of $66$ bytes of transport, network, and data-link header are added to each segment before the resulting packet is sent out over a $155$ Mbps link. Ignore flow control and congestion control so A can pump out the segments back to back and continuously.</strong></p>
<ul>
<li>MSS &#x3D; $536$ bytes  </li>
<li>每报文附加头部 &#x3D; $66$ bytes  </li>
<li>总报文尺寸 (536 + 66 &#x3D; 602) bytes  </li>
<li>报文数量<br>$$<br>N &#x3D; \left\lceil \frac{L_{\max}}{\text{MSS}} \right\rceil<br>  &#x3D; \left\lceil \frac{2^{32}-1}{536} \right\rceil<br>  &#x3D; 8,012,999<br>$$</li>
<li>总传输位数<br>$$<br>B &#x3D; N \times 602\ \text{bytes} \times 8\ \tfrac{\text{bits}}{\text{byte}}<br>  &#x3D; 8,012,999 \times 602 \times 8<br>  \approx 3.85906\times 10^{10}\ \text{bits}<br>$$</li>
<li>链路速率 (R &#x3D; 155\ \text{Mbps})  </li>
<li>传输时间<br>$$<br>T &#x3D; \frac{B}{R}<br>  &#x3D; \frac{3.85906\times 10^{10}}{155\times 10^6}<br>  \approx 249\ \text{秒}<br>  \approx 4.15\ \text{分钟}<br>$$</li>
</ul>
<h2 id="P-25"><a href="#P-25" class="headerlink" title="P.25"></a>P.25</h2><p>Host A and B are communicating over a TCP connection, and Host B has already received from A all bytes up through byte $126$. Suppose Host A then sends two segments to Host B back-to-back. The first and second segments contain $70$ and $50$ bytes of data, respectively. In the first segment, the sequence number is $127$, the source port number is $302$, and the destination port number is $80$. Host B sends an acknowledgement whenever it receives a segment from Host A.</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. In the second segment sent from Host A to B, what are the sequence number, source port number, and destination port number?</strong></p>
<ul>
<li>The sequence number is $197$, the source port number is $302$ and the dest port number is $80$.</li>
</ul>
<p><strong>b. If the first segment arrives before the second segment, in the acknowledgement of the first arriving segment, what is the acknowledgment number, the source port number, and the destination port number?</strong></p>
<ul>
<li>The acknowledgement number is $197$, the source port number is $80$ and the dest port number is $302$.</li>
</ul>
<p><strong>c. If the second segment arrives before the first segment, in the acknowledgement of the first arriving segment, what is the acknowledgment number?</strong></p>
<ul>
<li>The acknowledgement number is $127$.</li>
</ul>
<p><strong>d. Suppose the two segments sent by A arrive in order at B. The first acknowledgement is lost and the second acknowledgement arrives after the first timeout interval. Draw a timing diagram, showing these segments and all other segments and acknowledgements sent. (Assume there is no additional packet loss.) For each segment in your figure, provide the sequence number and the number of bytes of data; for each acknowledgement that you add, provide the acknowledgement number.</strong></p>
<ul>
<li>假设：  </li>
<li>A→B 连续发送两段  </li>
<li>B 收到每段即发 ACK  </li>
<li>第一条 ACK(197) 丢失，第二条 ACK(247) 成功到达  </li>
<li>超时重传未触发（因为第二条 ACK 收到后 A 已完成确认）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Time →</span><br><span class="line">Host A                          Host B</span><br><span class="line">  |                                |</span><br><span class="line">  |-- [Seq=127, Len=70] ----------&gt;|   接收 127-196，B 发送 ACK(197) → 丢失</span><br><span class="line">  |                                |</span><br><span class="line">  |-- [Seq=197, Len=50] ----------&gt;|   接收 197-246，B 发送 ACK(247)</span><br><span class="line">  |                                |</span><br><span class="line">  |      [超时等待 ACK(197)]       |</span><br><span class="line">  |                                |</span><br><span class="line">  |-- [Seq=127, Len=70] ----------&gt;|   重复包，B 再次发送 ACK(247)</span><br><span class="line">  |                                |</span><br><span class="line">  |&lt;----------- ACK(247) ----------|   A 收到确认，确认两段都已接收</span><br></pre></td></tr></table></figure>

<h2 id="P-31"><a href="#P-31" class="headerlink" title="P.31"></a>P.31</h2><p><strong>Question and Answer:</strong></p>
<p>What is the relationship between the variable SendBase in Section $3.5.4$ and the variable LastByteRcvd in Section $3.5.5$?</p>
<p>在理想网络条件下（无丢包、延迟较小）：</p>
<p>$$\text{SendBase} - 1 &#x3D; \text{LastByteRcvd}$$</p>
<p>这是因为：</p>
<ul>
<li>接收方接收到字节序号为 n 的数据后，LastByteRcvd &#x3D; n</li>
<li>接收方发送 ACK(n+1)</li>
<li>发送方收到 ACK(n+1) 后，更新 SendBase &#x3D; n+1</li>
</ul>
<p>由于网络延迟、丢包等因素：</p>
<ul>
<li>LastByteRcvd 可能<strong>小于</strong> SendBase-1（发送方已收到更新的确认）</li>
<li>LastByteRcvd 可能<strong>大于</strong> SendBase-1（某些已接收数据未被确认接收）</li>
</ul>
<h2 id="P-32"><a href="#P-32" class="headerlink" title="P.32"></a>P.32</h2><p><strong>Question and Answer:</strong></p>
<p>What is the relationship between the variable $\text{LastByteRcvd}$ in Section $3.5.5$ and the variable $\text{y}$ in Section $3.5.4$?</p>
<p>由上题所述：</p>
<p>$$<br>\text{acknowledgement number} &#x3D; \text{LastByteRcvd} + 1<br>$$</p>
<h2 id="P-34"><a href="#P-34" class="headerlink" title="P.34"></a>P.34</h2><p>Compare GBN, SR, and TCP (no delayed ACK). Assume that the timeout values for all three protocols are sufficiently long such that $5$ consecutive data segments and their corresponding ACKs can be received (if not lost in the channel) by the receiving host (Host B) and the sending host (Host A) respectively. Suppose Host A sends $5$ data segments to Host B, and the $2^{nd}$ segment (sent from A) is lost. In the end, all $5$ data segments have been correctly received by Host B.</p>
<p><strong>Question and Answer:</strong></p>
<p><strong>a. How many segments has Host A sent in total and how many ACKs has Host B sent in total? What are their sequence numbers? Answer this question for all three protocols.</strong></p>
<p>题目没有指定 sequence number，这里默认从 $0$ 开始，所有 segment 大小为 $1$ byte。首先，receiver 收到多少个 segment 就会回多少个 ACK。</p>
<p>首先明确各协议的ACK机制：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th><strong>协议</strong></th>
<th><strong>确认机制</strong></th>
<th><strong>ACK含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>GBN</td>
<td>累积确认</td>
<td>ACK(n)表示期望收到序号n的段</td>
</tr>
<tr>
<td>SR</td>
<td>选择确认</td>
<td>ACK(n)表示已收到序号n的段</td>
</tr>
<tr>
<td>TCP</td>
<td>累积确认+SACK</td>
<td>ACK(n)表示期望收到序号n的段</td>
</tr>
</tbody></table>
</div>

<p>分析 GBN 协议，第一个 segment 的 sequence number 为 $0$，以此类推，接下来的 sequence number 分别为 $1$ $2$ $3$ $4$，相应的 ACK 为 $1$ $2$ $3$ $4$ $5$。但由于第二个包丢失，实际上的 ACK 为 $1$ 丢失 $1$ $1$ $1$， 再重发，$2$ $3$ $4$ $5$。再分析剩下两个协议，最终得到</p>
<div style="display: block; margin: 0 auto; width: fit-content;">

<table>
<thead>
<tr>
<th><strong>Protocol</strong></th>
<th><strong>Segments Sent</strong></th>
<th><strong>ACKs Received</strong></th>
<th><strong>Their Sequence</strong></th>
</tr>
</thead>
<tbody><tr>
<td>GBN</td>
<td>9</td>
<td>8</td>
<td>1 1 1 1 2 3 4 5</td>
</tr>
<tr>
<td>SR</td>
<td>6</td>
<td>5</td>
<td>0 2 3 4 1</td>
</tr>
<tr>
<td>TCP</td>
<td>6</td>
<td>5</td>
<td>1 1 1 1 5</td>
</tr>
</tbody></table>
</div>

<p><strong>b. If the timeout values for all three protocol are much longer than $5$ RTT, then which protocol successfully delivers all five data segments in shortest time interval?</strong></p>
<p>SR 和 TCP，因为这两种协议都只发送了 $6$ 次包。</p>
<h2 id="P-37"><a href="#P-37" class="headerlink" title="P.37"></a>P.37</h2><p><strong>Questions and Answers:</strong></p>
<p><img src="/The-Transport-Layer/TCP%20window%20size%20as%20a%20function%20of%20time.png" alt="TCP window size as a function of time">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p>Assuming TCP <strong>Reno</strong> is the protocol experiencing the behavior shown above, answer the following questions. In all cases, you should provide a short discussion justifying your answer.</p>
<p><strong>a. Identify the intervals of time when TCP slow start is operating.</strong></p>
<p>根据 TCP congestion control 机制，slow start phase 期间 <strong>cwnd</strong> 是以指数函数增长，从图中可以得出大概是在 $\text{Transmission round} \in [1, 6] \cup [23, 26]$ 期间。</p>
<p><strong>b. Identify the intervals of time when TCP congestion avoidance is operating</strong></p>
<p>TCP congestion avoidance 期间的特点是 <strong>cwnd</strong> 以 $ k &#x3D; 1 $ MSS 的速率线性增长，从图中可以得出大概是在 $\text{Transmission round} \in [6, 16] \cup [17, 22]$ 期间。</p>
<p><strong>c. After the 16th transmission round, is segment loss detected by a triple duplicate ACK or by a timeout?</strong></p>
<p>从图中可以分析出，$\text{ssthresh} &#x3D; \frac{\text{cwnd}}{2}$，$\text{cwnd} &#x3D; \text{ssthresh}$，然后线性增长，所以 detected by a triple duplicate ACK。</p>
<p><strong>d. After the 22nd transmission round, is segment loss detected by a triple duplicate ACK or by a timeout?</strong></p>
<p><strong>cwnd</strong> 归一，进入 slow start phase，所以 detected by a timeout。</p>
<p><strong>e. What is the initial value of $\text{ssthresh}$ at the first transmission round?</strong></p>
<p>大概是 $32$ MSS，当 ${\text{cwnd} \geq \text{ssthresh}}$ 会进入 congestion avoidance phase，然后线性增长。</p>
<p><strong>f. What is the value of ssthresh at the $18^{th}$ transmission round?</strong></p>
<p>减半了，所以是，$\text{ssthresh} &#x3D; \frac{\text{cwnd}}{2} &#x3D; 21$ MSS</p>
<p><strong>g. What is the value of ssthresh at the $24^{th}$ transmission round?</strong></p>
<p>减半了，所以是，$\text{ssthresh} &#x3D; \frac{\text{cwnd}}{2} &#x3D; 13$ MSS</p>
<p><strong>h. During what transmission round is the $70^{th}$ segment sent?</strong></p>
<p>第一次 slow start phase 阶段后传了 63 个，所在第 $6$ 和 $7$ 轮之间。</p>
<p><strong>i. Assuming a packet loss is detected after the $26^{th}$ round by the receipt of a triple duplicate ACK, what will be the values of the congestion window size and of ssthresh?</strong></p>
<p>$\text{ssthresh} &#x3D; \frac{\text{cwnd}}{2}$，$\text{cwnd} &#x3D; \text{ssthresh}$，都是 $4$ segment.</p>
<p><strong>j. Suppose TCP Tahoe is used (instead of TCP Reno), and assume that triple duplicate ACKs are received at the $16^{th}$ round. What are the ssthresh and the congestion window size at the $19^{th}$ round?</strong></p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>特性</th>
<th>TCP Tahoe</th>
<th>TCP Reno</th>
</tr>
</thead>
<tbody><tr>
<td><strong>三次重复ACK时</strong></td>
<td>cwnd&#x3D;1MSS, 进入慢启动</td>
<td>cwnd&#x3D;ssthresh, 进入拥塞避免</td>
</tr>
<tr>
<td><strong>超时事件时</strong></td>
<td>cwnd&#x3D;1MSS, 进入慢启动</td>
<td>cwnd&#x3D;1MSS, 进入慢启动</td>
</tr>
<tr>
<td><strong>恢复速度</strong></td>
<td>较慢(需要重新慢启动)</td>
<td>较快(可能直接进入拥塞避免)</td>
</tr>
<tr>
<td><strong>快速恢复机制</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
</div>

<p>第 $16^{th}$ 出现了 triple duplicate ACKs，所以，第 $17^{th}$ $\text{ssthresh} &#x3D; \frac{\text{cwnd}}{2} &#x3D; 21$，$\text{cwnd} &#x3D; 1$，然后进入 slow start 阶段，第 $19^{th}$ $\text{cwnd} &#x3D; 4$</p>
<p><strong>k. Again suppose TCP Tahoe is used, and there is a timeout event at $22^{nd}$ round. How many packets have been sent out from $17^{th}$ round till $22^{nd}$ round, inclusive?</strong></p>
<p>需要注意的是，在第 $16^{th}$ 收到了三个 ACKs，同时，在第 $22^{th}$ 到达 ssthresh 所以实际收到 $1 + 2 + 4 + 8 + 16 + 21 &#x3D; 52$ MSS。</p>
<h2 id="P-43"><a href="#P-43" class="headerlink" title="P.43"></a>P.43</h2><p>Consider that only a single TCP (Reno) connection uses one $10$ Mbps link which does not buffer any data. Suppose that this link is the only congested link between the sending and receiving hosts. Assume that the TCP sender has a huge file to send to the receiver, and the receiver’s receive buffer is much larger than the congestion window. We also make the following assumptions: each TCP segment size is $1,500$ bytes; the two-way propagation delay of this connection is $100$ msec; and this TCP connection <strong>is always in congestion avoidance phase, that is, ignore slow start</strong>.</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. What is the maximum window size (in segments) that this TCP connection can achieve?</strong></p>
<p>最大窗口大小由 <strong>带宽延迟积(BDP)</strong> 决定：</p>
<p>首先计算 RTT：</p>
<ul>
<li>传播延迟 &#x3D; $100$ 毫秒</li>
<li>传输延迟 &#x3D; 段大小&#x2F;带宽 &#x3D; ($1500 \times 8$) 比特&#x2F;($10 \times 10^6$) 比特&#x2F;秒 &#x3D; $1.2$ 毫秒</li>
<li><strong>总RTT</strong> &#x3D; $101.2$ 毫秒</li>
</ul>
<p>带宽延迟积：<br>$$<br>\text{BDP} &#x3D; 10\text{ Mbps} \times 0.1012\text{ s} &#x3D; 1.012 \times 10^6 \text{ bits}<br>$$</p>
<p>也就是 PPT 上的公式：<br>$$<br>\text{rate} \approx \frac{\text{cwnd}}{\text{RTT}}<br>$$</p>
<p>最大窗口大小(段数)：<br>$$<br>\text{最大窗口} &#x3D; \frac{\text{BDP}}{\text{段大小}} &#x3D; \frac{1.012 \times 10^6}{1500 \times 8} \approx 84.33 &#x3D; \boxed{84\text{ 段}}<br>$$</p>
<p><strong>b. What is the average window size (in segments) and average throughput (in bps) of this TCP connection?</strong></p>
<p>根据TCP Reno特性，窗口大小在拥塞避免阶段会在 $\frac{W}{2}$ 和 $W$ 之间周期变化。</p>
<p>平均窗口大小：<br>$$<br>\text{平均窗口} &#x3D; 0.75 \times W &#x3D; 0.75 \times 84 &#x3D; \boxed{63\text{ 段}}<br>$$</p>
<p>平均吞吐量：<br>$$<br>\text{平均吞吐量} &#x3D; 0.75 \times \frac{W \times \text{段大小} \times 8}{\text{RTT}} &#x3D; 0.75 \times \frac{84 \times 1500 \times 8}{0.1012} \approx \boxed{7.5\text{ Mbps}}<br>$$</p>
<p><strong>c. How long would it take for this TCP connection to reach its maximum window again after recovering from a packet loss?</strong></p>
<p>在TCP Reno中，丢包后窗口大小减半，然后每个RTT增加 $1$ 个MSS：</p>
<ul>
<li>初始窗口（丢包后）&#x3D; $\frac{W}{2} &#x3D; 42$ 段</li>
<li>每个RTT增加 $1$ 段</li>
<li>需要增加的段数 &#x3D; $\frac{W}{2} &#x3D; 42$ 段</li>
<li>所需RTT数 &#x3D; $42$</li>
</ul>
<p>$$<br>\text{恢复时间} &#x3D; 42 \times 0.1012 &#x3D; \boxed{4.25\text{ 秒}}<br>$$</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/07/The-Application-Layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/07/The-Application-Layer/" class="post-title-link" itemprop="url">The Application Layer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-07 15:22:34" itemprop="dateCreated datePublished" datetime="2025-06-07T15:22:34+08:00">2025-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-17 10:22:12" itemprop="dateModified" datetime="2025-06-17T10:22:12+08:00">2025-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/" itemprop="url" rel="index"><span itemprop="name">Computer Network</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/Application-Layer/" itemprop="url" rel="index"><span itemprop="name">Application Layer</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Principles-of-network-applications"><a href="#Principles-of-network-applications" class="headerlink" title="Principles of network applications"></a>Principles of network applications</h1><h2 id="Application-architectures"><a href="#Application-architectures" class="headerlink" title="Application architectures"></a>Application architectures</h2><p><strong>Three Kinds:</strong></p>
<ul>
<li>Peer to Peer</li>
<li>Client-Server</li>
<li>hybrid of P2P and Client-Server</li>
</ul>
<h3 id="Client-Server"><a href="#Client-Server" class="headerlink" title="Client-Server"></a>Client-Server</h3><p><strong>Client-Server architecture has following characteristics:</strong></p>
<ul>
<li>Server is <strong>always-on</strong> host;</li>
<li>Server has a <strong>permanent IP address</strong>;</li>
<li>Clients do not communicate with each other directly.</li>
</ul>
<blockquote>
<p>clients 之间通过 server 交流。</p>
</blockquote>
<h3 id="Pure-P2P"><a href="#Pure-P2P" class="headerlink" title="Pure P2P"></a>Pure P2P</h3><p>In <strong>P2P architecture</strong>, there is no always-on server, what’s more, arbitrary end systems communicate directly.</p>
<h3 id="Hybrid-of-Client-Server-and-P2P"><a href="#Hybrid-of-Client-Server-and-P2P" class="headerlink" title="Hybrid of Client-Server and P2P"></a>Hybrid of Client-Server and P2P</h3><p>As the name suggests, this architecture is implemented with Client-Server and P2P.</p>
<p><strong>There are two important instance, Skype and QQ</strong></p>
<ul>
<li><strong>Skype:</strong> a voice-over-IP P2P application. If a host A wants to voice another host B, he will get B’s IP address from a server. And then they communicate with each other directly.</li>
<li><strong>QQ:</strong> a chat-over-IP P2P application.</li>
</ul>
<blockquote>
<p>clients 会给 server 提交自己的 IP address。</p>
</blockquote>
<h4 id="Client-Server-部分"><a href="#Client-Server-部分" class="headerlink" title="Client-Server 部分"></a>Client-Server 部分</h4><ul>
<li>用户登录、查找好友、获取在线状态等操作都需要通过<strong>集中服务器</strong>完成。</li>
<li>服务器维护所有用户的索引和状态信息，起到“中介”作用。</li>
</ul>
<h4 id="P2P-部分"><a href="#P2P-部分" class="headerlink" title="P2P 部分"></a>P2P 部分</h4><ul>
<li>当用户之间需要发送即时消息或文件时，<strong>实际数据传输可以直接在用户之间进行</strong>，不经过服务器。</li>
<li>这样可以减轻服务器压力，提高传输效率。</li>
</ul>
<h2 id="Processes-Communicating"><a href="#Processes-Communicating" class="headerlink" title="Processes Communicating"></a>Processes Communicating</h2><p><strong>Process</strong> is a program controlled by <strong>app developer</strong>, running within a host. Within a same host, two processes communicate with each other by <strong>inter-process communication</strong>. Between two hosts, processes communicate with each other by <strong>exchanging messages</strong>. Generally speaking, there are two kinds of processes, they are <strong>client process</strong> and <strong>server process</strong>. Client process initializes a communication, and server process waits to be contacted.</p>
<h2 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h2><p>A <strong>door</strong> between application layer and transport layer.</p>
<h2 id="Addressing-Processes"><a href="#Addressing-Processes" class="headerlink" title="Addressing Processes"></a>Addressing Processes</h2><p>To receive message, process must have an <strong>identifier</strong>. Identifier includes both <strong>IP address</strong> and <strong>port numbers</strong> associated with process on host.</p>
<h2 id="App-layer-Protocol-Defines"><a href="#App-layer-Protocol-Defines" class="headerlink" title="App-layer Protocol Defines"></a>App-layer Protocol Defines</h2><p><strong>What does an app-layer protocol define?</strong></p>
<ul>
<li>Type of message exchanged;</li>
<li>Message syntax: what fields in messages and how fields are delineated;</li>
<li>Message semantics: meaning of information in fields;</li>
<li>Rules for when and how a process requests and sends messages.</li>
</ul>
<blockquote>
<p>message 类型、语义、语法、传输时间和方式。</p>
</blockquote>
<p>Generally speaking, there are two sorts of app-layer protocols, they <strong>public-domain protocol</strong> and <strong>proprietary protocol</strong>.</p>
<blockquote>
<p>前者公开后者不公开。</p>
</blockquote>
<h2 id="What-transport-service-dose-an-application-need"><a href="#What-transport-service-dose-an-application-need" class="headerlink" title="What transport service dose an application need?"></a>What transport service dose an application need?</h2><p>We can consider four standards to select transport service.</p>
<ul>
<li>data loss</li>
<li>timing</li>
<li>throughput</li>
<li>security</li>
</ul>
<p>下面是常见的应用类型其需要的传输层服务：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th><strong>Application</strong></th>
<th><strong>Data Loss</strong></th>
<th><strong>Throughput</strong></th>
<th><strong>Time Sensitive</strong></th>
</tr>
</thead>
<tbody><tr>
<td>File transfer</td>
<td>No loss</td>
<td>Elastic</td>
<td>No</td>
</tr>
<tr>
<td>E-mail</td>
<td>No loss</td>
<td>Elastic</td>
<td>No</td>
</tr>
<tr>
<td>Web documents</td>
<td>No loss</td>
<td>Elastic</td>
<td>No</td>
</tr>
<tr>
<td>Real-time audio&#x2F;video</td>
<td>Loss-tolerant</td>
<td>Audio: 5kbps-1Mbps<br>Video: 10kbps-5Mbps</td>
<td>Yes, 100’s msec</td>
</tr>
<tr>
<td>Stored audio&#x2F;video</td>
<td>Loss-tolerant</td>
<td>Same as above</td>
<td>Yes, few secs</td>
</tr>
<tr>
<td>Interactive games</td>
<td>Loss-tolerant</td>
<td>Few kbps up</td>
<td>Yes, 100’s msec</td>
</tr>
<tr>
<td>Instant messaging</td>
<td>No loss</td>
<td>Elastic</td>
<td>Yes and no</td>
</tr>
</tbody></table>
</div>

<blockquote>
<p>远程医疗手术系统是 requires no data loss and is highly time-sensitive<br>实际上，在当今互联网中，语音和视频流量经常通过 <strong>TCP</strong> 发送，主要原因是<strong>防火墙和 NAT（网络地址转换）设备的兼容性和穿透性更好</strong>。许多防火墙和 NAT 设备默认只允许 TCP 流量通过，而对 UDP 流量进行限制或直接丢弃。这样做是出于安全性和管理的考虑，因为 TCP 连接有明确的建立和关闭过程，便于追踪和控制，而 UDP 是无连接的，容易被滥用。因此，为了确保语音和视频应用能够在各种网络环境下顺利传输数据，开发者往往选择基于 TCP 协议进行数据传输，即使 UDP 在实时性和低延迟方面更有优势。</p>
</blockquote>
<p>下面是常见的应用类型其需要的应用层、传输层协议：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th><strong>Application</strong></th>
<th><strong>Application Layer Protocol</strong></th>
<th><strong>Underlying Transport Protocol</strong></th>
</tr>
</thead>
<tbody><tr>
<td>E-mail</td>
<td>SMTP [RFC 2821]</td>
<td>TCP</td>
</tr>
<tr>
<td>Remote terminal access</td>
<td>Telnet [RFC 854]</td>
<td>TCP</td>
</tr>
<tr>
<td>Web</td>
<td>HTTP [RFC 2616]</td>
<td>TCP</td>
</tr>
<tr>
<td>File transfer</td>
<td>FTP [RFC 959]</td>
<td>TCP</td>
</tr>
<tr>
<td>Streaming multimedia</td>
<td>HTTP (e.g., YouTube), RTP [RFC 1889]</td>
<td>TCP or UDP</td>
</tr>
<tr>
<td>Internet telephony</td>
<td>SIP, RTP, proprietary (e.g., Skype)</td>
<td>Typically UDP</td>
</tr>
</tbody></table>
</div>

<h1 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h1><p>Web pages consist of some <strong>objects</strong>, each object can be HTML file, Java script and so on. Each object is addressed by a URL, for example, <code>www.someschool.edu/someDept/pic.gif</code>. Among this URL, <code>www.someschool.edu</code> is host name and <code>someDept/pic.gif</code> is path name.</p>
<p><strong>Base HTML-file</strong> is the core of a page. It may includes several referenced objects.</p>
<h2 id="HTTP-Hypertext-Transfer-Protocol"><a href="#HTTP-Hypertext-Transfer-Protocol" class="headerlink" title="HTTP: Hypertext Transfer Protocol"></a>HTTP: Hypertext Transfer Protocol</h2><p><strong>HTTP</strong> is Web’s application protocol with <strong>Client-Server model</strong>. Its transport layer protocol is <strong>TCP</strong>.</p>
<p>HTTP is <strong>stateless</strong>, this means server maintains no information of past clients requests. The reason why protocol that maintains state are complex is that if server or client crashes, their views of “state” may be inconsistent, must be reconciled.</p>
<blockquote>
<p>需要和后文的 cookie 区分开，cookie 并不和 stateless 的性质相违背，原因是：Cookie 只是让状态在客户端和服务器之间传递，而不是让服务器主动维护状态。</p>
</blockquote>
<h3 id="Non-Persistent-HTTP"><a href="#Non-Persistent-HTTP" class="headerlink" title="Non-Persistent HTTP"></a>Non-Persistent HTTP</h3><h4 id="RTT-Round-Trip-Time"><a href="#RTT-Round-Trip-Time" class="headerlink" title="RTT: Round Trip Time"></a>RTT: Round Trip Time</h4><p><img src="/The-Application-Layer/Non-Persistent-HTTP.png" alt="Non Persistent HTTP">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>Definition of $\text{RTT}$:</strong> time for a small packet to travel from client to server and back.</p>
<p>From the picture, we can calculate total time. $\text{total time} &#x3D; 2 \times \text{RTT} + \text{transmit time}_1$</p>
<h3 id="Persistent-HTTP"><a href="#Persistent-HTTP" class="headerlink" title="Persistent HTTP"></a>Persistent HTTP</h3><p>Persistent HTTP leaves <strong>TCP connection open</strong> after sending response. Client sends request as soon as it encounters a referenced object. As little as one RTT for all the referenced objects. $\text{total time} \approx 3 \times \text{RTT} + \text{transmit time}_1 + \text{transmit time}_2$</p>
<h2 id="HTTP-Message"><a href="#HTTP-Message" class="headerlink" title="HTTP Message"></a>HTTP Message</h2><p>Two types of HTTP message: <strong>request</strong> and <strong>response</strong>. <strong>Sent as ASCII text</strong></p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p><img src="/The-Application-Layer/Request-Format.png" alt="alt text">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<ol>
<li><strong>Request Line</strong><ul>
<li><strong>Method:</strong> GET, POST, HEAD; PUT, DELETE;<ul>
<li><strong>POST:</strong> Server decides the path;</li>
<li><strong>PUT:</strong> Client decides the path;</li>
</ul>
</li>
<li><strong>URL:</strong> path;</li>
<li><strong>Version:</strong> HTTP version.</li>
</ul>
</li>
<li><strong>Header Lines</strong><ul>
<li><strong>Host:</strong></li>
<li><strong>User-Agent:</strong></li>
<li><strong>Connection:</strong> keep-alive or close;</li>
<li><strong>Accept-Language:</strong> .</li>
</ul>
</li>
<li><strong>Entity Body:</strong></li>
</ol>
<blockquote>
<p>如果是 keep-alive 则是 persistent connection；如果是 close 则是 non-persistent connection。</p>
</blockquote>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p><img src="/The-Application-Layer/Response-Format.png" alt="Response Format">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>A few sample codes</strong></p>
<ul>
<li><code>200: OK</code></li>
<li><code>301: Moved Permanently</code></li>
<li><code>400: Bad Request</code></li>
<li><code>404: Not Found</code></li>
<li><code>505: HTTP Version Not Supported</code></li>
</ul>
<h2 id="User-Server-State-Cookies"><a href="#User-Server-State-Cookies" class="headerlink" title="User-Server State: Cookies"></a>User-Server State: Cookies</h2><p><strong>How to set cookies and use cookies?</strong><br>When a client first initialize HTTP TCP connection, server will <strong><code>set cookies</code></strong> in response message’s <strong>Header</strong> filed. After that, each request message from same client will take will <strong><code>cookies</code></strong> in request message <strong>HEADER</strong> filed.</p>
<p><strong>What cookies can bring:</strong></p>
<ul>
<li>authorization</li>
<li>shopping carts</li>
<li>recommendations</li>
<li>user session state (Web e-mail)</li>
</ul>
<p>比如：</p>
<ol>
<li>用户访问电商网站 → 服务器分配并下发 <code>user_id</code> Cookie</li>
<li>用户下单 → 浏览器携带 <code>user_id</code> Cookie → 服务器根据 <code>user_id</code> 更新购买记录</li>
<li>用户后续访问 → 服务器通过 Cookie 识别用户，展示其购买历史</li>
</ol>
<h2 id="Web-Caches"><a href="#Web-Caches" class="headerlink" title="Web Caches"></a>Web Caches</h2><p><strong>Goal</strong>: satisfy client request without involving origin server.</p>
<p><img src="/The-Application-Layer/Web-Caches.png" alt="Web Caches">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<blockquote>
<p>typically cache is installed by ISP.</p>
</blockquote>
<p><strong>Why Web caching?</strong></p>
<ul>
<li><strong>reduce response time</strong> for client request</li>
<li><strong>reduce traffic</strong> on an institution’s access link.</li>
<li>Internet dense with caches: enables “poor” content providers to effectively deliver content (but so does P2P file sharing)</li>
</ul>
<h3 id="Conditional-GET"><a href="#Conditional-GET" class="headerlink" title="Conditional GET"></a>Conditional GET</h3><p><strong>Goal:</strong> don’t send object if cache has <strong>up-to-date</strong> cached version</p>
<p><strong>cache:</strong> specify date of cached copy in <strong>HTTP request</strong>: <code>If-modified-since: date</code><br><strong>server:</strong> <strong>response</strong> contains no object if cached copy <code>is up-to-date: HTTP/1.0 304 Not Modified</code></p>
<h1 id="FTP-the-File-Transfer-Protocol"><a href="#FTP-the-File-Transfer-Protocol" class="headerlink" title="FTP: the File Transfer Protocol"></a>FTP: the File Transfer Protocol</h1><p><strong>Goal:</strong> File transfers from&#x2F;to remote host.</p>
<p><img src="/The-Application-Layer/FTP.png" alt="FTP">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p>FTP client contacts FTP server at <strong>port 21</strong>, <strong>TCP</strong> is transport protocol. When server receives <strong>file transfer command</strong>, server opens $2^{nd}$ TCP connection for file to client. After transferring one file, server closes data connection. Server opens another TCP data connection to transfer another file.</p>
<p>这是一种 <strong>out-of-band</strong> 的协议。</p>
<ul>
<li><strong>带外（Out-of-band）</strong> 指的是控制信息和数据内容通过<strong>不同的通道</strong>进行传输，而不是混合在同一个通道中。</li>
</ul>
<h2 id="FTP-Commands-Responses"><a href="#FTP-Commands-Responses" class="headerlink" title="FTP Commands, Responses"></a>FTP Commands, Responses</h2><p>Sent as <strong>ASCII text</strong>, response: <strong>status code and phrase</strong>.</p>
<p><strong>Sample commands:</strong></p>
<ul>
<li><code>USER</code> username;</li>
<li><code>PASS</code> password;</li>
<li><code>LIST</code> return list of file in current directory;</li>
<li><code>RETR</code> filename retrieves (gets) file;</li>
<li><code>STOR</code> filename stores (puts) file onto remote host.</li>
</ul>
<p><strong>Sample return codes:</strong></p>
<ul>
<li><code>331</code> Username OK, password required;</li>
<li><code>125</code> data connection already open; transfer starting;</li>
<li><code>425</code> Can’t open data connection;</li>
<li><code>452</code> Error writing file.</li>
</ul>
<h1 id="Electronic-Mail"><a href="#Electronic-Mail" class="headerlink" title="Electronic Mail"></a>Electronic Mail</h1><p><img src="/The-Application-Layer/e-mail-system.png" alt="e mail system">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>Three Major Components:</strong></p>
<ul>
<li>user agents;</li>
<li>mail servers;</li>
<li>simple mail transfer protocol: SMTP.</li>
</ul>
<p><strong>Mail Server</strong></p>
<ul>
<li><strong>mailbox</strong> contains incoming messages for user;</li>
<li><strong>message queue</strong> of outgoing (to be sent) mail messages</li>
<li>SMTP protocol <strong>between mail servers</strong> to send email messages</li>
</ul>
<h2 id="SMTP-Simple-Mail-Transfer-Protocol"><a href="#SMTP-Simple-Mail-Transfer-Protocol" class="headerlink" title="SMTP: Simple Mail Transfer Protocol"></a>SMTP: Simple Mail Transfer Protocol</h2><p><img src="/The-Application-Layer/SMTP-example.png" alt="SMTP example">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Uses <strong>TCP</strong> to reliably transfer email message from client to server, <strong>port 25</strong>;</li>
<li>Three phases of transfer;<ul>
<li><strong>Handshaking</strong> (Greeting);</li>
<li><strong>Transfer of Messages</strong>;</li>
<li><strong>Closure</strong>.</li>
</ul>
</li>
<li>Command&#x2F;Response interaction;<ul>
<li>Commands: ASCII text;</li>
<li>Response: status code and phrase.</li>
</ul>
</li>
</ul>
<p><strong>What’s more:</strong></p>
<ul>
<li>SMTP uses <strong>persistent connections</strong>;</li>
<li>SMTP requires message (header &amp; body) to be in <strong>7-bit ASCII</strong>;</li>
<li>SMTP server uses <code>CRLF.CRLF</code> to determine end of message.</li>
</ul>
<p><strong>Comparison with HTTP</strong></p>
<ul>
<li>HTTP: pull; SMTP: push</li>
<li>HTTP: each object encapsulated in its own response msg; SMTP: <strong>multiple objects sent in multipart msg</strong>.</li>
</ul>
<h2 id="Mail-Message-Format"><a href="#Mail-Message-Format" class="headerlink" title="Mail Message Format"></a>Mail Message Format</h2><p><img src="/The-Application-Layer/Message-Format.png" alt="Message Format">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<h2 id="Mail-Access-Protocols"><a href="#Mail-Access-Protocols" class="headerlink" title="Mail Access Protocols"></a>Mail Access Protocols</h2><p><img src="/The-Application-Layer/Mail-Access-Protocol.png" alt="Mail Access Protocol">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<ul>
<li>SMTP: <strong>delivery&#x2F;storage</strong> to receiver’s server;</li>
<li>Mail Access Protocol: <strong>retrieval</strong> from server.</li>
</ul>
<h3 id="POP3-Protocol"><a href="#POP3-Protocol" class="headerlink" title="POP3 Protocol"></a>POP3 Protocol</h3><p><img src="/The-Application-Layer/POP3.png" alt="POP3">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>More about POP3:</strong> Previous example uses “download and delete” mode. Bob cannot re-read e-mail if he changes client;<strong>“Download-and-keep”:</strong> copies of messages on different clients; POP3 is stateless across sessions.</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>模式</th>
<th>邮件服务器是否保留邮件</th>
<th>多终端访问体验</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>download-and-delete</td>
<td>否</td>
<td>仅首台设备可见</td>
<td>单一终端、节省空间</td>
</tr>
<tr>
<td>download-and-keep</td>
<td>是</td>
<td>多终端均可访问</td>
<td>多终端、备份安全</td>
</tr>
</tbody></table>
</div>

<h3 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h3><ul>
<li>Keep all messages in one place: <strong>the server</strong>;</li>
<li>Allows user to <strong>organize</strong> messages in folders;</li>
<li>IMAP keeps user state across sessions: names of folders and mappings between message IDs and folder name.</li>
</ul>
<h1 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS: Domain Name System"></a>DNS: Domain Name System</h1><p>组织的 Web 服务器和邮件服务器能否拥有相同的主机别名？对应的 RR 类型是什么？</p>
<p><strong>可以。</strong><br>一个组织的 Web 服务器和邮件服务器完全可以使用同一个主机别名（如 <code>foo.com</code>）。这是因为 DNS 允许为同一个域名设置不同类型的资源记录（Resource Record, RR），分别指向 Web 服务和邮件服务。</p>
<ul>
<li>当用户在浏览器中访问 <code>http://foo.com</code> 时，DNS 查询的是该域名的 <strong>A 记录</strong>（IPv4 地址）或 <strong>AAAA 记录</strong>（IPv6 地址），用于定位 Web 服务器。</li>
<li>当发送邮件到 <code>user@foo.com</code> 时，邮件系统会查询该域名的 <strong>MX 记录</strong>，用于定位邮件服务器。</li>
</ul>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>记录类型</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>域名到 IPv4 地址（Web 服务器）</td>
</tr>
<tr>
<td>MX</td>
<td>域名到邮件服务器主机名（邮件服务）</td>
</tr>
</tbody></table>
</div>

<p><strong>Hostname to IP address translation</strong></p>
<h2 id="Distributed-Hierarchical-Database"><a href="#Distributed-Hierarchical-Database" class="headerlink" title="Distributed, Hierarchical Database"></a>Distributed, Hierarchical Database</h2><p><img src="/The-Application-Layer/DNS-Server.png" alt="alt text">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<h3 id="Top-Level-Domain-TLD-Servers"><a href="#Top-Level-Domain-TLD-Servers" class="headerlink" title="Top-Level Domain (TLD) Servers"></a>Top-Level Domain (TLD) Servers</h3><ul>
<li>Responsible for com, org, net, edu, etc, and all top-level country domains uk, fr, ca, jp;</li>
<li><strong>Network Solutions(a company)</strong> maintains servers for com TLD;</li>
<li><strong>Educause(an institution)</strong> for edu TLD</li>
</ul>
<h3 id="Authoritative-DNS-Servers"><a href="#Authoritative-DNS-Servers" class="headerlink" title="Authoritative DNS Servers"></a>Authoritative DNS Servers</h3><p>Organization’s DNS servers, providing authoritative <strong>hostname to IP mappings</strong> for organization’s servers (e.g., Web, mail). Can be maintained by organization or service provider.</p>
<h3 id="Local-Name-Server"><a href="#Local-Name-Server" class="headerlink" title="Local Name Server"></a>Local Name Server</h3><ul>
<li>Does not strictly belong to hierarchy;</li>
<li>Each <strong>ISP</strong> (residential ISP, company, university) has one;</li>
<li>When host makes DNS query, query is sent to its local DNS server.</li>
</ul>
<h2 id="DNS-Name-Resolution"><a href="#DNS-Name-Resolution" class="headerlink" title="DNS Name Resolution"></a>DNS Name Resolution</h2><h3 id="Iterated-Query"><a href="#Iterated-Query" class="headerlink" title="Iterated Query"></a>Iterated Query</h3><p><img src="/The-Application-Layer/Iterated-Query.png" alt="alt text">{style&#x3D;”display: block; margin: 0 auto; width: 70%”}</p>
<h3 id="Recursive-Query"><a href="#Recursive-Query" class="headerlink" title="Recursive Query"></a>Recursive Query</h3><p><img src="/The-Application-Layer/Recursive-Query.png" alt="alt text">{style&#x3D;”display: block; margin: 0 auto; width: 70%”}</p>
<h2 id="DNS-Caching-and-Updating-Records"><a href="#DNS-Caching-and-Updating-Records" class="headerlink" title="DNS: Caching and Updating Records"></a>DNS: Caching and Updating Records</h2><ul>
<li>Once (any) name server learns mapping, it caches mapping;</li>
<li>Cache entries timeout (disappear) after some time;</li>
<li><strong>TLD servers</strong> typically cached in local name servers. Thus root name servers not often visited.</li>
</ul>
<h3 id="DNS-records"><a href="#DNS-records" class="headerlink" title="DNS records"></a>DNS records</h3><p>DNS: distributed db storing <strong>resource records (RR)</strong>.</p>
<p>RR format: <code>(name, value, type, ttl)</code>.</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th><strong>Type</strong></th>
<th><strong>Name</strong></th>
<th><strong>Value</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>A</strong></td>
<td>Hostname</td>
<td>IP address</td>
<td>Maps hostname to IP address</td>
</tr>
<tr>
<td><strong>NS</strong></td>
<td>Domain (e.g., <code>foo.com</code>)</td>
<td>Hostname of authoritative name server</td>
<td>Specifies authoritative name server for domain</td>
</tr>
<tr>
<td><strong>CNAME</strong></td>
<td>Alias name</td>
<td>Canonical name</td>
<td>Maps alias to canonical (real) name</td>
</tr>
<tr>
<td><strong>MX</strong></td>
<td>Domain name</td>
<td>Mail server name</td>
<td>Specifies mail server associated with domain</td>
</tr>
</tbody></table>
</div>

<h2 id="DNS-Protocol-Messages"><a href="#DNS-Protocol-Messages" class="headerlink" title="DNS Protocol, Messages"></a>DNS Protocol, Messages</h2><p>DNS protocol : <strong>query</strong> and <strong>reply</strong> messages, both with <strong>same message format</strong>.</p>
<p><img src="/The-Application-Layer/DNS-message-format.png" alt="alt text">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>Identification:</strong> 16 bit <code>#</code> for query, reply to query uses same <code>#</code>.</p>
<p><strong>Flags:</strong></p>
<ul>
<li>query or reply;</li>
<li>recursion desired;</li>
<li>recursion available;</li>
<li>reply is authoritative.</li>
</ul>
<h1 id="P2P-applications"><a href="#P2P-applications" class="headerlink" title="P2P applications"></a>P2P applications</h1><h2 id="Pure-P2P-Architecture"><a href="#Pure-P2P-Architecture" class="headerlink" title="Pure P2P Architecture"></a>Pure P2P Architecture</h2><h3 id="File-Distribution-Server-Client-vs-P2P"><a href="#File-Distribution-Server-Client-vs-P2P" class="headerlink" title="File Distribution: Server-Client vs P2P"></a>File Distribution: Server-Client vs P2P</h3><ul>
<li>$u_s$: server upload bandwidth;</li>
<li>$u_i$: peer i upload bandwidth;</li>
<li>$d_i$: peer i download bandwidth;</li>
<li>$F$: file size.</li>
</ul>
<p><strong>Question: How much time to distribute file from one server to $N$ peers?</strong></p>
<p><strong>Answer with Client-Server</strong><br>$$<br>t_{cs} &#x3D; \max \left {\frac{NF}{u_s}, \frac{F}{d_i} \right } \tag{1}<br>$$</p>
<p><strong>Answer with P2P</strong><br>$$<br>t_{p2p} &#x3D; \max \left {\frac{F}{u_s}, \frac{F}{d_i}, \frac{NF}{u_s + \sum_{i} u_i} \right } \tag{2}<br>$$</p>
<h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>基于 <strong>tit-for-tat</strong> （互惠）策略鼓励节点之间公平交换。每个节点会优先向那些<strong>当前向自己上传速度最快的节点</strong>上传数据块。</p>
<p>但是，即使 Alice 在 30 秒内持续向 Bob 上传数据块，Bob 也<strong>不一定会在同一时间段内回馈 Alice</strong>，原因如下：</p>
<ol>
<li><strong>带宽和资源限制</strong>：Bob 可能已经将上传带宽分配给了其他上传速度更快或更优先的 peer。</li>
<li><strong>块的可用性</strong>：Bob 可能没有 Alice 需要的数据块，无法立即回馈。</li>
<li><strong>策略调整延迟</strong>：BitTorrent 的“互惠”是基于一段时间内的统计结果，回馈行为可能会有延迟。</li>
<li><strong>乐善好施（optimistic unchoking）</strong>：每隔一段时间，客户端会随机选择一个 peer 上传数据块，以发现潜在的更优互惠对象，这也可能导致回馈不及时。</li>
</ol>
<p>上述 4. 解决了新加入节点启动问题。</p>
<h3 id="Skype"><a href="#Skype" class="headerlink" title="Skype"></a>Skype</h3><div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>用户查找与登录</td>
<td>通过 P2P 网络分布式存储和查找用户信息</td>
</tr>
<tr>
<td>媒体数据的传输</td>
<td>语音、视频、文件等数据优先点对点传输，必要时通过中继节点转发</td>
</tr>
</tbody></table>
</div>

<h1 id="Socket-programming"><a href="#Socket-programming" class="headerlink" title="Socket programming"></a>Socket programming</h1><p><strong>Goal:</strong> learn how to <strong>build Client-Server application</strong> that communicate using sockets.</p>
<h2 id="Definition-of-Socket"><a href="#Definition-of-Socket" class="headerlink" title="Definition of Socket"></a>Definition of Socket</h2><p><strong>An application-created, OS-controlled interface (a “door”) into which application process can both send and receive messages to&#x2F;from another application process.</strong></p>
<h2 id="Socket-Programming-with-UDP"><a href="#Socket-Programming-with-UDP" class="headerlink" title="Socket Programming with UDP"></a>Socket Programming with UDP</h2><p><img src="/The-Application-Layer/Socket-Programming-with-UDP.png" alt="alt text">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<h3 id="UDPClient-java"><a href="#UDPClient-java" class="headerlink" title="UDPClient.java"></a>UDPClient.java</h3><p><img src="/The-Application-Layer/UDPClient-java.png" alt="alt text">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<h2 id="Socket-programming-with-TCP"><a href="#Socket-programming-with-TCP" class="headerlink" title="Socket programming with TCP"></a>Socket programming with TCP</h2><p><img src="/The-Application-Layer/Socket-Programming-with-TCP.png" alt="alt text">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><img src="/The-Application-Layer/Three-kinds-of-Socket.png" alt="alt text">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><img src="/The-Application-Layer/TCP-Socket.png" alt="alt text">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<h3 id="TCPClient-java"><a href="#TCPClient-java" class="headerlink" title="TCPClient.java"></a>TCPClient.java</h3><p><img src="/The-Application-Layer/TCPClient-java.png" alt="alt text">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<h1 id="End-of-chapter-exercises"><a href="#End-of-chapter-exercises" class="headerlink" title="End-of-chapter exercises"></a>End-of-chapter exercises</h1><h2 id="R-1"><a href="#R-1" class="headerlink" title="R.1"></a>R.1</h2><p>List five nonproprietary Internet applications and the application-layer protocols that they use.</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th align="center"><strong>Type</strong></th>
<th align="center"><strong>Protocol(s)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Email</td>
<td align="center">SMTP, IMAP, POP3</td>
</tr>
<tr>
<td align="center">Web Browser</td>
<td align="center">HTTP</td>
</tr>
<tr>
<td align="center">File Transfer</td>
<td align="center">FTP</td>
</tr>
<tr>
<td align="center">Domain Name Resolution</td>
<td align="center">DNS</td>
</tr>
<tr>
<td align="center">Remote Terminal Access</td>
<td align="center">SSH, Telnet</td>
</tr>
</tbody></table>
</div>

<h2 id="R-2"><a href="#R-2" class="headerlink" title="R.2"></a>R.2</h2><p>What is the difference between network architecture and application architecture?（不太理解这里的 network architecture，默认和 application architecture 一样，都指的是在一个 OSI layer）</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th><strong>Aspect</strong></th>
<th><strong>Network Architecture</strong></th>
<th><strong>Application Architecture</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Definition</strong></td>
<td>Describes the organization of network layers and components for data transmission.</td>
<td>Describes how application components interact to achieve specific functionalities.</td>
</tr>
<tr>
<td><strong>Focus</strong></td>
<td>Focuses on data transmission methods, routing, switching, and protocol stacks.</td>
<td>Focuses on the logical structure and communication patterns of applications.</td>
</tr>
<tr>
<td><strong>Scope</strong></td>
<td>Concerned with the entire network, including physical, data link, and network layers.</td>
<td>Concerned with the application layer and its communication between processes.</td>
</tr>
<tr>
<td><strong>Examples</strong></td>
<td>Virtual circuit networks, datagram networks.</td>
<td>Client-server model, P2P model (e.g., Skype, HTTP).</td>
</tr>
</tbody></table>
</div>

<h2 id="R-6"><a href="#R-6" class="headerlink" title="R.6"></a>R.6</h2><p>Suppose you wanted to do a transaction from a remote client to a server as fast as possible. Would you use UDP or TCP? Why?</p>
<ul>
<li>对于<strong>简单、小型且允许失败的事务</strong>（如状态查询、监控数据上报），可以选择<strong>UDP</strong></li>
<li>对于<strong>大多数商业事务</strong>（如金融交易、数据库操作），应选择<strong>TCP</strong>，因为：<ul>
<li>事务的<strong>完整性和正确性</strong>通常比速度更重要</li>
<li>TCP的<strong>可靠性保障</strong>减少了应用层的复杂度</li>
<li>虽然TCP建立连接有开销，但对于事务的整体成功率和效率更有保障</li>
<li>在现代网络环境中，<strong>TCP连接建立的时延</strong>相对事务处理总时间通常可以接受</li>
</ul>
</li>
<li>但题目要求 <strong>as fast as possible</strong>，所以还是用 <strong>UDP</strong>。</li>
</ul>
<h2 id="R-17"><a href="#R-17" class="headerlink" title="R.17"></a>R.17</h2><p>Print out the header of an e-mail message you have recently received. How many <code>Received:</code> header lines are there? Analyze each of the header lines in the message.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Received: from codeforces.com (mx2.codeforces.com [77.234.215.195])</span><br><span class="line">        by newxmmxszgpub6-1.qq.com (NewMX) with SMTP id BF70781A</span><br><span class="line">        for &lt;1xx575xxxx@qq.com&gt;; Sat, 17 May 2025 00:47:55 +0800</span><br><span class="line">Received: from localhost (gauss.codeforces.com [192.168.10.103])</span><br><span class="line">        by codeforces.com (Postfix) with ESMTP id D7D9F322729C1</span><br><span class="line">        for &lt;1xx575xxxx@qq.com&gt;; Fri, 16 May 2025 18:48:56 +0300 (MSK)</span><br><span class="line">From: &quot;Codeforces@codeforces.com&quot; &lt;Codeforces@codeforces.com&gt;</span><br><span class="line">To: &quot;1xx575xxxx@qq.com&quot; &lt;1xx575xxxx@qq.com&gt;</span><br><span class="line">Subject: Codeforces Round 1025 (Div. 2)</span><br></pre></td></tr></table></figure>

<p>There are $2$ <code>Received:</code> header lines.</p>
<p>The first part is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Received: from codeforces.com (mx2.codeforces.com [77.234.215.195])</span><br><span class="line">        by newxmmxszgpub6-1.qq.com (NewMX) with SMTP id BF70781A</span><br><span class="line">        for &lt;1xx575xxxx@qq.com&gt;; Sat, 17 May 2025 00:47:55 +0800</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Received: from codeforces.com (mx2.codeforces.com [77.234.215.195])</code>: The email was sent from the Codeforces mail server with public IP.</li>
<li><code>by newxmmxszgpub6-1.qq.com (NewMX)</code>: Received by QQ Mail’s mail server.</li>
<li>Using <strong>SMTP</strong> protocol, <code>Date\Time</code>: <code>Sat, 17 May 2025 00:47:55 +0800</code>.</li>
<li>其中的 <code>mx2</code> 指的是 <strong>Mail eXchanger 2</strong>，即 codeforces 的第二台邮件交换 server。</li>
</ul>
<p>The second part is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Received: from localhost (gauss.codeforces.com [192.168.10.103])</span><br><span class="line">        by codeforces.com (Postfix) with ESMTP id D7D9F322729C1</span><br><span class="line">        for &lt;1xx575xxxx@qq.com&gt;; Fri, 16 May 2025 18:48:56 +0300 (MSK)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Received: from localhost (gauss.codeforces.com [192.168.10.103])</code>: The email originated from the local server named <code>gauss.codeforces.com</code> (internal IP).</li>
<li><code>by codeforces.com (Postfix)</code>: Received by the main Codeforces mail server using Postfix.</li>
<li>Using <strong>ESMTP</strong> protocol.</li>
</ul>
<ol>
<li><p><strong>邮件头传输顺序说明</strong>：邮件头按照邮件传输的<strong>相反顺序</strong>排列（最新的记录在最上面）。因此第二个<code>Received</code>行实际上是邮件传输的<strong>起始点</strong>，第一个是<strong>最后一跳</strong>。</p>
</li>
<li><p><strong>时区分析</strong>：注意到两个头部行的时间戳不同:</p>
<ul>
<li>第一个记录: <code>Sat, 17 May 2025 00:47:55 +0800</code>(中国时区)</li>
<li>第二个记录: <code>Fri, 16 May 2025 18:48:56 +0300</code>(莫斯科时区MSK)<br>这说明邮件确实是从俄罗斯发往中国的，时间差符合时区差异。</li>
</ul>
</li>
<li><p><strong>ESMTP vs SMTP的区别</strong>：第二个头部使用ESMTP(扩展SMTP)而不是普通SMTP，这表明使用了更多高级功能(如身份验证、加密等)。</p>
</li>
</ol>
<h2 id="R-22"><a href="#R-22" class="headerlink" title="R.22"></a>R.22</h2><p>What is an overlay network? Does it include routers? What are the edges in the overlay network? How is the query-flooding overlay network created and maintained?</p>
<p>An <strong>overlay network</strong> is a virtual network built on top of an existing physical network. It consists of logical connections (or “edges”) between nodes, which are typically end systems or hosts. These logical connections are established using the underlying physical network infrastructure.</p>
<ul>
<li><p><strong>Does it include routers?</strong><br>No, an overlay network does not include physical routers. Instead, the nodes in the overlay network are typically end systems (e.g., computers, servers) that communicate directly with each other using logical links. The physical routers are part of the underlying network and are not explicitly represented in the overlay.</p>
</li>
<li><p><strong>What are the edges in the overlay network?</strong><br>The edges in an overlay network are logical connections between nodes. These connections are established using the underlying physical network but are abstracted away from the physical topology. For example, in a peer-to-peer (P2P) network, the edges represent direct communication paths between peers.</p>
</li>
<li><p><strong>How is the query-flooding overlay network created and maintained?</strong><br>A query-flooding overlay network is created by connecting nodes in a logical topology where each node knows a subset of other nodes (its neighbors). When a query is initiated, it is broadcasted (or “flooded”) to all neighboring nodes, which in turn forward the query to their neighbors, and so on.<br>Maintenance of the overlay involves:</p>
<ol>
<li><strong>Node discovery:</strong> New nodes join the network by discovering existing nodes and establishing connections.</li>
<li><strong>Topology updates:</strong> Nodes periodically update their neighbor lists to reflect changes in the network (e.g., nodes joining or leaving).</li>
<li><strong>Failure handling:</strong> Mechanisms are implemented to detect and recover from node or connection failures to ensure the overlay remains functional.</li>
</ol>
</li>
</ul>
<h2 id="R-28"><a href="#R-28" class="headerlink" title="R.28"></a>R.28</h2><p>For the client-server application over TCP described in Section $2.7$, why must the server program be executed before the client program? For the clientserver application over UDP described in Section $2.8$, why may the client program be executed before the server program?</p>
<ul>
<li><strong>For the TCP client-server application (Section $2.7$):</strong><br>The server program must be executed before the client because the server needs to create a socket, bind it to a port, and listen for incoming connections. If the client starts first, it will try to connect to the server’s port, but if the server isn’t running and listening yet, the connection will fail.</li>
<li><strong>For the UDP client-server application (Section $2.8$):</strong><br>The client program may be executed before the server because UDP is connectionless. The client can send a datagram to the server’s address and port even if the server isn’t running yet; the datagram may be lost, but the client doesn’t need to establish a connection first. When the server starts, it can immediately receive any new datagrams sent to its port.</li>
</ul>
<h2 id="P-4"><a href="#P-4" class="headerlink" title="P.4"></a>P.4</h2><p>Consider the following string of ASCII characters that were captured by Wireshark when the browser sent an HTTP <code>GET</code> message (i.e., this is the actual content of an HTTP <code>GET</code> message). The characters <code>&lt;cr&gt;&lt;lf&gt;</code> are carriage return and line-feed characters (that is, the italized character string <code>&lt;cr&gt;</code> in the text below represents the single carriage-return character that was contained at that point in the HTTP header). Answer the following questions, indicating where in the HTTP GET message below you find the answer.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /cs453/index.html HTTP/1.1&lt;cr&gt;&lt;lf&gt;Host: gai</span><br><span class="line">a.cs.umass.edu&lt;cr&gt;&lt;lf&gt;User-Agent: Mozilla/5.0 (</span><br><span class="line">Windows;U; Windows NT 5.1; en-US; rv:1.7.2) Gec</span><br><span class="line">ko/20040804 Netscape/7.2 (ax) &lt;cr&gt;&lt;lf&gt;Accept:ex</span><br><span class="line">t/xml, application/xml, application/xhtml+xml, text</span><br><span class="line">/html;q=0.9, text/plain;q=0.8,image/png,*/*;q=0.5</span><br><span class="line">&lt;cr&gt;&lt;lf&gt;Accept-Language: en-us,en;q=0.5&lt;cr&gt;&lt;lf&gt;Accept-</span><br><span class="line">Encoding: zip,deflate&lt;cr&gt;&lt;lf&gt;Accept-Charset: ISO</span><br><span class="line">-8859-1,utf-8;q=0.7,*;q=0.7&lt;cr&gt;&lt;lf&gt;Keep-Alive: 300&lt;cr&gt;</span><br><span class="line">&lt;lf&gt;Connection:keep-alive&lt;cr&gt;&lt;lf&gt;&lt;cr&gt;&lt;lf&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Questions:</strong></p>
<p>a. What is the URL of the document requested by the browser?<br>b. What version of HTTP is the browser running?<br>c. Does the browser request a non-persistent or a persistent connection?<br>d. What is the IP address of the host on which the browser is running?<br>e. What type of browser initiates this message? Why is the browser type needed in an HTTP request message?</p>
<p><strong>Answers:</strong></p>
<p><strong>a. What is the URL of the document requested by the browser?</strong></p>
<ul>
<li><code>http://gaia.cs.umass.edu/cs453/index.html</code>.</li>
</ul>
<p><strong>b. What version of HTTP is the browser running?</strong></p>
<ul>
<li><code>HTTP/1.1</code></li>
</ul>
<p><strong>c. Does the browser request a non-persistent or a persistent connection?</strong></p>
<ul>
<li><code>Connection:keep-alive</code>: a persistent connection.</li>
</ul>
<p><strong>d. What is the IP address of the host on which the browser is running?</strong></p>
<ul>
<li>The IP address of the host is not explicitly provided in the HTTP GET message. It would typically be determined by examining the network layer (IP) headers in the packet capture, which are not included in the provided data.</li>
</ul>
<p><strong>e. What type of browser initiates this message? Why is the browser type needed in an HTTP request message?</strong>  </p>
<ul>
<li>The browser type is <code>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.2) Gecko/20040804 Netscape/7.2 (ax)</code>.  </li>
<li>The browser type is included in the <code>User-Agent</code> header. It is needed in an HTTP request message to allow the server to tailor its response based on the browser’s capabilities, such as supported features, rendering engine, or platform-specific optimizations.</li>
</ul>
<h2 id="P-5"><a href="#P-5" class="headerlink" title="P.5"></a>P.5</h2><p>The text below shows the reply sent from the server in response to the HTTP <code>GET</code> message in the question above. Answer the following questions, indicating where in the message below you find the answer.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK&lt;cr&gt;&lt;lf&gt;Date: Tue, 07 Mar 2008</span><br><span class="line">12:39:45GMT&lt;cr&gt;&lt;lf&gt;Server: Apache/2.0.52 (Fedora)</span><br><span class="line">&lt;cr&gt;&lt;lf&gt;Last-Modified: Sat, 10 Dec2005 18:27:46</span><br><span class="line">GMT&lt;cr&gt;&lt;lf&gt;ETag: &quot;526c3-f22-a88a4c80&quot;&lt;cr&gt;&lt;lf&gt;Accept-</span><br><span class="line">Ranges: bytes&lt;cr&gt;&lt;lf&gt;Content-Length: 3874&lt;cr&gt;&lt;lf&gt;</span><br><span class="line">Keep-Alive: timeout=max=100&lt;cr&gt;&lt;lf&gt;Connection:</span><br><span class="line">Keep-Alive&lt;cr&gt;&lt;lf&gt;Content-Type: text/html; charset=</span><br><span class="line">ISO-8859-1&lt;cr&gt;&lt;lf&gt;&lt;cr&gt;&lt;lf&gt;&lt;!doctype html public &quot;-</span><br><span class="line">//w3c//dtd html 4.0 transitional//en&quot;&gt;&lt;lf&gt;&lt;html&gt;&lt;lf&gt;</span><br><span class="line">&lt;head&gt;&lt;lf&gt; &lt;meta http-equiv=&quot;Content-Type&quot;</span><br><span class="line">content=&quot;text/html; charset=iso-8859-1&quot;&gt;&lt;lf&gt; &lt;meta</span><br><span class="line">name=&quot;GENERATOR&quot; content=&quot;Mozilla/4.79 [en] (Windows NT</span><br><span class="line">5.0; U) Netscape&quot;&gt;&lt;lf&gt; &lt;title&gt;CMPSCI 453 / 591 /</span><br><span class="line">NTU-ST550A Spring 2005 homepage&lt;/title&gt;&lt;lf&gt;&lt;/head&gt;&lt;lf&gt;</span><br><span class="line">&lt;much more document text following here (not shown)&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Questions and Answers:</strong></p>
<p><strong>a. Was the server able to successfully find the document or not? What time was the document reply provided?</strong></p>
<ul>
<li><code>200 OK</code>: successfully find the document; <code>Tue, 07 Mar2008 12:39:45</code></li>
</ul>
<p><strong>b. When was the document last modified?</strong></p>
<ul>
<li><code>Last-Modified: Sat, 10 Dec2005 18:27:46</code></li>
</ul>
<p><strong>c. How many bytes are there in the document being returned?</strong></p>
<ul>
<li><code>Ranges: bytes&lt;cr&gt;&lt;lf&gt;Content-Length: 3874</code>: $3874$ bytes.</li>
</ul>
<p><strong>d. What are the first 5 bytes of the document being returned? Did the server agree to a persistent connection?</strong></p>
<ul>
<li><strong>First 5 bytes of the document:</strong> <code>&lt;!doc</code> (from the document content starting with <code>&lt;!doctype html public...</code>). 所选的 HTTP 报文内容声明了 <code>Content-Type: text/html; charset=ISO-8859-1</code>，该编码是单字节编码（每个字符 1 字节）</li>
<li><strong>Persistent connection:</strong> Yes, the server agreed to a persistent connection as indicated by the header <code>Connection: Keep-Alive</code>.</li>
</ul>
<h2 id="P-9"><a href="#P-9" class="headerlink" title="P.9"></a>P.9</h2><p>Consider Figure $2.12$, for which there is an institutional network connected to the Internet. Suppose that the average object size is $850,000$ bits and that the average request rate from the institution’s browsers to the origin servers is $16$ requests per second. Also suppose that the amount of time it takes from when the router on the Internet side of the access link forwards an HTTP request until it receives the response is $3$ seconds on average (see $\text{Section}$ $2.2.5$). <strong>Model the total average response time as the sum of the average access delay (that is, the delay from Internet router to institution router) and the average Internet delay</strong>. For the average access delay, use $\Delta &#x2F; (1 - \Delta \beta)$, where $\Delta$ is the average time required to send an object over the access link and $\beta$ is the arrival rate of objects to the access link.</p>
<p><strong>Complement:</strong> $15$ Mbps access link and $100$ Mbps LAN.</p>
<p><img src="/The-Application-Layer/Bottleneck%20between%20an%20institutional%20network%20and%20the%20Internet.png" alt="Bottleneck between an institutional network and the Internet">{style&#x3D;”display: block; margin: 0 auto; width: 90%”}</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. Find the total average response time.</strong></p>
<p>The total average response time is the sum of the <strong>average access delay</strong> and the <strong>average Internet delay</strong>.</p>
<ol>
<li><p><strong>Given data:</strong></p>
<ul>
<li>Average object size: $L &#x3D; 850,000$ bits</li>
<li>Access link rate: $R &#x3D; 15$ Mbps</li>
<li>Request rate: $\beta &#x3D; 16$ requests&#x2F;second</li>
<li>Average Internet delay: $3$ seconds</li>
</ul>
</li>
<li><p><strong>Calculate $\Delta$:</strong><br>$$<br>\Delta &#x3D; \frac{L}{R} &#x3D; \frac{850,000}{15 \times 10^6} &#x3D; 0.0567 , \text{seconds}<br>$$</p>
</li>
<li><p><strong>Calculate average access delay:</strong><br>$$<br>\text{Access delay} &#x3D; \frac{\Delta}{1 - \Delta \beta} &#x3D; \frac{0.0567}{1 - (0.0567 \times 16)} &#x3D; \frac{0.0567}{1 - 0.9072} &#x3D; \frac{0.0567}{0.0928} \approx 0.611 , \text{seconds}<br>$$</p>
</li>
<li><p><strong>Total average response time:</strong><br>$$<br>\text{Total response time} &#x3D; \text{Access delay} + \text{Internet delay} &#x3D; 0.611 + 3 &#x3D; 3.611 , \text{seconds}<br>$$</p>
</li>
</ol>
<p><strong>b. Now suppose a cache is installed in the institutional LAN. Suppose the miss rate is $0.4$. Find the total response time.</strong></p>
<ol>
<li><p><strong>Given data:</strong></p>
<ul>
<li>Miss rate: $0.4$</li>
<li>Hit rate: $1 - 0.4 &#x3D; 0.6$</li>
<li>Access delay (from part a): $0.611$ seconds</li>
<li>Internet delay: $3$ seconds</li>
</ul>
</li>
<li><p><strong>Calculate total response time with caching:</strong><br>$$<br>\text{Total response time} &#x3D; (\text{Hit rate} \times \text{Access delay}) + (\text{Miss rate} \times (\text{Access delay} + \text{Internet delay}))<br>$$<br>Substituting values:<br>$$<br>\text{Total response time} &#x3D; 0.6 \times \frac{850000}{100 \times 10^6} + 0.4 \times (0.611 + 3)<br>$$<br>$$<br>\text{Total response time} &#x3D; 0.0051 + 0.4 \times 3.611 &#x3D; 1.4495 , \text{s}<br>$$</p>
</li>
</ol>
<h2 id="P-15"><a href="#P-15" class="headerlink" title="P.15"></a>P.15</h2><p><strong>Question:</strong></p>
<p>Read RFC $5321$ for SMTP. What does MTA stand for? Consider the following received spam email (modified from a real spam email). Assuming only the originator of this spam email is malacious and all other hosts are honest, identify the malacious host that has generated this spam email.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">From - Fri Nov 07 13:41:30 2008</span><br><span class="line">Return-Path: &lt;tennis5@pp33head.com&gt;</span><br><span class="line">Received: from barmail.cs.umass.edu</span><br><span class="line">(barmail.cs.umass.edu [128.119.240.3]) by cs.umass.edu</span><br><span class="line">(8.13.1/8.12.6) for &lt;hg@cs.umass.edu&gt;; Fri, 7 Nov 2008</span><br><span class="line">13:27:10 -0500</span><br><span class="line">Received: from asusus-4b96 (localhost [127.0.0.1]) by</span><br><span class="line">barmail.cs.umass.edu (Spam Firewall) for</span><br><span class="line">&lt;hg@cs.umass.edu&gt;; Fri, 7 Nov 2008 13:27:07 -0500</span><br><span class="line">(EST)</span><br><span class="line">Received: from asusus-4b96 ([58.88.21.177]) by</span><br><span class="line">barmail.cs.umass.edu for &lt;hg@cs.umass.edu&gt;; Fri,</span><br><span class="line">07 Nov 2008 13:27:07 -0500 (EST)</span><br><span class="line">Received: from [58.88.21.177] by</span><br><span class="line">inbnd55.exchangeddd.com; Sat, 8 Nov 2008 01:27:07 +0700</span><br><span class="line">From: &quot;Jonny&quot; &lt;tennis5@pp33head.com&gt;</span><br><span class="line">To: &lt;hg@cs.umass.edu&gt;</span><br><span class="line">Subject: How to secure your savings</span><br></pre></td></tr></table></figure>

<p><strong>Answer:</strong></p>
<p><strong>最底部的 <code>Received:</code> 记录代表邮件的最初来源</strong>，即发件人最初连接的主机。</p>
<ul>
<li><p><strong>What does MTA stand for?</strong><br>MTA stands for <strong>Mail Transfer Agent</strong>. It is a software application used to transfer email messages from one server to another using protocols such as SMTP.</p>
</li>
<li><p><strong>Identify the malicious host:</strong><br>To identify the malicious host, we analyze the <code>Received</code> headers in reverse order (from bottom to top), as each <code>Received</code> header represents a hop in the email’s journey.</p>
<ol>
<li><p><strong><code>Received: from [58.88.21.177] by inbnd55.exchangeddd.com</code></strong>  </p>
<ul>
<li>This indicates that the email originated from the IP address <code>58.88.21.177</code>.</li>
</ul>
</li>
<li><p><strong><code>Received: from asusus-4b96 ([58.88.21.177]) by barmail.cs.umass.edu</code></strong>  </p>
<ul>
<li>This confirms that the email was sent from the same IP address <code>58.88.21.177</code>.</li>
</ul>
</li>
<li><p><strong><code>Received: from asusus-4b96 (localhost [127.0.0.1]) by barmail.cs.umass.edu</code></strong>  </p>
<ul>
<li>This shows that the email passed through a local host (<code>127.0.0.1</code>) on the <code>barmail.cs.umass.edu</code> server.</li>
</ul>
</li>
<li><p><strong><code>Received: from barmail.cs.umass.edu (barmail.cs.umass.edu [128.119.240.3]) by cs.umass.edu</code></strong>  </p>
<ul>
<li>This indicates that the email was forwarded by <code>barmail.cs.umass.edu</code> to <code>cs.umass.edu</code>.</li>
</ul>
</li>
</ol>
<p>Based on the analysis, the <strong>malicious host</strong> is the originator of the email, which is the IP address <strong><code>58.88.21.177</code></strong>. This is the source of the spam email.</p>
</li>
</ul>
<h2 id="P-18"><a href="#P-18" class="headerlink" title="P.18"></a>P.18</h2><p><strong>Questions and Answers:</strong></p>
<p><strong>a. What is a whois database?</strong></p>
<p>A <strong>whois database</strong> is a publicly accessible database that contains information about the registered owners of domain names and IP address blocks. It is maintained by domain registrars and regional internet registries (RIRs). The database provides details such as:</p>
<ul>
<li>The name and contact information of the domain owner or organization.</li>
<li>The domain’s registration and expiration dates.</li>
<li>The domain’s associated name servers.</li>
<li>The registrar responsible for the domain.</li>
</ul>
<p>The <strong>whois database</strong> is commonly used for administrative purposes, such as verifying domain ownership, resolving technical issues, or investigating malicious activities.</p>
<p><strong>b. Use various whois databases on the Internet to obtain the names of two DNS servers. Indicate which whois databases you used.</strong></p>
<p>DNS server 的名字，通常指的是域名形式的主机名。</p>
<p>通过在 <a target="_blank" rel="noopener" href="https://lookup.icann.org/">ICANN Lookup</a> 查询 <code>BiliBili.com</code> 得到其 Nameservers</p>
<ul>
<li><code>NS3.DNSV5.COM</code></li>
<li><code>NS4.DNSV5.COM</code></li>
</ul>
<p>通过在 <a target="_blank" rel="noopener" href="https://whois.domaintools.com/">DomainTools</a> 查询 <code>Baidu.com</code> 得到其 Nameservers</p>
<ul>
<li><code>NS1.BAIDU.COM (has 805 domains)</code></li>
<li><code>NS2.BAIDU.COM (has 805 domains)</code></li>
<li><code>NS3.BAIDU.COM (has 805 domains)</code></li>
<li><code>NS4.BAIDU.COM (has 805 domains)</code></li>
<li><code>NS7.BAIDU.COM (has 805 domains)</code></li>
</ul>
<p><strong>c. Use nslookup on your local host to send DNS queries to three DNS servers: your local DNS server and the two DNS servers you found in part (b). Try querying for Type A, NS, and MX reports. Summarize your findings.</strong></p>
<p>我在终端输入的语句及其显示结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">(base) PS C:\Users\17657\Desktop\Github\HEXO&gt; nslookup</span><br><span class="line">默认服务器:  UnKnown</span><br><span class="line">Address:  10.3.9.5</span><br><span class="line"></span><br><span class="line">&gt; set type=A</span><br><span class="line">&gt; www.baidu.com</span><br><span class="line">服务器:  UnKnown</span><br><span class="line">Address:  10.3.9.5</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    www.a.shifen.com</span><br><span class="line">Addresses:  220.181.111.232</span><br><span class="line">          220.181.111.1</span><br><span class="line">Aliases:  www.baidu.com</span><br><span class="line"></span><br><span class="line">&gt; set type=NS</span><br><span class="line">&gt; baidu.com</span><br><span class="line">服务器:  UnKnown</span><br><span class="line">Address:  10.3.9.5</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">baidu.com       nameserver = ns2.baidu.com</span><br><span class="line">baidu.com       nameserver = ns7.baidu.com</span><br><span class="line">baidu.com       nameserver = ns3.baidu.com</span><br><span class="line">baidu.com       nameserver = dns.baidu.com</span><br><span class="line">baidu.com       nameserver = ns4.baidu.com</span><br><span class="line"></span><br><span class="line">ns2.baidu.com   internet address = 220.181.33.31</span><br><span class="line">ns7.baidu.com   internet address = 180.76.76.92</span><br><span class="line">dns.baidu.com   internet address = 110.242.68.134</span><br><span class="line">ns3.baidu.com   internet address = 36.155.132.78</span><br><span class="line">ns3.baidu.com   internet address = 153.3.238.93</span><br><span class="line">ns4.baidu.com   internet address = 14.215.178.80</span><br><span class="line">ns4.baidu.com   internet address = 111.45.3.226</span><br><span class="line">&gt; set type=MX</span><br><span class="line">&gt; baidu.com</span><br><span class="line">服务器:  UnKnown</span><br><span class="line">Address:  10.3.9.5</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">baidu.com       MX preference = 20, mail exchanger = mx.baidu.com</span><br><span class="line">baidu.com       MX preference = 10, mail exchanger = mx.maillb.baidu.com</span><br><span class="line">&gt; server ns1.baidu.com</span><br><span class="line">默认服务器:  ns1.baidu.com</span><br><span class="line">Address:  110.242.68.134</span><br><span class="line"></span><br><span class="line">&gt; set type=A</span><br><span class="line">&gt; www.baidu.com</span><br><span class="line">服务器:  ns1.baidu.com</span><br><span class="line">Address:  110.242.68.134</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    www.a.shifen.com</span><br><span class="line">Addresses:  220.181.111.1</span><br><span class="line">          220.181.111.232</span><br><span class="line">Aliases:  www.baidu.com</span><br><span class="line"></span><br><span class="line">&gt; set type=NS</span><br><span class="line">&gt; baidu.com</span><br><span class="line">服务器:  ns1.baidu.com</span><br><span class="line">Address:  110.242.68.134</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">baidu.com       nameserver = dns.baidu.com</span><br><span class="line">baidu.com       nameserver = ns3.baidu.com</span><br><span class="line">baidu.com       nameserver = ns4.baidu.com</span><br><span class="line">baidu.com       nameserver = ns2.baidu.com</span><br><span class="line">baidu.com       nameserver = ns7.baidu.com</span><br><span class="line"></span><br><span class="line">ns7.baidu.com   internet address = 180.76.76.92</span><br><span class="line">ns4.baidu.com   internet address = 14.215.178.80</span><br><span class="line">ns4.baidu.com   internet address = 111.45.3.226</span><br><span class="line">ns2.baidu.com   internet address = 220.181.33.31</span><br><span class="line">ns3.baidu.com   internet address = 36.155.132.78</span><br><span class="line">ns3.baidu.com   internet address = 153.3.238.93</span><br><span class="line">dns.baidu.com   internet address = 110.242.68.134</span><br><span class="line">&gt; set type=MX</span><br><span class="line">&gt; baidu.com</span><br><span class="line">服务器:  ns1.baidu.com</span><br><span class="line">Address:  110.242.68.134</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">baidu.com       MX preference = 20, mail exchanger = mx.baidu.com</span><br><span class="line">baidu.com       MX preference = 10, mail exchanger = mx.maillb.baidu.com</span><br><span class="line">&gt; server ns3.dnsv5.com</span><br><span class="line">默认服务器:  ns3.dnsv5.com</span><br><span class="line">Addresses:  1.12.0.18</span><br><span class="line">          1.12.0.17</span><br><span class="line">          43.140.237.52</span><br><span class="line">          111.13.203.52</span><br><span class="line">          36.155.149.211</span><br><span class="line">          101.227.168.52</span><br><span class="line">          220.196.136.52</span><br><span class="line"></span><br><span class="line">&gt; set type=A</span><br><span class="line">&gt; baidu.com</span><br><span class="line">服务器:  ns3.dnsv5.com</span><br><span class="line">Addresses:  1.12.0.18</span><br><span class="line">          1.12.0.17</span><br><span class="line">          43.140.237.52</span><br><span class="line">          111.13.203.52</span><br><span class="line">          36.155.149.211</span><br><span class="line">          101.227.168.52</span><br><span class="line">          220.196.136.52</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    baidu.com</span><br><span class="line">Addresses:  182.61.201.211</span><br><span class="line">          182.61.244.181</span><br><span class="line"></span><br><span class="line">&gt; set type=NS</span><br><span class="line">&gt; baidu.com</span><br><span class="line">服务器:  ns3.dnsv5.com</span><br><span class="line">Addresses:  1.12.0.18</span><br><span class="line">          1.12.0.17</span><br><span class="line">          43.140.237.52</span><br><span class="line">          111.13.203.52</span><br><span class="line">          36.155.149.211</span><br><span class="line">          101.227.168.52</span><br><span class="line">          220.196.136.52</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">baidu.com       nameserver = ns4.baidu.com</span><br><span class="line">baidu.com       nameserver = ns7.baidu.com</span><br><span class="line">baidu.com       nameserver = ns2.baidu.com</span><br><span class="line">baidu.com       nameserver = ns3.baidu.com</span><br><span class="line">baidu.com       nameserver = dns.baidu.com</span><br><span class="line"></span><br><span class="line">ns7.baidu.com   internet address = 180.76.76.92</span><br><span class="line">ns4.baidu.com   internet address = 14.215.178.80</span><br><span class="line">ns4.baidu.com   internet address = 111.45.3.226</span><br><span class="line">ns2.baidu.com   internet address = 220.181.33.31</span><br><span class="line">ns3.baidu.com   internet address = 36.155.132.78</span><br><span class="line">ns3.baidu.com   internet address = 153.3.238.93</span><br><span class="line">dns.baidu.com   internet address = 110.242.68.134</span><br><span class="line">&gt; set type=MX</span><br><span class="line">&gt; baidu.com</span><br><span class="line">服务器:  ns3.dnsv5.com</span><br><span class="line">Addresses:  1.12.0.18</span><br><span class="line">          1.12.0.17</span><br><span class="line">          43.140.237.52</span><br><span class="line">          111.13.203.52</span><br><span class="line">          36.155.149.211</span><br><span class="line">          101.227.168.52</span><br><span class="line">          220.196.136.52</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">baidu.com       MX preference = 10, mail exchanger = mx.maillb.baidu.com</span><br><span class="line">baidu.com       MX preference = 20, mail exchanger = mx.baidu.com</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><code>www.baidu.com</code> 和 <code>baidu.com</code> 不是同一个东西。具体来说后者涵盖范围更广。</li>
<li>一个 Nameserver 能有多个 Internet address。</li>
<li><code>type=A</code> 模式返回的是域名的 IPv4 地址。</li>
<li><code>type=NS</code> 模式返回的是 Nameserver 的名字和其 internet address。</li>
<li><code>type=MS</code> 模式返回的是该域名的邮件服务器主机名及优先级。</li>
</ul>
<p><strong>d. Use nslookup to find a Web server that has multiple IP addresses. Does the Web server of your institution (school or company) have multiple IP addresses?</strong></p>
<p>查询 <code>www.bilibili.com</code> 得到结果如下，其有两个 IP address。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; set type=A </span><br><span class="line">&gt; www.bilibili.com</span><br><span class="line">服务器:  ns3.dnsv5.com</span><br><span class="line">Addresses:  1.12.0.18</span><br><span class="line">          1.12.0.17</span><br><span class="line">          43.140.237.52</span><br><span class="line">          111.13.203.52</span><br><span class="line">          36.155.149.211</span><br><span class="line">          101.227.168.52</span><br><span class="line">          220.196.136.52</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    a.w.bilicdn1.com</span><br><span class="line">Addresses:  121.194.11.73</span><br><span class="line">          121.194.11.72</span><br><span class="line">Aliases:  www.bilibili.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>貌似我们学校的 web server 只有一个 IP Address</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; ucloud.bupt.edu.cn</span><br><span class="line">服务器:  ns3.dnsv5.com</span><br><span class="line">Addresses:  1.12.0.18</span><br><span class="line">          1.12.0.17</span><br><span class="line">          43.140.237.52</span><br><span class="line">          111.13.203.52</span><br><span class="line">          36.155.149.211</span><br><span class="line">          101.227.168.52</span><br><span class="line">          220.196.136.52</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    vn.bupt.edu.cn</span><br><span class="line">Address:  10.3.19.2</span><br><span class="line">Aliases:  ucloud.bupt.edu.cn</span><br><span class="line"></span><br><span class="line">&gt; auth.bupt.edu.cn</span><br><span class="line">服务器:  ns3.dnsv5.com</span><br><span class="line">Addresses:  1.12.0.18</span><br><span class="line">          1.12.0.17</span><br><span class="line">          43.140.237.52</span><br><span class="line">          111.13.203.52</span><br><span class="line">          36.155.149.211</span><br><span class="line">          101.227.168.52</span><br><span class="line">          220.196.136.52</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    vn.bupt.edu.cn</span><br><span class="line">Address:  10.3.19.2</span><br><span class="line">Aliases:  auth.bupt.edu.cn</span><br><span class="line"></span><br><span class="line">&gt; www.bupt.edu.cn</span><br><span class="line">服务器:  ns3.dnsv5.com</span><br><span class="line">Addresses:  1.12.0.18</span><br><span class="line">          1.12.0.17</span><br><span class="line">          43.140.237.52</span><br><span class="line">          111.13.203.52</span><br><span class="line">          36.155.149.211</span><br><span class="line">          101.227.168.52</span><br><span class="line">          220.196.136.52</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    vn46.bupt.edu.cn</span><br><span class="line">Address:  10.3.19.2</span><br><span class="line">Aliases:  www.bupt.edu.cn</span><br></pre></td></tr></table></figure>

<p><strong>e. Use the ARIN whois database to determine the IP address range used by your university.</strong></p>
<p>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nslookup www.bupt.edu.cn</span><br><span class="line">服务器:  UnKnown</span><br><span class="line">Address:  10.3.9.5</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    vn46.bupt.edu.cn</span><br><span class="line">Addresses:  2001:da8:215:4038::161</span><br><span class="line">          10.3.19.2</span><br><span class="line">Aliases:  www.bupt.edu.cn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的 IPv4 地址是子网地址吧？我在 rain 上查询查到了一个美国机构，而且网页也提醒我了 <strong>These addresses are in use by many millions of independently operated networks, which might be as small as a single computer connected to a home gateway, and are automatically configured in hundreds of millions of devices.</strong> 所以我用的是 IPv6 的地址，这个地址能查到，显示：Net Range<br><code>2001:da8:: - 2001:da8:ffff:ffff:ffff:ffff:ffff:ffff</code>。</p>
<p><strong>f. Describe how an attacker can use whois databases and the nslookup tool to perform reconnaissance on an institution before launching an attack.</strong></p>
<p>An attacker 可以用 whois 和 nslookup 干如下的事情：</p>
<ul>
<li><strong>whois 数据库</strong>：公开的域名&#x2F;IP 注册信息数据库，可查询域名所有者、联系方式、DNS 服务器、IP 地址段等信息。</li>
<li><strong>nslookup 工具</strong>：DNS 查询工具，可用来获取域名解析记录（如 A、NS、MX、CNAME 等），进一步了解目标机构的网络结构和服务部署。</li>
</ul>
<p>从而可以：</p>
<ul>
<li>查询目标机构的域名，获取注册人、联系方式、注册商、DNS 服务器、IP 地址段等信息。</li>
<li>通过 whois 查询 IP 地址，了解目标机构的公网 IP 范围、网络归属、可能的子网划分。</li>
<li>利用这些信息，攻击者可以锁定攻击目标、寻找潜在的弱点（如联系邮箱、技术负责人等）。</li>
<li>查询目标机构域名的 A 记录，获取 Web 服务器等主机的 IP 地址。</li>
<li>查询 NS 记录，了解目标机构使用的权威 DNS 服务器，判断是否存在 DNS 攻击面。</li>
<li>查询 MX 记录，获取邮件服务器信息，可能用于钓鱼邮件、垃圾邮件攻击。</li>
<li>查询 CNAME、TXT 等记录，发现隐藏的服务、第三方集成、邮件安全策略等。</li>
<li>通过对不同子域名的批量查询，发现更多内部服务和主机。</li>
</ul>
<p>进而：</p>
<ul>
<li>绘制目标机构的网络拓扑和服务分布图。</li>
<li>寻找潜在的攻击入口（如暴露的服务器、邮件系统、DNS 服务等）。</li>
<li>为后续的漏洞扫描、社工攻击、钓鱼邮件等攻击手段做准备。</li>
</ul>
<p><strong>g. Discuss why whois databases should be publicly available.</strong></p>
<p>whois数据库作为互联网基础设施的重要组成部分，其公开可用性具有多方面的价值与意义：</p>
<ol>
<li><p><strong>互联网透明度与问责制</strong></p>
<ul>
<li>提供域名和IP地址资源的<strong>所有权透明度</strong>，确保资源分配可追溯</li>
<li>建立互联网资源使用的<strong>公开记录</strong>，减少匿名滥用可能性</li>
<li>符合互联网作为<strong>公共资源</strong>的基本属性，保障公众知情权</li>
</ul>
</li>
<li><p><strong>技术协调与故障排除</strong></p>
<ul>
<li>网络管理员能迅速找到<strong>技术联系人</strong>解决网络问题</li>
<li>跨组织网络协作时提供必要的<strong>联络信息</strong></li>
<li>在安全事件、网络中断等紧急情况下提供<strong>快速响应渠道</strong></li>
</ul>
</li>
<li><p><strong>法律与知识产权保护</strong></p>
<ul>
<li>协助<strong>商标持有者</strong>保护其在线知识产权</li>
<li>为<strong>域名争议解决</strong>提供必要的所有权信息</li>
<li>帮助执法机构<strong>打击网络犯罪</strong>和识别不法行为</li>
</ul>
</li>
<li><p><strong>历史与文化因素</strong></p>
<ul>
<li>符合互联网早期建立的<strong>开放共享精神</strong></li>
<li>继承了学术网络环境下的<strong>信任与协作文化</strong></li>
<li>反映了互联网治理中的<strong>多方参与模式</strong></li>
</ul>
</li>
<li><p><strong>安全与风险的平衡</strong></p>
<ul>
<li>虽然公开信息存在被滥用的风险，但<strong>安全通过隐蔽</strong>不是可持续策略</li>
<li>现代whois服务已引入<strong>数据隐私保护机制</strong>（如代理注册服务）</li>
<li>信息公开带来的<strong>集体安全收益</strong>通常超过个体风险</li>
</ul>
</li>
</ol>
<p>总之，whois数据库的公开可用反映了互联网基于<strong>透明、协作和问责</strong>的核心价值观，在保护隐私和维护网络健康运行之间寻求平衡。尽管存在被攻击者利用的风险，但其对互联网正常运行、问题排除和资源管理的价值仍然超过潜在风险。</p>
<h2 id="P-20"><a href="#P-20" class="headerlink" title="P.20"></a>P.20</h2><p><strong>Question and Answer:</strong><br>Suppose you can access the caches in the local DNS servers of your department. Can you propose a way to roughly determine the Web servers (outside your department) that are most popular among the users in your department? Explain.</p>
<p>To determine the most popular external Web servers among the users in my department, I would propose the following method:</p>
<ol>
<li><p><strong>Access the local DNS server’s cache:</strong></p>
<ul>
<li>The local DNS server maintains a cache of recently resolved domain names and their corresponding IP addresses.</li>
<li>By accessing this cache, I can retrieve a list of domain names that users in my department have recently accessed.</li>
</ul>
</li>
<li><p><strong>Filter out internal domain names:</strong></p>
<ul>
<li>Remove any domain names that belong to the local department or organization.</li>
</ul>
</li>
<li><p><strong>Count the frequency of external domain names:</strong></p>
<ul>
<li>For each external domain name in the cache, count how many times it appears.</li>
<li>This will give an estimate of how frequently users in the department access each external Web server.</li>
</ul>
</li>
<li><p><strong>Identify the most popular Web servers:</strong></p>
<ul>
<li>Sort the external domain names by their access frequency.</li>
<li>The domain names with the highest counts represent the most popular external Web servers among the users in the department.</li>
</ul>
</li>
</ol>
<p><strong>Explanation:</strong><br>This method works because the local DNS server’s cache reflects the browsing behavior of users in the department. By analyzing the cache, we can infer which external Web servers are most frequently accessed. However, this method has limitations, as it only provides a rough estimate and may not account for caching mechanisms in user devices or browsers.</p>
<h2 id="P-22"><a href="#P-22" class="headerlink" title="P.22"></a>P.22</h2><p><strong>Question:</strong></p>
<p>Consider distributing a file of $F &#x3D; 15$ Gbits to $N$ peers. The server has an upload rate of $u_s &#x3D; 30$ Mbps, and each peer has a download rate of $d_i &#x3D; 2$ Mbps and an upload rate of $u$. For $N &#x3D; 10$, $100$, and $1,000$ and $u &#x3D; 300$ Kbps, $700$ Kbps, and $2$ Mbps, prepare a chart giving the minimum distribution time for each of the combinations of $N$ and $u$ for both client-server distribution and P2P distribution.</p>
<p><strong>Answer:</strong></p>
<p>To calculate the minimum distribution time for both client-server distribution and P2P distribution, we use the following formulas:</p>
<ol>
<li><p><strong>Client-Server Distribution:</strong><br>$$<br>t_{cs} &#x3D; \max \left{ \frac{N \cdot F}{u_s}, \frac{F}{d_i} \right}<br>$$</p>
</li>
<li><p><strong>P2P Distribution:</strong><br>$$<br>t_{p2p} &#x3D; \max \left{ \frac{F}{u_s}, \frac{F}{d_i}, \frac{N \cdot F}{u_s + \sum_{i} u_i} \right}<br>$$</p>
</li>
</ol>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>$N$</th>
<th>$u , \text{Kbps}$</th>
<th>$t_{cs} , \text{seconds}$</th>
<th>$t_{p2p} , \text{seconds}$</th>
</tr>
</thead>
<tbody><tr>
<td>$10$</td>
<td>$300$</td>
<td>$\max{5000, 7500} &#x3D; 7500$</td>
<td>$\max{500, 7500, 4545} &#x3D; 7500$</td>
</tr>
<tr>
<td>$10$</td>
<td>$700$</td>
<td>$\max{5000, 7500} &#x3D; 7500$</td>
<td>$\max{500, 7500, 4054} &#x3D; 7500$</td>
</tr>
<tr>
<td>$10$</td>
<td>$2,000$</td>
<td>$\max{5000, 7500} &#x3D; 7500$</td>
<td>$\max{500, 7500, 3000} &#x3D; 7500$</td>
</tr>
<tr>
<td>$100$</td>
<td>$300$</td>
<td>$\max{50000, 7500} &#x3D; 50000$</td>
<td>$\max{500, 7500, 25000} &#x3D; 25000$</td>
</tr>
<tr>
<td>$100$</td>
<td>$700$</td>
<td>$\max{50000, 7500} &#x3D; 50000$</td>
<td>$\max{500, 7500, 15000} &#x3D; 15000$</td>
</tr>
<tr>
<td>$100$</td>
<td>$2,000$</td>
<td>$\max{50000, 7500} &#x3D; 50000$</td>
<td>$\max{500, 7500, 6522} &#x3D; 7500$</td>
</tr>
<tr>
<td>$1,000$</td>
<td>$300$</td>
<td>$\max{500000, 7500} &#x3D; 500000$</td>
<td>$\max{500, 7500, 45455} &#x3D; 45455$</td>
</tr>
<tr>
<td>$1,000$</td>
<td>$700$</td>
<td>$\max{500000, 7500} &#x3D; 500000$</td>
<td>$\max{500, 7500, 20548} &#x3D; 20548$</td>
</tr>
<tr>
<td>$1,000$</td>
<td>$2,000$</td>
<td>$\max{500000, 7500} &#x3D; 500000$</td>
<td>$\max{500, 7500, 7389} &#x3D; 7500$</td>
</tr>
</tbody></table>
</div>

<ol>
<li><p>当节点数量<strong>较少</strong>（N&#x3D;10）时，无论使用何种上传速率，<strong>两种分发方式所需时间相同</strong>，均受限于节点的下载速率。</p>
</li>
<li><p>当节点数量<strong>增加</strong>时，客户端-服务器模式的分发时间<strong>显著上升</strong>，而P2P模式在节点上传速率足够高时<strong>效率更高</strong>。</p>
</li>
<li><p>当节点上传速率达到<strong>2 Mbps</strong>时，P2P模式的分发时间在各种节点数下都可以保持在<strong>较低水平</strong>，这显示了P2P架构在大规模分发时的优势。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/05/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/05/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/" class="post-title-link" itemprop="url">统计学习及监督学习概论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-06-05 20:53:05 / 修改时间：21:16:10" itemprop="dateCreated datePublished" datetime="2025-06-05T20:53:05+08:00">2025-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作为《统计学习方法》一书的开篇内容，本文旨在系统梳理统计学习领域中的基本概念与常见问题，为后续章节的深入学习奠定理论基础。</p>
<h2 id="模型评估与选择"><a href="#模型评估与选择" class="headerlink" title="模型评估与选择"></a>模型评估与选择</h2><h3 id="训练误差与测试误差"><a href="#训练误差与测试误差" class="headerlink" title="训练误差与测试误差"></a>训练误差与测试误差</h3><p>一般而言，统计学习方法具体采用的损失函数未必是评估时使用的损失函数。</p>
<p>假设学习到的模型是 $Y &#x3D; \hat{f}(X)$，<strong>训练误差</strong>是模型 $Y &#x3D; \hat{f}(X)$ 关于训练数据集的平局损失：</p>
<p>$$<br>R_{\text{emp}} &#x3D; \frac{1}{N} \sum_{i &#x3D; 1}^{N} L(y_i, \hat{f}(x_i))<br>$$</p>
<p>其中 $N$ 是训练样本容量。</p>
<p><strong>测试误差</strong>是模型 $Y &#x3D; \hat{f}(X)$ 关于测试数据集的平均损失：</p>
<p>$$<br>e_{\text{emp}} &#x3D; \frac{1}{N’} \sum_{i &#x3D; 1}^{N’} L(y_i, \hat{f}(x_i))<br>$$</p>
<p>其中 $N’$ 是测试样本容量。</p>
<p>上面所述中的函数 $L$ 是损失函数。</p>
<p>常见的 $L$ 有指示函数 $I$，当满足函数内容是取 $1$。当损失函数是指示函数时，此时测试误差又叫做<strong>测试误差率</strong>：</p>
<p>$$<br>e_{\text{test}} &#x3D; \frac{1}{N’} \sum_{i &#x3D; 1}^{N’} I(y_i \neq \hat{f}(x_i))<br>$$</p>
<h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p>过拟合是统计学习和机器学习领域中常见且重要的问题之一。它指的是模型在训练数据上表现良好，能够取得较低的训练误差，但在未见过的测试数据或新样本上表现较差，导致<strong>泛化能力下降</strong>的现象。过拟合通常发生在模型复杂度过高、参数数量远大于训练样本数量，或训练过程中对训练数据<strong>记忆</strong>过多而忽略了数据的内在规律时。</p>
<p>造成过拟合的主要原因包括：模型容量过大、训练数据不足、特征冗余或噪声较多等。为缓解过拟合，常用的方法有：增加训练数据量、选择更简单的模型、采用正则化技术（如L1或L2正则化）、剪枝、交叉验证等。合理地控制模型复杂度和提升数据质量，是提升模型泛化能力、避免过拟合的关键。</p>
<h3 id="正则化与交叉验证"><a href="#正则化与交叉验证" class="headerlink" title="正则化与交叉验证"></a>正则化与交叉验证</h3><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><p>正则化是<strong>结构风险最小化策略</strong>的实现，是在<strong>经验风险</strong>上加一个正则化项，一般具有下述形式：</p>
<p>$$<br>\min_{f \in \mathcal{F}} \quad \frac{1}{N} \sum_{i &#x3D; 1}^{N}L(y_i, \hat{f}(x_i)) + \lambda J(f)<br>$$</p>
<h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><p>如果样本数据不足，此时可以应用交叉验证。</p>
<h2 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/04/The-Data-Link-Layer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/04/The-Data-Link-Layer/" class="post-title-link" itemprop="url">The Data Link Layer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-04 15:53:36" itemprop="dateCreated datePublished" datetime="2025-06-04T15:53:36+08:00">2025-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-17 13:04:04" itemprop="dateModified" datetime="2025-06-17T13:04:04+08:00">2025-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/" itemprop="url" rel="index"><span itemprop="name">Computer Network</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Network/Data-Link-Layer/" itemprop="url" rel="index"><span itemprop="name">Data Link Layer</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="交换机网络通信原理解析"><a href="#交换机网络通信原理解析" class="headerlink" title="交换机网络通信原理解析"></a>交换机网络通信原理解析</h1><h2 id="交换机接口MAC地址的实际用途"><a href="#交换机接口MAC地址的实际用途" class="headerlink" title="交换机接口MAC地址的实际用途"></a>交换机接口MAC地址的实际用途</h2><p>交换机每个接口虽有MAC地址，但<strong>并非用于普通数据转发</strong>，而主要用于：</p>
<ul>
<li><strong>管理访问</strong>（Telnet&#x2F;SSH&#x2F;Web界面登录）</li>
<li><strong>协议通信</strong>（STP生成树协议、LLDP等）</li>
<li><strong>故障诊断和监控</strong></li>
</ul>
<h2 id="数据帧如何通过交换机转发"><a href="#数据帧如何通过交换机转发" class="headerlink" title="数据帧如何通过交换机转发"></a>数据帧如何通过交换机转发</h2><p>关键误解在于认为数据帧的目标MAC需要是交换机的MAC。实际上：</p>
<ol>
<li><p><strong>正常帧转发过程</strong>：</p>
<ul>
<li>主机A发送数据到F时，帧中<strong>目标MAC是路由器的MAC</strong>（不是交换机）</li>
<li>交换机收到帧后<strong>不检查”这是否发给我”</strong></li>
<li>交换机仅通过<strong>MAC地址表查询</strong>决定从哪个端口转发出去</li>
</ul>
</li>
<li><p><strong>交换机的核心工作原理</strong>：</p>
<ul>
<li>交换机维护一个<strong>MAC地址表</strong>，记录”哪个MAC地址在哪个端口”</li>
<li>收到帧后，查表找到目标MAC对应端口</li>
<li>从对应端口转发，<strong>不修改帧内容</strong></li>
</ul>
</li>
<li><p><strong>同网段和跨网段通信区别</strong>：</p>
<ul>
<li><strong>同网段</strong>：源MAC→主机A，目标MAC→主机B</li>
<li><strong>跨网段</strong>：源MAC→主机A，目标MAC→<strong>路由器</strong>接口</li>
</ul>
</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>交换机处理所有收到的有效帧，<strong>不会因为目标MAC不是自己而丢弃</strong>。这与路由器不同，路由器只处理目标MAC是自己接口MAC的帧。</p>
<p><strong>正是因为交换机不修改MAC地址并且不以自身MAC为转发判断依据</strong>，才使得以太网能够高效透明地工作。</p>
<h1 id="Introduction-and-Service"><a href="#Introduction-and-Service" class="headerlink" title="Introduction and Service"></a>Introduction and Service</h1><h2 id="Some-terminology"><a href="#Some-terminology" class="headerlink" title="Some terminology"></a>Some terminology</h2><p>我们规定：</p>
<ul>
<li><strong>Nodes</strong>: hosts and routers;</li>
<li><strong>Links</strong>: communication <strong>channels</strong> that connect adjacent nodes along communication path;<ul>
<li>wired links</li>
<li>wireless links</li>
<li>LANs</li>
</ul>
</li>
<li>layer-2 packet is a <strong>frame</strong>, encapsulates datagram.</li>
</ul>
<blockquote>
<p>这里就是在说 data link layer 的数据包叫做 frame。</p>
</blockquote>
<h2 id="Link-layer-context"><a href="#Link-layer-context" class="headerlink" title="Link layer: context"></a>Link layer: context</h2><p>Datagram transferred by different link protocols over different links, each  link protocol provides different services.</p>
<blockquote>
<p>不同的 link 用不同的 protocol。</p>
</blockquote>
<h2 id="Link-Layer-Services"><a href="#Link-Layer-Services" class="headerlink" title="Link Layer Services"></a>Link Layer Services</h2><ul>
<li><strong>framing, link access</strong><ul>
<li>encapsulate datagram into frame, adding header, trailer.</li>
<li>channel access if shared medium.</li>
<li><strong>MAC</strong> addresses used in frame headers to identify source, dest.</li>
</ul>
</li>
<li><strong>reliable delivery between adjacent nodes</strong><ul>
<li>seldom used on low bit-error link (fiber, some twisted pair).</li>
</ul>
</li>
<li><strong>flow control</strong><ul>
<li>pacing between adjacent sending and receiving nodes.</li>
</ul>
</li>
<li><strong>error detection</strong><ul>
<li>errors caused by signal <strong>attenuation, noise</strong>.</li>
<li>receiver detects presence of errors: signals sender for retransmission or drops frame.</li>
</ul>
</li>
<li><strong>error correction</strong><ul>
<li>receiver identifies and <strong>corrects</strong> bit error(s) without resorting to retransmission.</li>
</ul>
</li>
<li><strong>half-duplex and full-duplex</strong>（半双工和全双工）<ul>
<li>with half duplex, nodes at both ends of link can transmit, but not at same time.</li>
</ul>
</li>
</ul>
<h2 id="Where-is-the-link-layer-implemented"><a href="#Where-is-the-link-layer-implemented" class="headerlink" title="Where is the link layer implemented?"></a>Where is the link layer implemented?</h2><ul>
<li>The <strong>link layer is implemented in every host</strong>.</li>
<li>It is realized through an <strong>adaptor</strong>, also known as a <strong>Network Interface Card (NIC)</strong>.<ul>
<li>Examples include: <strong>Ethernet cards</strong>, <strong>PCMCIA cards</strong>, and <strong>802.11 wireless cards</strong>.</li>
</ul>
</li>
<li>The adaptor is responsible for implementing both the <strong>link layer</strong> and the <strong>physical layer</strong>.</li>
<li>It connects to the host via the <strong>system buses</strong>.</li>
<li>The adaptor is a <strong>combination of hardware, software, and firmware</strong>.</li>
</ul>
<p>In essence, the NIC handles the lower layers of network communication and serves as the interface between the host and the physical network.</p>
<p><img src="/The-Data-Link-Layer/Network%20adapter.png" alt="Network adapter">{style&#x3D;”display: block; margin: 0 auto; width: 70%”}</p>
<h2 id="Adaptors-Communicating"><a href="#Adaptors-Communicating" class="headerlink" title="Adaptors Communicating"></a>Adaptors Communicating</h2><p><img src="/The-Data-Link-Layer/AdaptorsCommunicating.png" alt="Adaptors Communicating}">{style&#x3D;”display: block; margin: 0 auto; width: 70%”}</p>
<h3 id="Sending-Side"><a href="#Sending-Side" class="headerlink" title="Sending Side"></a>Sending Side</h3><ul>
<li><strong>Encapsulates the network-layer datagram into a link-layer frame</strong>.</li>
<li><strong>Adds</strong>:<ul>
<li><strong>Error checking bits</strong> (e.g., CRC).</li>
<li><strong>Reliable data transfer (rdt)</strong> mechanisms (if needed).</li>
<li><strong>Flow control</strong> to manage data rate between sender and receiver.</li>
</ul>
</li>
</ul>
<h3 id="Receiving-Side"><a href="#Receiving-Side" class="headerlink" title="Receiving Side"></a>Receiving Side</h3><ul>
<li><strong>Checks</strong> the frame for:<ul>
<li><strong>Errors</strong> using error detection codes.</li>
<li><strong>Reliable data transfer</strong> mechanisms.</li>
<li><strong>Flow control</strong> compliance.</li>
</ul>
</li>
<li><strong>Extracts</strong> the datagram from the frame.</li>
</ul>
<h1 id="Error-Detection-and-Correction"><a href="#Error-Detection-and-Correction" class="headerlink" title="Error Detection and Correction"></a>Error Detection and Correction</h1><p><img src="/The-Data-Link-Layer/Error-detectionAnd-correctionScenario.png" alt="Error detection And correction Scenario">{style&#x3D;”display: block; margin: 0 auto; width: 70%”}</p>
<ul>
<li><p><strong>EDC (Error Detection and Correction bits)</strong>:</p>
<ul>
<li>Extra <strong>redundant bits</strong> added to data to detect and possibly correct errors during transmission.</li>
</ul>
</li>
<li><p><strong>D (Data)</strong>:</p>
<ul>
<li>The actual data being protected by error checking.</li>
<li>May include <strong>header fields</strong> along with the payload.</li>
</ul>
</li>
</ul>
<blockquote>
<p>也就是整个 IP datagram。</p>
</blockquote>
<ul>
<li><strong>Important Notes</strong>:<ul>
<li><strong>Error detection is not 100% reliable</strong>.<ul>
<li>Some errors may go undetected, though this is <strong>rare</strong>.</li>
</ul>
</li>
<li>A <strong>larger EDC field</strong> generally provides:<ul>
<li><strong>Better error detection</strong> capability.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Parity-Checks"><a href="#Parity-Checks" class="headerlink" title="Parity Checks"></a>Parity Checks</h2><ul>
<li><strong>Even Parity Scheme:</strong> the total number of $1$s in the $ d + 1 $ bits is even.</li>
<li><strong>Odd Parity Scheme:</strong> the total number of $1$s in the $ d + 1 $ bits is odd.</li>
</ul>
<blockquote>
<p>偶校验和奇校验。</p>
</blockquote>
<p>If an odd number of $1$-valued bits are found with an even parity schemes, the receiver knows that at least one bit error has occurred.</p>
<h3 id="Two-dimensional-Parity"><a href="#Two-dimensional-Parity" class="headerlink" title="Two-dimensional Parity"></a>Two-dimensional Parity</h3><p>The receiver can thus not only <strong>detect</strong> the fact that a single bit error has occurred, but can use the column and row indices of the column and row with parity errors to actually identify the bit that was corrupted<br>and <strong>correct</strong> that error!</p>
<p><img src="/The-Data-Link-Layer/Two-dimensional-even-parity.png" alt="Two dimensional even parity">{style&#x3D;”display: block; margin: 0 auto; width: 70%”}</p>
<h2 id="Cyclic-Redundancy-Check-CRC"><a href="#Cyclic-Redundancy-Check-CRC" class="headerlink" title="Cyclic Redundancy Check (CRC)"></a>Cyclic Redundancy Check (CRC)</h2><p>An error-detection technique used widely in today’s computer networks is based on <strong>cyclic redundancy check (CRC) codes</strong>. CRC codes are also known as <strong>polynomial codes</strong>, since it is possible to view the bit string to be sent as a polynomial whose coefficients are the $0$ and $1$ values in the bit string, with operations on the bit string interpreted as polynomial arithmetic.</p>
<ul>
<li><strong>数据表示</strong>：将要发送的 $d$ 位数据 $D$ 看作一个二进制多项式。</li>
<li><strong>生成多项式 $G$</strong>：发送方和接收方事先约定一个 $r + 1$ 位的生成多项式 $G$。</li>
<li><strong>附加冗余位 $R$</strong>：发送方为 $D$ 选择 $r$ 位冗余位 $R$，并将其附加到 $D$ 后面，形成 $d + r$ 位的发送数据，使得整个 $d + r$ 位数据能被 $G$ 整除（模 2 运算下）。</li>
</ul>
<h3 id="How-the-Sender-Computes-R"><a href="#How-the-Sender-Computes-R" class="headerlink" title="How the Sender Computes $R$?"></a>How the Sender Computes $R$?</h3><p>简单地来讲：</p>
<ul>
<li>发送方将 $D$ 左移 $r$ 位（即在 $D$ 后面补 $r$ 个 0），得到 $D \cdot 2^r$。</li>
<li>用 $D \cdot 2^r$ 除以 $G$，得到余数 $R$。</li>
<li>将 $R$ 附加到 $D$ 后面，形成最终发送的数据。</li>
</ul>
<p><strong>公式表示：</strong><br>$$<br>R &#x3D; \operatorname{remainder} \frac{D \cdot 2^r}{G}<br>$$</p>
<p><img src="/The-Data-Link-Layer/CRCSample.png" alt="CRC Sample">{style&#x3D;”display: block; margin: 0 auto; width: 70%”}</p>
<p>需要注意，$1 - 0 &#x3D; 1$，$0 - 1 &#x3D; 1$，$1 - 1 &#x3D;0$，$0 - 0 &#x3D; 0$，没有借位，最后的结果，比如：$11$，但是 $r &#x3D; 3$，则在左侧高位补充 $0$，也就是 $R &#x3D; 011$。</p>
<h1 id="Multiple-Access-Links-and-Protocols"><a href="#Multiple-Access-Links-and-Protocols" class="headerlink" title="Multiple Access Links and Protocols"></a>Multiple Access Links and Protocols</h1><h2 id="Two-Types-of-Links"><a href="#Two-Types-of-Links" class="headerlink" title="Two Types of Links"></a>Two Types of Links</h2><h3 id="Point-to-Point-Links"><a href="#Point-to-Point-Links" class="headerlink" title="Point-to-Point Links"></a><strong>Point-to-Point Links</strong></h3><ul>
<li><strong>定义</strong>：点对点链路是指仅有两个设备直接相连的通信链路。</li>
<li><strong>典型例子</strong>：<ul>
<li>拨号上网时使用的 PPP（Point-to-Point Protocol）协议。</li>
<li>以太网交换机与主机之间的连接。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>通信双方唯一，链路专用。</li>
<li>通常无需考虑信道竞争或冲突问题。</li>
<li>实现简单，性能稳定。</li>
</ul>
</li>
</ul>
<h3 id="Broadcast-Links"><a href="#Broadcast-Links" class="headerlink" title="Broadcast Links"></a><strong>Broadcast Links</strong></h3><ul>
<li><strong>定义</strong>：广播链路是指多个设备共享同一个物理通信介质的链路，所有设备都能”听到”同一信道上的数据。</li>
<li><strong>典型例子</strong>：<ul>
<li>早期以太网（同轴电缆共享）。</li>
<li>HFC（Hybrid Fiber-Coaxial）上行链路。</li>
<li>802.11 WiFi（无线局域网）。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>多个节点共享信道，可能发生冲突。</li>
<li>需要多路访问协议（如CSMA&#x2F;CD、ALOHA等）协调各节点的发送时机。</li>
<li>支持广播和组播通信。</li>
</ul>
</li>
</ul>
<h2 id="Multiple-Access-Protocol"><a href="#Multiple-Access-Protocol" class="headerlink" title="Multiple Access Protocol"></a>Multiple Access Protocol</h2><ul>
<li>A <strong>single shared broadcast channel</strong> is used by multiple nodes.<ul>
<li>If two or more nodes transmit at the same time, their signals interfere, causing a <strong>collision</strong>.</li>
</ul>
</li>
<li>A <strong>multiple access protocol</strong> is needed to coordinate transmissions.<ul>
<li>This protocol is a distributed algorithm that determines when each node can transmit.</li>
<li>All coordination and communication about channel sharing must occur over the same channel—there is <strong>no separate control channel</strong>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>多个结点共用一条 channel 进行传输，这条 channel 同一时间只能供一个结点传输。应用 multiple access protocol 来协调。</p>
</blockquote>
<ul>
<li><strong>链路（link）</strong> 更强调<strong>连接关系</strong>，即两个节点之间的直接连接。如上文介绍的两种 <strong>links</strong>。</li>
<li><strong>信道（channel）</strong> 更强调<strong>传输资源</strong>，即数据传输所依赖的物理或逻辑媒介。</li>
<li>在点对点链路中，link 和 channel 通常是一一对应的。</li>
<li>在广播链路中，多个 link（设备间的连接）共享同一个 channel（信道）。</li>
</ul>
<h3 id="Ideal-Multiple-Access-Protocol"><a href="#Ideal-Multiple-Access-Protocol" class="headerlink" title="Ideal Multiple Access Protocol"></a>Ideal Multiple Access Protocol</h3><ul>
<li>The broadcast channel has a total rate of <strong>$R$ bps</strong>.</li>
<li>If only one node transmits, it can use the full rate <strong>$R$</strong>.</li>
<li>If <strong>$M$</strong> nodes transmit simultaneously, each gets an average rate of <strong>$R&#x2F;M$</strong>.</li>
<li>The system is <strong>fully decentralized</strong>:<ul>
<li>No central coordinator.</li>
<li>No clock or slot synchronization required.</li>
</ul>
</li>
<li>The approach is simple and efficient for sharing the channel.</li>
</ul>
<h2 id="MAC-Protocols-a-taxonomy"><a href="#MAC-Protocols-a-taxonomy" class="headerlink" title="MAC Protocols: a taxonomy"></a>MAC Protocols: a taxonomy</h2><h3 id="Three-Broad-Classes-of-MAC-Protocols"><a href="#Three-Broad-Classes-of-MAC-Protocols" class="headerlink" title="Three Broad Classes of MAC Protocols"></a>Three Broad Classes of MAC Protocols</h3><ol>
<li><p><strong>Channel Partitioning</strong></p>
<ul>
<li>The channel is divided into smaller pieces (such as time slots, frequency bands, or codes).</li>
<li>Each node is allocated a piece for exclusive use.</li>
</ul>
</li>
<li><p><strong>Random Access</strong></p>
<ul>
<li>The channel is not divided; all nodes can transmit at any time.</li>
<li>Collisions may occur, but protocols are designed to <strong>detect and recover</strong> from collisions.</li>
</ul>
</li>
<li><p><strong>Taking Turns</strong></p>
<ul>
<li>Nodes take turns using the channel.</li>
<li>Nodes with more data to send can take longer turns.</li>
</ul>
</li>
</ol>
<h2 id="Channel-Partitioning-Protocols"><a href="#Channel-Partitioning-Protocols" class="headerlink" title="Channel Partitioning Protocols"></a>Channel Partitioning Protocols</h2><p><strong>TDMA</strong>: Time Division Multiple Access<br><strong>FDMA</strong>: Frequency Division Multiple Access<br><strong>CDMA</strong>: Code Division Multiple Access</p>
<h3 id="TDMA"><a href="#TDMA" class="headerlink" title="TDMA"></a>TDMA</h3><ul>
<li><strong>Mechanism:</strong>  <ul>
<li>Divides time into frames, and each frame into $N$ time slots (for $N$ nodes).</li>
<li>Each node is assigned a specific time slot in each frame.</li>
<li>When a node has data to send, it transmits only during its assigned slot.</li>
</ul>
</li>
<li><strong>Example:</strong>  <ul>
<li>In a four-node TDMA system, each node gets one slot per frame, and the slots repeat in a fixed order.</li>
</ul>
</li>
<li><strong>Advantages:</strong>  <ul>
<li>No collisions; perfectly fair (each node gets $R&#x2F;N$ bps).</li>
</ul>
</li>
<li><strong>Drawbacks:</strong>  <ul>
<li>Each node is limited to $R&#x2F;N$ bps even if others are idle.</li>
<li>Nodes must wait for their turn, even if they are the only one with data to send.</li>
</ul>
</li>
</ul>
<blockquote>
<p>只能用自己的。</p>
</blockquote>
<h3 id="FDMA"><a href="#FDMA" class="headerlink" title="FDMA"></a>FDMA</h3><ul>
<li><strong>Mechanism:</strong>  <ul>
<li>Divides the total channel bandwidth ($R$ bps) into $N$ frequency bands, each with bandwidth $R&#x2F;N$.</li>
<li>Each node is assigned a <strong>unique frequency band</strong> for exclusive use.</li>
</ul>
</li>
<li><strong>Example:</strong>  <ul>
<li>In a four-node FDM system, each node gets a $4$ KHz band out of a total $16$ KHz channel.</li>
</ul>
</li>
<li><strong>Advantages:</strong>  <ul>
<li>No collisions; fair bandwidth allocation.</li>
</ul>
</li>
<li><strong>Drawbacks:</strong>  <ul>
<li>Each node is limited to R&#x2F;N bps, even if others are idle (same as TDMA).</li>
</ul>
</li>
</ul>
<p><img src="/The-Data-Link-Layer/TDA-and-FDA-example.png" alt="TDA and FDA example">{style&#x3D;”display: block; margin: 0 auto; width: 70%”}</p>
<h3 id="CDMA"><a href="#CDMA" class="headerlink" title="CDMA"></a>CDMA</h3><ul>
<li><strong>Mechanism:</strong>  <ul>
<li>Each node is assigned a unique code.</li>
<li>Nodes encode their data using their code and transmit simultaneously over the same channel.</li>
<li>Receivers use the sender’s code to decode the intended message, even in the presence of other transmissions.</li>
</ul>
</li>
<li><strong>Features:</strong>  <ul>
<li>Allows multiple nodes to transmit at the same time without collisions, as long as codes are chosen carefully.</li>
<li>Widely used in wireless and cellular networks due to its anti-jamming properties.</li>
</ul>
</li>
<li><strong>Note:</strong>  <ul>
<li>CDMA codes serve a similar role as time slots in TDMA and frequency bands in FDMA, enabling multiple access to the channel.</li>
</ul>
</li>
</ul>
<blockquote>
<p>每个节点分配一个唯一的编码，所有节点可同时发送，接收端用对应的码提取目标信号。详细过程参考第六章。</p>
</blockquote>
<h2 id="Random-Access-Protocols"><a href="#Random-Access-Protocols" class="headerlink" title="Random Access Protocols"></a>Random Access Protocols</h2><ul>
<li>When a node has a packet to send, it transmits at the full channel data rate $\mathbf{R}$.</li>
<li>There is <strong>no prior coordination</strong> among nodes before transmission.（也就是说这个结点传输前不会考虑其它因素）</li>
<li>If two or more nodes transmit at the same time, a <strong>collision</strong> occurs.</li>
<li>A <strong>random access MAC protocol</strong> defines:（干了两件事）<ul>
<li><strong>How to detect collisions</strong>.</li>
<li><strong>How to recover from collisions (e.g., by delaying and retransmitting)</strong>.（后传和重传）</li>
<li><strong>Examples:</strong>  <ul>
<li>Slotted ALOHA  </li>
<li>ALOHA  </li>
<li>CSMA, CSMA&#x2F;CD, CSMA&#x2F;CA</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Slotted-ALOHA"><a href="#Slotted-ALOHA" class="headerlink" title="Slotted ALOHA"></a>Slotted ALOHA</h3><p><strong>Assumptions:</strong></p>
<ul>
<li>All frames are the same size.</li>
<li>Time is divided into equal-sized slots (each slot &#x3D; time to transmit one frame).</li>
<li>Nodes can only begin transmission at the start of a slot.</li>
<li>All nodes are synchronized.</li>
<li>If two or more nodes transmit in the same slot, a collision occurs and is detected by all.</li>
</ul>
<p><strong>Operation:</strong></p>
<ul>
<li>When a node has a new frame, it transmits in the next available slot.</li>
<li>If there is no collision, the node can send a new frame in the next slot.</li>
<li>If a collision occurs, the node retransmits the frame in each subsequent slot with probability $p$ until successful.</li>
</ul>
<p><strong>Pros of Slotted ALOHA:</strong></p>
<ul>
<li>A single active node can continuously transmit at the full channel rate.</li>
<li>Highly decentralized; only slot synchronization among nodes is needed.</li>
<li>Simple to implement.</li>
</ul>
<p><strong>Cons of Slotted ALOHA:</strong></p>
<ul>
<li>Collisions can occur, wasting slots.</li>
<li>Idle slots may occur, reducing efficiency.</li>
<li><strong>Nodes may detect collisions before a full packet is transmitted</strong>.</li>
<li><strong>Requires clock synchronization among all nodes</strong>.</li>
</ul>
<blockquote>
<p>前提假设不太现实，要求所有的 frame 大小相同，这样才能确保将时间分为等长的时隙有用。</p>
</blockquote>
<p><strong>同步(synchronize)</strong> 指的是：</p>
<ul>
<li>所有网络节点<strong>共享一个统一的时钟参考</strong></li>
<li>每个节点能够<strong>准确识别时隙的开始和结束时刻</strong></li>
<li>通常通过<strong>集中式时钟信号</strong>或<strong>同步协议</strong>实现</li>
</ul>
<p><strong>Slotted Aloha efficiency</strong></p>
<ul>
<li><strong>Efficiency</strong> is defined as the long-run fraction of slots that contain a successful transmission (i.e., exactly one node transmits).</li>
<li>Suppose there are $N$ nodes, each always has frames to send, and each transmits in a slot with probability $p$.</li>
<li>The probability that a given node has a successful transmission in a slot:<br>$$p(1-p)^{N-1}$$</li>
<li>The probability that any node has a successful transmission in a slot:<br>$$Np(1-p)^{N-1}$$</li>
<li><strong>Maximum efficiency</strong> is achieved by choosing $p^*$ that maximizes $Np(1-p)^{N-1}$.</li>
<li>As $N$ becomes very large, the maximum efficiency approaches:<br>$$\boxed{1&#x2F;e \approx 0.37}$$</li>
<li><strong>Interpretation:</strong><br>At best, the channel is used for successful transmissions only 37% of the time.</li>
</ul>
<blockquote>
<p>当前时隙有结点传输的概率。</p>
</blockquote>
<h1 id="TDMA与Slotted-ALOHA对比分析"><a href="#TDMA与Slotted-ALOHA对比分析" class="headerlink" title="TDMA与Slotted ALOHA对比分析"></a>TDMA与Slotted ALOHA对比分析</h1><p><strong>TDMA和Slotted ALOHA并不矛盾，它们是两种不同设计理念的多址接入协议</strong>，尽管都使用了时间分片的概念。</p>
<h2 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h2><div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>特性</th>
<th>TDMA</th>
<th>Slotted ALOHA</th>
</tr>
</thead>
<tbody><tr>
<td><strong>时隙分配</strong></td>
<td><strong>预先固定分配</strong>给特定节点</td>
<td><strong>动态竞争</strong>，任何节点可使用任何时隙</td>
</tr>
<tr>
<td><strong>传输决策</strong></td>
<td>只能在<strong>自己的专属时隙</strong>中传输</td>
<td>可以在<strong>任何时隙</strong>开始传输</td>
</tr>
<tr>
<td><strong>冲突可能性</strong></td>
<td><strong>无冲突</strong>（每个时隙专属一个节点）</td>
<td><strong>有冲突</strong>（多节点可能同时选择一个时隙）</td>
</tr>
<tr>
<td><strong>资源使用</strong></td>
<td>节点不传输时其时隙<strong>浪费</strong></td>
<td>任何节点都可以利用空闲时隙</td>
</tr>
<tr>
<td><strong>控制方式</strong></td>
<td><strong>集中式</strong>或预先协调</td>
<td><strong>分散式</strong>（各节点独立决策）</td>
</tr>
<tr>
<td><strong>最大效率</strong></td>
<td>理论上100%（无冲突）</td>
<td>理论上约37%（1&#x2F;e）</td>
</tr>
</tbody></table>
</div>

<h2 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h2><ul>
<li><p><strong>TDMA</strong>：<strong>预分配固定时隙</strong>的”预约”系统</p>
<ul>
<li>类似于餐厅固定座位：每人只能坐自己的座位</li>
<li>优点：无冲突，确定性高</li>
<li>缺点：资源可能浪费，缺乏灵活性</li>
</ul>
</li>
<li><p><strong>Slotted ALOHA</strong>：<strong>随机竞争时隙</strong>的”抢座”系统</p>
<ul>
<li>类似于餐厅先到先得：谁想坐就尝试坐，有冲突就重试</li>
<li>优点：简单实现，适应突发流量</li>
<li>缺点：存在冲突，效率有限</li>
</ul>
</li>
</ul>
<p>这两种协议代表了多址接入的两种不同设计思路：<strong>静态分配</strong>与<strong>动态竞争</strong>，各有优缺点，适用于不同应用场景。</p>
<h3 id="Pure-unslotted-ALOHA"><a href="#Pure-unslotted-ALOHA" class="headerlink" title="Pure (unslotted) ALOHA"></a>Pure (unslotted) ALOHA</h3><p><img src="/The-Data-Link-Layer/pure-ALOHA-sample.png" alt="pure ALOHA sample">{style&#x3D;”display: block; margin: 0 auto; width: 70%”}</p>
<ul>
<li>Simpler than slotted ALOHA; <strong>no synchronization</strong> required.</li>
<li>When a frame arrives, the node <strong>transmits immediately</strong>.</li>
<li><strong>Higher collision probability</strong>:  <ul>
<li>A frame sent at time $t_0$ will collide with any other frame sent in the interval $[t_0-1, t_0+1]$.</li>
</ul>
</li>
</ul>
<p><strong>Pure (Unslotted) ALOHA Efficiency:</strong></p>
<ul>
<li>Probability of success for a given node:<ul>
<li>$P(\text{success}) &#x3D; P(\text{node transmits}) \times P(\text{no other node transmits in } [t_0-1, t_0]) \times P(\text{no other node transmits in } [t_0, t_0+1])$</li>
<li>$&#x3D; p \cdot (1-p)^{N-1} \cdot (1-p)^{N-1}$</li>
<li>$&#x3D; p \cdot (1-p)^{2(N-1)}$</li>
</ul>
</li>
<li><strong>Maximum efficiency</strong> (choosing optimal $p$ and letting $N \to \infty$):<ul>
<li>$\boxed{1&#x2F;(2e) \approx 0.18}$</li>
</ul>
</li>
<li><strong>Interpretation:</strong><br>At best, the channel is used for successful transmissions only 18% of the time in pure ALOHA.</li>
</ul>
<blockquote>
<p>$t_0, , t_0 - 1, , t_0 + 1$ 三个时隙。</p>
</blockquote>
<h3 id="Carrier-Sense-Multiple-Access-CSMA"><a href="#Carrier-Sense-Multiple-Access-CSMA" class="headerlink" title="Carrier Sense Multiple Access (CSMA)"></a>Carrier Sense Multiple Access (CSMA)</h3><p>发送前先侦听，发送时检测碰撞，以太网核心技术</p>
<p><strong>Carrier Sensing</strong>: a node listens to the channel before transmitting. <strong>If a frame from another node is currently being transmitted into the channel</strong>, a node then waits until it detects no transmissions for a short amount of time and then begins transmission.</p>
<p>In networks using CSMA (like <strong>traditional Ethernet or wireless</strong>), all nodes communicate over a single shared physical channel. Many network interfaces operating under CSMA protocols are designed for half-duplex communication, meaning they can either transmit OR receive at any given moment, but not both simultaneously. This is why a node can not transmit while receiving.</p>
<blockquote>
<p>半双工机制。</p>
</blockquote>
<h3 id="CSMA-with-collision-detection-CSMA-CD"><a href="#CSMA-with-collision-detection-CSMA-CD" class="headerlink" title="CSMA with collision detection (CSMA&#x2F;CD)"></a>CSMA with collision detection (CSMA&#x2F;CD)</h3><p><strong>Collision Detection</strong>: a transmitting node listens to the channel while it is transmitting. If it detects that another node is transmitting an interfering frame, it stops transmitting and waits <strong>a random amount</strong> of time before repeating the sense-and-transmit-when-idle cycle.</p>
<blockquote>
<p>自己正在传的时候检测到有其他结点开始传了，停止自己的传输，随机等待一段时间后重试。</p>
</blockquote>
<h2 id="Taking-Turns-Protocols"><a href="#Taking-Turns-Protocols" class="headerlink" title="Taking-Turns Protocols"></a>Taking-Turns Protocols</h2><h3 id="Polling-Protocol"><a href="#Polling-Protocol" class="headerlink" title="Polling Protocol"></a>Polling Protocol</h3><p><strong>Polling Protocol（轮询协议）<strong>是一种</strong>轮流访问</strong>型的多路访问协议，常用于多个节点共享同一信道的场景。其核心思想是：  </p>
<ul>
<li>网络中指定一个节点为<strong>主节点（master node）</strong>。</li>
<li>主节点按照固定顺序依次<strong>轮询</strong>每个从节点，询问它们是否有数据要发送。</li>
<li>只有被轮询到的节点才被允许发送数据。</li>
</ul>
<p>这个协议有着如下缺陷：</p>
<ol>
<li><strong>轮询延迟</strong>：每个节点都要等主节点轮询到自己才能发送数据，可能会有等待延迟，尤其是节点数量多时。</li>
<li><strong>主节点单点故障</strong>：如果主节点出现故障，整个信道就无法正常工作，所有通信都会中断。</li>
</ol>
<p><em><strong>Bluetooth protocol</strong></em></p>
<h3 id="Token-Passing-Protocol"><a href="#Token-Passing-Protocol" class="headerlink" title="Token-Passing Protocol"></a>Token-Passing Protocol</h3><p>A small, special-purpose frame known as a <strong>token</strong> is exchanged among the nodes in some fixed order.</p>
<blockquote>
<p>When a node receives a token, it holds onto the token only if it has some frames to transmit; otherwise, it immediately forwards the token to the next node. If a node does have frames to transmit when it receives the token, it sends up to a maximum number of frames and then forwards the token to the next node.</p>
</blockquote>
<p>But it has its problems as well. For example, the failure of one node can crash the entire channel. Or if a node accidentally neglects to release the token, then some recovery procedure must be invoked to get the token back in circulation.</p>
<p>将一个特制的 <strong>frame</strong> 视作一个 <strong>token</strong>，这个 token 会在结点中以一个固定的顺序传输，收到 token 的结点可以选择发送自己的 frames 或者立即传给下一个结点。缺陷：时延和崩坏。</p>
<p><em><strong>fiber distributed data interface (FDDI) protocol</strong></em></p>
<h1 id="Link-Layer-Addressing-and-ARP"><a href="#Link-Layer-Addressing-and-ARP" class="headerlink" title="Link-Layer Addressing and ARP"></a>Link-Layer Addressing and ARP</h1><h2 id="Addressing-in-Computer-Networks"><a href="#Addressing-in-Computer-Networks" class="headerlink" title="Addressing in Computer Networks"></a>Addressing in Computer Networks</h2><p>先回顾一下之前学过的 address。</p>
<h3 id="IP-Address-32-bit"><a href="#IP-Address-32-bit" class="headerlink" title="IP Address (32-bit)"></a>IP Address (32-bit)</h3><ul>
<li><strong>Layer</strong>: Network layer address</li>
<li><strong>Primary function</strong>: Used to route datagrams to their destination IP subnet</li>
<li><strong>Scope</strong>: Global addressing for internet-wide routing</li>
</ul>
<h3 id="MAC-Address-48-bit"><a href="#MAC-Address-48-bit" class="headerlink" title="MAC Address (48-bit)"></a>MAC Address (48-bit)</h3><ul>
<li><strong>Layer</strong>: Data link layer (physical addressing)</li>
<li><strong>Primary function</strong>: Used to transfer frames between directly connected interfaces on the same physical network</li>
<li><strong>Implementation</strong>: Permanently burned into NIC ROM hardware, though sometimes software-configurable</li>
<li><strong>Scope</strong>: Local addressing limited to a single network segment</li>
</ul>
<p>The fundamental distinction is that IP addresses enable routing across multiple networks, while MAC addresses handle the physical delivery between devices on the same network segment.</p>
<ul>
<li><strong>IP 地址</strong>：用于在不同网络之间进行路由，确保数据能够跨越多个网络到达最终目标。</li>
<li><strong>MAC 地址</strong>：用于在同一个网络段（如同一个局域网）内实现设备之间的物理交付。</li>
<li><strong>IP 地址</strong>负<strong>找路</strong>，确定数据应该到哪个网络。</li>
<li><strong>MAC 地址</strong>负责<strong>最后一公里</strong>，在本地网络中找到具体的设备。</li>
<li>路由器转发数据时，每经过一跳，都会用新的 MAC 地址封装数据帧，但 IP 地址保持不变。</li>
</ul>
<p>假设主机 A 要给主机 B 发送数据：</p>
<ol>
<li><strong>跨网传输</strong>：数据包通过多个路由器，依靠 IP 地址进行路由选择。</li>
<li><strong>到达目标网络</strong>：最后一跳，数据包到达 B 所在的局域网。</li>
<li><strong>本地交付</strong>：A 通过 ARP 协议获取 B 的 MAC 地址，将数据帧封装后，通过以太网物理传输到 B。</li>
</ol>
<h2 id="MAC-Addresses-and-ARP"><a href="#MAC-Addresses-and-ARP" class="headerlink" title="MAC Addresses and ARP"></a>MAC Addresses and ARP</h2><p><img src="/The-Data-Link-Layer/MACAddress.png" alt="MAC Address">{style&#x3D;”display: block; margin: 0 auto; width: 70%”}</p>
<p>Broadcast address &#x3D; <code>FF-FF-FF-FF-FF-FF</code></p>
<h3 id="MAC-Address-Administration"><a href="#MAC-Address-Administration" class="headerlink" title="MAC Address Administration"></a>MAC Address Administration</h3><ul>
<li><p><strong>分配权威（Allocation Authority）</strong><br>MAC 地址空间由 <strong>IEEE（电气和电子工程师协会）</strong> 统一管理和分配，确保全球唯一性。</p>
</li>
<li><p><strong>分配流程（Assignment Process）</strong><br>各网络设备制造商需要向 IEEE 购买一批 MAC 地址块。这样，每个厂商生产的设备都能分配到唯一的 MAC 地址，避免地址冲突。</p>
</li>
<li><p><strong>结构（Structure）</strong><br>MAC 地址总长 48 位，<strong>前 24 位</strong>通常用来标识制造商（称为 OUI，Organizationally Unique Identifier，组织唯一标识符），后 24 位由厂商自行分配给各自的设备。</p>
</li>
</ul>
<h3 id="Conceptual-Comparison"><a href="#Conceptual-Comparison" class="headerlink" title="Conceptual Comparison"></a>Conceptual Comparison</h3><ul>
<li><p><strong>MAC Address</strong>: Similar to a Social Security Number</p>
<ul>
<li>Permanent identifier tied to hardware</li>
<li>Remains with the device regardless of location</li>
</ul>
</li>
<li><p><strong>IP Address</strong>: Similar to a postal address</p>
<ul>
<li>Indicates location in the network topology</li>
<li>Changes when moving between networks</li>
</ul>
</li>
</ul>
<h3 id="Address-Structure-Implications"><a href="#Address-Structure-Implications" class="headerlink" title="Address Structure Implications"></a>Address Structure Implications</h3><ul>
<li><p><strong>MAC Address (Flat)</strong>:</p>
<ul>
<li>Provides portability</li>
<li>LAN card maintains its address when moved between networks</li>
<li>No inherent network location information</li>
</ul>
</li>
<li><p><strong>IP Address (Hierarchical)</strong>:</p>
<ul>
<li>Not portable across networks</li>
<li>Contains network prefix that identifies subnet</li>
<li>Must change when moving to a different subnet</li>
<li>Enables efficient routing across internet</li>
</ul>
</li>
</ul>
<p>This fundamental difference in addressing philosophy reflects the different purposes of each address type: MAC for unique hardware identification, IP for routable network location.</p>
<h2 id="Address-Resolution-Protocol-ARP"><a href="#Address-Resolution-Protocol-ARP" class="headerlink" title="Address Resolution Protocol (ARP)"></a>Address Resolution Protocol (ARP)</h2><p>The Address Resolution Protocol (ARP) is used to discover the MAC address associated with a known IP address on the same local network:</p>
<ol>
<li><p><strong>Check Local ARP Table First</strong></p>
<ul>
<li>Every IP-enabled device maintains an ARP table</li>
<li>The table contains mappings of IP addresses to MAC addresses</li>
<li>Each entry format: <code>&lt;IP address; MAC address; TTL&gt;</code></li>
<li>TTL (Time To Live): Typically 20 minutes before entry expires</li>
</ul>
</li>
<li><p><strong>If MAC Address Not in Table:</strong></p>
<ul>
<li>Device broadcasts an ARP request to all devices on LAN</li>
<li>Uses broadcast MAC address: FF-FF-FF-FF-FF-FF</li>
<li>The request asks: “Who has IP address B? Send your MAC address”</li>
</ul>
</li>
<li><p><strong>Resolution Process:</strong></p>
<ul>
<li>Only the device with IP address B responds</li>
<li>Device B sends its MAC address directly to requester</li>
<li>Requester adds the IP-to-MAC mapping to its ARP table</li>
<li>Communication can now proceed using the discovered MAC address</li>
</ul>
</li>
<li><p><strong>When Entry Expires:</strong></p>
<ul>
<li>After TTL expires, the mapping is removed from ARP table</li>
<li>A new ARP request must be sent if communication is needed again</li>
</ul>
</li>
</ol>
<p>ARP is essential because link-layer delivery requires MAC addresses, while applications and higher protocols use IP addresses.</p>
<h2 id="ARP-Protocol-Same-LAN-Network"><a href="#ARP-Protocol-Same-LAN-Network" class="headerlink" title="ARP Protocol: Same LAN (Network)"></a>ARP Protocol: Same LAN (Network)</h2><p>When host A wants to send a datagram to host B on the same local network but doesn’t have B’s MAC address:</p>
<h3 id="ARP-Request-Process"><a href="#ARP-Request-Process" class="headerlink" title="ARP Request Process"></a>ARP Request Process</h3><ul>
<li>Host A broadcasts an ARP query packet containing B’s IP address</li>
<li>Destination MAC address &#x3D; <code>FF-FF-FF-FF-FF-FF</code> (broadcast address)</li>
<li>All machines on the LAN receive the ARP query</li>
<li>Only host B (with the matching IP address) processes and responds</li>
</ul>
<h3 id="ARP-Response"><a href="#ARP-Response" class="headerlink" title="ARP Response"></a>ARP Response</h3><ul>
<li>Host B replies to A with its (B’s) MAC address</li>
<li>Frame is sent directly to A’s MAC address (unicast)</li>
<li>A adds the IP-to-MAC mapping to its ARP table</li>
</ul>
<h3 id="Caching-Mechanism"><a href="#Caching-Mechanism" class="headerlink" title="Caching Mechanism"></a>Caching Mechanism</h3><ul>
<li>A caches (saves) the IP-to-MAC address pair in its ARP table</li>
<li>Mapping remains until the information becomes old (times out)</li>
<li>This is “soft state”: information expires unless refreshed through use</li>
</ul>
<h3 id="Key-Characteristics"><a href="#Key-Characteristics" class="headerlink" title="Key Characteristics"></a>Key Characteristics</h3><ul>
<li><strong>Self-configuring</strong>: ARP is “plug-and-play”</li>
<li><strong>Distributed</strong>: Nodes create their ARP tables without intervention from network administrators</li>
<li><strong>Automatic</strong>: Mappings are created and maintained dynamically as needed</li>
</ul>
<blockquote>
<p>自己也会创建置换表</p>
</blockquote>
<h2 id="Addressing-routing-to-another-LAN"><a href="#Addressing-routing-to-another-LAN" class="headerlink" title="Addressing: routing to another LAN"></a>Addressing: routing to another LAN</h2><p><img src="/The-Data-Link-Layer/619.png" alt="routing to another LAN">{style&#x3D;”display: block; margin: 0 auto; width: 100%”}</p>
<h2 id="Routing-Between-Different-LANs-Link-Layer-Process"><a href="#Routing-Between-Different-LANs-Link-Layer-Process" class="headerlink" title="Routing Between Different LANs: Link-Layer Process"></a>Routing Between Different LANs: Link-Layer Process</h2><p>When data travels between hosts on different networks, the router plays a critical intermediary role:</p>
<h3 id="Initial-Transmission-Source-Network"><a href="#Initial-Transmission-Source-Network" class="headerlink" title="Initial Transmission (Source Network)"></a>Initial Transmission (Source Network)</h3><ol>
<li><p>Host A creates an IP datagram with:</p>
<ul>
<li>Source IP address: Host A’s address</li>
<li>Destination IP address: Host B’s address (on different LAN)</li>
</ul>
</li>
<li><p>Host A determines B is on another network, so packet must go through router R:</p>
<ul>
<li>A uses ARP to resolve router interface IP (111.111.111.110) to R’s MAC address</li>
<li>A creates an Ethernet frame with:<ul>
<li>Destination: R’s MAC address</li>
<li>Source: A’s MAC address</li>
<li>Payload: The A-to-B IP datagram</li>
</ul>
</li>
</ul>
</li>
<li><p>A’s network interface card transmits this frame onto the LAN</p>
</li>
</ol>
<blockquote>
<p>从此可以看出，LAN 内部是通过以太网传输数据的，用的是 MAC address。</p>
</blockquote>
<h3 id="Router-Processing"><a href="#Router-Processing" class="headerlink" title="Router Processing"></a>Router Processing</h3><ol start="4">
<li><p>Router R’s interface receives the frame (recognizes its MAC address)</p>
</li>
<li><p>R extracts the IP datagram from the frame, examines the IP header:</p>
<ul>
<li>Sees destination IP is for host B on another network</li>
<li>Consults routing table to determine next hop</li>
</ul>
</li>
<li><p>R prepares to forward to the destination network:</p>
<ul>
<li>Uses ARP to resolve B’s IP address to B’s MAC address</li>
<li>Creates a new Ethernet frame with:<ul>
<li>Destination: B’s MAC address</li>
<li>Source: R’s MAC address (interface on B’s network)</li>
<li>Payload: The original A-to-B IP datagram (unchanged)</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>R 在不同网络段代表不同的路由器接口。</p>
</blockquote>
<h3 id="Final-Delivery-Destination-Network"><a href="#Final-Delivery-Destination-Network" class="headerlink" title="Final Delivery (Destination Network)"></a>Final Delivery (Destination Network)</h3><ol start="7">
<li><p>Router’s interface on B’s network transmits the new frame</p>
</li>
<li><p>Host B receives the frame, extracts and processes the IP datagram</p>
</li>
</ol>
<p>Note: The IP datagram remains unchanged throughout this process, while the frame addressing changes at each network segment.</p>
<h1 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h1><h2 id="The-Dominant-Wired-LAN-Technology"><a href="#The-Dominant-Wired-LAN-Technology" class="headerlink" title="The Dominant Wired LAN Technology"></a>The Dominant Wired LAN Technology</h2><ul>
<li><strong>Cost-effective</strong>: Extremely affordable - approximately $20 for a Network Interface Card</li>
<li><strong>Pioneer technology</strong>: First widely used LAN technology, establishing the foundation for modern networks</li>
<li><strong>Simplicity and economy</strong>: Significantly simpler and more economical than token LANs and ATM alternatives</li>
<li><strong>Scalable performance</strong>: Successfully kept pace with speed requirements over decades:<ul>
<li>Started at 10 Mbps</li>
<li>Evolved through 100 Mbps and 1 Gbps</li>
<li>Now supports up to 10 Gbps and beyond</li>
</ul>
</li>
</ul>
<p>Ethernet’s combination of low cost, simplicity, and adaptability to increasing performance demands has secured its position as the predominant wired networking technology in local area networks worldwide.</p>
<h2 id="Ethernet-Physical-Topologies"><a href="#Ethernet-Physical-Topologies" class="headerlink" title="Ethernet Physical Topologies"></a>Ethernet Physical Topologies</h2><h3 id="Historical-Evolution"><a href="#Historical-Evolution" class="headerlink" title="Historical Evolution"></a>Historical Evolution</h3><ul>
<li><strong>Bus topology</strong>: Popular through mid-1990s<ul>
<li>All nodes connected to a common shared cable</li>
<li><strong>Single collision domain</strong>: All nodes could interfere with each other’s transmissions</li>
<li>When one node transmitted, all others had to wait</li>
<li>Limited scalability due to increasing collision probability with more nodes</li>
</ul>
</li>
</ul>
<blockquote>
<p>前面提到过</p>
</blockquote>
<h3 id="Modern-Configuration"><a href="#Modern-Configuration" class="headerlink" title="Modern Configuration"></a>Modern Configuration</h3><ul>
<li><strong>Star topology</strong>: Dominant configuration today<ul>
<li><strong>Central active switch</strong>: Intelligent device at center of network</li>
<li>Point-to-point links between switch and end devices</li>
<li><strong>Separate collision domains</strong>: Each link operates as an independent Ethernet segment</li>
<li>Nodes connected to different switch ports cannot directly collide with each other</li>
<li>Dramatically improved performance and reliability compared to bus topology</li>
</ul>
</li>
</ul>
<p>The shift from bus to star topology represents a fundamental advance in Ethernet technology, effectively eliminating the collision problems that limited earlier implementations.</p>
<h2 id="Ethernet-frame-structure"><a href="#Ethernet-frame-structure" class="headerlink" title="Ethernet frame structure"></a>Ethernet frame structure</h2><p><img src="/The-Data-Link-Layer/620.png" alt="Ethernet frame structure">{style&#x3D;”display: block; margin: 0 auto; width: 100%”}</p>
<ul>
<li><p><strong>Preamble</strong>:</p>
<ul>
<li>7 bytes with pattern 10101010 followed by one byte with pattern 10101011</li>
<li>Used to synchronize receiver and sender clock rates</li>
<li>Allows receivers to “lock onto” the sender’s transmission timing</li>
</ul>
</li>
<li><p><strong>Addresses</strong>: 6 bytes each</p>
<ul>
<li>Destination MAC address (first)</li>
<li>Source MAC address (second)</li>
<li>Processing logic:<ul>
<li>If adapter receives frame with matching destination address or broadcast address (FF-FF-FF-FF-FF-FF), it passes data to network layer</li>
<li>Otherwise, adapter <strong>discards the frame</strong></li>
<li>Broadcast frames (e.g., ARP packets) are processed by all recipients</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Type</strong>: 2 bytes</p>
<ul>
<li>Indicates the higher layer protocol encapsulated in the frame payload</li>
<li>Common values:<ul>
<li>0x0800: IPv4</li>
<li>0x0806: ARP</li>
<li>0x86DD: IPv6</li>
<li>Other protocols: Novell IPX, AppleTalk, etc.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>CRC</strong>: 4 bytes (32 bits)</p>
<ul>
<li>Cyclic Redundancy Check for error detection</li>
<li>Checked at receiver</li>
<li>If error is detected, frame is <strong>immediately dropped</strong></li>
<li>No error correction or retransmission at Ethernet level</li>
</ul>
</li>
<li><p>**Preamble（前导码）**是以太网帧结构中的一个字段。</p>
</li>
<li><p>由<strong>7 个字节的 10101010 模式</strong>，后跟<strong>1 个字节的 10101011</strong> 组成。</p>
</li>
<li><p><strong>时钟同步</strong>：用于同步接收端和发送端的时钟速率。</p>
</li>
<li><p><strong>锁定信号</strong>：让接收方能够<strong>锁定</strong>到发送方的传输时序，确保后续数据能被准确采样和解析。</p>
</li>
</ul>
<h2 id="Ethernet-Key-Characteristics"><a href="#Ethernet-Key-Characteristics" class="headerlink" title="Ethernet: Key Characteristics"></a>Ethernet: Key Characteristics</h2><h3 id="Connectionless-Protocol"><a href="#Connectionless-Protocol" class="headerlink" title="Connectionless Protocol"></a>Connectionless Protocol</h3><ul>
<li><strong>No handshaking</strong> between transmitting and receiving Network Interface Cards (NICs)</li>
<li>Each frame is sent independently without establishing a connection first</li>
<li>Sender simply transmits frames when the medium is available</li>
<li>No session establishment or termination phases</li>
</ul>
<h3 id="Unreliable-Service"><a href="#Unreliable-Service" class="headerlink" title="Unreliable Service"></a>Unreliable Service</h3><ul>
<li><strong>No acknowledgments (ACKs)</strong> or negative acknowledgments (NACKs) sent by receiving NICs</li>
<li>Sending NIC has no built-in way to know if frames were successfully delivered</li>
<li>Corrupted frames are simply discarded by the receiver (detected via CRC)</li>
<li>No automatic retransmission mechanism at the Ethernet level</li>
</ul>
<h3 id="Implications-for-Data-Delivery"><a href="#Implications-for-Data-Delivery" class="headerlink" title="Implications for Data Delivery"></a>Implications for Data Delivery</h3><ul>
<li>Stream of datagrams passed to the network layer may contain <strong>gaps</strong> (missing datagrams)</li>
<li>If the application uses TCP (Transport layer):<ul>
<li>Gaps will be detected and filled through TCP’s reliable delivery mechanisms</li>
<li>End users won’t see missing data</li>
</ul>
</li>
<li>If using UDP or other unreliable protocols:<ul>
<li>Application will see the gaps and must handle them if needed</li>
<li>Responsibility for reliability shifts to the application layer</li>
</ul>
</li>
</ul>
<h3 id="Medium-Access-Control"><a href="#Medium-Access-Control" class="headerlink" title="Medium Access Control"></a>Medium Access Control</h3><ul>
<li>Ethernet’s MAC protocol: <strong>unslotted CSMA&#x2F;CD</strong> (Carrier Sense Multiple Access with Collision Detection)</li>
<li>Provides a way to share the communication medium among multiple devices</li>
<li>Modern switched Ethernet largely eliminates collisions, but the protocol foundation remains</li>
</ul>
<h2 id="CSMA-CD-Algorithm-in-Ethernet"><a href="#CSMA-CD-Algorithm-in-Ethernet" class="headerlink" title="CSMA&#x2F;CD Algorithm in Ethernet"></a>CSMA&#x2F;CD Algorithm in Ethernet</h2><p>Ethernet’s original medium access control protocol uses CSMA&#x2F;CD (Carrier Sense Multiple Access with Collision Detection) to handle shared medium access:</p>
<h3 id="Step-by-Step-Process"><a href="#Step-by-Step-Process" class="headerlink" title="Step-by-Step Process"></a>Step-by-Step Process</h3><ol>
<li><p><strong>Frame Creation</strong></p>
<ul>
<li>NIC receives datagram from network layer</li>
<li>Creates an Ethernet frame with appropriate headers</li>
</ul>
</li>
<li><p><strong>Channel Sensing</strong></p>
<ul>
<li>If NIC senses channel is <strong>idle</strong>: begins frame transmission immediately</li>
<li>If NIC senses channel is <strong>busy</strong>: waits until channel becomes idle, then transmits</li>
</ul>
</li>
<li><p><strong>Successful Transmission</strong></p>
<ul>
<li>If NIC transmits the entire frame without detecting another transmission</li>
<li>Transmission is complete and successful</li>
</ul>
</li>
<li><p><strong>Collision Handling</strong></p>
<ul>
<li>If NIC detects another transmission while transmitting</li>
<li>Immediately aborts transmission</li>
<li><strong>Sends a brief jam signal to ensure all stations recognize the collision</strong></li>
</ul>
</li>
<li><p><strong>Exponential Backoff</strong></p>
<ul>
<li>After aborting, NIC enters exponential backoff procedure:</li>
<li>After the mᵗʰ collision, NIC chooses K randomly from {0,1,2,…,2ᵐ-1}</li>
<li>NIC waits <strong>K·512 bit times</strong> before attempting retransmission</li>
<li>Returns to Step 2 to attempt transmission again</li>
</ul>
</li>
</ol>
<p>The exponential backoff mechanism ensures that after repeated collisions, stations spread their retransmission attempts over increasingly longer intervals, reducing the probability of repeated collisions.</p>
<h2 id="Ethernet’s-CSMA-CD-Technical-Details"><a href="#Ethernet’s-CSMA-CD-Technical-Details" class="headerlink" title="Ethernet’s CSMA&#x2F;CD: Technical Details"></a>Ethernet’s CSMA&#x2F;CD: Technical Details</h2><h3 id="Collision-Handling-Components"><a href="#Collision-Handling-Components" class="headerlink" title="Collision Handling Components"></a>Collision Handling Components</h3><ul>
<li><p><strong>Jam Signal</strong>:</p>
<ul>
<li>48-bit signal transmitted after detecting a collision</li>
<li>Purpose: Ensures all transmitting stations are aware of the collision</li>
<li>Small, fixed size makes collision detection efficient</li>
<li>Contains a deliberate pattern that cannot be mistaken for valid data</li>
</ul>
</li>
<li><p><strong>Bit Time</strong>:</p>
<ul>
<li>The time required to transmit one bit on the network</li>
<li><strong>For $10$ Mbps Ethernet: $0.1$ microseconds per bit</strong></li>
<li>Used as the basic time unit for backoff calculations</li>
<li>For <strong>$K &#x3D; 1023$ (maximum backoff value)</strong>, wait time is approximately $50$ milliseconds</li>
</ul>
</li>
</ul>
<h3 id="Exponential-Backoff-Algorithm"><a href="#Exponential-Backoff-Algorithm" class="headerlink" title="Exponential Backoff Algorithm"></a>Exponential Backoff Algorithm</h3><ul>
<li><p><strong>Goal</strong>: Adaptively adjust retransmission timing based on estimated network load</p>
<ul>
<li>Under heavy load conditions, stations wait longer before retrying</li>
<li>Helps prevent collision cascades when multiple stations are competing for access</li>
</ul>
</li>
<li><p><strong>Progressive Backoff Process</strong>:</p>
<ul>
<li>After first collision: Choose K randomly from ${0,1}$<ul>
<li>Wait time &#x3D; $K × 512$ bit transmission times</li>
</ul>
</li>
<li>After second collision: Choose K randomly from ${0,1,2,3}$</li>
<li>After third collision: Choose K randomly from ${0,1,2,3,4,5,6,7}$</li>
<li>Pattern continues: After nth collision, range is ${0,1,2,…,2^n-1}$</li>
<li>After tenth collision: Choose K randomly from ${0,1,2,…,1023}$</li>
<li><strong>Maximum range is capped at ${0,1,2,…,1023}$ even after more collisions</strong></li>
</ul>
</li>
</ul>
<p>This adaptive algorithm ensures efficient channel utilization by dynamically adjusting to network congestion levels, minimizing repeated collisions while maintaining reasonable access times.</p>
<h2 id="CSMA-CD-efficiency"><a href="#CSMA-CD-efficiency" class="headerlink" title="CSMA&#x2F;CD efficiency"></a>CSMA&#x2F;CD efficiency</h2><ul>
<li>$t_{prop}$: max prop delay between $2$ nodes in LAN;</li>
<li>$t_{trans}$: time to transmit max-size frame.</li>
</ul>
<p>$$<br>\text{efficiency} &#x3D; \frac{1}{1 + \frac{5 t_{prop}}{t_{trans}}}<br>$$</p>
<h2 id="Ethernet-Standards-Link-Physical-Layers"><a href="#Ethernet-Standards-Link-Physical-Layers" class="headerlink" title="Ethernet Standards: Link &amp; Physical Layers"></a>Ethernet Standards: Link &amp; Physical Layers</h2><p><img src="/The-Data-Link-Layer/621.png" alt="alt text">{style&#x3D;”display: block; margin: 0 auto; width: 100%”}</p>
<ul>
<li><p><strong>Common Foundation</strong>:</p>
<ul>
<li>All Ethernet variants share the same <strong>MAC protocol</strong> principles</li>
<li><strong>Frame format</strong> remains consistent across implementations</li>
<li>Upper layers interact with Ethernet through the same interface regardless of physical medium</li>
</ul>
</li>
<li><p><strong>Speed Evolution</strong>:</p>
<ul>
<li><strong>2 Mbps</strong>: Early experimental implementations</li>
<li><strong>10 Mbps</strong>: Original Ethernet standard (10BASE-T)</li>
<li><strong>100 Mbps</strong>: Fast Ethernet (100BASE-TX, 100BASE-FX)</li>
<li><strong>1 Gbps</strong>: Gigabit Ethernet (1000BASE-T, 1000BASE-SX&#x2F;LX)</li>
<li><strong>10 Gbps</strong>: 10 Gigabit Ethernet (10GBASE-T, 10GBASE-SR&#x2F;LR)</li>
<li><strong>Higher speeds</strong>: 40 Gbps, 100 Gbps, 400 Gbps technologies now available</li>
</ul>
</li>
<li><p><strong>Physical Media Diversity</strong>:</p>
<ul>
<li><strong>Copper cable</strong>:<ul>
<li>Twisted pair (Cat5e, Cat6, Cat6a, Cat7)</li>
<li>Coaxial cable (older implementations)</li>
</ul>
</li>
<li><strong>Optical fiber</strong>:<ul>
<li>Multimode fiber (shorter distances)</li>
<li>Single-mode fiber (longer distances)</li>
<li>Various wavelengths and transmission techniques</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This standardized approach allows equipment from different manufacturers to interoperate while enabling continuous performance improvements through new physical layer technologies.</p>
<h1 id="Link-Layer-Switches"><a href="#Link-Layer-Switches" class="headerlink" title="Link-Layer Switches"></a>Link-Layer Switches</h1><h2 id="Hubs"><a href="#Hubs" class="headerlink" title="Hubs"></a>Hubs</h2><p>physical-layer (dumb) repeaters:</p>
<ul>
<li>bits coming in one link go out all other links at same rate</li>
<li>all nodes connected to hub can collide with one another</li>
<li>no frame buffering</li>
<li>no CSMA&#x2F;CD at hub: host NICs detect collisions</li>
</ul>
<p><img src="/The-Data-Link-Layer/hub.png" alt="hub">{style&#x3D;”display: block; margin: 0 auto; width: 70%”}</p>
<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><ul>
<li><p><strong>Link-layer intelligence</strong>:</p>
<ul>
<li>Smarter than hubs, taking an active role in network traffic management</li>
<li>Process frames at the data link layer (Layer 2) rather than merely repeating signals</li>
<li>Make forwarding decisions based on MAC addresses</li>
</ul>
</li>
<li><p><strong>Store-and-forward operation</strong>:</p>
<ul>
<li>Receive complete frames before forwarding</li>
<li>Buffer frames in memory, allowing for collision domain isolation</li>
<li>Check frames for errors (using CRC) before forwarding, improving network reliability</li>
</ul>
</li>
<li><p><strong>Selective forwarding</strong>:</p>
<ul>
<li>Examine incoming frame’s destination MAC address</li>
<li>Forward frame only to the specific port where destination device is connected</li>
<li>Send to multiple ports only when necessary (broadcasts, unknown destinations)</li>
<li>When forwarding frames onto a segment, uses CSMA&#x2F;CD to access the medium</li>
</ul>
</li>
<li><p><strong>Transparent operation</strong>:</p>
<ul>
<li>Hosts are completely unaware of switches’ presence in the network</li>
<li>End devices communicate as if directly connected</li>
<li>No modification of frame content during transit through switch</li>
</ul>
</li>
<li><p><strong>Plug-and-play functionality</strong>:</p>
<ul>
<li>Self-learning capability builds forwarding tables automatically</li>
<li>Observes source MAC addresses of incoming frames to learn device locations</li>
<li>Dynamically updates tables when devices move to different ports</li>
<li>No manual configuration required for basic operation</li>
</ul>
</li>
</ul>
<p>These capabilities allow switches to significantly improve network performance by creating separate collision domains for each port while maintaining the same Ethernet protocol standards.</p>
<h3 id="Switch-Advanced-Link-Layer-Functionality"><a href="#Switch-Advanced-Link-Layer-Functionality" class="headerlink" title="Switch: Advanced Link-Layer Functionality"></a>Switch: Advanced Link-Layer Functionality</h3><ul>
<li><p><strong>Simultaneous transmissions</strong>:</p>
<ul>
<li>Allows multiple pairs of nodes to transmit concurrently</li>
<li>Different ports can carry independent data streams at the same time</li>
<li>Dramatically increases total network throughput compared to hubs</li>
</ul>
</li>
<li><p><strong>Dedicated connections</strong>:</p>
<ul>
<li>Each host has a dedicated, direct connection to the switch</li>
<li>Full bandwidth of the link is available to each host-switch connection</li>
<li>No competition for bandwidth between devices on different ports</li>
</ul>
</li>
<li><p><strong>Frame buffering</strong>:</p>
<ul>
<li>Switches contain memory to store frames temporarily</li>
<li>Can hold frames when output ports are busy</li>
<li>Prevents frame loss during periods of network congestion</li>
<li>Enables handling of traffic between different speed interfaces</li>
</ul>
</li>
<li><p><strong>Collision elimination</strong>:</p>
<ul>
<li>Ethernet protocol used on each link but without collisions</li>
<li>Full-duplex operation: simultaneous transmission and reception</li>
<li>Each link is its own separate collision domain</li>
<li>CSMA&#x2F;CD no longer needed on point-to-point links to switch</li>
</ul>
</li>
<li><p><strong>Parallel communications</strong>:</p>
<ul>
<li>Host A can transmit to host A’ while host B simultaneously transmits to host B’</li>
<li>No interference between unrelated data flows</li>
<li>Example: In a network with hosts A, A’, B, and B’ all connected to a switch:<ul>
<li>A→A’ and B→B’ transmissions occur in parallel</li>
<li>Network throughput effectively multiplied by number of concurrent transmissions</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Contrast with hubs</strong>:</p>
<ul>
<li>Hubs force a single shared collision domain among all connected devices</li>
<li>Only one device can transmit at any given time with a hub</li>
<li>Switches enable parallel, independent data flows that hubs cannot support</li>
</ul>
</li>
</ul>
<h2 id="Switch-Table"><a href="#Switch-Table" class="headerlink" title="Switch Table"></a>Switch Table</h2><p>Q: How does switch know that A’ reachable via interface 4, B’ reachable via interface 5?</p>
<p>A: Each switch has a switch table, each entry contains</p>
<ul>
<li>MAC address of host</li>
<li>Interface to reach host</li>
<li>Time stamp</li>
</ul>
<p>This structure is similar to a routing table, but operates at Layer 2 (MAC addresses) rather than Layer 3 (IP addresses).</p>
<p>Q: How are entries created, maintained in switch table? Something like a routing protocol?</p>
<p>A: Switch tables are built through self-learning</p>
<ol>
<li><p><strong>Self-learning process</strong>:</p>
<ul>
<li>Initially the switch table is empty</li>
<li>When a frame arrives, the switch records the sender’s MAC address and the interface on which it arrived</li>
<li>The switch learns the location of hosts based on the source MAC address of incoming frames</li>
</ul>
</li>
<li><p><strong>Table maintenance</strong>:</p>
<ul>
<li>Each entry has a time-to-live (typically 20-30 minutes)</li>
<li>Entries are refreshed when new frames from the same source arrive</li>
<li>Entries timeout and are removed if not refreshed before TTL expires</li>
</ul>
</li>
<li><p><strong>Handling unknown destinations</strong>:</p>
<ul>
<li>If destination MAC is unknown (not in table), the switch floods the frame to all interfaces except the one it arrived on</li>
<li>Once the destination host responds, its location is learned</li>
</ul>
</li>
<li><p><strong>Key differences from routing protocols</strong>:</p>
<ul>
<li>No explicit protocol messages exchanged between switches for MAC learning</li>
<li>Learning is passive, based solely on observing normal traffic</li>
<li>Completely automatic with no configuration required</li>
</ul>
</li>
</ol>
<h2 id="Switch-Self-Learning"><a href="#Switch-Self-Learning" class="headerlink" title="Switch: Self-Learning"></a>Switch: Self-Learning</h2><h3 id="Learning-Host-Locations"><a href="#Learning-Host-Locations" class="headerlink" title="Learning Host Locations"></a>Learning Host Locations</h3><ul>
<li><strong>Basic principle</strong>: Switches automatically learn which hosts are located on which interfaces</li>
<li><strong>No configuration required</strong>: Learning happens dynamically as frames traverse the switch</li>
<li><strong>Process for each incoming frame</strong>:<ol>
<li>Switch examines the <strong>source MAC address</strong> in the frame header</li>
<li>Switch records the <strong>interface</strong> on which the frame arrived</li>
<li>Switch associates this MAC address with this interface in its table</li>
<li>Timestamp is recorded for the entry for aging purposes</li>
</ol>
</li>
</ul>
<h3 id="Switch-Table-Management"><a href="#Switch-Table-Management" class="headerlink" title="Switch Table Management"></a>Switch Table Management</h3><ul>
<li><strong>Dynamic updates</strong>: If a host moves to a different port, the switch updates its table when the host transmits</li>
<li><strong>Aging mechanism</strong>: Each entry includes a time-to-live (typically 20-30 minutes)<ul>
<li>Entries are refreshed when new frames from the same source arrive</li>
<li>If no frames are received from a MAC address before TTL expires, entry is removed</li>
</ul>
</li>
<li><strong>Adaptation to network changes</strong>: Tables automatically adjust when:<ul>
<li>New devices connect to the network</li>
<li>Existing devices are moved to different switch ports</li>
<li>Devices are removed from the network</li>
</ul>
</li>
</ul>
<h3 id="Handling-Unknown-Destinations"><a href="#Handling-Unknown-Destinations" class="headerlink" title="Handling Unknown Destinations"></a>Handling Unknown Destinations</h3><ul>
<li><strong>Initial state</strong>: Empty table when switch boots up</li>
<li><strong>Flooding</strong>: When destination is unknown (not in table), switch forwards frame out all interfaces except the arrival interface</li>
<li><strong>Progressive learning</strong>: Table builds up as hosts send frames, gradually reducing the need for flooding</li>
<li><strong>Self-correcting</strong>: If an entry becomes outdated, flooding will occur until the host location is relearned</li>
</ul>
<p>This passive learning approach enables plug-and-play networking with minimal administrative overhead.</p>
<h2 id="Switch-Frame-Filtering-Forwarding"><a href="#Switch-Frame-Filtering-Forwarding" class="headerlink" title="Switch: Frame Filtering&#x2F;Forwarding"></a>Switch: Frame Filtering&#x2F;Forwarding</h2><h3 id="Frame-Processing-Algorithm"><a href="#Frame-Processing-Algorithm" class="headerlink" title="Frame Processing Algorithm"></a>Frame Processing Algorithm</h3><p>When a frame is received by a switch, it follows this decision process:</p>
<ol>
<li><p><strong>Record source information</strong>:</p>
<ul>
<li>Record the link&#x2F;interface associated with the sending host</li>
<li>Update or create switch table entry for source MAC address</li>
</ul>
</li>
<li><p><strong>Destination lookup</strong>:</p>
<ul>
<li>Index the switch table using the destination MAC address</li>
</ul>
</li>
<li><p><strong>Forwarding decision</strong>:</p>
<ul>
<li>If destination MAC entry is found in table:<ul>
<li>If destination is on same segment from which frame arrived:<ul>
<li>Drop the frame (no need to forward to the same segment)</li>
</ul>
</li>
<li>Else:<ul>
<li>Forward the frame on the interface indicated in the table entry</li>
</ul>
</li>
</ul>
</li>
<li>Else (destination not found in table):<ul>
<li>Flood the frame (forward on all interfaces except the one on which it arrived)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Flooding process</strong>:</p>
<ul>
<li>When flooding is required, the frame is sent out all switch ports</li>
<li>Exception: Never send the frame back on the interface where it was received</li>
<li>This ensures the destination will receive the frame if it exists on the network</li>
<li>Subsequent replies will help the switch learn the destination’s location</li>
</ul>
</li>
</ol>
<p>This algorithm combines the efficiency of direct forwarding with the reliability of flooding when necessary, while also preventing unnecessary network traffic through frame filtering.</p>
<h2 id="Switches-vs-Routers-Key-Differences"><a href="#Switches-vs-Routers-Key-Differences" class="headerlink" title="Switches vs. Routers: Key Differences"></a>Switches vs. Routers: Key Differences</h2><h3 id="Similarities"><a href="#Similarities" class="headerlink" title="Similarities"></a>Similarities</h3><ul>
<li>Both are <strong>store-and-forward devices</strong><ul>
<li>Receive complete packets&#x2F;frames before processing and forwarding</li>
<li>Buffer data during processing</li>
</ul>
</li>
</ul>
<h3 id="Fundamental-Differences"><a href="#Fundamental-Differences" class="headerlink" title="Fundamental Differences"></a>Fundamental Differences</h3><table>
<thead>
<tr>
<th>Characteristic</th>
<th>Switches</th>
<th>Routers</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OSI Layer</strong></td>
<td>Link layer (Layer 2)</td>
<td>Network layer (Layer 3)</td>
</tr>
<tr>
<td><strong>Addressing</strong></td>
<td>Use MAC addresses</td>
<td>Use IP addresses</td>
</tr>
<tr>
<td><strong>Header Examination</strong></td>
<td>Examine frame headers</td>
<td>Examine packet headers</td>
</tr>
<tr>
<td><strong>Decision Making</strong></td>
<td>Simple forwarding based on MAC address</td>
<td>Complex routing decisions based on network topology</td>
</tr>
</tbody></table>
<h3 id="Table-Management"><a href="#Table-Management" class="headerlink" title="Table Management"></a>Table Management</h3><ul>
<li><p><strong>Switches</strong>:</p>
<ul>
<li>Maintain switch tables mapping MAC addresses to interfaces</li>
<li>Implement self-learning algorithms (passive learning from traffic)</li>
<li>Use filtering to prevent unnecessary traffic propagation</li>
<li>Tables built automatically without configuration</li>
</ul>
</li>
<li><p><strong>Routers</strong>:</p>
<ul>
<li>Maintain routing tables mapping network addresses to next hops</li>
<li>Implement dynamic routing algorithms (RIP, OSPF, BGP, etc.)</li>
<li>Exchange routing protocol messages with other routers</li>
<li>Often require explicit configuration</li>
</ul>
</li>
</ul>
<h3 id="Operational-Scope"><a href="#Operational-Scope" class="headerlink" title="Operational Scope"></a>Operational Scope</h3><ul>
<li><strong>Switches</strong>: Operate within a single network (broadcast domain)</li>
<li><strong>Routers</strong>: Connect multiple networks and provide inter-network communication</li>
</ul>
<p>These fundamental differences reflect their different roles in network architecture: switches optimize local traffic flow within networks, while routers enable traffic to traverse between different networks.</p>
<p><img src="/The-Data-Link-Layer/624.png" alt="Route">{style&#x3D;”display: block; margin: 0 auto; width: 70%”}</p>
<h2 id="Virtual-Local-Area-Networks-VLANs"><a href="#Virtual-Local-Area-Networks-VLANs" class="headerlink" title="Virtual Local Area Networks (VLANs)"></a>Virtual Local Area Networks (VLANs)</h2><h3 id="802-1Q-VLAN-Frame-Format"><a href="#802-1Q-VLAN-Frame-Format" class="headerlink" title="802.1Q VLAN Frame Format"></a>802.1Q VLAN Frame Format</h3><ul>
<li>Compares standard 802.1 Ethernet frame with 802.1Q VLAN frame</li>
<li>802.1Q frame adds a 2-byte Tag Protocol Identifier (value: 81-00)</li>
<li>Includes Tag Control Information with 12-bit VLAN ID field and 3-bit priority field</li>
<li>CRC is recomputed to account for the added header fields</li>
<li>Allows frames to carry VLAN identification information</li>
</ul>
<h3 id="VLANs-Spanning-Multiple-Switches"><a href="#VLANs-Spanning-Multiple-Switches" class="headerlink" title="VLANs Spanning Multiple Switches"></a>VLANs Spanning Multiple Switches</h3><ul>
<li>VLANs can extend across multiple physical switches</li>
<li>Trunk ports connect switches and carry frames between VLANs</li>
<li>Frames forwarded between switches must use 802.1Q protocol to maintain VLAN information</li>
<li>Example shows Electrical Engineering VLAN (ports 1-8) and Computer Science VLAN (ports 9-15) spanning two switches</li>
<li>Trunk ports ensure proper VLAN segregation across the extended network</li>
</ul>
<h3 id="Port-based-VLAN"><a href="#Port-based-VLAN" class="headerlink" title="Port-based VLAN"></a>Port-based VLAN</h3><ul>
<li>Provides traffic isolation between different port groups</li>
<li>Supports dynamic membership where port</li>
<li>s can be reassigned to different VLANs</li>
<li>Communication between VLANs requires routing, similar to separate physical networks</li>
<li>VLANs can be defined by port numbers or by MAC addresses of endpoints</li>
<li>Vendors typically offer combined switch&#x2F;router devices to facilitate inter-VLAN routing</li>
</ul>
<h3 id="VLAN-Concept-Overview"><a href="#VLAN-Concept-Overview" class="headerlink" title="VLAN Concept Overview"></a>VLAN Concept Overview</h3><ul>
<li>Defines VLANs as virtual networks created on a single physical infrastructure</li>
<li>A single physical switch operates as multiple virtual switches</li>
<li>Logically separates networks (e.g., Electrical Engineering from Computer Science)</li>
<li>Provides network segmentation without requiring separate physical switches</li>
<li>Increases network flexibility, security, and management capabilities</li>
</ul>
<h1 id="End-of-chapter-exercises"><a href="#End-of-chapter-exercises" class="headerlink" title="End-of-chapter exercises"></a>End-of-chapter exercises</h1><h2 id="R-8"><a href="#R-8" class="headerlink" title="R.8"></a>R.8</h2><p><strong>Question</strong></p>
<p>How big is the $\text{MAC}$ address space? The $\text{IPv4}$ address space? The $\text{IPv6}$ address space?</p>
<p><strong>Answer</strong></p>
<p>The sizes of the three address spaces are:</p>
<h3 id="MAC-Address-Space"><a href="#MAC-Address-Space" class="headerlink" title="MAC Address Space"></a>MAC Address Space</h3><ul>
<li><strong>Size</strong>: $2^{48}$ possible addresses</li>
<li><strong>Format</strong>: $48$-bit addresses, typically represented as six groups of two hexadecimal digits (e.g., <code>00:1A:2B:3C:4D:5E</code>)</li>
</ul>
<h3 id="IPv4-Address-Space"><a href="#IPv4-Address-Space" class="headerlink" title="IPv4 Address Space"></a>IPv4 Address Space</h3><ul>
<li><strong>Size</strong>: $2^{32}$ possible addresses</li>
<li><strong>Format</strong>: $32$-bit addresses, typically represented as four decimal numbers separated by dots (e.g., <code>192.168.1.1</code>)</li>
</ul>
<h3 id="IPv6-Address-Space"><a href="#IPv6-Address-Space" class="headerlink" title="IPv6 Address Space"></a>IPv6 Address Space</h3><ul>
<li><strong>Size</strong>: $2^{128}$ possible addresses</li>
<li><strong>Format</strong>: $128$-bit addresses, typically represented as eight groups of four hexadecimal digits separated by colons (e.g., <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>)</li>
</ul>
<p>The IPv6 address space is vastly larger than both MAC and IPv4 address spaces, which was designed to address the IPv4 address exhaustion problem.</p>
<h2 id="P-4"><a href="#P-4" class="headerlink" title="P.4"></a>P.4</h2><p><strong>Consider the previous problem, but instead of containing the binary of the numbers 0 through 9 suppose these 10 bytes contain.</strong></p>
<p><strong>Questions and Answers:</strong></p>
<p>a. the binary representation of the numbers 1 through 10.<br>b. the ASCII representation of the letters A through J (uppercase).<br>c. the ASCII representation of the letters a through j (lowercase).<br>Compute the Internet checksum for this data.</p>
<p>下面按 16-bit 大端顺序（高字节在前）计算 Internet 校验和（ones’complement sum）：</p>
<ol>
<li>每两个字节组成一个 16-bit 字，超出 0xFFFF 时将高位环回加到低位。</li>
<li>对所有字求和后取反。</li>
</ol>
<p>a. 数值 1 ～ 10（二进制，字节值 0x01～0x0A）  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x01 0x02 → 0x0102  </span><br><span class="line">0x03 0x04 → 0x0304  </span><br><span class="line">0x05 0x06 → 0x0506  </span><br><span class="line">0x07 0x08 → 0x0708  </span><br><span class="line">0x09 0x0A → 0x090A  </span><br><span class="line">Sum = 0x0102+0x0304+0x0506+0x0708+0x090A = 0x191E  </span><br><span class="line">Checksum = ~0x191E = 0xE6E1</span><br></pre></td></tr></table></figure>

<p>b. 大写字母 A ～ J（ASCII 0x41～0x4A）  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x41 0x42 → 0x4142  </span><br><span class="line">0x43 0x44 → 0x4344  </span><br><span class="line">0x45 0x46 → 0x4546  </span><br><span class="line">0x47 0x48 → 0x4748  </span><br><span class="line">0x49 0x4A → 0x494A  </span><br><span class="line">Sum = 0x4142+0x4344+0x4546+0x4748+0x494A = 0x5A5F  </span><br><span class="line">Checksum = ~0x5A5F = 0xA5A0</span><br></pre></td></tr></table></figure>

<p>c. 小写字母 a ～ j（ASCII 0x61～0x6A）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x61 0x62 → 0x6162  </span><br><span class="line">0x63 0x64 → 0x6364  </span><br><span class="line">0x65 0x66 → 0x6566  </span><br><span class="line">0x67 0x68 → 0x6768  </span><br><span class="line">0x69 0x6A → 0x696A  </span><br><span class="line">Sum = 0x6162+0x6364+0x6566+0x6768+0x696A = 0xFAFF  </span><br><span class="line">Checksum = ~0xFAFF = 0x0500</span><br></pre></td></tr></table></figure>

<h2 id="P-11"><a href="#P-11" class="headerlink" title="P.11"></a>P.11</h2><p>Suppose four active nodes—nodes A, B, C and D—are competing for access to a channel using slotted ALOHA. Assume each node has an infinite number of packets to send. Each node attempts to transmit in each slot with probability p. The first slot is numbered slot 1, the second slot is numbered slot 2, and so on.</p>
<p><strong>Questions and Answers:</strong></p>
<p><strong>a. What is the probability that node A succeeds for the first time in slot 5?</strong></p>
<p>在单个 slot 中成功的概率：$$P_{\text{succ}} &#x3D; p (1 - p)^{3}$$</p>
<p>在前 4 个 slot 中都未成功的概率：$$P_{\text{4s}} &#x3D; \left(1 - P_{\text{succ}}\right)^{4}$$</p>
<p>也就是：$$P(\text{first success in slot 5}) &#x3D; \bigl[1 - p(1-p)^3\bigr]^4 \times p(1-p)^3.$$</p>
<p><strong>b. What is the probability that some node (either A, B, C or D) succeeds in slot 4?</strong></p>
<p>总共有 $N &#x3D; 4$ 个结点，某个结点在 slot4 成功的概率为：<br>$$<br>P_{\text{succ}} &#x3D; 4 \cdot p \cdot (1 - p)^{3}<br>$$</p>
<p><strong>c. What is the probability that the first success occurs in slot 3?</strong></p>
<p>第一次成功出现在 slot3 的概率<br>$$<br>P &#x3D; (1-4p(1-p)^3)^2 \cdot 4p(1-p)^3<br>$$</p>
<p><strong>d. What is the efficiency of this four-node system?</strong></p>
<p>我们需要计算出使得 $Np(1-p)^{N-1}$ 最大的 $p$，记原式子为 $L(p)$，最优解为 $p^{\ast}$。对 $p$ 求偏导：<br>$$<br>\frac{\partial L(p)}{\partial p} &#x3D; 4(1 - p)^{3} - 12p(1 - p)^{2}<br>$$</p>
<p>得到<br>$$<br>p^{\ast} &#x3D; 0.25<br>$$</p>
<p>所以，效率为：<br>$$<br>\text{efficiency} &#x3D; 4 \times 0.25 \times 0.75^3 &#x3D; \frac{27}{64}<br>$$</p>
<h2 id="P-17"><a href="#P-17" class="headerlink" title="P.17"></a>P.17</h2><p><strong>Question and Answer:</strong></p>
<p>Recall that with the CSMA&#x2F;CD protocol, the adapter waits $K \cdot 512$ bit times after a collision, where $K$ is drawn randomly. For $K &#x3D; 100$, how long does the adapter wait until returning to Step 2 for a $10$ Mbps Ethernet? For a $100$ Mbps Ethernet?</p>
<p>等待时间的计算公式为：<br>$$<br>T &#x3D; K \cdot 512 \cdot t_{\text{bit}}<br>$$</p>
<p>其中，$t_{\text{bit}}$ 是比特时间，其计算公式为：<br>$$<br>t_{\text{bit}} &#x3D; \frac{1}{\text{传输速率}}<br>$$</p>
<p>分别带入 $10$ Mbps 和 $100$ Mbps，解得分别等待时间为 <strong>$5.12$ ms</strong> 和 <strong>$0.512$ ms</strong>。</p>
<h2 id="P-18"><a href="#P-18" class="headerlink" title="P.18"></a>P.18</h2><p><strong>Question and Answer:</strong></p>
<p>Suppose nodes A and B are on the same $10$ Mbps Ethernet bus, and the propagation delay between the two nodes is $325$ bit times. Suppose node A begins transmitting a frame and, before it finishes, node B begins transmitting a frame. Can A finish transmitting before it detects that B has transmitted? Why or why not? If the answer is yes, then A incorrectly believes that its frame was successfully transmitted without a collision. <em>Hint</em>: Suppose at time $t &#x3D; 0$ bit times, A begins transmitting a frame. In the worst case, A transmits a minimum-sized frame of $512 + 64$ bit times. So A would finish transmitting the frame at $t &#x3D; 512 + 64$ bit times. Thus, the answer is no, if B’s signal reaches A before bit time $t &#x3D; 512 + 64$ bits. In the worst case, when does B’s signal reach A?</p>
<ol>
<li><p><strong>传播延迟计算</strong>  </p>
<ul>
<li>两节点之间的传播延迟为 $325$ 比特时间。</li>
<li>因此，B 的信号从 B 传播到 A 所需的时间为 $325$ 比特时间。</li>
</ul>
</li>
<li><p><strong>最小帧传输时间</strong>  </p>
<ul>
<li>A 传输一个最小帧所需的时间为 $512 + 64 &#x3D; 576$ 比特时间。</li>
</ul>
</li>
<li><p><strong>碰撞检测条件</strong>  </p>
<ul>
<li>如果 B 的信号在 A 完成帧传输之前到达 A，则 A 可以检测到碰撞。</li>
<li>在最坏情况下，B 在传播延迟的最后一刻（即 $t &#x3D; 325$ 比特时间）开始传输。</li>
<li>B 的信号需要 $325$ 比特时间到达 A，因此 B 的信号到达 A 的时间为：<br>$$<br>t_{\text{到达}} &#x3D; 325 + 325 &#x3D; 650 , \text{比特时间}<br>$$</li>
</ul>
</li>
<li><p><strong>结论</strong>  </p>
<ul>
<li>A 在 $t &#x3D; 576$ 比特时间完成帧传输，而 B 的信号在 $t &#x3D; 650$ 比特时间到达 A。</li>
<li>因此，A <strong>无法检测到碰撞</strong>，并会错误地认为其帧已成功传输。</li>
</ul>
</li>
</ol>
<h2 id="P-27"><a href="#P-27" class="headerlink" title="P.27"></a>P.27</h2><p><strong>Question and Answer:</strong></p>
<p>Consider Figure $5.38$ in problem P$14$. Provide MAC addresses and IP addresses for the interfaces at Host A, both routers, and Host F. Suppose Host A sends a datagram to Host F. Give the source and destination MAC addresses in the frame encapsulating this IP datagram as the frame is transmitted <em>(i)</em> from A to the left router, <em>(ii)</em> from the left router to the right router, <em>(iii)</em> from the right router to F. Also give the source and destination IP addresses in the IP datagram encapsulated within the frame at each of these points in time.</p>
<p><img src="/The-Data-Link-Layer/Three%20subnets,%20interconnected%20by%20routers.png" alt="Figure 5.38">{ style&#x3D;”display: block; margin: 0 auto; width: 50%” }</p>
<p>Assign IP addresses to all of the interfaces. For Subnet $1$ use addresses of the form <code>192.168.1.xxx</code>; for Subnet $2$ uses addresses of the form <code>192.168.2.xxx</code>; and for Subnet $3$ use addresses of the form <code>192.168.3.xxx</code>. Assign MAC addresses to all of the adapters.</p>
<p>$14$ 和 $27$ 都没有明确说明 IP address 和 MAC address。先分配接口，如下表所示。</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>设备&#x2F;接口</th>
<th>子网</th>
<th>IP 地址</th>
<th>MAC 地址</th>
</tr>
</thead>
<tbody><tr>
<td>Host A</td>
<td>Subnet 1</td>
<td>192.168.1.1</td>
<td>AA-AA-AA-AA-AA-AA</td>
</tr>
<tr>
<td>Host B</td>
<td>Subnet 1</td>
<td>192.168.1.2</td>
<td>BB-BB-BB-BB-BB-BB</td>
</tr>
<tr>
<td>Router1-接口1</td>
<td>Subnet 1</td>
<td>192.168.1.254</td>
<td>A1-B1-C1-D1-E1-F1</td>
</tr>
<tr>
<td>Router1-接口2</td>
<td>Subnet 2</td>
<td>192.168.2.1</td>
<td>A1-B2-C2-D2-E2-F2</td>
</tr>
<tr>
<td>Router2-接口1</td>
<td>Subnet 2</td>
<td>192.168.2.254</td>
<td>A2-B1-C1-D1-E1-F1</td>
</tr>
<tr>
<td>Router2-接口2</td>
<td>Subnet 3</td>
<td>192.168.3.1</td>
<td>A2-B2-C2-D2-E2-F2</td>
</tr>
<tr>
<td>Host C</td>
<td>Subnet 2</td>
<td>192.168.2.2</td>
<td>CC-CC-CC-CC-CC-CC</td>
</tr>
<tr>
<td>Host D</td>
<td>Subnet 2</td>
<td>192.168.2.3</td>
<td>DD-DD-DD-DD-DD-DD</td>
</tr>
<tr>
<td>Host E</td>
<td>Subnet 3</td>
<td>192.168.3.2</td>
<td>EE-EE-EE-EE-EE-EE</td>
</tr>
<tr>
<td>Host F</td>
<td>Subnet 3</td>
<td>192.168.3.3</td>
<td>FF-FF-FF-FF-FF-FF</td>
</tr>
</tbody></table>
</div>

<p><strong><em>(i)</em> from A to the left router</strong></p>
<ul>
<li><strong>Source MAC address</strong>: <code>AA-AA-AA-AA-AA-AA</code>.</li>
<li><strong>Destination MAC address</strong>: <code>A1-B1-C1-D1-E1-F1</code>.</li>
</ul>
<p><strong><em>(ii)</em> from the left router to the right router</strong></p>
<ul>
<li><strong>Source MAC address</strong>: <code>A1-B2-C2-D2-E2-F2</code>.</li>
<li><strong>Destination MAC address</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</li>
</ul>
<p><strong><em>(iii)</em> from the right router to F</strong></p>
<ul>
<li><strong>Source MAC address</strong>: <code>A2-B2-C2-D2-E2-F2</code>.</li>
<li><strong>Destination MAC address</strong>: <code>FF-FF-FF-FF-FF-FF</code>.</li>
</ul>
<h2 id="P-28"><a href="#P-28" class="headerlink" title="P.28"></a>P.28</h2><p>Suppose now that the leftmost router in Figure $5.38$ is replaced by a switch. Hosts A, B, C, and D and the right router are all star-connected into this switch. Give the source and destination MAC addresses in the frame encapsulating this IP datagram as the frame is transmitted <em>(i)</em> from A to the switch, <em>(ii)</em> from the switch to the right router, <em>(iii)</em> from the right router to F. Also give the source and destination IP addresses in the IP datagram encapsulated within the frame at each of these points in time.</p>
<p>首先需要明确的是，switch 的每个接口都有一个 MAC address，但由于 switch 并不会修改经过它的 frame，这里简单地用一个 MAC address 概括。同时，理论上 subnet1 和 subnet2 应该合为一个 subnet，但接下来的结果仍做区分（因为题目要仍在问 MAC address）。</p>
<p>接上题的接口配置，做简单修改：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>设备&#x2F;接口</th>
<th>子网</th>
<th>IP 地址</th>
<th>MAC 地址</th>
</tr>
</thead>
<tbody><tr>
<td>Host A</td>
<td>Subnet 1</td>
<td>192.168.1.1</td>
<td>AA-AA-AA-AA-AA-AA</td>
</tr>
<tr>
<td>Host B</td>
<td>Subnet 1</td>
<td>192.168.1.2</td>
<td>BB-BB-BB-BB-BB-BB</td>
</tr>
<tr>
<td>Switch</td>
<td>Subnet 1 2</td>
<td>192.168.1.254</td>
<td>A1-B1-C1-D1-E1-F1</td>
</tr>
<tr>
<td>Router2-接口1</td>
<td>Subnet 2</td>
<td>192.168.2.254</td>
<td>A2-B1-C1-D1-E1-F1</td>
</tr>
<tr>
<td>Router2-接口2</td>
<td>Subnet 3</td>
<td>192.168.3.1</td>
<td>A2-B2-C2-D2-E2-F2</td>
</tr>
<tr>
<td>Host C</td>
<td>Subnet 2</td>
<td>192.168.2.2</td>
<td>CC-CC-CC-CC-CC-CC</td>
</tr>
<tr>
<td>Host D</td>
<td>Subnet 2</td>
<td>192.168.2.3</td>
<td>DD-DD-DD-DD-DD-DD</td>
</tr>
<tr>
<td>Host E</td>
<td>Subnet 3</td>
<td>192.168.3.2</td>
<td>EE-EE-EE-EE-EE-EE</td>
</tr>
<tr>
<td>Host F</td>
<td>Subnet 3</td>
<td>192.168.3.3</td>
<td>FF-FF-FF-FF-FF-FF</td>
</tr>
</tbody></table>
</div>

<p><strong><em>(i)</em> from A to the switch</strong></p>
<ul>
<li><strong>Source MAC address</strong>: <code>AA-AA-AA-AA-AA-AA</code>.</li>
<li><strong>Destination MAC address</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</li>
</ul>
<p><strong><em>(ii)</em> from the switch to the right router</strong></p>
<ul>
<li><strong>Source MAC address</strong>: <code>A1-B1-C1-D1-E1-F1</code>.</li>
<li><strong>Destination MAC address</strong>: <code>A2-B1-C1-D1-E1-F1</code>.</li>
</ul>
<p><strong><em>(iii)</em> from the right router to F</strong></p>
<ul>
<li><strong>Source MAC address</strong>: <code>A2-B2-C2-D2-E2-F2</code>.</li>
<li><strong>Destination MAC address</strong>: <code>FF-FF-FF-FF-FF-FF</code>.</li>
</ul>
<h2 id="P-32"><a href="#P-32" class="headerlink" title="P.32"></a>P.32</h2><p><img src="/The-Data-Link-Layer/A%20link-layer%20switch%20inter-connecting%20six%20nodes.png" alt="A link-layer switch inter-connecting six nodes">{ style&#x3D;”display: block; margin: 0 auto; width: 60%” }</p>
<p>Let’s consider the operation of a learning switch in the context of Figure $5.24$. Suppose that <em>(i)</em> B sends a frame to E, <em>(ii)</em> E replies with a frame to B, <em>(iii)</em> A sends a frame to B, <em>(iv)</em> B replies with a frame to A. The switch table is initially empty. Show the state of the switch table before and after each of these events. For each of these events, identify the link(s) on which the transmitted frame will be forwarded, and briefly justify your answers.</p>
<p>按字典序从小到大的顺序分配接口，用如下表格总结题目所述过程：</p>
<div style="display: block; margin: 0 auto; width: fit-content">

<table>
<thead>
<tr>
<th>步骤</th>
<th>事件</th>
<th>表项变化</th>
<th>转发链路</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>B→E</td>
<td>+B@2</td>
<td>1,3,4,5,6</td>
<td>泛洪</td>
</tr>
<tr>
<td>2</td>
<td>E→B</td>
<td>+E@5</td>
<td>2</td>
<td>定向转发</td>
</tr>
<tr>
<td>3</td>
<td>A→B</td>
<td>+A@1</td>
<td>2</td>
<td>定向转发</td>
</tr>
<tr>
<td>4</td>
<td>B→A</td>
<td>B@2 刷新</td>
<td>1</td>
<td>定向转发</td>
</tr>
</tbody></table>
</div>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/04/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/04/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/" class="post-title-link" itemprop="url">朴素贝叶斯法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-04 09:59:52" itemprop="dateCreated datePublished" datetime="2025-06-04T09:59:52+08:00">2025-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 10:19:28" itemprop="dateModified" datetime="2025-06-06T10:19:28+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="text-Naive-Bayes"><a href="#text-Naive-Bayes" class="headerlink" title="$\text{Naive Bayes}$"></a>$\text{Naive Bayes}$</h2><p><strong>朴素</strong>贝叶斯法基于一个强假设，即特征条件独立性。由条件独立性假设可将公式 $(2)$ 化简为公式 $(3)$。此外，朴素贝叶斯法是对输入进行<strong>分类</strong>，这其中的机理涉及到两个概念：<strong>先验概率</strong>和<strong>后验概率</strong>；先验概率是类别的先验分布 $P(Y)$，条件概率 $P(X |Y)$ 是在类别条件下输入的分布，后验概率 $P(Y |X)$ 是在输入条件下类的分布；最后我们选择后验概率最大的分类情况作为输入的类标签。</p>
<h2 id="朴素贝叶斯法的学习与分类"><a href="#朴素贝叶斯法的学习与分类" class="headerlink" title="朴素贝叶斯法的学习与分类"></a>朴素贝叶斯法的学习与分类</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>设输入空间 $\mathcal{X} \in \mathbb{R}^n$ 为 $n$ 维向量的集合，输出空间类标记集合 $\mathcal{Y} &#x3D; {c_1, c_2, \cdots, c_K }$。训练数据集</p>
<p>$$<br>T &#x3D; {(x_1, y_1), (x_2, y_2), \dots, (x_N, y_N)}<br>$$</p>
<p>由 $P(X, Y)$ 独立同分布产生。</p>
<p>朴素贝叶斯法通过训练数据集学习联合概率分布 $P(X, Y)$。具体地，学习以下先验概率分布及条件概率分布。先验概率分布</p>
<p>$$<br>P(Y &#x3D; c_k), \quad k &#x3D; 1, 2, \cdots K \tag{1}<br>$$</p>
<p>条件概率分布</p>
<p>$$<br>P(X &#x3D; x |Y &#x3D; c_k) &#x3D; P(X^{(1)} &#x3D; x^{(1)}, \cdots, X^{(n)} &#x3D; x^{(n)} |Y &#x3D; c_k), \quad k &#x3D; 1, 2, \cdots, K \tag{2}<br>$$</p>
<p>于是学习到联合概率分布 $P(X, Y)$。</p>
<p>由条件独立性假设得</p>
<p>$$<br>P(X &#x3D; x |Y &#x3D; c_k) &#x3D; \prod_{j &#x3D; 1}^{n} P(X^{(j)} &#x3D; x^{(j)} |Y &#x3D; c_k) \tag{3}<br>$$</p>
<p>朴素贝叶斯法分类时，对给定的输入 $x$，通过学习到的模型计算后验概率分布 $P(Y &#x3D; c_k |X &#x3D; x)$，将后验概率最大的类作为 $x$ 的类输出。后验概率计算如下：</p>
<p>$$<br>P(Y &#x3D; c_k |X &#x3D; x) &#x3D; \frac{P(X &#x3D; x |Y &#x3D; c_k) P(Y &#x3D; c_k)}{\sum_{k} P(X &#x3D; x |Y &#x3D; c_k) P(Y &#x3D; c_k)} \tag{4}<br>$$</p>
<p>也就是：</p>
<p>$$<br>P(Y &#x3D; c_k |X &#x3D; x) &#x3D; \frac{P(Y &#x3D; c_k) \prod_{j &#x3D; 1}^{n} P(X^{(j)} &#x3D; x^{(j)} |Y &#x3D; c_k)}{\sum_{k} P(Y &#x3D; c_k) \prod_{j &#x3D; 1}^{n} P(X^{(j)} &#x3D; x^{(j)} |Y &#x3D; c_k)} \tag{5}<br>$$</p>
<p>这是朴素贝叶斯法分类的基本公式。于是，朴素贝叶斯分类器可表示为</p>
<p>$$<br>y &#x3D; f(x) &#x3D; \operatorname{arg} \max_{c_k} \frac{P(Y &#x3D; c_k) \prod_{j &#x3D; 1}^{n} P(X^{(j)} &#x3D; x^{(j)} |Y &#x3D; c_k)}{\sum_{k} P(Y &#x3D; c_k) \prod_{j &#x3D; 1}^{n} P(X^{(j)} &#x3D; x^{(j)} |Y &#x3D; c_k)} \tag{6}<br>$$</p>
<p>注意到分母对所有 $c_k$ 都是相同的，所以，</p>
<p>$$<br>y &#x3D; f(x) &#x3D; \operatorname{arg} \max_{c_k} P(Y &#x3D; c_k) \prod_{j &#x3D; 1}^{n} P(X^{(j)} &#x3D; x^{(j)} |Y &#x3D; c_k) \tag{7}<br>$$</p>
<h3 id="后验概率最大化的含义"><a href="#后验概率最大化的含义" class="headerlink" title="后验概率最大化的含义"></a>后验概率最大化的含义</h3><p>朴素贝叶斯法将实例分到后验概率最大的类中。这等价于期望风险最小化。假设选择 0-1 损失函数：</p>
<p>$$<br>L(Y, f(X)) &#x3D;<br>\begin{cases}<br>1, &amp;Y \neq f(X)<br>\[10pt]<br>0, &amp;Y &#x3D; f(X)<br>\end{cases}<br>$$</p>
<p>式中 $f(X)$ 是分类决策函数。这时，期望风险函数为</p>
<p>$$<br>R_{\exp}(f) &#x3D; \mathbf{E}[L(Y, f(X))]<br>$$</p>
<p>期望是对联合分布 $P(X, Y)$取的。由此取条件期望：</p>
<p>$$<br>R_{\exp}(f) &#x3D; \mathbf{E_{X}} \sum_{k &#x3D; 1}^{K}[L(c_k, f(X))] P(c_k |X)<br>$$</p>
<p>为了使期望风险最小化，只需对 $X &#x3D; x$ 逐个极小化，由此得到：</p>
<p>$$<br>f(x) &#x3D; \operatorname{arg} \max_{y \in \mathcal{Y}} P(y &#x3D; c_k |X &#x3D; x)<br>$$</p>
<h2 id="朴素贝叶斯法的参数估计"><a href="#朴素贝叶斯法的参数估计" class="headerlink" title="朴素贝叶斯法的参数估计"></a>朴素贝叶斯法的参数估计</h2><h3 id="学习与分类算法"><a href="#学习与分类算法" class="headerlink" title="学习与分类算法"></a>学习与分类算法</h3><p>输入：训练数据 $T &#x3D; {(x_1, y_1), (x_2, y_2), \dots, (x_N, y_N)}$，其中 $x_i &#x3D; (x_i^{(1)}, x_i^{(2)}, \dots, x_i^{(n)})$，$x_i^{(j)}$ 是第 $i$ 个样本的第 $j$ 个特征，$x_i^{(j)} \in {a_{j1}, a_{j2}, \cdots, a_{jS_j}}$ 是特征 $x_i^{(j)}$ 的可能取值，$y_i \in {c_1, c_2, \cdots, c_K}$。<br>输出：实例 $x$ 的分类。</p>
<p><strong>（1）计算先验概率及条件概率</strong><br>$$<br>\begin{align*}<br>P(Y &#x3D; c_k) &amp;&#x3D; \frac{\sum_{i &#x3D; 1}^{N} I(y_i &#x3D; ck)}{N}, \quad k &#x3D; 1, 2, \cdots, K<br>\[10pt]<br>P(X^{(j)} &#x3D; a_{jl} |Y &#x3D; c_k) &amp;&#x3D; \frac{\sum_{i &#x3D; 1}^{N} I(x_i^{(j)} &#x3D; a_{jl}, y_i &#x3D; c_k)}{\sum_{i &#x3D; 1}^{N} I(y_i &#x3D; c_k)}<br>\[10pt]<br>j &#x3D; 1, 2, \cdots, n; \quad l &amp;&#x3D; 1, 2, \cdots, S_j; \quad k &#x3D; 1, 2, \cdots, K<br>\end{align*}<br>$$<br><strong>（2）对于给定实例 $x &#x3D; (x^{(1)}, x^{(2)}, \dots, x^{(n)})$，计算：</strong><br>$$<br>P(Y &#x3D; c_k) \prod_{j &#x3D; 1}^{n} P(X^{(j)} &#x3D; x^{(j)} |Y &#x3D; c_k), \quad k &#x3D; 1, 2, \cdots, K<br>$$<br><strong>（3）确定实例 $x$ 的类</strong><br>$$<br>y &#x3D; \operatorname{arg} \max_{c_k} P(Y &#x3D; c_k) \prod_{j &#x3D; 1}^{n} P(X^{(j)} &#x3D; x^{(j)} |Y &#x3D; c_k)<br>$$</p>
<h3 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h3><p>用极大似然估计可能会出现所要估计的概率值为 $0$ 的情况。这是采用贝叶斯估计。</p>
<p>$$<br>\begin{align*}<br>P_{\lambda}(X^{(j)} &#x3D; a_{jl} |Y &#x3D; c_k) &amp;&#x3D; \frac{\sum_{i &#x3D; 1}^{N} I(x_i^{(j)} &#x3D; a_{jl}, y_i &#x3D; c_k) + \lambda}{\sum_{i &#x3D; 1}^{N} I(y_i &#x3D; c_k) + S_j \lambda} \tag{8}<br>\[10pt]<br>P_{\lambda}(Y &#x3D; c_k) &amp;&#x3D; \frac{\sum_{i &#x3D; 1}^{N} I(y_i &#x3D; c_k) + \lambda}{N + K \lambda} \tag{9}<br>\end{align*}<br>$$</p>
<p>常取 $\lambda &#x3D; 1$</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/03/%E6%9C%9F%E6%9C%9B%E6%9E%81%E5%A4%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/03/%E6%9C%9F%E6%9C%9B%E6%9E%81%E5%A4%A7/" class="post-title-link" itemprop="url">期望极大</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-03 12:51:44" itemprop="dateCreated datePublished" datetime="2025-06-03T12:51:44+08:00">2025-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-06 12:36:32" itemprop="dateModified" datetime="2025-06-06T12:36:32+08:00">2025-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="operatorname-EM-算法"><a href="#operatorname-EM-算法" class="headerlink" title="$\operatorname{EM}$ 算法"></a>$\operatorname{EM}$ 算法</h2><p>$\operatorname{EM}$ 算法通过迭代求 $L(\theta) &#x3D; \log P(Y | \theta)$ 的极大似然估计。每次迭代包含两步：$\operatorname{E}$ 步，求期望；$\operatorname{M}$ 步，求极大化。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>输入：观测变量数据 $Y$，隐变量数据 $Z$，联合分布 $P(Y, Z | \theta)$，条件分布 $P(Z | Y, \theta)$；<br>输出：模型参数$\theta$。</p>
<p><strong>（1）选择参数初始值 $\theta^{(0)}$，开始迭代；</strong></p>
<p><strong>（2）$\operatorname{E}$ 步：计算 Q 函数值</strong></p>
<p>$$<br>Q(\theta, \theta^{(i)}) &#x3D; \sum_{Z} \log P(Y, Z | \theta) P(Z | Y, \theta^{(i)}) \tag{1}<br>$$</p>
<p>这里，$P(Z | Y, \theta^{(i)})$ 是在给定观测数据 $Y$ 和当前的参数估计 $\theta^{(i)}$ 下隐变量数据 $Z$ 条件概率分布；</p>
<p><strong>（3）$\operatorname{M}$ 步：求使 $Q(\theta, \theta^{(i)})$ 极大化的 $\theta$，确定第 $i + 1$ 次迭代的参数估计值 $\theta^{(i + 1)}$</strong></p>
<p>$$<br>\theta^{(i + 1)} &#x3D; \operatorname{arg} \max_{\theta} Q(\theta, \theta^{(i)}) \tag{2}<br>$$</p>
<p><strong>（4）重复（2）（3）步直到收敛</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ddccffq.github.io/2025/06/03/%E6%84%9F%E7%9F%A5%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ddccffq">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddccffq的技术博客">
      <meta itemprop="description" content="专注于机器学习、计算机网络、统计学习方法的技术分享">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | ddccffq的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/03/%E6%84%9F%E7%9F%A5%E6%9C%BA/" class="post-title-link" itemprop="url">感知机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-03 11:04:29" itemprop="dateCreated datePublished" datetime="2025-06-03T11:04:29+08:00">2025-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-05 22:37:39" itemprop="dateModified" datetime="2025-06-05T22:37:39+08:00">2025-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">统计学习方法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="text-Perceptron"><a href="#text-Perceptron" class="headerlink" title="$\text{Perceptron}$"></a>$\text{Perceptron}$</h2><p>感知机用于<strong>二分类线性问题</strong>，这说明感知机只能用于二分类问题，同时样本数据线性可分。</p>
<p>接下来会介绍感知机的<strong>数学定义</strong>，也就是感知机的输入输出映射；然后介绍感知机的学习算法，学习什么？学习的是感知机数学定义中提及到的<strong>参数</strong>；如何学习？会介绍两种方法，第一种是基于原始<strong>损失函数</strong>的迭代算法，另一种是基于原始损失函数的<strong>对偶形式</strong>的迭代算法，这两种算法本质上等价。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/03/%E6%84%9F%E7%9F%A5%E6%9C%BA/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ddccffq</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/ddccffq" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
